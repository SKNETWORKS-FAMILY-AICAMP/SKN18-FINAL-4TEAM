scenario,prompt,method,first_sentence,first_sentence_length,first_audio_time,total_time,llm_time,tts_time,audio_files
문제설명,단계적구조,스트리밍(문장별),안녕하세요!,6,1.7164385318756104,21.336381196975708,0.6087942123413086,20.66961097717285,9
초단답,단계적구조,스트리밍(문장별),배열에 대해 잘 알고 계시네요.,17,1.7958447933197021,12.735537052154541,0.6374163627624512,12.072169065475464,6
보통설명,단계적구조,스트리밍(문장별),안녕하세요!,6,2.090453863143921,16.597432851791382,0.8534152507781982,15.694660902023315,8
초단답,단계적구조,최적화(첫문장우선),안녕하세요!,6,2.114952564239502,7.967019081115723,0.9448025226593018,6.709907293319702,2
문제설명,우선순위,최적화(첫문장우선),즉각 반응: 문제 정의부터 시작!,18,2.137049436569214,4.038119077682495,0.8216886520385742,3.2014541625976562,2
문제설명,우선순위,스트리밍(문장별),즉각 반응: 문제 정의부터 시작!,18,2.1970651149749756,12.731684684753418,0.872269868850708,11.830322027206421,6
보통설명,초간결,스트리밍(문장별),이진 탐색 트리는 정렬된 구조입니다.,20,2.21928334236145,8.103703737258911,0.865501880645752,7.221776485443115,4
초단답,초간결,최적화(첫문장우선),배열의 시간복잡도는 작업에 따라 다릅니다.,23,2.2648708820343018,3.636596202850342,0.9529621601104736,2.67376708984375,2
보통설명,단계적구조,최적화(첫문장우선),안녕하세요!,6,2.2879562377929688,12.30458927154541,0.6725928783416748,9.445396661758423,2
긴힌트,우선순위,스트리밍(문장별),즉각 반응: 두 포인터 활용!,16,2.3281986713409424,11.088430404663086,0.9365758895874023,10.12592101097107,5
긴힌트,단계적구조,스트리밍(문장별),이해가 잘 안되시군요.,12,2.3955533504486084,13.485510349273682,0.7739570140838623,12.682397365570068,6
짧은설명,짧은첫문장,스트리밍(문장별),좋은 질문이네요.,9,2.4076030254364014,24.84530735015869,0.7957284450531006,23.978779077529907,11
초단답,우선순위,최적화(첫문장우선),"O(1) 또는 O(n)  
접근은 O(1), 탐색은 O(n)  
계속 연습하세요!",45,2.418501853942871,2.419741153717041,1.0967073440551758,1.3217899799346924,1
짧은설명,우선순위,최적화(첫문장우선),즉각 반응: 동기화 여부 차이!,17,2.4916396141052246,5.80210542678833,0.7240245342254639,4.996291399002075,2
초단답,우선순위,기본(전체→TTS),"O(1) 또는 O(n)  
검색은 O(1), 순회는 O(n)  
더 깊이 알아보세요!.",48,2.525118112564087,2.525118589401245,1.184216022491455,1.340876817703247,1
문제설명,짧은첫문장,최적화(첫문장우선),좋은 질문이네요.,9,2.620387315750122,13.87598204612732,0.7340056896209717,9.378448009490967,2
긴힌트,짧은첫문장,최적화(첫문장우선),좋은 질문이네요.,9,2.646353006362915,16.257290601730347,0.6633257865905762,11.281619310379028,2
짧은설명,단계적구조,최적화(첫문장우선),안녕하세요!,6,2.647813558578491,6.67243504524231,0.7824018001556396,5.86961555480957,2
짧은설명,우선순위,스트리밍(문장별),즉각 반응: 동기화 여부 차이!,17,2.67417311668396,10.71163010597229,1.0323166847229004,9.656502723693848,5
초단답,짧은첫문장,최적화(첫문장우선),좋은 질문이네요.,9,2.7195091247558594,8.982884883880615,0.5440828800201416,8.031099319458008,2
짧은설명,초간결,최적화(첫문장우선),해시맵과 해시테이블은 다릅니다.,17,2.7349390983581543,4.384631872177124,1.1862831115722656,3.1898324489593506,2
긴힌트,단계적구조,최적화(첫문장우선),"알겠습니다, 도움이 필요하군요.",17,2.7550721168518066,10.223774433135986,0.7237839698791504,9.087056398391724,2
보통설명,짧은첫문장,스트리밍(문장별),좋은 질문이네요.,9,2.772139549255371,25.383487462997437,0.5688095092773438,24.74516248703003,10
보통설명,우선순위,스트리밍(문장별),즉각 반응: 정렬된 이진 트리!,17,2.7878270149230957,9.032846450805664,0.8181040287017822,8.198180913925171,5
긴힌트,우선순위,최적화(첫문장우선),즉각 반응: 두 개의 포인터!,16,2.811034917831421,6.008533954620361,0.7637166976928711,5.22883677482605,2
보통설명,짧은첫문장,최적화(첫문장우선),좋은 질문이네요.,9,2.8225491046905518,16.01151466369629,0.7074944972991943,13.516093254089355,2
문제설명,초간결,최적화(첫문장우선),동적 프로그래밍은 최적화 문제를 해결하는 기법입니다.,29,2.923931121826172,6.528197526931763,1.0013606548309326,5.511873245239258,2
초단답,기본,최적화(첫문장우선),배열의 시간 복잡도는 특정 작업에 따라 다르게 평가될 수 있습니다.,37,2.927541494369507,20.243290901184082,1.4488918781280518,16.322420120239258,2
문제설명,초간결,스트리밍(문장별),동적 프로그래밍은 최적 부분 구조와 중복되는 부분 문제를 이용합니다.,38,2.9648046493530273,10.513731002807617,1.1987547874450684,9.291975975036621,6
초단답,우선순위,스트리밍(문장별),"O(1) 또는 O(n)  
접근은 O(1), 검색은 O(n)입니다.",37,2.99790096282959,5.221540451049805,0.7901811599731445,4.425226449966431,2
보통설명,초간결,최적화(첫문장우선),이진 탐색 트리는 정렬된 구조입니다.,20,3.000964641571045,6.017850875854492,0.8135044574737549,5.190432548522949,2
긴힌트,짧은첫문장,스트리밍(문장별),좋은 질문이네요.,9,3.0058000087738037,23.088067770004272,0.8528196811676025,22.140607357025146,12
긴힌트,초간결,스트리밍(문장별),투 포인터 알고리즘은 두 개의 포인터를 사용하는 기법입니다.,33,3.1402504444122314,16.99223494529724,1.1717357635498047,15.789299726486206,7
초단답,짧은첫문장,스트리밍(문장별),좋은 질문이네요.,9,3.162541389465332,21.30497097969055,0.645688533782959,20.618253707885742,12
짧은설명,짧은첫문장,최적화(첫문장우선),좋은 질문이네요.,9,3.194167137145996,7.625391244888306,1.4187142848968506,5.837294340133667,2
보통설명,우선순위,기본(전체→TTS),"즉각 반응: 정렬된 이진 트리  
핵심: 왼쪽 < 루트 < 오른쪽  
선택: 검색, 삽입, 삭제 O(log n)  
마무리: 잘 이해하셨어요.",79,3.283897876739502,3.28389835357666,1.602236032485962,1.6816258430480957,1
초단답,기본,스트리밍(문장별),배열의 시간 복잡도는 수행하는 작업의 종류에 따라 다릅니다.,33,3.5261363983154297,33.93253135681152,0.9976234436035156,32.86420965194702,16
문제설명,기본,최적화(첫문장우선),"동적 프로그래밍(Dynamic Programming, DP)은 복잡한 문제를 더 간단한 여러 개의 하위 문제로 나누어 해결하는 방법입니다.",77,3.530078172683716,15.60003113746643,1.2065520286560059,12.157131433486938,2
긴힌트,기본,최적화(첫문장우선),투 포인터 알고리즘(Two Pointer Algorithm)은 배열이나 리스트와 같은 선형 자료구조를 탐색할 때 유용하게 사용되는 기법입니다.,79,3.5963194370269775,18.809755325317383,1.7051472663879395,13.025618076324463,2
문제설명,단계적구조,최적화(첫문장우선),안녕하세요!,6,3.66912841796875,13.364803791046143,0.8004910945892334,11.415655612945557,2
초단답,초간결,스트리밍(문장별),배열의 시간복잡도는 접근 방식에 따라 다릅니다.,26,3.6849584579467773,11.480668306350708,1.1112606525421143,10.355211019515991,4
짧은설명,기본,스트리밍(문장별),"해시맵(HashMap)과 해시테이블(Hashtable)은 모두 키-값 쌍을 저장하는 자료구조로, 해시 함수를 사용하여 데이터를 저장하고 검색하는 방식입니다.",87,3.8465325832366943,28.359225511550903,1.1585664749145508,27.114118099212646,14
긴힌트,초간결,최적화(첫문장우선),투 포인터 알고리즘은 두 개의 포인터를 사용하는 기법입니다.,33,3.9644107818603516,7.304229259490967,1.0656144618988037,6.219640016555786,2
짧은설명,초간결,스트리밍(문장별),해시맵과 해시테이블은 다릅니다.,17,4.051344871520996,8.662418842315674,0.9647915363311768,7.683084726333618,4
보통설명,기본,최적화(첫문장우선),"이진 탐색 트리는 데이터 구조의 일종으로, 다음과 같은 주요 특징을 가지고 있습니다:

### 특징:
1.",59,4.2520270347595215,13.78833818435669,1.3847017288208008,10.016057968139648,2
문제설명,기본,스트리밍(문장별),"동적 프로그래밍(Dynamic Programming, DP)은 최적화 문제를 해결하기 위한 알고리즘 기법으로, 문제를 작은 하위 문제로 나누어 해결하고, 그 결과를 저장하여 중복 계산을 피하는 방식입니다.",114,4.582958221435547,29.50281572341919,1.985729694366455,27.45238971710205,14
보통설명,우선순위,최적화(첫문장우선),"즉각 반응: 정렬된 이진 트리  
핵심: 왼쪽 < 루트 < 오른쪽  
선택: 탐색, 삽입, 삭제 O(log n)  
마무리: 잘하고 계세요!",78,4.632889270782471,5.848361492156982,2.187229871749878,3.6584312915802,2
긴힌트,기본,스트리밍(문장별),투 포인터(Two Pointers) 알고리즘은 배열이나 리스트에서 두 개의 포인터를 사용하여 특정 조건을 만족하는 값을 찾거나 문제를 해결하는 기법입니다.,86,4.663554668426514,29.967291355133057,1.185323715209961,28.699897289276123,15
보통설명,기본,스트리밍(문장별),"이진 탐색 트리(BST, Binary Search Tree)는 이진 트리의 일종으로, 각 노드가 최대 두 개의 자식을 가지며, 다음과 같은 특징을 가지고 있습니다:

### 특징:
1.",103,4.6755640506744385,19.43558144569397,1.3327786922454834,18.037588357925415,8
짧은설명,초간결,기본(전체→TTS),해시맵과 해시테이블은 다릅니다.,17,4.813366889953613,4.8133673667907715,1.7127411365509033,3.100609540939331,1
초단답,초간결,기본(전체→TTS),배열의 시간복잡도는 작업에 따라 다릅니다.,23,4.88997220993042,4.889972686767578,2.003309726715088,2.8866302967071533,1
문제설명,짧은첫문장,스트리밍(문장별),좋은 질문이네요.,9,5.061620473861694,33.703588008880615,1.8980908393859863,31.725658178329468,17
보통설명,초간결,기본(전체→TTS),이진 탐색 트리는 정렬된 데이터 구조입니다.,24,5.672640800476074,5.672641277313232,2.1631758213043213,3.509442090988159,1
짧은설명,단계적구조,기본(전체→TTS),안녕하세요.,6,6.159668445587158,6.159668922424316,1.8305890560150146,4.329044818878174,1
짧은설명,우선순위,기본(전체→TTS),즉각 반응: 동기화 여부.,14,6.289208650588989,6.2892091274261475,1.9230372905731201,4.366143465042114,1
문제설명,우선순위,기본(전체→TTS),즉각 반응: 동적 프로그래밍 기초.,19,6.792442321777344,6.792442798614502,2.231544256210327,4.560875654220581,1
긴힌트,우선순위,기본(전체→TTS),즉각 반응: 두 포인터 사용.,16,7.01877760887146,7.018778085708618,2.5806610584259033,4.4380879402160645,1
초단답,단계적구조,기본(전체→TTS),안녕하세요.,6,7.311280250549316,7.3112804889678955,2.2492616176605225,5.061991453170776,1
긴힌트,초간결,기본(전체→TTS),투 포인터는 두 개의 포인터를 사용하는 기법입니다.,28,7.483039140701294,7.483039379119873,2.3759706020355225,5.1070451736450195,1
초단답,짧은첫문장,기본(전체→TTS),좋은 질문이네요.,9,7.5904083251953125,7.59040904045105,2.8153514862060547,4.7750115394592285,1
문제설명,초간결,기본(전체→TTS),동적 프로그래밍은 문제를 작은 하위 문제로 나누는 방법입니다.,34,8.471973896026611,8.471974611282349,2.702078342437744,5.7698588371276855,1
짧은설명,기본,최적화(첫문장우선),"해시맵(HashMap)과 해시테이블(Hashtable)은 모두 키-값 쌍을 저장하는 자료구조로, 해시 함수를 이용해 데이터를 저장하고 검색하는 방식입니다.",86,9.320420742034912,16.13816475868225,1.5381979942321777,14.522242546081543,2
보통설명,단계적구조,기본(전체→TTS),안녕하세요.,6,9.960359811782837,9.960360765457153,3.7200241088867188,6.240309238433838,1
짧은설명,짧은첫문장,기본(전체→TTS),좋은 질문이네요.,9,10.542394638061523,10.542395114898682,4.661956548690796,5.88039755821228,1
보통설명,짧은첫문장,기본(전체→TTS),좋은 질문이네요.,9,12.953005075454712,12.95300555229187,4.623305082321167,8.329667091369629,1
긴힌트,단계적구조,기본(전체→TTS),"괜찮아요, 도움이 필요하군요.",16,13.795169591903687,13.795170545578003,3.9068655967712402,9.888267040252686,1
문제설명,단계적구조,기본(전체→TTS),안녕하세요.,6,14.205099105834961,14.205099821090698,4.002878427505493,10.202193021774292,1
보통설명,기본,기본(전체→TTS),"이진 탐색 트리(BST, Binary Search Tree)는 이진 트리의 일종으로, 다음과 같은 특징을 가지고 있습니다:

### 특징:
1.",80,15.937447547912598,15.937447786331177,5.892390489578247,10.045006036758423,1
짧은설명,기본,기본(전체→TTS),"해시맵(HashMap)과 해시테이블(HashTable)은 모두 키-값 쌍을 저장하는 데이터 구조로, 해시 함수를 사용하여 데이터를 저장하고 검색하는 방식입니다.",89,15.95473575592041,15.954736232757568,5.688446998596191,10.266261100769043,1
문제설명,짧은첫문장,기본(전체→TTS),좋은 질문이네요.,9,19.106887340545654,19.106887817382812,6.459866285324097,12.646984577178955,1
긴힌트,기본,기본(전체→TTS),투 포인터 알고리즘(Two Pointer Algorithm)은 주로 배열이나 리스트와 같은 데이터 구조에서 두 개의 포인터를 사용하여 문제를 해결하는 기법입니다.,90,19.318454027175903,19.318454265594482,5.957087278366089,13.361330032348633,1
초단답,기본,기본(전체→TTS),배열의 시간 복잡도는 특정 작업에 따라 다릅니다.,27,22.546396493911743,22.54639720916748,7.32231068611145,15.223893165588379,1
긴힌트,짧은첫문장,기본(전체→TTS),좋은 질문이네요.,9,23.390265703201294,23.390266180038452,6.501827716827393,16.888392210006714,1
문제설명,기본,기본(전체→TTS),"동적 프로그래밍(Dynamic Programming, DP)은 최적화 문제를 해결하는 강력한 기법입니다.",58,23.44506573677063,23.44506597518921,6.238123893737793,17.206911087036133,1

id,problem,difficulty,category
1,"선물을 직접 전하기 힘들 때 카카오톡 선물하기 기능을 이용해 축하 선물을 보낼 수 있습니다. 당신의 친구들이 이번 달까지 선물을 주고받은 기록을 바탕으로 다음 달에 누가 선물을 많이 받을지 예측하려고 합니다. 두 사람이 선물을 주고받은 기록이 있다면, 이번 달까지 두 사람 사이에 더 많은 선물을 준 사람이 다음 달에 선물을 하나 받습니다. 예를 들어 A가 B에게 선물을 5번 줬고, B가 A에게 선물을 3번 줬다면 다음 달엔 A가 B에게 선물을 하나 받습니다. 두 사람이 선물을 주고받은 기록이 하나도 없거나 주고받은 수가 같다면, 선물 지수가 더 큰 사람이 선물 지수가 더 작은 사람에게 선물을 하나 받습니다. 선물 지수는 이번 달까지 자신이 친구들에게 준 선물의 수에서 받은 선물의 수를 뺀 값입니다. 예를 들어 A가 친구들에게 준 선물이 3개고 받은 선물이 10개라면 A의 선물 지수는 -7입니다. B가 친구들에게 준 선물이 3개고 받은 선물이 2개라면 B의 선물 지수는 1입니다. 만약 A와 B가 선물을 주고받은 적이 없거나 정확히 같은 수로 선물을 주고받았다면, 다음 달엔 B가 A에게 선물을 하나 받습니다. 만약 두 사람의 선물 지수도 같다면 다음 달에 선물을 주고받지 않습니다. 위에서 설명한 규칙대로 다음 달에 선물을 주고받을 때, 당신은 선물을 가장 많이 받을 친구가 받을 선물의 수를 알고 싶습니다. 친구들의 이름을 담은 1차원 문자열 배열 friends 이번 달까지 친구들이 주고받은 선물 기록을 담은 1차원 문자열 배열 gifts가 매개변수로 주어집니다. 이때, 다음달에 가장 많은 선물을 받는 친구가 받을 선물의 수를 return 하도록 solution 함수를 완성해 주세요. 제한사항 2 ≤ friends의 길이 = 친구들의 수 ≤ 50 friends의 원소는 친구의 이름을 의미하는 알파벳 소문자로 이루어진 길이가 10 이하인 문자열입니다. 이름이 같은 친구는 없습니다. 1 ≤ gifts의 길이 ≤ 10,000 gifts의 원소는 ""A B""형태의 문자열입니다. A는 선물을 준 친구의 이름을 B는 선물을 받은 친구의 이름을 의미하며 공백 하나로 구분됩니다. A와 B는 friends의 원소이며 A와 B가 같은 이름인 경우는 존재하지 않습니다. 입출력 예 friends gifts result [""muzi"", ""ryan"", ""frodo"", ""neo""] [""muzi frodo"", ""muzi frodo"", ""ryan muzi"", ""ryan muzi"", ""ryan muzi"", ""frodo muzi"", ""frodo ryan"", ""neo muzi""] 2 [""joy"", ""brad"", ""alessandro"", ""conan"", ""david""] [""alessandro brad"", ""alessandro joy"", ""alessandro conan"", ""david alessandro"", ""alessandro david""] 4 [""a"", ""b"", ""c""] [""a b"", ""b a"", ""c a"", ""a c"", ""a c"", ""c a""] 0 입출력 예 설명 입출력 예 #1 주고받은 선물과 선물 지수를 표로 나타내면 다음과 같습니다. ↓준 사람 \ 받은 사람→ muzi ryan frodo neo muzi - 0 2 0 ryan 3 - 0 0 frodo 1 1 - 0 neo 1 0 0 - 이름 준 선물 받은 선물 선물 지수 muzi 2 5 -3 ryan 3 1 2 frodo 2 2 0 neo 1 0 1 muzi는 선물을 더 많이 줬던 frodo에게서 선물을 하나 받습니다. ryan은 선물을 더 많이 줬던 muzi에게서 선물을 하나 받고, 선물을 주고받지 않았던 neo보다 선물 지수가 커 선물을 하나 받습니다. frodo는 선물을 더 많이 줬던 ryan에게 선물을 하나 받습니다. neo는 선물을 더 많이 줬던 muzi에게서 선물을 하나 받고, 선물을 주고받지 않았던 frodo보다 선물 지수가 커 선물을 하나 받습니다. 다음달에 가장 선물을 많이 받는 사람은 ryan과 neo이고 2개의 선물을 받습니다. 따라서 2를 return 해야 합니다. 입출력 예 #2 주고받은 선물과 선물 지수를 표로 나타내면 다음과 같습니다. ↓준 사람 \ 받은 사람→ joy brad alessandro conan david joy - 0 0 0 0 brad 0 - 0 0 0 alessandro 1 1 - 1 1 conan 0 0 0 - 0 david 0 0 1 0 - 이름 준 선물 받은 선물 선물 지수 joy 0 1 -1 brad 0 1 -1 alessandro 4 1 3 conan 0 1 -1 david 1 1 0 alessandro가 선물을 더 많이 줬던 joy, brad, conan에게서 선물을 3개 받습니다. 선물을 하나씩 주고받은 david보다 선물 지수가 커 선물을 하나 받습니다. david는 선물을 주고받지 않았던 joy, brad, conan보다 선물 지수가 커 다음 달에 선물을 3개 받습니다. joy, brad, conan은 선물을 받지 못합니다. 다음달에 가장 선물을 많이 받는 사람은 alessandro이고 4개의 선물을 받습니다. 따라서 4를 return 해야 합니다. 입출력 예 #3 a와 b, a와 c, b와 c 사이에 서로 선물을 주고받은 수도 같고 세 사람의 선물 지수도 0으로 같아 다음 달엔 아무도 선물을 받지 못합니다. 따라서 0을 return 해야 합니다.",easy,Array
2,"도넛 모양 그래프, 막대 모양 그래프, 8자 모양 그래프들이 있습니다. 이 그래프들은 1개 이상의 정점과, 정점들을 연결하는 단방향 간선으로 이루어져 있습니다. 크기가 n인 도넛 모양 그래프는 n개의 정점과 n개의 간선이 있습니다. 도넛 모양 그래프의 아무 한 정점에서 출발해 이용한 적 없는 간선을 계속 따라가면 나머지 n-1개의 정점들을 한 번씩 방문한 뒤 원래 출발했던 정점으로 돌아오게 됩니다. 도넛 모양 그래프의 형태는 다음과 같습니다. 크기가 n인 막대 모양 그래프는 n개의 정점과 n-1개의 간선이 있습니다. 막대 모양 그래프는 임의의 한 정점에서 출발해 간선을 계속 따라가면 나머지 n-1개의 정점을 한 번씩 방문하게 되는 정점이 단 하나 존재합니다. 막대 모양 그래프의 형태는 다음과 같습니다. 크기가 n인 8자 모양 그래프는 2n+1개의 정점과 2n+2개의 간선이 있습니다. 8자 모양 그래프는 크기가 동일한 2개의 도넛 모양 그래프에서 정점을 하나씩 골라 결합시킨 형태의 그래프입니다. 8자 모양 그래프의 형태는 다음과 같습니다. 도넛 모양 그래프, 막대 모양 그래프, 8자 모양 그래프가 여러 개 있습니다. 이 그래프들과 무관한 정점을 하나 생성한 뒤, 각 도넛 모양 그래프, 막대 모양 그래프, 8자 모양 그래프의 임의의 정점 하나로 향하는 간선들을 연결했습니다. 그 후 각 정점에 서로 다른 번호를 매겼습니다. 이때 당신은 그래프의 간선 정보가 주어지면 생성한 정점의 번호와 정점을 생성하기 전 도넛 모양 그래프의 수, 막대 모양 그래프의 수, 8자 모양 그래프의 수를 구해야 합니다. 그래프의 간선 정보를 담은 2차원 정수 배열 edges가 매개변수로 주어집니다. 이때, 생성한 정점의 번호, 도넛 모양 그래프의 수, 막대 모양 그래프의 수, 8자 모양 그래프의 수를 순서대로 1차원 정수 배열에 담아 return 하도록 solution 함수를 완성해 주세요. 제한사항 1 ≤ edges의 길이 ≤ 1,000,000 edges의 원소는 [a,b] 형태이며, a번 정점에서 b번 정점으로 향하는 간선이 있다는 것을 나타냅니다. 1 ≤ a, b ≤ 1,000,000 문제의 조건에 맞는 그래프가 주어집니다. 도넛 모양 그래프, 막대 모양 그래프, 8자 모양 그래프의 수의 합은 2이상입니다. 입출력 예 edges result [[2, 3], [4, 3], [1, 1], [2, 1]] [2, 1, 1, 0] [[4, 11], [1, 12], [8, 3], [12, 7], [4, 2], [7, 11], [4, 8], [9, 6], [10, 11], [6, 10], [3, 5], [11, 1], [5, 3], [11, 9], [3, 8]] [4, 0, 1, 2] 입출력 예 설명 입출력 예 #1 주어진 그래프를 그림으로 나타내면 다음과 같습니다. 2번 정점이 생성한 정점이고 도넛 모양 그래프 1개, 막대 모양 그래프 1개가 존재합니다. 따라서 [2, 1, 1, 0]을 return 해야 합니다. 입출력 예 #2 주어진 그래프를 그림으로 나타내면 다음과 같습니다. 4번 정점이 생성한 정점이고 막대 모양 그래프 1개, 8자 모양 그래프 2개가 존재합니다. 따라서 [4, 0, 1, 2]를 return 해야 합니다. ※ 공지 - 2024년 1월 23일 테스트 케이스가 추가되었습니다. 기존에 제출한 코드가 통과하지 못할 수도 있습니다.",normal,Array
3,"A와 B가 n개의 주사위를 가지고 승부를 합니다. 주사위의 6개 면에 각각 하나의 수가 쓰여 있으며, 주사위를 던졌을 때 각 면이 나올 확률은 동일합니다. 각 주사위는 1 ~ n의 번호를 가지고 있으며, 주사위에 쓰인 수의 구성은 모두 다릅니다. A가 먼저 n / 2개의 주사위를 가져가면 B가 남은 n / 2개의 주사위를 가져갑니다. 각각 가져간 주사위를 모두 굴린 뒤, 나온 수들을 모두 합해 점수를 계산합니다. 점수가 더 큰 쪽이 승리하며, 점수가 같다면 무승부입니다. A는 자신이 승리할 확률이 가장 높아지도록 주사위를 가져가려 합니다. 다음은 n = 4인 예시입니다. 주사위 구성 #1 [1, 2, 3, 4, 5, 6] #2 [3, 3, 3, 3, 4, 4] #3 [1, 3, 3, 4, 4, 4] #4 [1, 1, 4, 4, 5, 5] 예를 들어 A가 주사위 #1, #2를 가져간 뒤 6, 3을 굴리고, B가 주사위 #3, #4를 가져간 뒤 4, 1을 굴린다면 A의 승리입니다. (6 + 3 > 4 + 1) A가 가져가는 주사위 조합에 따라, 주사위를 굴린 1296가지 경우의 승패 결과를 세어보면 아래 표와 같습니다. A의 주사위 승 무 패 #1, #2 596 196 504 #1, #3 560 176 560 #1, #4 616 184 496 #2, #3 496 184 616 #2, #4 560 176 560 #3, #4 504 196 596 A가 승리할 확률이 가장 높아지기 위해선 주사위 #1, #4를 가져가야 합니다. 주사위에 쓰인 수의 구성을 담은 2차원 정수 배열 dice가 매개변수로 주어집니다. 이때, 자신이 승리할 확률이 가장 높아지기 위해 A가 골라야 하는 주사위 번호를 오름차순으로 1차원 정수 배열에 담아 return 하도록 solution 함수를 완성해 주세요. 승리할 확률이 가장 높은 주사위 조합이 유일한 경우만 주어집니다. 제한사항 2 ≤ dice의 길이 = n ≤ 10 n은 2의 배수입니다. dice[i]는 i+1번 주사위에 쓰인 6개의 수를 담고 있습니다. dice[i]의 길이 = 6 1 ≤ dice[i]의 원소 ≤ 100 입출력 예 dice result [[1, 2, 3, 4, 5, 6], [3, 3, 3, 3, 4, 4], [1, 3, 3, 4, 4, 4], [1, 1, 4, 4, 5, 5]] [1, 4] [[1, 2, 3, 4, 5, 6], [2, 2, 4, 4, 6, 6]] [2] [[40, 41, 42, 43, 44, 45], [43, 43, 42, 42, 41, 41], [1, 1, 80, 80, 80, 80], [70, 70, 1, 1, 70, 70]] [1, 3] 입출력 예 설명 입출력 예 #1 문제 예시와 같습니다. 입출력 예 #2 주사위 구성 #1 [1, 2, 3, 4, 5, 6] #2 [2, 2, 4, 4, 6, 6] A가 주사위 #2를 가져갔을 때 승리할 확률이 가장 높습니다. A가 #2, B가 #1 주사위를 굴린 결과에 따른 승패는 아래 표와 같습니다. 주사위 결과 1 (B) 2 (B) 3 (B) 4 (B) 5 (B) 6 (B) 2 (A) 승 무 패 패 패 패 2 (A) 승 무 패 패 패 패 4 (A) 승 승 승 무 패 패 4 (A) 승 승 승 무 패 패 6 (A) 승 승 승 승 승 무 6 (A) 승 승 승 승 승 무 입출력 예 #3 주사위 구성 #1 [40, 41, 42, 43, 44, 45] #2 [43, 43, 42, 42, 41, 41] #3 [1, 1, 80, 80, 80, 80] #4 [70, 70, 1, 1, 70, 70] A가 가져가는 주사위 조합에 따라, 주사위를 굴린 1296가지 경우의 승패 결과를 세어보면 아래 표와 같습니다. A의 주사위 승 무 패 #1, #2 704 16 576 #1, #3 936 24 336 #1, #4 360 24 912 #2, #3 912 24 360 #2, #4 336 24 936 #3, #4 576 16 704 따라서 A가 주사위 #1, #3을 가져갔을 때 승리할 확률이 가장 높습니다.",normal,Array
4,"당신은 1~n 사이의 수가 적힌 카드가 하나씩 있는 카드 뭉치와 동전 coin개를 이용한 게임을 하려고 합니다. 카드 뭉치에서 카드를 뽑는 순서가 정해져 있으며, 게임은 다음과 같이 진행합니다. 처음에 카드 뭉치에서 카드 n/3장을 뽑아 모두 가집니다. (n은 6의 배수입니다.) 당신은 카드와 교환 가능한 동전 coin개를 가지고 있습니다. 게임은 1라운드부터 시작되며, 각 라운드가 시작할 때 카드를 두 장 뽑습니다. 카드 뭉치에 남은 카드가 없다면 게임을 종료합니다. 뽑은 카드는 카드 한 장당 동전 하나를 소모해 가지거나, 동전을 소모하지 않고 버릴 수 있습니다. 카드에 적힌 수의 합이 n+1이 되도록 카드 두 장을 내고 다음 라운드로 진행할 수 있습니다. 만약 카드 두 장을 낼 수 없다면 게임을 종료합니다. 예를 들어 n = 12, coin = 4이고 [3, 6, 7, 2, 1, 10, 5, 9, 8, 12, 11, 4] 순서대로 카드를 뽑도록 카드 뭉치가 섞여 있습니다. 처음에 3, 6, 7, 2 카드 4장(= n/3)과 동전 4개(= coin)를 가지고 시작합니다. 다음 라운드로 진행하기 위해 내야 할 카드 두 장에 적힌 수의 합은 13(= n+1)입니다. 다음과 같은 방법으로 최대 5라운드까지 도달할 수 있습니다. 1라운드에서 뽑은 카드 1, 10을 동전 두 개를 소모해서 모두 가집니다. 카드 3, 10을 내고 다음 라운드로 진행합니다. 이때 손에 남은 카드는 1, 2, 6, 7이고 동전이 2개 남습니다. 2라운드에서 뽑은 카드 5, 9를 동전을 소모하지 않고 모두 버립니다. 카드 6, 7을 내고 다음 라운드로 진행합니다. 이때 손에 남은 카드는 1, 2고 동전이 2개 남습니다. 3라운드에서 뽑은 카드 8, 12 중 동전 한 개를 소모해서 카드 12를 가집니다. 카드 1, 12을 내고 다음 라운드로 진행합니다. 이때 손에 남은 카드는 2이고 동전이 1개 남습니다. 4라운드에서 뽑은 카드 11, 4 중 동전 한 개를 소모해서 카드 11을 가집니다. 카드 2, 11을 내고 다음 라운드로 진행합니다. 이때 손에 남은 카드와 동전은 없습니다. 5라운드에서 카드 뭉치에 남은 카드가 없으므로 게임을 종료합니다. 처음에 가진 동전수를 나타내는 정수 coin과 카드를 뽑는 순서대로 카드에 적힌 수를 담은 1차원 정수 배열 cards가 매개변수로 주어질 때, 게임에서 도달 가능한 최대 라운드의 수를 return 하도록 solution 함수를 완성해 주세요. 제한사항 0 ≤ coin ≤ n 6 ≤ cards의 길이 = n < 1,000 cards[i]는 i+1번째로 뽑는 카드에 적힌 수를 나타냅니다. 1 ≤ cards[i] ≤ n cards의 원소는 중복되지 않습니다. n은 6의 배수입니다. 입출력 예 coin cards result 4 [3, 6, 7, 2, 1, 10, 5, 9, 8, 12, 11, 4] 5 3 [1, 2, 3, 4, 5, 8, 6, 7, 9, 10, 11, 12] 2 2 [5, 8, 1, 2, 9, 4, 12, 11, 3, 10, 6, 7] 4 10 [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18] 1 입출력 예 설명 입출력 예 #1 문제 예시와 같습니다. 입출력 예 #2 처음에 1, 2, 3, 4 카드 4장과 동전 3개를 가지고 시작합니다. 다음 라운드로 진행하기 위해 내야 할 카드 두 장에 적힌 수의 합은 13입니다. 다음과 같은 방법으로 최대 2라운드까지 도달할 수 있습니다. 1라운드에서 뽑은 카드 5, 8을 동전 두 개를 소모해서 모두 가집니다. 카드 5, 8을 내고 다음 라운드로 진행합니다. 이때 손에 남은 카드는 1, 2, 3, 4이고 동전이 1개 남습니다. 2라운드에서 뽑은 카드 6, 7중 남은 동전 한 개로 어떤 카드를 골라도 카드에 적힌 수의 합이 13이 되도록 카드 두 장을 낼 수 없으므로 게임이 종료됩니다. 따라서 2를 return 하면 됩니다. 입출력 예 #3 처음에 5, 8, 1, 2 카드 4장과 동전 2개를 가지고 시작합니다. 다음 라운드로 진행하기 위해 내야 할 카드 두 장에 적힌 수의 합은 13입니다. 다음과 같은 방법으로 최대 4라운드까지 도달할 수 있습니다. 1라운드에서 뽑은 카드 9, 4를 동전을 소모하지 않고 모두 버립니다. 카드 5, 8을 내고 다음 라운드로 진행합니다. 이때 손에 남은 카드는 1, 2고 동전이 2개 남습니다. 2라운드에서 뽑은 카드 12, 11를 동전 두 개를 소모해서 모두 가집니다. 카드 1, 12를 내고 다음 라운드로 진행합니다. 이때 손에 남은 카드는 2, 11이고 남은 동전이 없으므로 더 이상 카드를 추가로 가질 수 없습니다. 3라운드에서 뽑은 카드 3, 10을 모두 버립니다. 카드 2, 11을 내고 다음 라운드로 진행합니다. 이때 손에 남은 카드와 동전은 없습니다. 4라운드에서 뽑은 카드 6, 7을 모두 버립니다. 카드에 적힌 수의 합이 13이 되도록 카드 두 장을 낼 수 없으므로 게임이 종료됩니다. 따라서 4를 return 하면 됩니다. 입출력 예 #4 처음에 1, 2, 3, 4, 5, 6 카드 6장과 동전 10개를 가지고 시작합니다. 다음 라운드로 진행하기 위해 내야 할 카드 두 장에 적힌 수의 합은 19입니다. 1라운드에서 카드 7, 8 두 장을 모두 가져도 합이 19가 되도록 카드 두 장을 낼 수 없으므로 최대 1라운드까지만 도달할 수 있습니다. 따라서 1을 return 하면 됩니다.",normal,Array
5,"한 변의 길이가 1인 정삼각형 2n+1개를 이어붙여 윗변의 길이가 n, 아랫변의 길이가 n+1인 사다리꼴을 만들 수 있습니다. 이때 사다리꼴의 윗변과 변을 공유하는 n개의 정삼각형 중 일부의 위쪽에 같은 크기의 정삼각형을 붙여 새로운 모양을 만들었습니다. 예를 들어 n이 4이고, 1번째, 2번째, 4번째 정삼각형 위에 정삼각형을 붙인 모양은 다음과 같습니다. 이렇게 만든 모양을 정삼각형 타일 또는 정삼각형 2개를 이어 붙인 마름모 타일로 빈 곳이 없도록 채우려고 합니다. 정삼각형 타일과 마름모 타일은 돌려서 사용할 수 있습니다. 타일을 놓을 때 다른 타일과 겹치거나 모양을 벗어나게 놓을 수는 없습니다. 위의 예시 모양을 채우는 방법 중 일부는 다음과 같습니다. 사다리꼴의 윗변의 길이를 나타내는 정수 n과 사다리꼴 윗변에 붙인 정삼각형을 나타내는 1차원 정수 배열 tops가 매개변수로 주어집니다. 이때 문제 설명에 따라 만든 모양을 정삼각형 또는 마름모 타일로 빈 곳이 없도록 채우는 경우의 수를 10007로 나눈 나머지를 return 하도록 solution 함수를 완성해 주세요. 제한사항 1 ≤ n ≤ 100,000 tops의 길이 = n tops[i]는 사다리꼴의 윗변과 변을 공유하는 i+1번째 정삼각형의 위쪽에 정삼각형을 붙이는 경우 1, 붙이지 않는 경우 0입니다. 입출력 예 n tops result 4 [1, 1, 0, 1] 149 2 [0, 1] 11 10 [0, 0, 0, 0, 0, 0, 0, 0, 0, 0] 7704 입출력 예 설명 입출력 예 #1 문제의 예시와 같습니다. 문제에서 설명한 방법을 포함해 총 149가지 방법이 존재합니다. 따라서 149를 return 해야 합니다. 입출력 예 #2 문제 설명에 따라 만든 모양은 다음과 같습니다. 이 모양을 타일로 채우는 방법은 다음과 같이 총 11가지입니다. 따라서 11을 return 해야 합니다. 입출력 예 #3 경우의 수는 총 17,711가지입니다. 따라서 17711을 10007로 나눈 나머지인 7704를 return 해야 합니다.",normal,Array
6,"어떤 게임에는 붕대 감기라는 기술이 있습니다. 붕대 감기는 t초 동안 붕대를 감으면서 1초마다 x만큼의 체력을 회복합니다. t초 연속으로 붕대를 감는 데 성공한다면 y만큼의 체력을 추가로 회복합니다. 게임 캐릭터에는 최대 체력이 존재해 현재 체력이 최대 체력보다 커지는 것은 불가능합니다. 기술을 쓰는 도중 몬스터에게 공격을 당하면 기술이 취소되고, 공격을 당하는 순간에는 체력을 회복할 수 없습니다. 몬스터에게 공격당해 기술이 취소당하거나 기술이 끝나면 그 즉시 붕대 감기를 다시 사용하며, 연속 성공 시간이 0으로 초기화됩니다. 몬스터의 공격을 받으면 정해진 피해량만큼 현재 체력이 줄어듭니다. 이때, 현재 체력이 0 이하가 되면 캐릭터가 죽으며 더 이상 체력을 회복할 수 없습니다. 당신은 붕대감기 기술의 정보, 캐릭터가 가진 최대 체력과 몬스터의 공격 패턴이 주어질 때 캐릭터가 끝까지 생존할 수 있는지 궁금합니다. 붕대 감기 기술의 시전 시간, 1초당 회복량, 추가 회복량을 담은 1차원 정수 배열 bandage와 최대 체력을 의미하는 정수 health, 몬스터의 공격 시간과 피해량을 담은 2차원 정수 배열 attacks가 매개변수로 주어집니다. 모든 공격이 끝난 직후 남은 체력을 return 하도록 solution 함수를 완성해 주세요. 만약 몬스터의 공격을 받고 캐릭터의 체력이 0 이하가 되어 죽는다면 -1을 return 해주세요. 제한사항 bandage는 [시전 시간, 초당 회복량, 추가 회복량] 형태의 길이가 3인 정수 배열입니다. 1 ≤ 시전 시간 = t ≤ 50 1 ≤ 초당 회복량 = x ≤ 100 1 ≤ 추가 회복량 = y ≤ 100 1 ≤ health ≤ 1,000 1 ≤ attacks의 길이 ≤ 100 attacks[i]는 [공격 시간, 피해량] 형태의 길이가 2인 정수 배열입니다. attacks는 공격 시간을 기준으로 오름차순 정렬된 상태입니다. attacks의 공격 시간은 모두 다릅니다. 1 ≤ 공격 시간 ≤ 1,000 1 ≤ 피해량 ≤ 100 입출력 예 bandage health attacks result [5, 1, 5] 30 [[2, 10], [9, 15], [10, 5], [11, 5]] 5 [3, 2, 7] 20 [[1, 15], [5, 16], [8, 6]] -1 [4, 2, 7] 20 [[1, 15], [5, 16], [8, 6]] -1 [1, 1, 1] 5 [[1, 2], [3, 2]] 3 입출력 예 설명 입출력 예 #1 몬스터의 마지막 공격은 11초에 이루어집니다. 0초부터 11초까지 캐릭터의 상태는 아래 표와 같습니다. 시간 현재 체력(변화량) 연속 성공 공격 설명 0 30 0 X 초기 상태 1 30(+0) 1 X 최대 체력 이상의 체력을 가질 수 없습니다. 2 20(-10) 0 O 몬스터의 공격으로 연속 성공이 초기화됩니다. 3 21(+1) 1 X 4 22(+1) 2 X 5 23(+1) 3 X 6 24(+1) 4 X 7 30(+6) 5 → 0 X 5초 연속 성공해 체력을 5만큼 추가 회복하고 연속 성공이 초기화됩니다. 8 30(+0) 1 X 최대 체력 이상의 체력을 가질 수 없습니다. 9 15(-15) 0 O 몬스터의 공격으로 연속 성공이 초기화됩니다. 10 10(-5) 0 O 몬스터의 공격으로 연속 성공이 초기화됩니다. 11 5(-5) 0 O 몬스터의 마지막 공격입니다. 몬스터의 마지막 공격 직후 캐릭터의 체력은 5입니다. 따라서 5을 return 해야 합니다. 입출력 예 #2 몬스터의 마지막 공격은 8초에 이루어집니다. 0초부터 8초까지 캐릭터의 상태는 아래 표와 같습니다. 시간 현재 체력(변화량) 연속 성공 공격 설명 0 20 0 X 초기 상태 1 5(-15) 0 O 몬스터의 공격으로 연속 성공이 초기화됩니다. 2 7(+2) 1 X 3 9(+2) 2 X 4 18(+9) 3 → 0 X 3초 연속 성공해 체력을 7만큼 추가 회복하고 연속 성공이 초기화됩니다. 5 2(-16) 0 O 몬스터의 공격으로 연속 성공이 초기화됩니다. 6 4(+2) 1 X 7 6(+2) 2 X 8 0(-6) 0 O 몬스터의 마지막 공격을 받아 캐릭터의 체력이 0 이하가 됩니다. 몬스터의 공격을 받아 캐릭터의 체력이 0 이하가 됩니다. 따라서 -1을 return 해야 합니다. 입출력 예 #3 몬스터의 마지막 공격은 8초에 이루어집니다. 0초부터 5초까지 캐릭터의 상태는 아래 표와 같습니다. 시간 현재 체력(변화량) 연속 성공 공격 설명 0 20 0 X 초기 상태 1 5(-15) 0 O 몬스터의 공격으로 연속 성공이 초기화됩니다. 2 7(+2) 1 X 3 9(+2) 2 X 4 11(+2) 3 X 5 -5(-16) 0 O 몬스터의 공격을 받아 캐릭터의 체력이 0 이하가 됩니다. 몬스터의 공격을 받아 캐릭터의 체력이 0 이하가 됩니다. 따라서 -1을 return 해야 합니다. 입출력 예 #4 몬스터의 마지막 공격은 3초에 이루어집니다. 0초부터 3초까지 캐릭터의 상태는 아래 표와 같습니다. 시간 현재 체력(변화량) 연속 성공 공격 설명 0 5 0 X 초기 상태 1 3(-2) 0 O 몬스터의 공격으로 연속 성공이 초기화됩니다. 2 5(+2) 1 → 0 X 1초 연속 성공해 체력을 1만큼 추가 회복하고 연속 성공이 초기화됩니다. 3 3(-2) 0 O 몬스터의 마지막 공격입니다. 몬스터의 마지막 공격 직후 캐릭터의 체력은 3입니다. 따라서 3을 return 해야 합니다.",easy,Array
7,"[본 문제는 정확성과 효율성 테스트 각각 점수가 있는 문제입니다.] 세로길이가 n 가로길이가 m인 격자 모양의 땅 속에서 석유가 발견되었습니다. 석유는 여러 덩어리로 나누어 묻혀있습니다. 당신이 시추관을 수직으로 단 하나만 뚫을 수 있을 때, 가장 많은 석유를 뽑을 수 있는 시추관의 위치를 찾으려고 합니다. 시추관은 열 하나를 관통하는 형태여야 하며, 열과 열 사이에 시추관을 뚫을 수 없습니다. 예를 들어 가로가 8, 세로가 5인 격자 모양의 땅 속에 위 그림처럼 석유가 발견되었다고 가정하겠습니다. 상, 하, 좌, 우로 연결된 석유는 하나의 덩어리이며, 석유 덩어리의 크기는 덩어리에 포함된 칸의 수입니다. 그림에서 석유 덩어리의 크기는 왼쪽부터 8, 7, 2입니다. 시추관은 위 그림처럼 설치한 위치 아래로 끝까지 뻗어나갑니다. 만약 시추관이 석유 덩어리의 일부를 지나면 해당 덩어리에 속한 모든 석유를 뽑을 수 있습니다. 시추관이 뽑을 수 있는 석유량은 시추관이 지나는 석유 덩어리들의 크기를 모두 합한 값입니다. 시추관을 설치한 위치에 따라 뽑을 수 있는 석유량은 다음과 같습니다. 시추관의 위치 획득한 덩어리 총 석유량 1 [8] 8 2 [8] 8 3 [8] 8 4 [7] 7 5 [7] 7 6 [7] 7 7 [7, 2] 9 8 [2] 2 오른쪽 그림처럼 7번 열에 시추관을 설치하면 크기가 7, 2인 덩어리의 석유를 얻어 뽑을 수 있는 석유량이 9로 가장 많습니다. 석유가 묻힌 땅과 석유 덩어리를 나타내는 2차원 정수 배열 land가 매개변수로 주어집니다. 이때 시추관 하나를 설치해 뽑을 수 있는 가장 많은 석유량을 return 하도록 solution 함수를 완성해 주세요. 제한사항 1 ≤ land의 길이 = 땅의 세로길이 = n ≤ 500 1 ≤ land[i]의 길이 = 땅의 가로길이 = m ≤ 500 land[i][j]는 i+1행 j+1열 땅의 정보를 나타냅니다. land[i][j]는 0 또는 1입니다. land[i][j]가 0이면 빈 땅을, 1이면 석유가 있는 땅을 의미합니다. 정확성 테스트 케이스 제한사항 1 ≤ land의 길이 = 땅의 세로길이 = n ≤ 100 1 ≤ land[i]의 길이 = 땅의 가로길이 = m ≤ 100 효율성 테스트 케이스 제한사항 주어진 조건 외 추가 제한사항 없습니다. 입출력 예 land result [[0, 0, 0, 1, 1, 1, 0, 0], [0, 0, 0, 0, 1, 1, 0, 0], [1, 1, 0, 0, 0, 1, 1, 0], [1, 1, 1, 0, 0, 0, 0, 0], [1, 1, 1, 0, 0, 0, 1, 1]] 9 [[1, 0, 1, 0, 1, 1], [1, 0, 1, 0, 0, 0], [1, 0, 1, 0, 0, 1], [1, 0, 0, 1, 0, 0], [1, 0, 0, 1, 0, 1], [1, 0, 0, 0, 0, 0], [1, 1, 1, 1, 1, 1]] 16 입출력 예 설명 입출력 예 #1 문제의 예시와 같습니다. 입출력 예 #2 시추관을 설치한 위치에 따라 뽑을 수 있는 석유는 다음과 같습니다. 시추관의 위치 획득한 덩어리 총 석유량 1 [12] 12 2 [12] 12 3 [3, 12] 15 4 [2, 12] 14 5 [2, 12] 14 6 [2, 1, 1, 12] 16 6번 열에 시추관을 설치하면 크기가 2, 1, 1, 12인 덩어리의 석유를 얻어 뽑을 수 있는 석유량이 16으로 가장 많습니다. 따라서 16을 return 해야 합니다. 제한시간 안내 정확성 테스트 : 10초 효율성 테스트 : 언어별로 작성된 정답 코드의 실행 시간의 적정 배수",normal,Array
8,"시침, 분침, 초침이 있는 아날로그시계가 있습니다. 시계의 시침은 12시간마다, 분침은 60분마다, 초침은 60초마다 시계를 한 바퀴 돕니다. 따라서 시침, 분침, 초침이 움직이는 속도는 일정하며 각각 다릅니다. 이 시계에는 초침이 시침/분침과 겹칠 때마다 알람이 울리는 기능이 있습니다. 당신은 특정 시간 동안 알람이 울린 횟수를 알고 싶습니다. 다음은 0시 5분 30초부터 0시 7분 0초까지 알람이 울린 횟수를 세는 예시입니다. 가장 짧은 바늘이 시침, 중간 길이인 바늘이 분침, 가장 긴 바늘이 초침입니다. 알람이 울리는 횟수를 세기 시작한 시각은 0시 5분 30초입니다. 이후 0시 6분 0초까지 초침과 시침/분침이 겹치는 일은 없습니다. 약 0시 6분 0.501초에 초침과 시침이 겹칩니다. 이때 알람이 한 번 울립니다. 이후 0시 6분 6초까지 초침과 시침/분침이 겹치는 일은 없습니다. 약 0시 6분 6.102초에 초침과 분침이 겹칩니다. 이때 알람이 한 번 울립니다. 이후 0시 7분 0초까지 초침과 시침/분침이 겹치는 일은 없습니다. 0시 5분 30초부터 0시 7분 0초까지는 알람이 두 번 울립니다. 이후 약 0시 7분 0.584초에 초침과 시침이 겹쳐서 울리는 세 번째 알람은 횟수에 포함되지 않습니다. 다음은 12시 0분 0초부터 12시 0분 30초까지 알람이 울린 횟수를 세는 예시입니다. 알람이 울리는 횟수를 세기 시작한 시각은 12시 0분 0초입니다. 초침과 시침, 분침이 겹칩니다. 이때 알람이 한 번 울립니다. 이와 같이 0시 정각, 12시 정각에 초침과 시침, 분침이 모두 겹칠 때는 알람이 한 번만 울립니다. 이후 12시 0분 30초까지 초침과 시침/분침이 겹치는 일은 없습니다. 12시 0분 0초부터 12시 0분 30초까지는 알람이 한 번 울립니다. 알람이 울리는 횟수를 센 시간을 나타내는 정수 h1, m1, s1, h2, m2, s2가 매개변수로 주어집니다. 이때, 알람이 울리는 횟수를 return 하도록 solution 함수를 완성해주세요. 제한사항 0 ≤ h1, h2 ≤ 23 0 ≤ m1, m2 ≤ 59 0 ≤ s1, s2 ≤ 59 h1시 m1분 s1초부터 h2시 m2분 s2초까지 알람이 울리는 횟수를 센다는 의미입니다. h1시 m1분 s1초 < h2시 m2분 s2초 시간이 23시 59분 59초를 초과해서 0시 0분 0초로 돌아가는 경우는 주어지지 않습니다. 입출력 예 h1 m1 s1 h2 m2 s2 result 0 5 30 0 7 0 2 12 0 0 12 0 30 1 0 6 1 0 6 6 0 11 59 30 12 0 0 1 11 58 59 11 59 0 1 1 5 5 1 5 6 2 0 0 0 23 59 59 2852 입출력 예 설명 입출력 예 #1 문제 예시와 같습니다. 입출력 예 #2 문제 예시와 같습니다. 입출력 예 #3 0시 6분 1초부터 0시 6분 6초까지 초침과 시침/분침이 겹치는 일은 없습니다. 따라서 알람이 울리지 않으며 0을 return 해야 합니다. 입출력 예 #4 11시 59분 30초부터 11시 59분 59초까지 초침과 시침/분침이 겹치는 일은 없습니다. 12시 0분 0초에 초침과 시침, 분침이 겹칩니다. 이때 알람이 한 번 울립니다. 11시 59분 30초부터 12시 0분 0초까지 초침과 시침/분침이 겹치는 횟수는 1이며 따라서 알람이 한 번 울립니다. 입출력 예 #5 약 11시 58분 59.917초에 초침과 시침이 겹칩니다. 이때 알람이 한 번 울립니다. 11시 58분 59초부터 11시 59분 0초까지 초침과 시침/분침이 겹치는 횟수는 1이며 따라서 알람이 한 번 울립니다. 입출력 예 #6 약 1시 5분 5.085초에 초침과 분침이 겹칩니다. 이때 알람이 한 번 울립니다. 약 1시 5분 5.424초에 초침과 시침이 겹칩니다. 이때 알람이 한 번 울립니다. 1시 5분 5초부터 1시 5분 6초까지 초침과 시침/분침이 겹치는 횟수는 2며 따라서 알람이 두 번 울립니다. 입출력 예 #7 0시 0분 0초부터 23시 59분 59초까지 초침과 시침/분침이 겹치는 횟수는 2852며 따라서 알람이 총 2852번 울립니다.",normal,Math
9,"n x m 크기 격자 모양의 퍼즐판이 주어집니다. 퍼즐판에는 빨간색 수레와 파란색 수레가 하나씩 존재합니다. 각 수레들은 자신의 시작 칸에서부터 자신의 도착 칸까지 이동해야 합니다. 모든 수레들을 각자의 도착 칸으로 이동시키면 퍼즐을 풀 수 있습니다. 당신은 각 턴마다 반드시 모든 수레를 상하좌우로 인접한 칸 중 한 칸으로 움직여야 합니다. 단, 수레를 움직일 때는 아래와 같은 규칙이 있습니다. 수레는 벽이나 격자 판 밖으로 움직일 수 없습니다. 수레는 자신이 방문했던 칸으로 움직일 수 없습니다. 자신의 도착 칸에 위치한 수레는 움직이지 않습니다. 계속 해당 칸에 고정해 놓아야 합니다. 동시에 두 수레를 같은 칸으로 움직일 수 없습니다. 수레끼리 자리를 바꾸며 움직일 수 없습니다. 예를 들어, 아래 그림처럼 n = 3, m = 2인 퍼즐판이 있습니다. 속이 빨간색인 원은 빨간색 수레를 나타냅니다. 속이 파란색인 원은 파란색 수레를 나타냅니다. 테두리가 빨간색인 원은 빨간색 수레의 도착 칸을 나타냅니다. 테두리가 파란색인 원은 파란색 수레의 도착 칸을 나타냅니다. 위 퍼즐판은 아래와 같은 순서로 3턴만에 풀 수 있습니다. 빨간색 사선이 처진 칸은 빨간색 수레가 방문했던 칸을 나타냅니다. 규칙에 따라 빨간색 수레는 빨간색 사선이 처진 칸(방문했던 칸)으로는 이동할 수 없습니다. 파란색 사선이 처진 칸은 파란색 수레가 방문했던 칸을 나타냅니다. 규칙에 따라 파란색 수레는 파란색 사선이 처진 칸(방문했던 칸)으로는 이동할 수 없습니다. 위처럼 동시에 수레를 같은 칸으로 움직일 수는 없습니다. 퍼즐판의 정보를 나타내는 2차원 정수 배열 maze가 매개변수로 주어집니다. 퍼즐을 푸는데 필요한 턴의 최솟값을 return 하도록 solution 함수를 완성해 주세요. 퍼즐을 풀 수 없는 경우 0을 return 해주세요. 제한사항 1 ≤ maze의 길이 (= 세로 길이) ≤ 4 1 ≤ maze[i]의 길이 (= 가로 길이) ≤ 4 maze[i][j]는 0,1,2,3,4,5 중 하나의 값을 갖습니다. maze[i][j] 의미 0 빈칸 1 빨간 수레의 시작 칸 2 파란 수레의 시작 칸 3 빨간 수레의 도착 칸 4 파란 수레의 도착 칸 5 벽 빨간 수레의 시작 칸, 빨간 수레의 도착 칸, 파란 수레의 시작 칸, 파란 수레의 도착 칸은 퍼즐판에 1개씩 존재합니다. 입출력 예 maze result [[1, 4], [0, 0], [2, 3]] 3 [[1, 0, 2], [0, 0, 0], [5, 0 ,5], [4, 0, 3]] 7 [[1, 5], [2, 5], [4, 5], [3, 5]] 0 [[4, 1, 2, 3]] 0 입출력 예 설명 입출력 예 #1 문제 예시와 같습니다. 입출력 예 #2 7턴만에 퍼즐을 풀 수 있습니다. 다른 방법으로도 퍼즐을 풀 수 있지만 7턴보다 빠르게 풀 수는 없습니다. 입출력 예 #3 다음 턴에 파란색 수레가 파란색 수레의 도착 칸에 위치한 후 고정되어 빨간색 수레가 빨간색 수레의 도착 칸에 도착할 수 없게 됩니다. 퍼즐을 풀 수 없으므로 0을 return 해야 합니다. 입출력 예 #4 수레는 서로 위치를 바꾸면서 움직일 수 없으므로 퍼즐을 풀 수 없습니다. 따라서 0을 return 해야 합니다.",normal,Array
10,주어진 초기 코드는 변수에 데이터를 저장하고 출력하는 코드입니다. 아래와 같이 출력되도록 빈칸을 채워 코드를 완성해 주세요. 출력 예시 Spring is beginning 13 310,easy,Design
11,"직각삼각형이 주어졌을 때 빗변의 제곱은 다른 두 변을 각각 제곱한 것의 합과 같습니다. 직각삼각형의 한 변의 길이를 나타내는 정수 a와 빗변의 길이를 나타내는 정수 c가 주어질 때, 다른 한 변의 길이의 제곱, b_square 을 출력하도록 한 줄을 수정해 코드를 완성해 주세요. 제한사항 1 ≤ a < c ≤ 100 입출력 예 입력 #1 3 5 출력 #1 16 입력 #2 9 10 출력 #2 19 입출력 예 설명 입출력 예 #1 a2 = 9, c2 = 25 이므로 16을 출력합니다. 입출력 예 #2 a2 = 81, c2 = 100 이므로 19를 출력합니다.",easy,Math
12,"나이를 세는 방법은 여러 가지가 있습니다. 그중 한국식 나이는 태어난 순간 1살이 되며 해가 바뀔 때마다 1살씩 더 먹게 됩니다. 연 나이는 태어난 순간 0살이며 해가 바뀔 때마다 1살씩 더 먹게 됩니다. 각각 나이의 계산법은 다음과 같습니다. 한국식 나이 : 현재 연도 - 출생 연도 + 1 연 나이 : 현재 연도 - 출생 연도 출생 연도를 나타내는 정수 year와 구하려는 나이의 종류를 나타내는 문자열 age_type이 주어질 때 2030년에 몇 살인지 출력하도록 빈칸을 채워 코드를 완성해 주세요. age_type이 ""Korea""라면 한국식 나이를, ""Year""라면 연 나이를 출력합니다. 제한사항 1950 ≤ year ≤ 2030 age_type은 ""Korea"" 또는 ""Year""만 주어집니다. 입출력 예 입력 #1 2000 Korea 출력 #1 31 입력 #2 1999 Year 출력 #2 31 입출력 예 설명 입출력 예 #1 2030년에 2000년생의 한국식 나이는 2030 - 2000 + 1 = 31살입니다. 입출력 예 #2 2030년에 1999년생의 연 나이는 2030 - 1999 = 31살입니다.",easy,String
13,"진우는 돈을 모으기 위해 저축을 하려고 합니다. 목표로 하는 금액은 100만 원이며, 첫 달에 일정 금액을 넣은 뒤 70만 원까지는 매월 조금씩 저축하다가 70만 원 이후부터는 월 저축량을 늘려 빠르게 목표 금액을 달성하고자 합니다. 첫 달에 저축하는 금액을 나타내는 정수 start, 두 번째 달 부터 70만 원 이상 모일 때까지 매월 저축하는 금액을 나타내는 정수 before, 100만 원 이상 모일 때 까지 매월 저축하는 금액을 나타내는 정수 after가 주어질 때, 100만 원 이상을 모을 때까지 걸리는 개월 수를 출력하도록 빈칸을 채워 코드를 완성해 주세요. 제한사항 0 ≤ start ≤ 99 1 ≤ before ≤ after ≤ 25 입출력 예 입력 #1 28 6 8 출력 #1 12 입력 #2 75 8 25 출력 #2 2 입출력 예 설명 입출력 예 #1 매월 저축된 금액은 아래 표와 같습니다. 따라서 12를 출력합니다. 1 2 3 4 5 6 7 8 9 10 11 12 28 34 40 46 52 58 64 70 78 86 94 102 입출력 예 #2 첫 달 저축된 금액이 70이 넘으므로 두 번째 달부터 바로 after= 25 만큼 저축합니다. 따라서 2를 출력합니다. 1 2 75 100",easy,Math
14,"여름이는 강아지를 산책시키려고 합니다. 여름이는 2차원 좌표평면에서 동/서/남/북 방향으로 1m 단위로 이동하면서 강아지를 산책시킵니다. 산책루트가 담긴 문자열 route가 주어질 때, 도착점의 위치를 return하도록 빈칸을 채워 solution함수를 완성해 주세요. route는 ""N"", ""S"", ""E"", ""W""로 이루어져 있습니다. ""N""은 북쪽으로 1만큼 움직입니다. ""S""는 남쪽으로 1만큼 움직입니다. 북쪽으로 -1만큼 움직인 것과 같습니다. ""E""는 동쪽으로 1만큼 움직입니다. ""W""는 서쪽으로 1만큼 움직입니다. 동쪽으로 -1만큼 움직인 것과 같습니다. 출발점으로부터 [동쪽으로 떨어진 거리, 북쪽으로 떨어진 거리]형태로 강아지의 최종 위치를 구해서 return해야 합니다. 출발점을 기준으로 서쪽, 남쪽에 있는 경우는 동쪽, 북쪽으로 음수만큼 떨어진 것으로 표현합니다. 출발점으로부터 동쪽으로 2, 북쪽으로 3만큼 떨어졌다면 [2, 3]을 return 합니다. 출발점으로부터 서쪽으로 1, 남쪽으로 4만큼 떨어졌다면 [-1, -4]를 return 합니다. 제한사항 1 ≤ route의 길이 ≤ 20 route는 ""N"", ""S"", ""E"", ""W""로만 이루어져 있습니다. 입출력 예 route result ""NSSNEWWN"" [-1, 1] ""EESEEWNWSNWWNS"" [0, 0] 입출력 예 설명 입출력 예 #1 ""NSSNEWWN"" 순서대로 움직이면 서쪽으로 1, 북쪽으로 1만큼 떨어진 곳에 도착하게 되므로 [-1, 1]을 return합니다. 입출력 예 #2 ""EESEEWNWSNWWNS"" 순서대로 움직이면 출발지와 같은 곳으로 돌아오므로 [0, 0]을 return합니다. cpp를 응시하는 경우 리스트는 배열과 동일한 의미이니 풀이에 참고해주세요. ex) 번호가 담긴 정수 리스트 numbers가 주어집니다. => 번호가 담긴 정수 배열 numbers가 주어집니다. java를 응시하는 경우 리스트는 배열, 함수는 메소드와 동일한 의미이니 풀이에 참고해주세요. ex) solution 함수가 올바르게 작동하도록 한 줄을 수정해 주세요. => solution 메소드가 올바르게 작동하도록 한 줄을 수정해 주세요.",easy,Array
15,"A반 학생들은 시험이 끝난 뒤 성적이 나오기 전 자기 시험지를 가채점해 보았습니다. 이후에 선생님이 실제 성적을 불러 줄 때 가채점한 점수와 실제 성적이 다른 학생들이 있어 선생님께 문의를 하려고 합니다. 성적을 문의하려는 학생들의 번호가 담긴 정수 리스트 numbers와 가채점한 점수가 성적을 문의하려는 학생 순서대로 담긴 정수 리스트 our_score, 실제 성적이 번호 순서대로 담긴 정수 리스트 score_list가 주어집니다. 주어진 solution 함수는 가채점한 점수가 실제 성적과 동일하다면 ""Same""을, 다르다면 ""Different""를 순서대로 리스트에 담아 return하는 함수입니다. solution 함수가 올바르게 작동하도록 한 줄을 수정해 주세요. 제한사항 1 ≤ numbers의 길이 = our_score의 길이 ≤ 10 1 ≤ numbers의 원소 ≤ 31 0 ≤ our_score의 원소 ≤ 100 our_score[i]는 numbers[i]번 학생이 가채점한 점수입니다. numbers는 중복된 원소를 가지지 않습니다. 2 ≤ score_list의 길이 ≤ 31 0 ≤ score_list의 원소 ≤ 100 score_list에는 실제 성적이 [1번 학생 성적, 2번 학생 성적, 3번 학생 성적 …] 순서로 들어있습니다. 입출력 예 numbers our_score score_list result [1] [100] [100, 80, 90, 84, 20] [""Same""] [3, 4] [85, 93] [85, 92, 38, 93, 48, 85, 92, 56] [""Different"", ""Same""] 입출력 예 설명 입출력 예 #1 1번 학생이 가채점한 성적은 100점으로 실제 성적과 같기 때문에 ""Same""을 담아 return합니다. 입출력 예 #2 3번 학생이 가채점한 성적은 85점으로 실제 성적 38점과 다르기 때문에 ""Different""를, 4번 학생이 채점한 성적은 93점으로 실제 성적과 같기 때문에 ""Same""을 담아 return합니다. cpp를 응시하는 경우 리스트는 배열과 동일한 의미이니 풀이에 참고해주세요. ex) 번호가 담긴 정수 리스트 numbers가 주어집니다. => 번호가 담긴 정수 배열 numbers가 주어집니다. java를 응시하는 경우 리스트는 배열, 함수는 메소드와 동일한 의미이니 풀이에 참고해주세요. ex) solution 함수가 올바르게 작동하도록 한 줄을 수정해 주세요. => solution 메소드가 올바르게 작동하도록 한 줄을 수정해 주세요.",easy,Array
16,"상우가 사용하는 가습기에는 ""auto"", ""target"", ""minimum""의 세 가지 모드가 있습니다. 가습기의 가습량은 0~5단계로 구분되며 각 모드 별 동작 방식은 다음과 같습니다. ""auto"" 모드 습도가 0 이상 10 미만인 경우 : 5단계 습도가 10 이상 20 미만인 경우 : 4단계 습도가 20 이상 30 미만인 경우 : 3단계 습도가 30 이상 40 미만인 경우 : 2단계 습도가 40 이상 50 미만인 경우 : 1단계 습도가 50 이상인 경우 : 0단계 ""target"" 모드 습도가 설정값 미만일 경우 : 3단계 습도가 설정값 이상일 경우 : 1단계 ""minimum""모드 습도가 설정값 미만일 경우 : 1단계 습도가 설정값 이상일 경우 : 0단계 상우가 설정한 가습기의 모드를 나타낸 문자열 mode_type, 현재 공기 중 습도를 나타낸 정수 humidity, 설정값을 나타낸 정수 val_set이 주어질 때 현재 가습기가 몇 단계로 작동 중인지 return하도록 빈칸을 채워 solution 함수를 완성해 주세요. 제한사항 mode_type은 ""auto"", ""target"", ""minimum"" 세 가지 중 하나의 값을 갖습니다. 0 ≤ humidity, val_set ≤ 100 입출력 예 mode_type humidity val_set result ""auto"" 23 45 3 ""target"" 41 40 1 ""minimum"" 10 34 1 입출력 예 설명 입출력 예 #1 ""auto""모드이므로 습도에 따라 가습량이 조절됩니다. 현재 습도가 20 이상 30 미만이므로 3을 return합니다. 입출력 예 #2 ""target""모드이고, 설정값보다 습도가 높으므로 1을 return합니다. 입출력 예 #3 ""minimum""모드이고, 설정값보다 습도가 낮으므로 1을 return합니다. cpp를 응시하는 경우 리스트는 배열과 동일한 의미이니 풀이에 참고해주세요. ex) 번호가 담긴 정수 리스트 numbers가 주어집니다. => 번호가 담긴 정수 배열 numbers가 주어집니다. java를 응시하는 경우 리스트는 배열, 함수는 메소드와 동일한 의미이니 풀이에 참고해주세요. ex) solution 함수가 올바르게 작동하도록 한 줄을 수정해 주세요. => solution 메소드가 올바르게 작동하도록 한 줄을 수정해 주세요.",easy,Array
17,"선빈이는 게임을 즐기던 중 가지고 있는 물건이 너무 많아 창고 정리를 하기로 했습니다. 선빈이가 보유한 게임 속 창고는 여러 칸으로 나누어져 있고 각 칸에는 물건들이 담겨있습니다. 창고를 정리할 방법을 고민하던 선빈이는 같은 물건이 여러 칸에 나누어 들어있는 것을 발견하고 우선 같은 물건끼리 최대한 겹쳐쌓는 방식으로 창고를 정리하기로 했습니다. 선빈이의 창고에 들어있는 물건의 이름과 개수는 리스트 형태로 주어지며, 한 칸에 겹쳐질 수 있는 물건의 개수에는 제한이 없다고 가정합니다. 예를 들어 창고의 각 칸에 담겨있는 물건의 이름이storage = [""pencil"", ""pencil"", ""pencil"", ""book""], 각 물건의 개수가 num = [2, 4, 3, 1]이라면 연필과 책을 한 칸에 각각 겹쳐 쌓아 간단하게 clean_storage = [""pencil"", ""book""], clean_num = [9, 1]로 만들 수 있습니다. 주어진 solution 함수는 정리되기 전 창고의 물건 이름이 담긴 문자열 리스트 storage와 각 물건의 개수가 담긴 정수 리스트 num이 주어질 때, 정리된 창고에서 개수가 가장 많은 물건의 이름을 return 하는 함수입니다. solution 함수가 올바르게 작동하도록 한 줄을 수정해 주세요. 제한사항 1 ≤ storage의 길이 = num의 길이 ≤ 30 storage[i]는 영어 대소문자로 이루어져 있습니다. 물건은 대소문자를 구분합니다. 즉, ""Book""과 ""book""은 서로 다른 물건입니다. 1 ≤ storage[i]의 길이 ≤ 30 1 ≤ num[i] ≤ 20 num[i]에는 storage[i]에 해당하는 물건의 개수가 담겨있습니다. 가장 개수가 많은 물건이 두 가지 이상인 경우는 없습니다. 한 칸에는 한 종류의 물건만 들어갈 수 있습니다. 입출력 예 storage num result [""pencil"", ""pencil"", ""pencil"", ""book""] [2, 4, 3, 1] ""pencil"" [""doll"", ""doll"", ""doll"", ""doll""] [1, 1, 1, 1] ""doll"" [""apple"", ""steel"", ""leaf"", ""apple"", ""leaf""] [5, 3, 5, 3, 7] ""leaf"" [""mirror"", ""net"", ""mirror"", ""net"", ""bottle""] [4, 1, 4, 1, 5] ""mirror"" 입출력 예 설명 입출력 예 #1 본문에 설명된 대로 창고를 정리하면 clean_storage = [""pencil"", ""book""], clean_num = [9, 1]이 됩니다. 따라서 가장 개수가 많은 물건인 ""pencil""을 return합니다. 입출력 예 #2 창고를 정리하면 clean_storage = [""doll""], clean_num = [4]가 됩니다. 따라서 가장 개수가 많은 물건인 ""doll""을 return합니다. 입출력 예 #3 창고를 정리하면 clean_storage = [""apple"", ""steel"", ""leaf""], clean_num = [8, 3, 12]가 됩니다. 따라서 가장 개수가 많은 물건인 ""leaf""를 return합니다. 입출력 예 #4 창고를 정리하면 clean_storage = [""mirror"", ""net"", ""bottle""], clean_num = [8, 2, 5]가 됩니다. 따라서 가장 개수가 많은 물건인 ""mirror""를 return합니다. cpp를 응시하는 경우 리스트는 배열과 동일한 의미이니 풀이에 참고해주세요. ex) 번호가 담긴 정수 리스트 numbers가 주어집니다. => 번호가 담긴 정수 배열 numbers가 주어집니다. java를 응시하는 경우 리스트는 배열, 함수는 메소드와 동일한 의미이니 풀이에 참고해주세요. ex) solution 함수가 올바르게 작동하도록 한 줄을 수정해 주세요. => solution 메소드가 올바르게 작동하도록 한 줄을 수정해 주세요.",easy,Array
18,"각 칸마다 색이 칠해진 2차원 격자 보드판이 있습니다. 그중 한 칸을 골랐을 때, 위, 아래, 왼쪽, 오른쪽 칸 중 같은 색깔로 칠해진 칸의 개수를 구하려고 합니다. 보드의 각 칸에 칠해진 색깔 이름이 담긴 이차원 문자열 리스트 board와 고른 칸의 위치를 나타내는 두 정수 h, w가 주어질 때 board[h][w]와 이웃한 칸들 중 같은 색으로 칠해져 있는 칸의 개수를 return 하도록 solution 함수를 완성해 주세요. 이웃한 칸들 중 몇 개의 칸이 같은 색으로 색칠되어 있는지 확인하는 과정은 다음과 같습니다. 1. 정수를 저장할 변수 n을 만들고 board의 길이를 저장합니다. 2. 같은 색으로 색칠된 칸의 개수를 저장할 변수 count를 만들고 0을 저장합니다. 3. h와 w의 변화량을 저장할 정수 리스트 dh, dw를 만들고 각각 [0, 1, -1, 0], [1, 0, 0, -1]을 저장합니다. 4. 반복문을 이용해 i 값을 0부터 3까지 1 씩 증가시키며 아래 작업을 반복합니다. 4-1. 체크할 칸의 h, w 좌표를 나타내는 변수 h_check, w_check를 만들고 각각 h + dh[i], w + dw[i]를 저장합니다. 4-2. h_check가 0 이상 n 미만이고 w_check가 0 이상 n 미만이라면 다음을 수행합니다. 4-2-a. board[h][w]와 board[h_check][w_check]의 값이 동일하다면 count의 값을 1 증가시킵니다. 5. count의 값을 return합니다. 위의 의사코드와 작동방식이 다른 코드를 작성해도 상관없습니다. 제한사항 1 ≤ board의 길이 ≤ 7 board의 길이와 board[n]의 길이는 동일합니다. 0 ≤ h, w < board의 길이 1 ≤ board[h][w]의 길이 ≤ 10 board[h][w]는 영어 소문자로만 이루어져 있습니다. 입출력 예 board h w result [[""blue"", ""red"", ""orange"", ""red""], [""red"", ""red"", ""blue"", ""orange""], [""blue"", ""orange"", ""red"", ""red""], [""orange"", ""orange"", ""red"", ""blue""]] 1 1 2 [[""yellow"", ""green"", ""blue""], [""blue"", ""green"", ""yellow""], [""yellow"", ""blue"", ""blue""]] 0 1 1 입출력 예 설명 입출력 예 #1 주어진 보드를 나타내면 아래 그림과 같고, board[1][1]의 인접한 칸들은 화살표가 가리키는 칸들입니다. 따라서 board[1][1] 주변의 ""red"" 칸은 총 2개입니다. 입출력 예 #2 주어진 보드를 나타내면 아래 그림과 같고, board[0][1]의 인접한 칸들은 화살표가 가리키는 칸들입니다. 따라서 board[0][1] 주변의 ""green""칸은 총 1개입니다. cpp를 응시하는 경우 리스트는 배열과 동일한 의미이니 풀이에 참고해주세요. ex) 번호가 담긴 정수 리스트 numbers가 주어집니다. => 번호가 담긴 정수 배열 numbers가 주어집니다. java를 응시하는 경우 리스트는 배열, 함수는 메소드와 동일한 의미이니 풀이에 참고해주세요. ex) solution 함수가 올바르게 작동하도록 한 줄을 수정해 주세요. => solution 메소드가 올바르게 작동하도록 한 줄을 수정해 주세요.",easy,Array
19,"AI 엔지니어인 현식이는 데이터를 분석하는 작업을 진행하고 있습니다. 데이터는 [""코드 번호(code)"", ""제조일(date)"", ""최대 수량(maximum)"", ""현재 수량(remain)""]으로 구성되어 있으며 현식이는 이 데이터들 중 조건을 만족하는 데이터만 뽑아서 정렬하려 합니다. 예를 들어 다음과 같이 데이터가 주어진다면 data = [[1, 20300104, 100, 80], [2, 20300804, 847, 37], [3, 20300401, 10, 8]] 이 데이터는 다음 표처럼 나타낼 수 있습니다. code date maximum remain 1 20300104 100 80 2 20300804 847 37 3 20300401 10 8 주어진 데이터 중 ""제조일이 20300501 이전인 물건들을 현재 수량이 적은 순서""로 정렬해야 한다면 조건에 맞게 가공된 데이터는 다음과 같습니다. data = [[3,20300401,10,8],[1,20300104,100,80]] 정렬한 데이터들이 담긴 이차원 정수 리스트 data와 어떤 정보를 기준으로 데이터를 뽑아낼지를 의미하는 문자열 ext, 뽑아낼 정보의 기준값을 나타내는 정수 val_ext, 정보를 정렬할 기준이 되는 문자열 sort_by가 주어집니다. data에서 ext 값이 val_ext보다 작은 데이터만 뽑은 후, sort_by에 해당하는 값을 기준으로 오름차순으로 정렬하여 return 하도록 solution 함수를 완성해 주세요. 단, 조건을 만족하는 데이터는 항상 한 개 이상 존재합니다. 제한사항 1 ≤ data의 길이 ≤ 500 data[i]의 원소는 [코드 번호(code), 제조일(date), 최대 수량(maximum), 현재 수량(remain)] 형태입니다. 1 ≤ 코드 번호≤ 100,000 20000101 ≤ 제조일≤ 29991231 data[i][1]은 yyyymmdd 형태의 값을 가지며, 올바른 날짜만 주어집니다. (yyyy : 연도, mm : 월, dd : 일) 1 ≤ 최대 수량≤ 10,000 1 ≤ 현재 수량≤ 최대 수량 ext와 sort_by의 값은 다음 중 한 가지를 가집니다. ""code"", ""date"", ""maximum"", ""remain"" 순서대로 코드 번호, 제조일, 최대 수량, 현재 수량을 의미합니다. val_ext는 ext에 따라 올바른 범위의 숫자로 주어집니다. 정렬 기준에 해당하는 값이 서로 같은 경우는 없습니다. 입출력 예 data ext val_ext sort_by result [[1, 20300104, 100, 80], [2, 20300804, 847, 37], [3, 20300401, 10, 8]] ""date"" 20300501 ""remain"" [[3,20300401,10,8],[1,20300104,100,80]] 입출력 예 설명 입출력 예 #1 본문의 내용과 동일합니다. cpp를 응시하는 경우 리스트는 배열과 동일한 의미이니 풀이에 참고해주세요. ex) 번호가 담긴 정수 리스트 numbers가 주어집니다. => 번호가 담긴 정수 배열 numbers가 주어집니다. java를 응시하는 경우 리스트는 배열, 함수는 메소드와 동일한 의미이니 풀이에 참고해주세요. ex) solution 함수가 올바르게 작동하도록 한 줄을 수정해 주세요. => solution 메소드가 올바르게 작동하도록 한 줄을 수정해 주세요.",easy,Array
20,"현대모비스에서는 운전자와 탑승자의 편의를 위한 인포테인먼트 헤드유닛이 탑재되어 있습니다. 인포테인먼트 헤드유닛은 운전자와 탑승자에게 차량내/외의 다양한 정보를 제공하면서 동시에 내비게이션, 음성인식, 텔레매틱스 서비스, 멀티미디어 기능 등 엔터테인먼트 및 편의 서비스를 통합적으로 제공하는 기기입니다. n × m 직사각형 격자 모양의 도로가 나 있는 미로가 있습니다. 미로에서 왼쪽 아래 구석의 좌표는 (0, 0), 오른쪽 위 구석의 좌표는 (n, m) 입니다. 정수 좌표 (a, b)에는 표지판이 있습니다. 자동차의 내비게이션 기능과 차량의 주행 능력을 검증하기 위해 미로의 다양한 위치에서 출발하여 표지판까지 최단 경로를 따라 이동한 테스트 기록이 있습니다. 각 테스트는 출발점의 좌표, 남은 연료량에 따른 최대 주행 거리, 표지판 도달 여부가 기록되어 있습니다. 출발점의 위치와 표지판의 위치가 같을 수 있으며, 이때는 최대 주행 거리에 상관없이 항상 표지판에 도달한 것으로 간주합니다. 테스트 기록을 토대로 표지판의 위치를 알아내려 합니다. 예를 들어 n = 3, m = 5이고 테스트 기록이 다음과 같은 경우를 생각해 봅시다. 번호 출발점 좌표 최대 주행 거리 표지판 도달 여부 #1 (2, 3) 2 O #2 (1, 0) 4 X #3 (0, 4) 1 X 이때 표지판이 있을 수 있는 좌표는 (2, 4), (2, 5), (3, 3), (3, 4)의 4개입니다. 격자의 가로 길이 n, 세로 길이 m, 테스트 기록을 나타내는 2차원 정수 배열 tests가 매개변수로 주어집니다. 표지판이 있을 수 있는 좌표의 개수를 return 하도록 solution 함수를 완성해 주세요. 제한사항 3 ≤ n ≤ 109 3 ≤ m ≤ 109 1 ≤ tests의 길이 ≤ 250,000 tests의 원소는 [x, y, d, flag] 형태의 길이가 4인 정수 배열입니다. 출발점의 좌표가 (x, y), 최대 주행 거리가 d이고, flag가 1인 경우 표지판에 도달했음을, 0인 경우 표지판에 도달하지 못했음을 의미합니다. 0 ≤ x ≤ n 0 ≤ y ≤ m 0 ≤ d ≤ n + m 0 ≤ flag ≤ 1 표지판이 있을 수 있는 좌표가 하나 이상 존재합니다. 입출력 예 n m tests result 3 5 [[2, 3, 2, 1], [1, 0, 4, 0], [0, 4, 1, 0]] 4 99999 99999 [[0, 0, 199997, 1]] 9999999999 99999 99999 [[50000, 50000, 3, 0]] 9999999975 300 100 [[123, 28, 124, 1], [183, 22, 34, 0], [188, 81, 116, 1], [167, 53, 33, 0], [125, 55, 20, 0]] 6535 입출력 예 설명 입출력 예 #1 문제 예시와 같습니다. 입출력 예 #2 총 (99,999 + 1) × (99,999 + 1) = 10,000,000,000개의 정수 좌표 중 (99999, 99999)를 제외한 모든 좌표에 표지판이 있을 수 있습니다. 따라서 9,999,999,999를 return 하면 됩니다. 입출력 예 #3 총 (99,999 + 1) × (99,999 + 1) = 10,000,000,000개의 정수 좌표 중 (50000, 50000)으로부터 거리가 3 이하인 좌표 25개를 제외한 모든 좌표에 표지판이 있을 수 있습니다. 따라서 9,999,999,975를 return 하면 됩니다. 입출력 예 #4 5개의 테스트 기록을 모두 만족하는 정수 좌표의 개수는 총 6,535개임을 알 수 있습니다. 따라서 6,535를 return 하면 됩니다.",hard,Array
21,"현대모비스의 주행시험장 트랙을 주행해 볼 수 있는 가상 시뮬레이션 프로그램이 있습니다. 시뮬레이션의 트랙에는 1 ~ n의 서로 다른 번호가 붙은 지점이 n개 있으며, 각 지점마다 고유한 스탬프가 있습니다. 각 지점을 방문할 때 해당 지점의 스탬프를 얻을 수 있습니다. 당신은 1번 지점에서 시작하여 각 지점을 최소 한 번씩 방문해 n가지 스탬프를 모두 모으려 합니다. 지점들은 m개의 단방향 도로로 연결되어 있습니다. 당신은 지점 사이를 이동하기 위해 단방향 도로를 이용할 수 있습니다. 다음은 n = 6인 예시입니다. 각 원은 지점을 나타내며, 원 안에 적힌 수는 지점의 번호를 나타냅니다. 화살표는 두 지점을 연결하고 있는 단방향 도로를 나타냅니다. 위 예시에서 1번 지점에서 출발해 1 - 2 - 6과 같은 경로로 움직이면 1, 2, 6번 지점의 스탬프 3가지를 모을 수 있습니다. 하지만 6번 지점에 도착하면 더 이상 이용할 수 있는 도로가 없습니다. 시뮬레이션에는 단방향 도로를 이용하는 것 외의 이동 방법으로 빠른 이동 기능이 있습니다. 빠른 이동이란 당신이 스탬프를 얻은 지점 중 원하는 곳으로 순간 이동할 수 있는 기능입니다. 예를 들어 위 예시에서 1 - 2 - 6 - 2(빠른 이동) - 4 - 3 - 5와 같은 경로로 움직이면 모든 지점을 한 번씩 방문해 n가지 스탬프를 모두 모을 수 있습니다. 당신은 n가지 스탬프를 모두 모으기 위해 필요한 빠른 이동의 최소 사용 횟수를 알고 싶습니다. 지점의 수를 나타내는 정수 n과 지점을 연결하는 단방향 도로들의 정보를 담고 있는 2차원 정수 배열 roads가 매개변수로 주어집니다. 이때, 1번 지점에서 출발해 n가지 스탬프를 모두 모으기 위해 필요한 빠른 이동의 최소 사용 횟수를 return 하도록 solution 함수를 완성해 주세요. 제한사항 2 ≤ n ≤ 500 n - 1 ≤ roads의 길이 = m ≤ 100,000 roads의 원소는 [a, b] 형태입니다. a번 지점에서 b번 지점으로 이동할 수 있는 단방향 도로를 의미합니다. 1 ≤ a, b ≤ n a ≠ b 같은 도로는 최대 한 번만 주어집니다. 도착 불가능한 지점이 있는 경우는 주어지지 않습니다. 입출력 예 n roads result 6 [[1, 2], [2, 6], [2, 4], [4, 3], [3, 2], [3, 5]] 1 5 [[1, 2], [2, 3], [3, 4], [4, 5]] 0 8 [[6, 4], [2, 3], [1, 6], [4, 5], [1, 2], [1, 8], [3, 7], [7, 2]] 2 9 [[1, 2], [1, 3], [1, 4], [2, 5], [4, 5], [5, 6], [5, 7], [6, 9], [7, 9], [5, 8]] 3 7 [[1, 2], [2, 3], [3, 4], [4, 5], [3, 6], [1, 7], [7, 4]] 1 입출력 예 설명 입출력 예 #1 문제 예시와 같습니다. 입출력 예 #2 지점들의 연결 상태는 아래 그림과 같습니다. 1 - 2 - 3 - 4 - 5와 같은 경로로 움직이면 빠른 이동을 사용하지 않고 모든 지점을 최소 한 번씩 방문해 5가지 스탬프를 모두 모을 수 있습니다. 따라서 0을 return 합니다. 입출력 예 #3 지점들의 연결 상태는 아래 그림과 같습니다. 1 - 6 - 4 - 5 - 1(빠른 이동) - 2 - 3 - 7 - 1(빠른 이동) - 8과 같은 경로로 움직이면 모든 지점을 최소 한 번씩 방문해 8가지 스탬프를 모두 모을 수 있으며, 이보다 빠른 이동을 적게 사용하는 방법은 없습니다. 따라서 2를 return 합니다. 입출력 예 #4 지점들의 연결 상태는 아래 그림과 같습니다. 1 - 2 - 5 - 6 - 9 - 1(빠른 이동) - 4 - 5 - 7 - 5(빠른 이동) - 8 - 1(빠른 이동) - 3과 같은 경로로 움직이면 모든 지점을 최소 한 번씩 방문해 9가지 스탬프를 모두 모을 수 있으며, 이보다 빠른 이동을 적게 사용하는 방법은 없습니다. 따라서 3을 return 합니다. 입출력 예 #5 지점들의 연결 상태는 아래 그림과 같습니다. 1 - 2 - 3 - 6 - 1(빠른 이동) - 7 - 4 - 5와 같은 경로로 움직이면 모든 지점을 최소 한 번씩 방문해 7가지 스탬프를 모두 모을 수 있으며, 이보다 빠른 이동을 적게 사용하는 방법은 없습니다. 따라서 1을 return 합니다.",hard,Array
22,"현대모비스의 자율주행 시스템은 출발지와 목적지를 입력하면 목적지에 도착하기까지의 가장 빠른 예상 소요 시간을 알려줍니다. 자율주행 시스템은 도시 내에 있는 n개의 지점을 연결하는 양방향 도로 m개의 교통량을 분석해서 예상 소요 시간을 실시간으로 계산합니다. 만약 어떤 도로의 길이가 L이고 교통량이 T라면 해당 도로를 통과하는데 L + T분이 소요됩니다. (0 ≤ T) 다음은 n = 5, m = 7인 예시입니다. 원은 지점을 나타내며, 원에 적힌 수는 지점의 번호입니다. 항상 1번 지점이 출발지, n번 지점이 목적지입니다. 선분은 지점을 연결하는 도로를 나타내며, 선분 옆에 적힌 수는 [#도로 번호] 길이/교통량을 의미합니다. 목적지에 도착하기까지의 가장 빠른 예상 소요 시간은 1-2-4-5와 같이 이동했을 때 20(= 10 + 8 + 2)분입니다. 이때 7번 도로의 교통량이 3 증가한다고 가정해 보겠습니다. 목적지에 도착하기까지의 가장 빠른 예상 소요 시간은 1-2-5와 같이 이동했을 때 22(= 10 + 12)분으로, 교통량이 변하기 전에 비해 2분 증가했습니다. 7번 도로 대신 2번 도로의 교통량이 2 증가한다고 가정해 보겠습니다. 목적지에 도착하기까지의 가장 빠른 예상 소요 시간은 1-3-4-5와 같이 이동했을 때 20(= 9 + 9 + 2)분으로, 교통량이 변하기 전과 같습니다. 2, 7번 도로 대신 5번 도로의 교통량이 6 감소한다고 가정해 보겠습니다. 목적지에 도착하기까지의 가장 빠른 예상 소요 시간은 1-3-5와 같이 이동했을 때 19(= 10 + 9)분으로, 교통량이 변하기 전에 비해 1분 감소했습니다. 모든 도로의 교통량 정보를 실시간으로 업데이트하는 것은 비효율적이기 때문에, 위와 같이 한 도로의 교통량이 변했을 때 가장 빠른 예상 소요 시간이 변할 수 있는 도로(5, 7번 도로)에 대해서만 실시간으로 교통량 정보를 업데이트해야 합니다. 지점의 수를 나타내는 정수 n과 도로의 정보를 나타내는 2차원 정수 배열 roads가 매개변수로 주어집니다. 이때 한 도로의 교통량이 변했을 때 1번 지점에서 출발해 n번 지점에 도착하는 가장 빠른 예상 소요 시간이 변할 수 있는 도로의 번호를 오름차순으로 1차원 정수 배열에 담아 return 하도록 solution 함수를 완성해 주세요. 만약 그러한 도로가 없다면 [-1]을 return 합니다. 제한사항 2 ≤ n ≤ 50,000 1번 지점이 출발지, n번 지점이 목적지입니다. n - 1 ≤ roads의 길이 = m ≤ 200,000 roads[i]는 i+1번 도로에 대한 정보를 담고 있으며 [U, V, L, T] 형태의 길이가 4인 1차원 정수 배열입니다. U번 지점과 V번 지점을 연결하는 길이 L, 교통량 T인 도로를 의미합니다. 1 ≤ U < V ≤ n 1 ≤ L ≤ 109 0 ≤ T ≤ 109 서로 다른 두 지점을 직접 연결하는 도로는 최대 1개입니다. 도로를 통해 한 지점에서 다른 지점으로 이동하는 방법이 항상 존재합니다. 입출력 예 n roads result 5 [[1, 2, 10, 0], [2, 4, 8, 0], [1, 3, 9, 0], [3, 4, 9, 0], [3, 5, 10, 6], [2, 5, 10, 2], [4, 5, 2, 0]] [5, 7] 4 [[1, 2, 10, 10], [2, 3, 10, 10], [3, 4, 10, 10]] [1, 2, 3] 4 [[1, 2, 5, 0], [2, 4, 5, 0], [1, 3, 5, 0], [3, 4, 5, 0]] [-1] 4 [[1, 2, 5, 0], [2, 4, 5, 0], [1, 3, 5, 0], [3, 4, 5, 0], [1, 4, 5, 5]] [5] 입출력 예 설명 입출력 예 #1 문제 예시와 같습니다. 입출력 예 #2 4개의 지점은 일자로 연결된 형태입니다. 1번 지점에서 4번 지점으로 가기 위해서는 반드시 모든 도로를 거쳐가야 하며, 따라서 모든 도로의 교통량이 예상 소요 시간에 영향을 미칩니다. 따라서 [1, 2, 3]을 return 해야 합니다. 입출력 예 #3 1번 또는 2번 도로의 교통량이 증가했을 때 가장 빠른 예상 소요 시간은 1-3-4와 같이 이동했을 때 10(= 5 + 5)분입니다. 3번 또는 4번 도로의 교통량이 증가했을 때 가장 빠른 예상 소요 시간은 1-2-4와 같이 이동했을 때 10(= 5 + 5)분입니다. 어떤 도로의 교통량이 변하여도 교통량이 변하기 전과 가장 빠른 예상 소요 시간이 같습니다. 교통량이 변했을 때 가장 빠른 예상 소요 시간이 변하는 도로가 없으므로 [-1]을 return 해야 합니다. 입출력 예 #4 3번째 예시와 같지만 5번 도로가 추가되었습니다. 5번 도로의 교통량이 감소한다면 1-4와 같이 이동했을 때 가장 빠른 예상 소요 시간이 10분보다 작아집니다. 따라서 [5]를 return 해야 합니다.",hard,Array
23,"현대모비스에서 개발한 자율주행을 이용한 레이싱 대회가 열렸습니다. 당신은 관람객들이 레이싱 대회를 재밌게 즐길 수 있도록 레이싱 경기장을 설계하려고 합니다. 레이싱 경기장은 n개의 지점으로 구성됩니다. 각 지점의 높이는 정해져 있지만, 그 순서는 자유롭게 바꿀 수 있습니다. 당신의 목표는 이웃한 지점끼리의 높이 차이의 최솟값이 최대가 되도록 높이 순서를 정하는 것입니다. 예를 들어 n이 3이고 세 지점의 높이가 각각 1, 5, 8인 경우를 생각해 봅시다. 높이를 [1, 5, 8] 순서로 배치하면 1번과 2번 지점의 높이 차이는 4, 2번과 3번 지점의 높이 차이는 3이므로 높이 차이의 최솟값은 3입니다. 높이를 [5, 1, 8] 순서로 배치하면 1번과 2번 지점의 높이 차이는 4, 2번과 3번 지점의 높이 차이는 7이므로 높이 차이의 최솟값은 4입니다. 높이 차이의 최솟값을 4보다 크게 만드는 방법은 없습니다. 지점 n개의 높이를 담은 1차원 정수 배열 heights가 매개변수로 주어집니다. 높이 차이의 최솟값이 최대가 되도록 레이싱 경기장을 설계했을 때의 높이 차이의 최솟값을 return 하도록 solution 함수를 완성해 주세요. 제한사항 2 ≤ heights의 길이 = n ≤ 200,000 1 ≤ heights의 원소 ≤ 109 입출력 예 heights result [1, 8, 5] 4 [11, 6, 4, 11] 5 [9, 9, 9, 9, 30] 0 입출력 예 설명 입출력 예 #1 문제 예시와 같습니다. 입출력 예 #2 높이를 [4, 11, 6, 11] 순서로 배치하면 높이 차이의 최솟값이 5입니다. 높이 차이의 최솟값을 5보다 크게 만드는 방법은 없습니다. 따라서 5를 return 하면 됩니다. 입출력 예 #3 높이를 어떻게 배치하더라도 높이가 9인 지점 두 개가 이웃하게 됩니다. 따라서 높이 차이의 최솟값은 항상 0입니다. 따라서 0을 return 하면 됩니다.",hard,Array
24,"정수 0 ~ n-1을 담고 있는 크기가 n인 1차원 정수 배열 a가 있습니다. 배열의 각 원소마다 하나의 집합을 이루고 있습니다. 당신은 여기에 다음 쿼리들을 실행하려고 합니다. [1, x, y] 형태의 쿼리가 주어집니다. y가 포함된 집합의 원소들을 모두 x가 포함된 집합으로 옮깁니다. x와 y가 같은 집합에 속해있다면 해당 쿼리는 실행하지 않습니다. [2, x, y] 형태의 쿼리가 주어집니다. 새로운 집합을 생성합니다. x와 y가 포함된 집합에서 x와 같거나 늦게 집합으로 들어왔으면서 y와 같거나 빠르게 집합으로 들어온 원소들을 새로 생성한 집합으로 옮깁니다. 집합에 들어온 순서는 몇 번째 쿼리로 집합에 들어왔는지로 판별합니다. 같은 쿼리로 집합에 들어왔다면 같은 순서로 집합에 들어왔다는 것을 의미합니다. x와 y는 항상 같은 집합에 포함되어 있습니다. [3, x, y] 형태의 쿼리가 주어집니다. x와 y가 같은 집합에 속해있다면 ""Yes""를, 그렇지 않다면 ""No""를 return 할 배열의 뒤에 추가합니다. 집합은 크기가 0이 되면 사라지며, 초기 집합들은 0번째 쿼리로 형성됩니다. a의 길이를 나타내는 정수 n, 쿼리들을 담은 2차원 정수 배열 queries가 매개변수로 주어집니다. 쿼리들을 순서대로 실행했을 때, 3번 쿼리의 결과를 순서대로 담아 return 하도록 solution 함수를 완성해주세요. 제한사항 1 ≤ n ≤ 500,000 1 ≤ queries의 길이 ≤ 500,000 queries[i]는 i+1번째로 실행할 쿼리를 나타내며, [q, x, y] 형태의 1차원 정수 배열입니다. 1 ≤ q ≤ 3 0 ≤ x, y < n 2번 쿼리의 경우 x와 y는 항상 같은 집합에 속해 있습니다. 3번 쿼리는 1개 이상 주어집니다. 입출력 예 n queries result 4 [[3, 2, 3], [1, 3, 2], [3, 2, 3], [1, 2, 0], [3, 0, 1], [2, 2, 0], [3, 2, 3], [3, 0, 2]] [""No"", ""Yes"", ""No"", ""No"", ""Yes""] 7 [[1, 0, 1], [1, 2, 3], [3, 1, 3], [1, 2, 0], [3, 1, 3], [1, 1, 5], [1, 5, 4], [3, 4, 5], [2, 2, 5], [3, 4, 5]] [""No"", ""Yes"", ""Yes"", ""No""] 입출력 예 설명 입출력 예 #1 초기 집합은 다음과 같습니다. [0], [1], [2], [3] [3, 2, 3]쿼리를 실행했을 때 결과는 다음과 같습니다. 2와 3은 다른 집합에 들어있으므로 return 할 배열의 뒤에 ""No""를 추가합니다. [1, 3, 2]쿼리를 실행했을 때 결과는 다음과 같습니다. 2가 들어있는 [2]의 원소들을 모두 3이 들어있는 [3]으로 옮깁니다. 쿼리를 실행한 뒤의 집합은 [0], [1], [2, 3]이 있습니다. [3, 2, 3]쿼리를 실행했을 때 결과는 다음과 같습니다. 2와 3은 같은 집합에 있으므로 return 할 배열의 뒤에 ""Yes""를 추가합니다. [1, 2, 0]쿼리를 실행했을 때의 결과는 다음과 같습니다. 0이 들어있는 [0]의 모든 원소들을 2가 들어있는 [2, 3]으로 옮깁니다. 쿼리를 실행한 뒤의 집합은 [0, 2, 3], [1]이 있습니다. [3, 0, 1]쿼리를 실행했을 때의 결과는 다음과 같습니다. 0과 1은 다른 집합에 들어있으므로 return 할 배열의 뒤에 ""No""를 추가합니다. [2, 2, 0]쿼리를 실행했을 때의 결과는 다음과 같습니다. 2는 2번째 쿼리로 현재 집합에 들어왔고, 0은 4번째 쿼리로 현재 집합에 들어왔습니다. 2와 0이 속한 [0, 2, 3]에서 2~4번째 쿼리에 들어온 원소인 0과 2로 새로운 집합을 만듭니다. 쿼리를 실행한 뒤의 집합은 [0, 2], [1], [3]이 있습니다. [3, 2, 3]쿼리를 실행했을 때의 결과는 다음과 같습니다. 2와 3은 다른 집합에 들어있으므로 return 할 배열의 뒤에 ""No""를 추가합니다. [3, 0, 2]쿼리를 실행했을 때의 결과는 다음과 같습니다. 0과 2는 같은 집합에 들어있으므로 return 할 배열의 뒤에 ""Yes""를 추가합니다. return 할 배열은 [""No"", ""Yes"", ""No"", ""No"", ""Yes""]입니다. 입출력 예 #2 초기 집합은 다음과 같습니다. [0], [1], [2], [3], [4], [5], [6] 쿼리를 실행하는 과정은 다음과 같습니다. [1, 0, 1]쿼리를 실행했을 때 결과는 다음과 같습니다. 1이 들어있는 [1]의 원소들을 모두 0이 들어있는 [0]으로 옮깁니다. 쿼리를 실행한 뒤의 집합은 [0, 1], [2], [3], [4], [5], [6]이 있습니다. [1, 2, 3]쿼리를 실행했을 때 결과는 다음과 같습니다. 3이 들어있는 [3]의 원소들을 모두 2가 들어있는 [2]로 옮깁니다. 쿼리를 실행한 뒤의 집합은 [0, 1], [2, 3], [4], [5], [6]이 있습니다. [3, 1, 3]쿼리를 실행했을 때 결과는 다음과 같습니다. 1과 3은 다른 집합에 있으므로 return 할 배열의 뒤에 ""No""를 추가합니다. [1, 2, 0]쿼리를 실행했을 때 결과는 다음과 같습니다. 0이 들어있는 [0, 1]의 원소들을 모두 2가 들어있는 [2, 3]으로 옮깁니다. 쿼리를 실행한 뒤의 집합은 [0, 1, 2, 3], [4], [5], [6]이 있습니다. [3, 1, 3]쿼리를 실행했을 때 결과는 다음과 같습니다. 1과 3은 같은 집합에 있으므로 return 할 배열의 뒤에 ""Yes""를 추가합니다. [1, 1, 5]쿼리를 실행했을 때 결과는 다음과 같습니다. 5가 들어있는 [5]의 원소들을 모두 1이 들어있는 [0, 1, 2, 3]으로 옮깁니다. 쿼리를 실행한 뒤의 집합은 [0, 1, 2, 3, 5], [4], [6]이 있습니다. [1, 5, 4]쿼리를 실행했을 때 결과는 다음과 같습니다. 4가 들어있는 [4]의 원소들을 모두 5가 들어있는 [0, 1, 2, 3, 5]로 옮깁니다. 쿼리를 실행한 뒤의 집합은 [0, 1, 2, 3, 4, 5], [6]이 있습니다. [3, 4, 5]쿼리를 실행했을 때 결과는 다음과 같습니다. 4와 5는 같은 집합에 있으므로 return 할 배열의 뒤에 ""Yes""를 추가합니다. [2, 2, 5]쿼리를 실행했을 때 결과는 다음과 같습니다. 2와 5가 들어있는 [0, 1, 2, 3, 4, 5] 집합에서 쿼리가 실행됩니다. 2는 0번째 쿼리로 집합에 들어왔고, 5는 6번째 쿼리로 집합에 들어왔습니다. 0~6번째 쿼리에 [0, 1, 2, 3, 4, 5] 집합에 들어온 원소는 0, 1, 2, 3, 5 입니다. 쿼리를 실행한 뒤의 집합은 [0, 1, 2, 3, 5], [4], [6]이 있습니다. [3, 4, 5]쿼리를 실행했을 때 결과는 다음과 같습니다. 4와 5는 다른 집합에 있으므로 return 할 배열의 뒤에 ""No""를 추가합니다. return 할 배열은 [""No"", ""Yes"", ""Yes"", ""No""]입니다.",hard,Array
25,"현대모비스에서 전기차로 경사로 주행 테스트를 하려고 합니다. 경사로 테스트는 n×m 크기의 격자 형태의 공간에서 진행되며, 각 칸에 적힌 숫자는 높이를 나타냅니다. 전기차는 격자 내의 모든 칸에서 출발 가능하며, 상하좌우로 인접한 칸으로만 이동 가능하고 격자 밖을 벗어날 수는 없습니다. 전기차가 인접한 칸으로 이동하는 길의 경사는 이동하려는 칸의 높이에서 현재 칸의 높이를 뺀 값입니다. 예를 들어 높이가 5인 칸에서 7인 칸으로 이동하는 길의 경사는 2(= 7 - 5)이고, 높이가 6인 칸에서 높이가 1인 칸으로 이동하는 길의 경사는 -5(= 1 - 6)입니다. 경사 수열 d가 주어집니다. 경사 수열은 테스트에서 전기차가 이동할 길의 경사를 나타내며, d[i]는 전기차가 i+1번째로 이동할 때 경사가 d[i]인 길을 지나야 함을 나타냅니다. 전기차가 경사로를 반복적으로 이동할 때 받는 스트레스를 관찰하기 위해 주어진 경사수열을 k번 반복할 수 있는 경로를 찾으려 합니다. 같은 칸을 여러 번 방문하거나 지나온 길을 바로 되돌아가는 경로도 가능합니다. 예를 들어 아래와 같은 격자에서 경사 수열 d = [1, -2, -1, 0, 2]이고 k = 2라고 가정해 보겠습니다. 이 경사 수열을 k = 2 번 반복할 수 있는 경로 중 하나는 아래 그림과 같습니다. 위 경로에서 방문한 칸의 높이는 방문 순서대로 [5, 6, 4, 3, 3, 5, 6, 4, 3, 3, 5]입니다. 길의 경사가 순서대로 [1, -2, -1, 0, 2, 1, -2, -1, 0, 2]으로, d가 2번 반복되었습니다. 격자 칸의 높이를 담은 2차원 정수 배열 grid, 경사 수열을 담은 1차원 정수 배열 d와 경사 수열을 반복하는 횟수를 나타내는 정수 k가 매개변수로 주어집니다. 이때, 격자 내에서 조건을 만족하는 경로의 수를 return 하도록 solution 함수를 완성해 주세요. 단, 답이 커질 수 있으므로 1,000,000,007(= 109 + 7)로 나눈 나머지를 return 해주세요. 제한사항 3 ≤ grid의 길이 = n ≤ 8 3 ≤ grid[i]의 길이 = m ≤ 8 0 ≤ grid[i][j] ≤ 1,000 grid[i][j]는 각자의 i+1번째 행, j+1번째 열에 위치한 칸의 높이를 나타냅니다. 1 ≤ d의 길이 ≤ 100 -100 ≤ d의 원소 ≤ 100 1 ≤ k ≤ 109 입출력 예 grid d k result [[3, 4, 6, 5, 3], [3, 5, 5, 3, 6], [5, 6, 4, 3, 6], [7, 4, 3, 5, 0]] [1, -2, -1, 0, 2] 2 16 [[3, 6, 11, 12], [4, 8, 15, 10], [2, 7, 0, 16]] [1, -2, 5] 3 1 [[0, 0, 0], [1, 0, 0], [0, 0, 0], [0, 0, 1], [1, 0, 0]] [0, 0, 1, -1, 0, 0, 1, -1] 10 595737277 입출력 예 설명 입출력 예 #1 문제 예시와 같습니다. 조건을 만족하는 경로의 수는 16가지가 있습니다. 따라서 16을 return 하면 됩니다. 입출력 예 #2 조건을 만족하는 경로의 수는 1가지가 있습니다. 따라서 1을 return 하면 됩니다. 입출력 예 #3 조건을 만족하는 경로의 수는 8,160,249,293,367,222,249,455,616 가지가 있습니다. 따라서 경로의 수를 109 + 7로 나눈 나머지인 595737277을 return 하면 됩니다.",hard,Array
26,"현대모비스에서 개발한 실내공조 제어 시스템은 차내에 승객이 탑승 중일 때 항상 쾌적한 실내온도(t1 ~ t21)를 유지할 수 있도록 합니다. 현재(0분) 실내온도는 실외온도와 같습니다. 실내공조 제어 시스템은 실내온도를 조절하기 위해 에어컨의 전원을 켜 희망온도를 설정합니다. 희망온도는 에어컨의 전원이 켜져 있는 동안 원하는 값으로 변경할 수 있습니다. 실내온도와 희망온도가 다르다면 1분 뒤 실내온도가 희망온도와 같아지는 방향으로 1도 상승 또는 하강합니다. 실내온도가 희망온도와 같다면 에어컨이 켜져 있는 동안은 실내온도가 변하지 않습니다. 에어컨의 전원을 끄면 실내온도가 실외온도와 같아지는 방향으로 매 분 1도 상승 또는 하강합니다. 실내온도와 실외온도가 같다면 실내온도는 변하지 않습니다. 에어컨의 소비전력은 현재 실내온도에 따라 달라집니다. 에어컨의 희망온도와 실내온도가 다르다면 매 분 전력을 a만큼 소비하고, 희망온도와 실내온도가 같다면 매 분 전력을 b만큼 소비합니다. 에어컨이 꺼져 있다면 전력을 소비하지 않으며, 에어컨을 켜고 끄는데 필요한 시간과 전력은 0이라고 가정합니다. 실내공조 제어 시스템은 차내에 승객이 탑승 중일 때 실내온도를 t1 ~ t2도 사이로 유지하면서, 에어컨의 소비전력을 최소화합니다. 다음은 실외온도가 28도, t1= 18, t2 = 26, a = 10 b = 8인 예시입니다. 시간(분) 승객 탑승 0 x 1 x 2 o 3 o 4 o 5 o 6 o 승객이 탑승 중인 2 ~ 6분의 실내온도를 18 ~ 26도 사이로 유지해야 합니다. 다음은 2 ~ 6분의 실내온도를 쾌적한 온도로 유지하는 방법 중 하나입니다. 시간(분) 승객 탑승 실내온도 희망온도 0 x 28 26 1 x 27 26 2 o 26 26 3 o 26 26 4 o 26 26 5 o 26 26 6 o 26 off 0분의 실내온도는 항상 실외온도와 같습니다. 6분에 에어컨의 전원을 껐습니다. 0 ~ 5분에 에어컨의 희망온도를 26도로 설정했습니다. 0 ~ 1분에 희망온도와 실내온도가 다르므로 전력을 매 분 10씩, 2 ~ 5분에 희망온도와 실내온도가 같으므로 전력을 매 분 8씩 소비했습니다. 이때 총 소비전력은 52(= 2 × 10 + 4 × 8)입니다. 다음은 2 ~ 6분의 실내온도를 쾌적한 온도로 유지하는 또 다른 방법입니다. 시간(분) 승객 탑승 실내온도 희망온도 0 x 28 24 1 x 27 24 2 o 26 24 3 o 25 24 4 o 24 off 5 o 25 off 6 o 26 off 0 ~ 3분에 에어컨의 희망온도를 24도로 설정해 전력을 매 분 10씩 소비했습니다. 이때 총 소비전력은 40(= 4 × 10)이며, 이보다 소비전력이 적어지는 방법은 없습니다. 실외온도를 나타내는 정수 temperature, 쾌적한 실내온도의 범위를 나타내는 정수 t1, t2, 에어컨의 소비전력을 나타내는 정수 a, b와 승객이 탑승 중인 시간을 나타내는 1차원 정수 배열 onboard가 매개변수로 주어집니다. 승객이 탑승 중인 시간에 쾌적한 실내온도를 유지하기 위한 최소 소비전력을 return 하도록 solution 함수를 완성해 주세요. 제한사항 -10 ≤ temperature ≤ 40 -10 ≤ t1 < t2 ≤ 40 temperature는 t1 ~ t2 범위 밖의 값입니다. 1 ≤ a, b ≤ 100 a는 에어컨의 희망온도와 실내온도가 다를 때의 1분당 소비전력을 나타냅니다. b는 에어컨의 희망온도와 실내온도가 같을 때의 1분당 소비전력을 나타냅니다. 2 ≤ onboard의 길이 ≤ 1,000 onboard[i]는 0 혹은 1이며, onboard[i]가 1이라면 i분에 승객이 탑승 중이라는 것을 의미합니다. onboard[0] = 0 onboard에 1이 최소 한 번 이상 등장합니다. 승객이 탑승 중인 시간에 쾌적한 실내온도를 유지하는 것이 불가능한 경우는 주어지지 않습니다. 입출력 예 temperature t1 t2 a b onboard result 28 18 26 10 8 [0, 0, 1, 1, 1, 1, 1] 40 -10 -5 5 5 1 [0, 0, 0, 0, 0, 1, 0] 25 11 8 10 10 1 [0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1] 20 11 8 10 10 100 [0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1] 60 입출력 예 설명 입출력 예 #1 문제 예시와 같습니다. 입출력 예 #2 시간(분) 승객 탑승 실내온도 희망온도 0 x -10 40 1 x -9 40 2 x -8 40 3 x -7 40 4 x -6 40 5 o -5 off 6 x -6 off 0 ~ 4분에 에어컨의 희망온도를 40도로 설정하고, 5 ~ 6분에 에어컨의 전원을 끕니다. 이때 총 소비전력은 25(= 5 × 5)며, 이보다 소비전력이 적어지는 방법은 없습니다. 따라서 25를 return 해야 합니다. 입출력 예 #3 아래 표와 같이 에어컨을 조작하면 소비전력이 최소가 됩니다. 시간(분) 승객 탑승 실내온도 희망온도 0 x 11 10 1 o 10 10 2 o 10 10 3 o 10 10 4 o 10 10 5 o 10 10 6 o 10 10 7 x 10 10 8 x 10 10 9 x 10 10 10 o 10 10 11 o 10 off 이때 총 소비전력은 20이며, 이보다 소비전력이 적어지는 방법은 없습니다. 따라서 20을 return 해야 합니다. 입출력 예 #4 3번째 예시와 비교했을 때 b의 값이 다릅니다. 아래 표와 같이 에어컨을 조작하면 소비전력이 최소가 됩니다. 시간(분) 승객 탑승 실내온도 희망온도 0 x 11 8 1 o 10 8 2 o 9 8 3 o 8 off 4 o 9 off 5 o 10 8 6 o 9 off 7 x 10 off 8 x 11 off 9 x 11 9 10 o 10 9 11 o 9 off 이때 총 소비전력은 60이며, 이보다 소비전력이 적어지는 방법은 없습니다. 따라서 60을 return 해야 합니다. t1 ~ t2는 t1도 이상 t2도 이하의 온도 범위를 나타냅니다. ↩",normal,Array
27,"현대모비스는 우수한 SW 인재 채용을 위해 상시로 채용 설명회를 진행하고 있습니다. 채용 설명회에서는 채용과 관련된 상담을 원하는 참가자에게 멘토와 1:1로 상담할 수 있는 기회를 제공합니다. 채용 설명회에는 멘토 n명이 있으며, 1~k번으로 분류되는 상담 유형이 있습니다. 각 멘토는 k개의 상담 유형 중 하나만 담당할 수 있습니다. 멘토는 자신이 담당하는 유형의 상담만 가능하며, 다른 유형의 상담은 불가능합니다. 멘토는 동시에 참가자 한 명과만 상담 가능하며, 상담 시간은 정확히 참가자가 요청한 시간만큼 걸립니다. 참가자가 상담 요청을 하면 아래와 같은 규칙대로 상담을 진행합니다. 상담을 원하는 참가자가 상담 요청을 했을 때, 참가자의 상담 유형을 담당하는 멘토 중 상담 중이 아닌 멘토와 상담을 시작합니다. 만약 참가자의 상담 유형을 담당하는 멘토가 모두 상담 중이라면, 자신의 차례가 올 때까지 기다립니다. 참가자가 기다린 시간은 참가자가 상담 요청했을 때부터 멘토와 상담을 시작할 때까지의 시간입니다. 모든 멘토는 상담이 끝났을 때 자신의 상담 유형의 상담을 받기 위해 기다리고 있는 참가자가 있으면 즉시 상담을 시작합니다. 이때, 먼저 상담 요청한 참가자가 우선됩니다. 참가자의 상담 요청 정보가 주어질 때, 참가자가 상담을 요청했을 때부터 상담을 시작하기까지 기다린 시간의 합이 최소가 되도록 각 상담 유형별로 멘토 인원을 정하려 합니다. 단, 각 유형별로 멘토 인원이 적어도 한 명 이상이어야 합니다. 예를 들어, 5명의 멘토가 있고 1~3번의 3가지 상담 유형이 있을 때 아래와 같은 참가자의 상담 요청이 있습니다. 참가자의 상담 요청 참가자 번호 시각 상담 시간 상담 유형 1번 참가자 10분 60분 1번 유형 2번 참가자 15분 100분 3번 유형 3번 참가자 20분 30분 1번 유형 4번 참가자 30분 50분 3번 유형 5번 참가자 50분 40분 1번 유형 6번 참가자 60분 30분 2번 유형 7번 참가자 65분 30분 1번 유형 8번 참가자 70분 100분 2번 유형 이때, 멘토 인원을 아래와 같이 정하면, 참가자가 기다린 시간의 합이 25로 최소가 됩니다. 1번 유형 2번 유형 3번 유형 2명 1명 2명 1번 유형 1번 유형을 담당하는 멘토가 2명 있습니다. 1번 참가자가 상담 요청했을 때, 멘토#1과 10분~70분 동안 상담을 합니다. 3번 참가자가 상담 요청했을 때, 멘토#2와 20분~50분 동안 상담을 합니다. 5번 참가자가 상담 요청했을 때, 멘토#2와 50분~90분 동안 상담을 합니다. 7번 참가자가 상담 요청했을 때, 모든 멘토가 상담 중이므로 1번 참가자의 상담이 끝날 때까지 5분 동안 기다리고 멘토#1과 70분~100분 동안 상담을 합니다. 2번 유형 2번 유형을 담당하는 멘토가 1명 있습니다. 6번 참가자가 상담 요청했을 때, 멘토와 60분~90분 동안 상담을 합니다. 8번 참가자가 상담 요청했을 때, 모든 멘토가 상담 중이므로 6번 참가자의 상담이 끝날 때까지 20분 동안 기다리고 90분~190분 동안 상담을 합니다. 3번 유형 3번 유형을 담당하는 멘토가 2명 있습니다. 2번 참가자가 상담 요청했을 때, 멘토#1과 15분~115분 동안 상담을 합니다. 4번 참가자가 상담 요청했을 때, 멘토#2와 30분~80분 동안 상담을 합니다. 상담 유형의 수를 나타내는 정수 k, 멘토의 수를 나타내는 정수 n과 참가자의 상담 요청을 담은 2차원 정수 배열 reqs가 매개변수로 주어집니다. 멘토 인원을 적절히 배정했을 때 참가자들이 상담을 받기까지 기다린 시간을 모두 합한 값의 최솟값을 return 하도록 solution 함수를 완성해 주세요. 제한사항 1 ≤ k ≤ 5 k ≤ n ≤ 20 3 ≤ reqs의 길이 ≤ 300 reqs의 원소는 [a, b, c] 형태의 길이가 3인 정수 배열이며, c번 유형의 상담을 원하는 참가자가 a분에 b분 동안의 상담을 요청했음을 의미합니다. 1 ≤ a ≤ 1,000 1 ≤ b ≤ 100 1 ≤ c ≤ k reqs는 a를 기준으로 오름차순으로 정렬되어 있습니다. reqs 배열에서 a는 중복되지 않습니다. 즉, 참가자가 상담 요청한 시각은 모두 다릅니다. 입출력 예 k n reqs result 3 5 [[10, 60, 1], [15, 100, 3], [20, 30, 1], [30, 50, 3], [50, 40, 1], [60, 30, 2], [65, 30, 1], [70, 100, 2]] 25 2 3 [[5, 55, 2], [10, 90, 2], [20, 40, 2], [50, 45, 2], [100, 50, 2]] 90 입출력 예 설명 입출력 예 #1 문제 예시와 같습니다. 입출력 예 #2 참가자의 상담 요청 참가자 번호 시각 상담 시간 상담 유형 1번 참가자 5분 55분 2번 유형 2번 참가자 10분 90분 2번 유형 3번 참가자 20분 40분 2번 유형 4번 참가자 50분 45분 2번 유형 5번 참가자 100분 50분 2번 유형 멘토 인원을 아래와 같이 정하면, 참가자가 기다린 시간의 합이 90으로 최소가 됩니다. 1번 유형 2번 유형 1명 2명 1번 유형 1번 유형을 담당하는 멘토가 1명 있습니다. 1번 유형의 상담을 요청한 참가자가 없지만, 유형별로 멘토 인원이 적어도 한 명 이상이어야 합니다. 2번 유형 2번 유형을 담당하는 멘토가 2명 있습니다. 1번 참가자가 상담 요청했을 때, 멘토#1과 5분~60분 동안 상담을 합니다. 2번 참가자가 상담 요청했을 때, 멘토#2와 10분~100분 동안 상담을 합니다. 3번 참가자가 상담 요청했을 때, 모든 멘토가 상담 중이므로 1번 참가자의 상담이 끝날 때까지 40분 동안 기다리고 멘토#1과 60분~100분 동안 상담을 합니다. 1번 참가자의 상담이 끝났을 때 4번 참가자도 기다리고 있었지만, 먼저 상담 요청한 3번 참가자가 우선됩니다. 4번 참가자가 상담 요청했을 때, 모든 멘토가 상담 중이므로 2번 참가자의 상담이 끝날 때까지 50분 동안 기다리고 멘토#2와 100분~145분 동안 상담을 합니다. 이때, 멘토#1과 상담할 수도 있지만 어느 멘토와 상담해도 상관없습니다. 5번 참가자가 상담 요청했을 때, 멘토#1과 100분~150분 동안 상담을 합니다. 따라서 90을 return 하면 됩니다.",normal,Array
28,"문자열 str이 주어질 때, str을 출력하는 코드를 작성해 보세요. 제한사항 1 ≤ str의 길이 ≤ 1,000,000 str에는 공백이 없으며, 첫째 줄에 한 줄로만 주어집니다. 입출력 예 입력 #1 HelloWorld! 출력 #1 HelloWorld!",easy,String
29,"정수 a와 b가 주어집니다. 각 수를 입력받아 입출력 예와 같은 형식으로 출력하는 코드를 작성해 보세요. 제한사항 -100,000 ≤ a, b ≤ 100,000 입출력 예 입력 #1 4 5 출력 #1 a = 4 b = 5",easy,Design
30,문자열 str과 정수 n이 주어집니다. str이 n번 반복된 문자열을 만들어 출력하는 코드를 작성해 보세요. 제한사항 1 ≤ str의 길이 ≤ 10 1 ≤ n ≤ 5 입출력 예 입력 #1 string 5 출력 #1 stringstringstringstringstring,easy,String
31,영어 알파벳으로 이루어진 문자열 str이 주어집니다. 각 알파벳을 대문자는 소문자로 소문자는 대문자로 변환해서 출력하는 코드를 작성해 보세요. 제한사항 1 ≤ str의 길이 ≤ 20 str은 알파벳으로 이루어진 문자열입니다. 입출력 예 입력 #1 aBcDeFg 출력 #1 AbCdEfG ※2023년 05월 03일 제한사항이 수정되었습니다.,easy,String
32,"다음과 같이 출력하도록 코드를 작성해 주세요. 출력 예시 !@#$%^&*(\'""<>?:;",easy,Design
33,"두 정수 a, b가 주어질 때 다음과 같은 형태의 계산식을 출력하는 코드를 작성해 보세요. a + b = c 제한사항 1 ≤ a, b ≤ 100 입출력 예 입력 #1 4 5 출력 #1 4 + 5 = 9",easy,Design
34,"두 개의 문자열 str1, str2가 공백으로 구분되어 입력으로 주어집니다. 입출력 예와 같이 str1과 str2을 이어서 출력하는 코드를 작성해 보세요. 제한사항 1 ≤ str1, str2의 길이 ≤ 10 입출력 예 입력 #1 apple pen 출력 #1 applepen 입력 #2 Hello World! 출력 #2 HelloWorld!",easy,String
35,문자열 str이 주어집니다. 문자열을 시계방향으로 90도 돌려서 아래 입출력 예와 같이 출력하는 코드를 작성해 보세요. 제한사항 1 ≤ str의 길이 ≤ 10 입출력 예 입력 #1 abcde 출력 #1 a b c d e,easy,String
36,"자연수 n이 입력으로 주어졌을 때 만약 n이 짝수이면 ""n is even""을, 홀수이면 ""n is odd""를 출력하는 코드를 작성해 보세요. 제한사항 1 ≤ n ≤ 1,000 입출력 예 입력 #1 100 출력 #1 100 is even 입력 #2 1 출력 #2 1 is odd ※ 2023년 05월 15일 지문이 수정되었습니다.",easy,Design
37,"문자열 my_string, overwrite_string과 정수 s가 주어집니다. 문자열 my_string의 인덱스 s부터 overwrite_string의 길이만큼을 문자열 overwrite_string으로 바꾼 문자열을 return 하는 solution 함수를 작성해 주세요. 제한사항 my_string와 overwrite_string은 숫자와 알파벳으로 이루어져 있습니다. 1 ≤ overwrite_string의 길이 ≤ my_string의 길이 ≤ 1,000 0 ≤ s ≤ my_string의 길이 - overwrite_string의 길이 입출력 예 my_string overwrite_string s result ""He11oWor1d"" ""lloWorl"" 2 ""HelloWorld"" ""Program29b8UYP"" ""merS123"" 7 ""ProgrammerS123"" 입출력 예 설명 입출력 예 #1 예제 1번의 my_string에서 인덱스 2부터 overwrite_string의 길이만큼에 해당하는 부분은 ""11oWor1""이고 이를 ""lloWorl""로 바꾼 ""HelloWorld""를 return 합니다. 입출력 예 #2 예제 2번의 my_string에서 인덱스 7부터 overwrite_string의 길이만큼에 해당하는 부분은 ""29b8UYP""이고 이를 ""merS123""로 바꾼 ""ProgrammerS123""를 return 합니다.",easy,Array
38,"길이가 같은 두 문자열 str1과 str2가 주어집니다. 두 문자열의 각 문자가 앞에서부터 서로 번갈아가면서 한 번씩 등장하는 문자열을 만들어 return 하는 solution 함수를 완성해 주세요. 제한사항 1 ≤ str1의 길이 = str2의 길이 ≤ 10 str1과 str2는 알파벳 소문자로 이루어진 문자열입니다. 입출력 예 str1 str2 result ""aaaaa"" ""bbbbb"" ""ababababab""",easy,String
39,"문자들이 담겨있는 배열 arr가 주어집니다. arr의 원소들을 순서대로 이어 붙인 문자열을 return 하는 solution함수를 작성해 주세요. 제한사항 1 ≤ arr의 길이 ≤ 200 arr의 원소는 전부 알파벳 소문자로 이루어진 길이가 1인 문자열입니다. 입출력 예 arr result [""a"",""b"",""c""] ""abc""",easy,Array
40,"문자열 my_string과 정수 k가 주어질 때, my_string을 k번 반복한 문자열을 return 하는 solution 함수를 작성해 주세요. 제한사항 1 ≤ my_string의 길이 ≤ 100 my_string은 영소문자로만 이루어져 있습니다. 1 ≤ k ≤ 100 입출력 예 my_string k result ""string"" 3 ""stringstringstring"" ""love"" 10 ""lovelovelovelovelovelovelovelovelovelove"" 입출력 예 설명 입출력 예 #1 예제 1번의 my_string은 ""string""이고 이를 3번 반복한 문자열은 ""stringstringstring""이므로 이를 return 합니다. 입출력 예 #2 예제 2번의 my_string은 ""love""이고 이를 10번 반복한 문자열은 ""lovelovelovelovelovelovelovelovelovelove""이므로 이를 return 합니다.",easy,String
41,"연산 ⊕는 두 정수에 대한 연산으로 두 정수를 붙여서 쓴 값을 반환합니다. 예를 들면 다음과 같습니다. 12 ⊕ 3 = 123 3 ⊕ 12 = 312 양의 정수 a와 b가 주어졌을 때, a ⊕ b와 b ⊕ a 중 더 큰 값을 return 하는 solution 함수를 완성해 주세요. 단, a ⊕ b와 b ⊕ a가 같다면 a ⊕ b를 return 합니다. 제한사항 1 ≤ a, b < 10,000 입출력 예 a b result 9 91 991 89 8 898 입출력 예 설명 입출력 예 #1 a ⊕ b = 991 이고, b ⊕ a = 919 입니다. 둘 중 더 큰 값은 991 이므로 991을 return 합니다. 입출력 예 #2 a ⊕ b = 898 이고, b ⊕ a = 889 입니다. 둘 중 더 큰 값은 898 이므로 898을 return 합니다.",easy,Math
42,"연산 ⊕는 두 정수에 대한 연산으로 두 정수를 붙여서 쓴 값을 반환합니다. 예를 들면 다음과 같습니다. 12 ⊕ 3 = 123 3 ⊕ 12 = 312 양의 정수 a와 b가 주어졌을 때, a ⊕ b와 2 * a * b 중 더 큰 값을 return하는 solution 함수를 완성해 주세요. 단, a ⊕ b와 2 * a * b가 같으면 a ⊕ b를 return 합니다. 제한사항 1 ≤ a, b < 10,000 입출력 예 a b result 2 91 364 91 2 912 입출력 예 설명 입출력 예 #1 a ⊕ b = 291 이고, 2 * a * b = 364 입니다. 둘 중 더 큰 값은 364 이므로 364를 return 합니다. 입출력 예 #2 a ⊕ b = 912 이고, 2 * a * b = 364 입니다. 둘 중 더 큰 값은 912 이므로 912를 return 합니다. ※ 2023년 04월 27일 입출력 예 설명이 수정되었습니다.",easy,Math
43,"정수 num과 n이 매개 변수로 주어질 때, num이 n의 배수이면 1을 return n의 배수가 아니라면 0을 return하도록 solution 함수를 완성해주세요. 제한사항 2 ≤ num ≤ 100 2 ≤ n ≤ 9 입출력 예 num n result 98 2 1 34 3 0 입출력 예 설명 입출력 예 #1 98은 2의 배수이므로 1을 return합니다. 입출력 예 #2 32는 3의 배수가 아니므로 0을 return합니다.",easy,Math
44,"정수 number와 n, m이 주어집니다. number가 n의 배수이면서 m의 배수이면 1을 아니라면 0을 return하도록 solution 함수를 완성해주세요. 제한사항 10 ≤ number ≤ 100 2 ≤ n, m < 10 입출력 예 number n m result 60 2 3 1 55 10 5 0 입출력 예 설명 입출력 예 #1 60은 2의 배수이면서 3의 배수이기 때문에 1을 return합니다. 입출력 예 #2 55는 5의 배수이지만 10의 배수가 아니기 때문에 0을 return합니다.",easy,Math
45,"양의 정수 n이 매개변수로 주어질 때, n이 홀수라면 n 이하의 홀수인 모든 양의 정수의 합을 return 하고 n이 짝수라면 n 이하의 짝수인 모든 양의 정수의 제곱의 합을 return 하는 solution 함수를 작성해 주세요. 제한사항 1 ≤ n ≤ 100 입출력 예 n result 7 16 10 220 입출력 예 설명 입출력 예 #1 예제 1번의 n은 7로 홀수입니다. 7 이하의 모든 양의 홀수는 1, 3, 5, 7이고 이들의 합인 1 + 3 + 5 + 7 = 16을 return 합니다. 입출력 예 #2 예제 2번의 n은 10으로 짝수입니다. 10 이하의 모든 양의 짝수는 2, 4, 6, 8, 10이고 이들의 제곱의 합인 22 + 42 + 62 + 82 + 102 = 4 + 16 + 36 + 64 + 100 = 220을 return 합니다.",easy,Math
46,"문자열에 따라 다음과 같이 두 수의 크기를 비교하려고 합니다. 두 수가 n과 m이라면 "">"", ""="" : n >= m ""<"", ""="" : n <= m "">"", ""!"" : n > m ""<"", ""!"" : n < m 두 문자열 ineq와 eq가 주어집니다. ineq는 ""<""와 "">""중 하나고, eq는 ""=""와 ""!""중 하나입니다. 그리고 두 정수 n과 m이 주어질 때, n과 m이 ineq와 eq의 조건에 맞으면 1을 아니면 0을 return하도록 solution 함수를 완성해주세요. 제한 사항 1 ≤ n, m ≤ 100 입출력 예 ineq eq n m result ""<"" ""="" 20 50 1 "">"" ""!"" 41 78 0 입출력 예 설명 입출력 예 #1 20 <= 50은 참이기 때문에 1을 return합니다. 입출력 예 #2 41 > 78은 거짓이기 때문에 0을 return합니다. ※ 2023.05.31 테스트 케이스가 수정되었습니다. 기존에 제출한 코드가 통과하지 못할 수도 있습니다.",easy,String
47,"두 정수 a, b와 boolean 변수 flag가 매개변수로 주어질 때, flag가 true면 a + b를 false면 a - b를 return 하는 solution 함수를 작성해 주세요. 제한사항 -1,000 ≤ a, b ≤ 1,000 입출력 예 a b flag result -4 7 true 3 -4 7 false -11 입출력 예 입출력 예 #1 예제 1번에서 flag가 true이므로 a + b = (-4) + 7 = 3을 return 합니다. 입출력 예 #2 예제 2번에서 flag가 false이므로 a - b = (-4) - 7 = -11을 return 합니다.",easy,Math
48,"문자열 code가 주어집니다. code를 앞에서부터 읽으면서 만약 문자가 ""1""이면 mode를 바꿉니다. mode에 따라 code를 읽어가면서 문자열 ret을 만들어냅니다. mode는 0과 1이 있으며, idx를 0 부터 code의 길이 - 1 까지 1씩 키워나가면서 code[idx]의 값에 따라 다음과 같이 행동합니다. mode가 0일 때 code[idx]가 ""1""이 아니면 idx가 짝수일 때만 ret의 맨 뒤에 code[idx]를 추가합니다. code[idx]가 ""1""이면 mode를 0에서 1로 바꿉니다. mode가 1일 때 code[idx]가 ""1""이 아니면 idx가 홀수일 때만 ret의 맨 뒤에 code[idx]를 추가합니다. code[idx]가 ""1""이면 mode를 1에서 0으로 바꿉니다. 문자열 code를 통해 만들어진 문자열 ret를 return 하는 solution 함수를 완성해 주세요. 단, 시작할 때 mode는 0이며, return 하려는 ret가 만약 빈 문자열이라면 대신 ""EMPTY""를 return 합니다. 제한사항 1 ≤ code의 길이 ≤ 100,000 code는 알파벳 소문자 또는 ""1""로 이루어진 문자열입니다. 입출력 예 code result ""abc1abc1abc"" ""acbac"" 입출력 예 설명 입출력 예 #1 code의 각 인덱스 i에 따라 다음과 같이 mode와 ret가 변합니다. i code[i] mode ret 0 ""a"" 0 ""a"" 1 ""b"" 0 ""a"" 2 ""c"" 0 ""ac"" 3 ""1"" 1 ""ac"" 4 ""a"" 1 ""ac"" 5 ""b"" 1 ""acb"" 6 ""c"" 1 ""acb"" 7 ""1"" 0 ""acb"" 8 ""a"" 0 ""acba"" 9 ""b"" 0 ""acba"" 10 ""c"" 0 ""acbac"" 따라서 ""acbac""를 return 합니다. ※ 2023년 05월 18일 지문이 수정되었습니다.",easy,Array
49,"두 정수 a, d와 길이가 n인 boolean 배열 included가 주어집니다. 첫째항이 a, 공차가 d인 등차수열에서 included[i]가 i + 1항을 의미할 때, 이 등차수열의 1항부터 n항까지 included가 true인 항들만 더한 값을 return 하는 solution 함수를 작성해 주세요. 제한사항 1 ≤ a ≤ 100 1 ≤ d ≤ 100 1 ≤ included의 길이 ≤ 100 included에는 true가 적어도 하나 존재합니다. 입출력 예 a d included result 3 4 [true, false, false, true, true] 37 7 1 [false, false, false, true, false, false, false] 10 입출력 예 설명 입출력 예 #1 예제 1번은 a와 d가 각각 3, 4이고 included의 길이가 5입니다. 이를 표로 나타내면 다음과 같습니다. 1항 2항 3항 4항 5항 등차수열 3 7 11 15 19 included true false false true true 따라서 true에 해당하는 1항, 4항, 5항을 더한 3 + 15 + 19 = 37을 return 합니다. 입출력 예 #2 예제 2번은 a와 d가 각각 7, 1이고 included의 길이가 7입니다. 이를 표로 나타내면 다음과 같습니다. 1항 2항 3항 4항 5항 6항 7항 등차수열 7 8 9 10 11 12 13 included false false false true false false false 따라서 4항만 true이므로 10을 return 합니다.",easy,Array
50,"1부터 6까지 숫자가 적힌 주사위가 세 개 있습니다. 세 주사위를 굴렸을 때 나온 숫자를 각각 a, b, c라고 했을 때 얻는 점수는 다음과 같습니다. 세 숫자가 모두 다르다면 a + b + c 점을 얻습니다. 세 숫자 중 어느 두 숫자는 같고 나머지 다른 숫자는 다르다면 (a + b + c) × (a2 + b2 + c2 )점을 얻습니다. 세 숫자가 모두 같다면 (a + b + c) × (a2 + b2 + c2 ) × (a3 + b3 + c3 )점을 얻습니다. 세 정수 a, b, c가 매개변수로 주어질 때, 얻는 점수를 return 하는 solution 함수를 작성해 주세요. 제한사항 a, b, c는 1이상 6이하의 정수입니다. 입출력 예 a b c result 2 6 1 9 5 3 3 473 4 4 4 110592 입출력 예 설명 입출력 예 #1 예제 1번에서 세 주사위 숫자가 모두 다르므로 2 + 6 + 1 = 9점을 얻습니다. 따라서 9를 return 합니다. 입출력 예 #2 예제 2번에서 두 주사위 숫자만 같으므로 (5 + 3 + 3) × (52 + 32 + 32 ) = 11 × 43 = 473점을 얻습니다. 따라서 473을 return 합니다. 입출력 예 #3 예제 3번에서 세 주사위 숫자가 모두 같으므로 (4 + 4 + 4) × (42 + 42 + 42 ) × (43 + 43 + 43 ) = 12 × 48 × 192 = 110,592점을 얻습니다. 따라서 110592를 return 합니다.",easy,Math
51,"정수가 담긴 리스트 num_list가 주어질 때, 모든 원소들의 곱이 모든 원소들의 합의 제곱보다 작으면 1을 크면 0을 return하도록 solution 함수를 완성해주세요. 제한사항 2 ≤ num_list의 길이 ≤ 10 1 ≤ num_list의 원소 ≤ 9 입출력 예 num_list result [3, 4, 5, 2, 1] 1 [5, 7, 8, 3] 0 입출력 예 설명 입출력 예 #1 모든 원소의 곱은 120, 합의 제곱은 225이므로 1을 return합니다. 입출력 예 #2 모든 원소의 곱은 840, 합의 제곱은 529이므로 0을 return합니다.",easy,Array
52,"정수가 담긴 리스트 num_list가 주어집니다. num_list의 홀수만 순서대로 이어 붙인 수와 짝수만 순서대로 이어 붙인 수의 합을 return하도록 solution 함수를 완성해주세요. 제한사항 2 ≤ num_list의 길이 ≤ 10 1 ≤ num_list의 원소 ≤ 9 num_list에는 적어도 한 개씩의 짝수와 홀수가 있습니다. 입출력 예 num_list result [3, 4, 5, 2, 1] 393 [5, 7, 8, 3] 581 입출력 예 설명 입출력 예 #1 홀수만 이어 붙인 수는 351이고 짝수만 이어 붙인 수는 42입니다. 두 수의 합은 393입니다. 입출력 예 #2 홀수만 이어 붙인 수는 573이고 짝수만 이어 붙인 수는 8입니다. 두 수의 합은 581입니다.",easy,Array
53,"정수 리스트 num_list가 주어질 때, 마지막 원소가 그전 원소보다 크면 마지막 원소에서 그전 원소를 뺀 값을 마지막 원소가 그전 원소보다 크지 않다면 마지막 원소를 두 배한 값을 추가하여 return하도록 solution 함수를 완성해주세요. 제한사항 2 ≤ num_list의 길이 ≤ 10 1 ≤ num_list의 원소 ≤ 9 입출력 예 num_list result [2, 1, 6] [2, 1, 6, 5] [5, 2, 1, 7, 5] [5, 2, 1, 7, 5, 10] 입출력 예 설명 입출력 예 #1 마지막 원소인 6이 그전 원소인 1보다 크기 때문에 6 - 1인 5를 추가해 return합니다. 입출력 예 #2 마지막 원소인 5가 그전 원소인 7보다 크지 않기 때문에 5의 두 배인 10을 추가해 return합니다.",easy,Array
54,"정수 n과 문자열 control이 주어집니다. control은 ""w"", ""a"", ""s"", ""d""의 4개의 문자로 이루어져 있으며, control의 앞에서부터 순서대로 문자에 따라 n의 값을 바꿉니다. ""w"" : n이 1 커집니다. ""s"" : n이 1 작아집니다. ""d"" : n이 10 커집니다. ""a"" : n이 10 작아집니다. 위 규칙에 따라 n을 바꿨을 때 가장 마지막에 나오는 n의 값을 return 하는 solution 함수를 완성해 주세요. 제한사항 -100,000 ≤ n ≤ 100,000 1 ≤ control의 길이 ≤ 100,000 control은 알파벳 소문자 ""w"", ""a"", ""s"", ""d""로 이루어진 문자열입니다. 입출력 예 n control result 0 ""wsdawsdassw"" -1 입출력 예 설명 입출력 예 #1 수 n은 control에 따라 다음과 같은 순서로 변하게 됩니다. 0 → 1 → 0 → 10 → 0 → 1 → 0 → 10 → 0 → -1 → -2 → -1 따라서 -1을 return 합니다.",easy,String
55,"정수 배열 numLog가 주어집니다. 처음에 numLog[0]에서 부터 시작해 ""w"", ""a"", ""s"", ""d""로 이루어진 문자열을 입력으로 받아 순서대로 다음과 같은 조작을 했다고 합시다. ""w"" : 수에 1을 더한다. ""s"" : 수에 1을 뺀다. ""d"" : 수에 10을 더한다. ""a"" : 수에 10을 뺀다. 그리고 매번 조작을 할 때마다 결괏값을 기록한 정수 배열이 numLog입니다. 즉, numLog[i]는 numLog[0]로부터 총 i번의 조작을 가한 결과가 저장되어 있습니다. 주어진 정수 배열 numLog에 대해 조작을 위해 입력받은 문자열을 return 하는 solution 함수를 완성해 주세요. 제한사항 2 ≤ numLog의 길이 ≤ 100,000 -100,000 ≤ numLog[0] ≤ 100,000 1 ≤ i ≤ numLog의 길이인 모든 i에 대해 |numLog[i] - numLog[i - 1]|의 값은 1 또는 10입니다. 입출력 예 numLog result [0, 1, 0, 10, 0, 1, 0, 10, 0, -1, -2, -1] ""wsdawsdassw"" 입출력 예 설명 입출력 예 #1 result인 ""wsdawsdassw""를 따라 numLog[0]에서부터 시작해 조작을 하면 numLog의 값과 순서대로 일치합니다. 따라서 ""wsdawsdassw""를 return 합니다. Hint ""수 조작하기 1"" 문제의 n값이 numLog[0]에 해당하며, 이 문제에서 주어진 numLog에 따라 ""수 조작하기 1"" 문제의 control을 구하는 문제라고 이해할 수 있습니다. 입출력 예 #1은 ""수 조작하기 1"" 문제의 입출력 예 #1과 같은 예시이므로 참고하시기 바랍니다.",easy,Array
56,"정수 배열 arr와 2차원 정수 배열 queries이 주어집니다. queries의 원소는 각각 하나의 query를 나타내며, [i, j] 꼴입니다. 각 query마다 순서대로 arr[i]의 값과 arr[j]의 값을 서로 바꿉니다. 위 규칙에 따라 queries를 처리한 이후의 arr를 return 하는 solution 함수를 완성해 주세요. 제한사항 1 ≤ arr의 길이 ≤ 1,000 0 ≤ arr의 원소 ≤ 1,000,000 1 ≤ queries의 길이 ≤ 1,000 0 ≤ i < j < arr의 길이 입출력 예 arr queries result [0, 1, 2, 3, 4] [[0, 3],[1, 2],[1, 4]] [3, 4, 1, 0, 2] 입출력 예 설명 입출력 예 #1 각 쿼리에 따라 arr가 다음과 같이 변합니다. arr [0, 1, 2, 3, 4] [3, 1, 2, 0, 4] [3, 2, 1, 0, 4] [3, 4, 1, 0, 2] 따라서 [3, 4, 1, 0, 2]를 return 합니다.",easy,Array
57,"정수 배열 arr와 2차원 정수 배열 queries이 주어집니다. queries의 원소는 각각 하나의 query를 나타내며, [s, e, k] 꼴입니다. 각 query마다 순서대로 s ≤ i ≤ e인 모든 i에 대해 k보다 크면서 가장 작은 arr[i]를 찾습니다. 각 쿼리의 순서에 맞게 답을 저장한 배열을 반환하는 solution 함수를 완성해 주세요. 단, 특정 쿼리의 답이 존재하지 않으면 -1을 저장합니다. 제한사항 1 ≤ arr의 길이 ≤ 1,000 0 ≤ arr의 원소 ≤ 1,000,000 1 ≤ queries의 길이 ≤ 1,000 0 ≤ s ≤ e < arr의 길이 0 ≤ k ≤ 1,000,000 입출력 예 arr queries result [0, 1, 2, 4, 3] [[0, 4, 2],[0, 3, 2],[0, 2, 2]] [3, 4, -1] 입출력 예 설명 입출력 예 #1 첫 번째 쿼리의 범위에는 0, 1, 2, 4, 3이 있으며 이 중 2보다 크면서 가장 작은 값은 3입니다. 두 번째 쿼리의 범위에는 0, 1, 2, 4가 있으며 이 중 2보다 크면서 가장 작은 값은 4입니다. 세 번째 쿼리의 범위에는 0, 1, 2가 있으며 여기에는 2보다 큰 값이 없습니다. 따라서 [3, 4, -1]을 return 합니다.",easy,Array
58,"정수 배열 arr와 2차원 정수 배열 queries이 주어집니다. queries의 원소는 각각 하나의 query를 나타내며, [s, e, k] 꼴입니다. 각 query마다 순서대로 s ≤ i ≤ e인 모든 i에 대해 i가 k의 배수이면 arr[i]에 1을 더합니다. 위 규칙에 따라 queries를 처리한 이후의 arr를 return 하는 solution 함수를 완성해 주세요. 제한사항 1 ≤ arr의 길이 ≤ 1,000 0 ≤ arr의 원소 ≤ 1,000,000 1 ≤ queries의 길이 ≤ 1,000 0 ≤ s ≤ e < arr의 길이 0 ≤ k ≤ 5 입출력 예 arr queries result [0, 1, 2, 4, 3] [[0, 4, 1],[0, 3, 2],[0, 3, 3]] [3, 2, 4, 6, 4] 입출력 예 설명 입출력 예 #1 각 쿼리에 따라 arr가 다음과 같이 변합니다. arr [0, 1, 2, 4, 3] [1, 2, 3, 5, 4] [2, 2, 4, 5, 4] [3, 2, 4, 6, 4] 따라서 [3, 2, 4, 6, 4]를 return 합니다. ※ 2023년 04월 27일 입출력 예 설명이 수정되었습니다.",easy,Array
59,"정수 l과 r이 주어졌을 때, l 이상 r이하의 정수 중에서 숫자 ""0""과 ""5""로만 이루어진 모든 정수를 오름차순으로 저장한 배열을 return 하는 solution 함수를 완성해 주세요. 만약 그러한 정수가 없다면, -1이 담긴 배열을 return 합니다. 제한사항 1 ≤ l ≤ r ≤ 1,000,000 입출력 예 l r result 5 555 [5, 50, 55, 500, 505, 550, 555] 10 20 [-1] 입출력 예 설명 입출력 예 #1 5 이상 555 이하의 0과 5로만 이루어진 정수는 작은 수부터 5, 50, 55, 500, 505, 550, 555가 있습니다. 따라서 [5, 50, 55, 500, 505, 550, 555]를 return 합니다. 입출력 예 #2 10 이상 20 이하이면서 0과 5로만 이루어진 정수는 없습니다. 따라서 [-1]을 return 합니다.",easy,Array
60,"정수 start_num와 end_num가 주어질 때, start_num부터 end_num까지의 숫자를 차례로 담은 리스트를 return하도록 solution 함수를 완성해주세요. 제한사항 0 ≤ start_num ≤ end_num ≤ 50 입출력 예 start_num end_num result 3 10 [3, 4, 5, 6, 7, 8, 9, 10] 입출력 예 설명 입출력 예 #1 3부터 10까지의 숫자들을 담은 리스트 [3, 4, 5, 6, 7, 8, 9, 10]를 return합니다.",easy,Array
61,"모든 자연수 x에 대해서 현재 값이 x이면 x가 짝수일 때는 2로 나누고, x가 홀수일 때는 3 * x + 1로 바꾸는 계산을 계속해서 반복하면 언젠가는 반드시 x가 1이 되는지 묻는 문제를 콜라츠 문제라고 부릅니다. 그리고 위 과정에서 거쳐간 모든 수를 기록한 수열을 콜라츠 수열이라고 부릅니다. 계산 결과 1,000 보다 작거나 같은 수에 대해서는 전부 언젠가 1에 도달한다는 것이 알려져 있습니다. 임의의 1,000 보다 작거나 같은 양의 정수 n이 주어질 때 초기값이 n인 콜라츠 수열을 return 하는 solution 함수를 완성해 주세요. 제한사항 1 ≤ n ≤ 1,000 입출력 예 n result 10 [10, 5, 16, 8, 4, 2, 1] 입출력 예 설명 입출력 예 #1 순서대로 연산한 결과를 표로 만들면 다음과 같습니다. 연산 횟수 x 홀짝 여부 0 10 짝수 1 5 홀수 2 16 짝수 3 8 짝수 4 4 짝수 5 2 짝수 6 1 홀수 따라서 [10, 5, 16, 8, 4, 2, 1]을 return 합니다.",easy,Math
62,"정수 배열 arr가 주어집니다. arr를 이용해 새로운 배열 stk를 만드려고 합니다. 변수 i를 만들어 초기값을 0으로 설정한 후 i가 arr의 길이보다 작으면 다음 작업을 반복합니다. 만약 stk가 빈 배열이라면 arr[i]를 stk에 추가하고 i에 1을 더합니다. stk에 원소가 있고, stk의 마지막 원소가 arr[i]보다 작으면 arr[i]를 stk의 뒤에 추가하고 i에 1을 더합니다. stk에 원소가 있는데 stk의 마지막 원소가 arr[i]보다 크거나 같으면 stk의 마지막 원소를 stk에서 제거합니다. 위 작업을 마친 후 만들어진 stk를 return 하는 solution 함수를 완성해 주세요. 제한사항 1 ≤ arr의 길이 ≤ 100,000 1 ≤ arr의 원소 ≤ 100,000 입출력 예 arr result [1, 4, 2, 5, 3] [1, 2, 3] 입출력 예 설명 입출력 예 #1 각 작업을 마친 후에 배열의 변화를 나타내면 다음 표와 같습니다. i arr[i] stk 0 1 [] 1 4 [1] 2 2 [1, 4] 2 2 [1] 3 5 [1, 2] 4 3 [1, 2, 5] 4 3 [1, 2] - - [1, 2, 3] 따라서 [1, 2, 3]을 return 합니다.",easy,Array
63,"boolean 변수 x1, x2, x3, x4가 매개변수로 주어질 때, 다음의 식의 true/false를 return 하는 solution 함수를 작성해 주세요. (x1 ∨ x2) ∧ (x3 ∨ x4) 입출력 예 x1 x2 x3 x4 result false true true true true true false false false false 입출력 예 설명 입출력 예 #1 예제 1번의 x1, x2, x3, x4로 식을 계산하면 다음과 같습니다. (x1 ∨ x2) ∧ (x3 ∨ x4) ≡ (F ∨ T) ∧ (T ∨ T) ≡ T ∧ T ≡ T 따라서 true를 return 합니다. 입출력 예 #2 예제 2번의 x1, x2, x3, x4로 식을 계산하면 다음과 같습니다. (x1 ∨ x2) ∧ (x3 ∨ x4) ≡ (T ∨ F) ∧ (F ∨ F) ≡ T ∧ F ≡ F 따라서 false를 return 합니다. ∨과 ∧의 진리표는 다음과 같습니다. x y x ∨ y x ∧ y T T T T T F T F F T T F F F F",easy,Math
64,"1부터 6까지 숫자가 적힌 주사위가 네 개 있습니다. 네 주사위를 굴렸을 때 나온 숫자에 따라 다음과 같은 점수를 얻습니다. 네 주사위에서 나온 숫자가 모두 p로 같다면 1111 × p점을 얻습니다. 세 주사위에서 나온 숫자가 p로 같고 나머지 다른 주사위에서 나온 숫자가 q(p ≠ q)라면 (10 × p + q)2 점을 얻습니다. 주사위가 두 개씩 같은 값이 나오고, 나온 숫자를 각각 p, q(p ≠ q)라고 한다면 (p + q) × |p - q|점을 얻습니다. 어느 두 주사위에서 나온 숫자가 p로 같고 나머지 두 주사위에서 나온 숫자가 각각 p와 다른 q, r(q ≠ r)이라면 q × r점을 얻습니다. 네 주사위에 적힌 숫자가 모두 다르다면 나온 숫자 중 가장 작은 숫자 만큼의 점수를 얻습니다. 네 주사위를 굴렸을 때 나온 숫자가 정수 매개변수 a, b, c, d로 주어질 때, 얻는 점수를 return 하는 solution 함수를 작성해 주세요. 제한사항 a, b, c, d는 1 이상 6 이하의 정수입니다. 입출력 예 a b c d result 2 2 2 2 2222 4 1 4 4 1681 6 3 3 6 27 2 5 2 6 30 6 4 2 5 2 입출력 예 설명 입출력 예 #1 예제 1번에서 네 주사위 숫자가 모두 2로 같으므로 1111 × 2 = 2222점을 얻습니다. 따라서 2222를 return 합니다. 입출력 예 #2 예제 2번에서 세 주사위에서 나온 숫자가 4로 같고 나머지 다른 주사위에서 나온 숫자가 1이므로 (10 × 4 + 1)2 = 412 = 1681점을 얻습니다. 따라서 1681을 return 합니다. 입출력 예 #3 예제 3번에서 a, d는 6으로, b, c는 3으로 각각 같으므로 (6 + 3) × |6 - 3| = 9 × 3 = 27점을 얻습니다. 따라서 27을 return 합니다. 입출력 예 #4 예제 4번에서 두 주사위에서 2가 나오고 나머지 다른 두 주사위에서 각각 5, 6이 나왔으므로 5 × 6 = 30점을 얻습니다. 따라서 30을 return 합니다. 입출력 예 #5 예제 5번에서 네 주사위 숫자가 모두 다르고 나온 숫자 중 가장 작은 숫자가 2이므로 2점을 얻습니다. 따라서 2를 return 합니다.",easy,Math
65,"문자열 my_string과 정수 배열 index_list가 매개변수로 주어집니다. my_string의 index_list의 원소들에 해당하는 인덱스의 글자들을 순서대로 이어 붙인 문자열을 return 하는 solution 함수를 작성해 주세요. 제한사항 1 ≤ my_string의 길이 ≤ 1,000 my_string의 원소는 영소문자로 이루어져 있습니다. 1 ≤ index_list의 길이 ≤ 1,000 0 ≤ index_list의 원소 < my_string의 길이 입출력 예 my_string index_list result ""cvsgiorszzzmrpaqpe"" [16, 6, 5, 3, 12, 14, 11, 11, 17, 12, 7] ""programmers"" ""zpiaz"" [1, 2, 0, 0, 3] ""pizza"" 입출력 예 설명 입출력 예 #1 예제 1번의 my_string에서 인덱스 3, 5, 6, 11, 12, 14, 16, 17에 해당하는 글자는 각각 g, o, r, m, r, a, p, e이므로 my_string에서 index_list에 들어있는 원소에 해당하는 인덱스의 글자들은 각각 순서대로 p, r, o, g, r, a, m, m, e, r, s입니다. 따라서 ""programmers""를 return 합니다. 입출력 예 #2 예제 2번의 my_string에서 인덱스 0, 1, 2, 3에 해당하는 글자는 각각 z, p, i, a이므로 my_string에서 index_list에 들어있는 원소에 해당하는 인덱스의 글자들은 각각 순서대로 p, i, z, z, a입니다. 따라서 ""pizza""를 return 합니다.",easy,Array
66,"음이 아닌 정수를 9로 나눈 나머지는 그 정수의 각 자리 숫자의 합을 9로 나눈 나머지와 같은 것이 알려져 있습니다. 이 사실을 이용하여 음이 아닌 정수가 문자열 number로 주어질 때, 이 정수를 9로 나눈 나머지를 return 하는 solution 함수를 작성해주세요. 제한사항 1 ≤ number의 길이 ≤ 100,000 number의 원소는 숫자로만 이루어져 있습니다. number는 정수 0이 아니라면 숫자 '0'으로 시작하지 않습니다. 입출력 예 number result ""123"" 6 ""78720646226947352489"" 2 입출력 예 설명 입출력 예 #1 예제 1번의 number는 123으로 각 자리 숫자의 합은 6입니다. 6을 9로 나눈 나머지는 6이고, 실제로 123 = 9 × 13 + 6입니다. 따라서 6을 return 합니다. 입출력 예 #2 예제 2번의 number는 78720646226947352489으로 각자리 숫자의 합은 101입니다. 101을 9로 나눈 나머지는 2이고, 실제로 78720646226947352489 = 9 × 8746738469660816943 + 2입니다. 따라서 2를 return 합니다.",easy,String
67,"문자열 my_string과 이차원 정수 배열 queries가 매개변수로 주어집니다. queries의 원소는 [s, e] 형태로, my_string의 인덱스 s부터 인덱스 e까지를 뒤집으라는 의미입니다. my_string에 queries의 명령을 순서대로 처리한 후의 문자열을 return 하는 solution 함수를 작성해 주세요. 제한사항 my_string은 영소문자로만 이루어져 있습니다. 1 ≤ my_string의 길이 ≤ 1,000 queries의 원소는 [s, e]의 형태로 0 ≤ s ≤ e < my_string의 길이를 만족합니다. 1 ≤ queries의 길이 ≤ 1,000 입출력 예 my_string queries result ""rermgorpsam"" [[2, 3], [0, 7], [5, 9], [6, 10]] ""programmers"" 입출력 예 설명 예제 1번의 my_string은 ""rermgorpsam""이고 주어진 queries를 순서대로 처리하면 다음과 같습니다. queries my_string ""rermgorpsam"" [2, 3] ""remrgorpsam"" [0, 7] ""progrmersam"" [5, 9] ""prograsremm"" [6, 10] ""programmers"" 따라서 ""programmers""를 return 합니다.",easy,Array
68,"문자열 배열 intStrs와 정수 k, s, l가 주어집니다. intStrs의 원소는 숫자로 이루어져 있습니다. 배열 intStrs의 각 원소마다 s번 인덱스에서 시작하는 길이 l짜리 부분 문자열을 잘라내 정수로 변환합니다. 이때 변환한 정수값이 k보다 큰 값들을 담은 배열을 return 하는 solution 함수를 완성해 주세요. 제한사항 0 ≤ s < 100 1 ≤ l ≤ 8 10l - 1 ≤ k < 10l 1 ≤ intStrs의 길이 ≤ 10,000 s + l ≤ intStrs의 원소의 길이 ≤ 120 입출력 예 intStrs k s l result [""0123456789"",""9876543210"",""9999999999999""] 50000 5 5 [56789, 99999] 입출력 예 설명 입출력 예 #1 idx에 따라 잘라낸 문자열과 그에 따른 ret의 변화를 표시하면 다음 표와 같습니다. idx 잘라낸 문자열 ret 0 ""56789"" [56789] 1 ""43210"" [56789] 2 ""99999"" [56789, 99999] 따라서 [56789, 99999]를 return 합니다.",easy,Array
69,"길이가 같은 문자열 배열 my_strings와 이차원 정수 배열 parts가 매개변수로 주어집니다. parts[i]는 [s, e] 형태로, my_string[i]의 인덱스 s부터 인덱스 e까지의 부분 문자열을 의미합니다. 각 my_strings의 원소의 parts에 해당하는 부분 문자열을 순서대로 이어 붙인 문자열을 return 하는 solution 함수를 작성해 주세요. 제한사항 1 ≤ my_strings의 길이 = parts의 길이 ≤ 100 1 ≤ my_strings의 원소의 길이 ≤ 100 parts[i]를 [s, e]라 할 때, 다음을 만족합니다. 0 ≤ s ≤ e < my_strings[i]의 길이 입출력 예 my_strings parts result [""progressive"", ""hamburger"", ""hammer"", ""ahocorasick""] [[0, 4], [1, 2], [3, 5], [7, 7]] ""programmers"" 입출력 예 설명 입출력 예 #1 예제 1번의 입력을 보기 좋게 표로 나타내면 다음과 같습니다. i my_strings[i] parts[i] 부분 문자열 0 ""progressive"" [0, 4] ""progr"" 1 ""hamburger"" [1, 2] ""am"" 2 ""hammer"" [3, 5] ""mer"" 3 ""ahocorasick"" [7, 7] ""s"" 각 부분 문자열을 순서대로 이어 붙인 문자열은 ""programmers""입니다. 따라서 ""programmers""를 return 합니다.",easy,Array
70,"문자열 my_string과 정수 n이 매개변수로 주어질 때, my_string의 뒤의 n글자로 이루어진 문자열을 return 하는 solution 함수를 작성해 주세요. 제한사항 my_string은 숫자와 알파벳으로 이루어져 있습니다. 1 ≤ my_string의 길이 ≤ 1,000 1 ≤ n ≤ my_string의 길이 입출력 예 my_string n result ""ProgrammerS123"" 11 ""grammerS123"" ""He110W0r1d"" 5 ""W0r1d"" 입출력 예 입출력 예 #1 예제 1번의 my_string에서 뒤의 11글자는 ""grammerS123""이므로 이 문자열을 return 합니다. 입출력 예 #2 예제 2번의 my_string에서 뒤의 5글자는 ""W0r1d""이므로 이 문자열을 return 합니다.",easy,String
71,"어떤 문자열에 대해서 접미사는 특정 인덱스부터 시작하는 문자열을 의미합니다. 예를 들어, ""banana""의 모든 접미사는 ""banana"", ""anana"", ""nana"", ""ana"", ""na"", ""a""입니다. 문자열 my_string이 매개변수로 주어질 때, my_string의 모든 접미사를 사전순으로 정렬한 문자열 배열을 return 하는 solution 함수를 작성해 주세요. 제한사항 my_string은 알파벳 소문자로만 이루어져 있습니다. 1 ≤ my_string의 길이 ≤ 100 입출력 예 my_string result ""banana"" [""a"", ""ana"", ""anana"", ""banana"", ""na"", ""nana""] ""programmers"" [""ammers"", ""ers"", ""grammers"", ""mers"", ""mmers"", ""ogrammers"", ""programmers"", ""rammers"", ""rogrammers"", ""rs"", ""s""] 입출력 예 설명 입출력 예 #1 예제 1번의 my_string는 ""banana""로 모든 접미사는 문제의 설명과 같습니다. 이를 사전순으로 정렬하면 ""a"", ""ana"", ""anana"", ""banana"", ""na"", ""nana""이므로 [""a"", ""ana"", ""anana"", ""banana"", ""na"", ""nana""]를 return 합니다. 입출력 예 #2 예제 2번의 my_string는 ""programmers""이고 모든 접미사는 ""programmers"", ""rogrammers"", ""ogrammers"", ""grammers"", ""rammers"", ""ammers"", ""mmers"", ""mers"", ""ers"", ""rs"", ""s""입니다. 이를 사전순으로 정렬한 문자열 배열 [""ammers"", ""ers"", ""grammers"", ""mers"", ""mmers"", ""ogrammers"", ""programmers"", ""rammers"", ""rogrammers"", ""rs"", ""s""]를 return 합니다.",easy,Array
72,"어떤 문자열에 대해서 접미사는 특정 인덱스부터 시작하는 문자열을 의미합니다. 예를 들어, ""banana""의 모든 접미사는 ""banana"", ""anana"", ""nana"", ""ana"", ""na"", ""a""입니다. 문자열 my_string과 is_suffix가 주어질 때, is_suffix가 my_string의 접미사라면 1을, 아니면 0을 return 하는 solution 함수를 작성해 주세요. 제한사항 1 ≤ my_string의 길이 ≤ 100 1 ≤ is_suffix의 길이 ≤ 100 my_string과 is_suffix는 영소문자로만 이루어져 있습니다. 입출력 예 my_string is_suffix result ""banana"" ""ana"" 1 ""banana"" ""nan"" 0 ""banana"" ""wxyz"" 0 ""banana"" ""abanana"" 0 입출력 예 설명 입출력 예 #1 예제 1번에서 is_suffix가 my_string의 접미사이기 때문에 1을 return 합니다. 입출력 예 #2 예제 2번에서 is_suffix가 my_string의 접미사가 아니기 때문에 0을 return 합니다. 입출력 예 #3 예제 3번에서 is_suffix가 my_string의 접미사가 아니기 때문에 0을 return 합니다. 입출력 예 #4 예제 4번에서 is_suffix가 my_string의 접미사가 아니기 때문에 0을 return 합니다.",easy,Array
73,"문자열 my_string과 정수 n이 매개변수로 주어질 때, my_string의 앞의 n글자로 이루어진 문자열을 return 하는 solution 함수를 작성해 주세요. 제한사항 my_string은 숫자와 알파벳으로 이루어져 있습니다. 1 ≤ my_string의 길이 ≤ 1,000 1 ≤ n ≤ my_string의 길이 입출력 예 my_string n result ""ProgrammerS123"" 11 ""ProgrammerS"" ""He110W0r1d"" 5 ""He110"" 입출력 예 입출력 예 #1 예제 1번의 my_string에서 앞의 11글자는 ""ProgrammerS""이므로 이 문자열을 return 합니다. 입출력 예 #2 예제 2번의 my_string에서 앞의 5글자는 ""He110""이므로 이 문자열을 return 합니다.",easy,String
74,"어떤 문자열에 대해서 접두사는 특정 인덱스까지의 문자열을 의미합니다. 예를 들어, ""banana""의 모든 접두사는 ""b"", ""ba"", ""ban"", ""bana"", ""banan"", ""banana""입니다. 문자열 my_string과 is_prefix가 주어질 때, is_prefix가 my_string의 접두사라면 1을, 아니면 0을 return 하는 solution 함수를 작성해 주세요. 제한사항 1 ≤ my_string의 길이 ≤ 100 1 ≤ is_prefix의 길이 ≤ 100 my_string과 is_prefix는 영소문자로만 이루어져 있습니다. 입출력 예 my_string is_prefix result ""banana"" ""ban"" 1 ""banana"" ""nan"" 0 ""banana"" ""abcd"" 0 ""banana"" ""bananan"" 0 입출력 예 설명 입출력 예 #1 예제 1번에서 is_prefix가 my_string의 접두사이기 때문에 1을 return 합니다. 입출력 예 #2 예제 2번에서 is_prefix가 my_string의 접두사가 아니기 때문에 0을 return 합니다. 입출력 예 #3 예제 3번에서 is_prefix가 my_string의 접두사가 아니기 때문에 0을 return 합니다. 입출력 예 #4 예제 4번에서 is_prefix가 my_string의 접두사가 아니기 때문에 0을 return 합니다.",easy,Array
75,"문자열 my_string과 정수 s, e가 매개변수로 주어질 때, my_string에서 인덱스 s부터 인덱스 e까지를 뒤집은 문자열을 return 하는 solution 함수를 작성해 주세요. 제한사항 my_string은 숫자와 알파벳으로만 이루어져 있습니다. 1 ≤ my_string의 길이 ≤ 1,000 0 ≤ s ≤ e < my_string의 길이 입출력 예 my_string s e result ""Progra21Sremm3"" 6 12 ""ProgrammerS123"" ""Stanley1yelnatS"" 4 10 ""Stanley1yelnatS"" 입출력 예 설명 입출력 예 #1 예제 1번의 my_string에서 인덱스 6부터 인덱스 12까지를 뒤집은 문자열은 ""ProgrammerS123""이므로 ""ProgrammerS123""를 return 합니다. 입출력 예 #2 예제 2번의 my_string에서 인덱스 4부터 인덱스 10까지를 뒤집으면 원래 문자열과 같은 ""Stanley1yelnatS""이므로 ""Stanley1yelnatS""를 return 합니다.",easy,Array
76,"문자열 my_string과 두 정수 m, c가 주어집니다. my_string을 한 줄에 m 글자씩 가로로 적었을 때 왼쪽부터 세로로 c번째 열에 적힌 글자들을 문자열로 return 하는 solution 함수를 작성해 주세요. 제한사항 my_string은 영소문자로 이루어져 있습니다. 1 ≤ m ≤ my_string의 길이 ≤ 1,000 m은 my_string 길이의 약수로만 주어집니다. 1 ≤ c ≤ m 입출력 예 my_string m c result ""ihrhbakrfpndopljhygc"" 4 2 ""happy"" ""programmers"" 1 1 ""programmers"" 입출력 예 설명 입출력 예 #1 예제 1번의 my_string을 한 줄에 4 글자씩 쓰면 다음의 표와 같습니다. 1열 2열 3열 4열 i h r h b a k r f p n d o p l j h y g c 2열에 적힌 글자를 세로로 읽으면 happy이므로 ""happy""를 return 합니다. 입출력 예 #2 예제 2번의 my_string은 m이 1이므로 세로로 ""programmers""를 적는 것과 같고 따라서 1열에 적힌 글자를 세로로 읽으면 programmers입니다. 따라서 ""programmers""를 return 합니다.",easy,String
77,"두 정수 q, r과 문자열 code가 주어질 때, code의 각 인덱스를 q로 나누었을 때 나머지가 r인 위치의 문자를 앞에서부터 순서대로 이어 붙인 문자열을 return 하는 solution 함수를 작성해 주세요. 제한사항 0 ≤ r < q ≤ 20 r < code의 길이 ≤ 1,000 code는 영소문자로만 이루어져 있습니다. 입출력 예 q r code result 3 1 ""qjnwezgrpirldywt"" ""jerry"" 1 0 ""programmers"" ""programmers"" 입출력 예 설명 입출력 예 #1 예제 1번의 q와 r은 각각 3, 1이고 인덱스와 그 값을 q로 나눈 나머지가 잘 보이도록 표로 만들면 다음과 같습니다. code q j n w e z g r p i r l d y w t index 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 q로 나눈 나머지 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 `q`로 나눈 나머지가 1인 인덱스의 문자들을 앞에서부터 순서대로 이어 붙이면 ""jerry""가 되므로 이를 return 합니다. 입출력 예 #2 예제 2번의 q와 r은 각각 1, 0이고 인덱스와 그 값을 q로 나눈 나머지가 잘 보이도록 표로 만들면 다음과 같습니다. code p r o g r a m m e r s index 0 1 2 3 4 5 6 7 8 9 10 q로 나눈 나머지 0 0 0 0 0 0 0 0 0 0 0 `q`로 나눈 나머지가 1인 인덱스의 문자들을 앞에서부터 순서대로 이어 붙이면 ""programmers""가 되므로 이를 return 합니다.",easy,Array
78,"알파벳 대소문자로만 이루어진 문자열 my_string이 주어질 때, my_string에서 'A'의 개수, my_string에서 'B'의 개수,..., my_string에서 'Z'의 개수, my_string에서 'a'의 개수, my_string에서 'b'의 개수,..., my_string에서 'z'의 개수를 순서대로 담은 길이 52의 정수 배열을 return 하는 solution 함수를 작성해 주세요. 제한사항 1 ≤ my_string의 길이 ≤ 1,000 입출력 예 my_string result ""Programmers"" [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 2, 0, 1, 0, 0, 3, 1, 0, 0, 0, 0, 0, 0, 0] 입출력 예 설명 입출력 예 #1 예제 1번의 my_string에서 'P'가 1개, 'a'가 1개, 'e'가 1개, 'g'가 1개, 'm'이 2개, 'o'가 1개, 'r'가 3개, 's'가 1개 있으므로 [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 2, 0, 1, 0, 0, 3, 1, 0, 0, 0, 0, 0, 0, 0]를 return 합니다.",easy,Array
79,"정수 n과 k가 주어졌을 때, 1 이상 n이하의 정수 중에서 k의 배수를 오름차순으로 저장한 배열을 return 하는 solution 함수를 완성해 주세요. 제한사항 1 ≤ n ≤ 1,000,000 1 ≤ k ≤ min(1,000, n) 입출력 예 n k result 10 3 [3, 6, 9] 15 5 [5, 10, 15] 입출력 예 설명 입출력 예 #1 1 이상 10 이하의 3의 배수는 3, 6, 9 이므로 [3, 6, 9]를 return 합니다. 입출력 예 #2 1 이상 15 이하의 5의 배수는 5, 10, 15 이므로 [5, 10, 15]를 return 합니다.",easy,Array
80,"문자열 my_string과 정수 배열 indices가 주어질 때, my_string에서 indices의 원소에 해당하는 인덱스의 글자를 지우고 이어 붙인 문자열을 return 하는 solution 함수를 작성해 주세요. 제한사항 1 ≤ indices의 길이 < my_string의 길이 ≤ 100 my_string은 영소문자로만 이루어져 있습니다 0 ≤ indices의 원소 < my_string의 길이 indices의 원소는 모두 서로 다릅니다. 입출력 예 my_string indices result ""apporoograpemmemprs"" [1, 16, 6, 15, 0, 10, 11, 3] ""programmers"" 입출력 예 설명 입출력 예 #1 예제 1번의 my_string의 인덱스가 잘 보이도록 표를 만들면 다음과 같습니다. index 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 my_string a p p o r o o g r a p e m m e m p r s `indices`에 있는 인덱스의 글자들을 지우고 이어붙이면 ""programmers""가 되므로 이를 return 합니다.",easy,Array
81,"정수 start_num와 end_num가 주어질 때, start_num에서 end_num까지 1씩 감소하는 수들을 차례로 담은 리스트를 return하도록 solution 함수를 완성해주세요. 제한사항 0 ≤ end_num ≤ start_num ≤ 50 입출력 예 start_num end_num result 10 3 [10, 9, 8, 7, 6, 5, 4, 3] 입출력 예 설명 입출력 예 #1 10부터 3까지 1씩 감소하는 수를 담은 리스트는 [10, 9, 8, 7, 6, 5, 4, 3]입니다.",easy,Array
82,"정수 배열 arr가 주어집니다. 이때 arr의 원소는 1 또는 0입니다. 정수 idx가 주어졌을 때, idx보다 크면서 배열의 값이 1인 가장 작은 인덱스를 찾아서 반환하는 solution 함수를 완성해 주세요. 단, 만약 그러한 인덱스가 없다면 -1을 반환합니다. 제한사항 3 ≤ arr의 길이 ≤ 100'000 arr의 원소는 전부 1 또는 0입니다. 입출력 예 arr idx result [0, 0, 0, 1] 1 3 [1, 0, 0, 1, 0, 0] 4 -1 [1, 1, 1, 1, 0] 3 3 입출력 예 설명 입출력 예 #1 1보다 크면서 원소가 1인 가장 작은 인덱스는 3입니다. 따라서 3을 return 합니다. 입출력 예 #2 4번 인덱스 이후에 1은 등장하지 않습니다. 따라서 -1을 return 합니다. 입출력 예 #3 3번 인덱스의 값이 1입니다. 따라서 3을 return 합니다.",easy,Array
83,"정수 n과 정수 3개가 담긴 리스트 slicer 그리고 정수 여러 개가 담긴 리스트 num_list가 주어집니다. slicer에 담긴 정수를 차례대로 a, b, c라고 할 때, n에 따라 다음과 같이 num_list를 슬라이싱 하려고 합니다. n = 1 : num_list의 0번 인덱스부터 b번 인덱스까지 n = 2 : num_list의 a번 인덱스부터 마지막 인덱스까지 n = 3 : num_list의 a번 인덱스부터 b번 인덱스까지 n = 4 : num_list의 a번 인덱스부터 b번 인덱스까지 c 간격으로 올바르게 슬라이싱한 리스트를 return하도록 solution 함수를 완성해주세요. 제한사항 n 은 1, 2, 3, 4 중 하나입니다. slicer의 길이 = 3 slicer에 담긴 정수를 차례대로 a, b, c라고 할 때 0 ≤ a ≤ b ≤ num_list의 길이 - 1 1 ≤ c ≤ 3 5 ≤ num_list의 길이 ≤ 30 0 ≤ num_list의 원소 ≤ 100 입출력 예 n slicer num_list result 3 [1, 5, 2] [1, 2, 3, 4, 5, 6, 7, 8, 9] [2, 3, 4, 5, 6] 4 [1, 5, 2] [1, 2, 3, 4, 5, 6, 7, 8, 9] [2, 4, 6] 입출력 예 설명 입출력 예 #1 [1, 2, 3, 4, 5, 6, 7, 8, 9]에서 1번 인덱스부터 5번 인덱스까지 자른 리스트는 [2, 3, 4, 5, 6]입니다. 입출력 예 #2 [1, 2, 3, 4, 5, 6, 7, 8, 9]에서 1번 인덱스부터 5번 인덱스까지 2개 간격으로 자른 리스트는 [2, 4, 6]입니다.",easy,Array
84,"정수 리스트 num_list가 주어질 때, 첫 번째로 나오는 음수의 인덱스를 return하도록 solution 함수를 완성해주세요. 음수가 없다면 -1을 return합니다. 제한사항 5 ≤ num_list의 길이 ≤ 100 -10 ≤ num_list의 원소 ≤ 100 입출력 예 num_list result [12, 4, 15, 46, 38, -2, 15] 5 [13, 22, 53, 24, 15, 6] -1 입출력 예 설명 입출력 예 #1 5번 인덱스에서 음수가 처음 등장하므로 5를 return합니다. 입출력 예 #2 음수가 없으므로 -1을 return합니다.",easy,Array
85,"정수 배열 arr와 2개의 구간이 담긴 배열 intervals가 주어집니다. intervals는 항상 [[a1, b1], [a2, b2]]의 꼴로 주어지며 각 구간은 닫힌 구간입니다. 닫힌 구간은 양 끝값과 그 사이의 값을 모두 포함하는 구간을 의미합니다. 이때 배열 arr의 첫 번째 구간에 해당하는 배열과 두 번째 구간에 해당하는 배열을 앞뒤로 붙여 새로운 배열을 만들어 return 하는 solution 함수를 완성해 주세요. 제한사항 1 ≤ arr의 길이 ≤ 100,000 1 ≤ arr의 원소 < 100 1 ≤ a1 ≤ b1 < arr의 길이 1 ≤ a2 ≤ b2 < arr의 길이 입출력 예 arr intervals result [1, 2, 3, 4, 5] [[1, 3], [0, 4]] [2, 3, 4, 1, 2, 3, 4, 5] 입출력 예 설명 입출력 예 #1 첫 번째 구간에 해당하는 배열은 [2, 3, 4] 입니다. 두 번째 구간에 해당하는 배열은 [1, 2, 3, 4, 5] 입니다. 따라서 이 두 배열을 앞뒤로 붙인 배열인 [2, 3, 4, 1, 2, 3, 4, 5]를 return 합니다.",easy,Array
86,"정수 배열 arr가 주어집니다. 배열 안의 2가 모두 포함된 가장 작은 연속된 부분 배열을 return 하는 solution 함수를 완성해 주세요. 단, arr에 2가 없는 경우 [-1]을 return 합니다. 제한사항 1 ≤ arr의 길이 ≤ 100,000 1 ≤ arr의 원소 ≤ 10 입출력 예 arr result [1, 2, 1, 4, 5, 2, 9] [2, 1, 4, 5, 2] [1, 2, 1] [2] [1, 1, 1] [-1] [1, 2, 1, 2, 1, 10, 2, 1] [2, 1, 2, 1, 10, 2] 입출력 예 설명 입출력 예 #1 2가 있는 인덱스는 1번, 5번 인덱스뿐이므로 1번부터 5번 인덱스까지의 부분 배열인 [2, 1, 4, 5, 2]를 return 합니다. 입출력 예 #2 2가 한 개뿐이므로 [2]를 return 합니다. 입출력 예 #3 2가 배열에 없으므로 [-1]을 return 합니다. 입출력 예 #4 2가 있는 인덱스는 1번, 3번, 6번 인덱스이므로 1번부터 6번 인덱스까지의 부분 배열인 [2, 1, 2, 1, 10, 2]를 return 합니다. ※ 2023년 04월 27일 입출력 예, 입출력 예 설명 및 예시 테스트 케이스가 수정 되었습니다.",easy,Array
87,"정수 배열 arr와 query가 주어집니다. query를 순회하면서 다음 작업을 반복합니다. 짝수 인덱스에서는 arr에서 query[i]번 인덱스를 제외하고 배열의 query[i]번 인덱스 뒷부분을 잘라서 버립니다. 홀수 인덱스에서는 arr에서 query[i]번 인덱스는 제외하고 배열의 query[i]번 인덱스 앞부분을 잘라서 버립니다. 위 작업을 마친 후 남은 arr의 부분 배열을 return 하는 solution 함수를 완성해 주세요. 제한사항 5 ≤ arr의 길이 ≤ 100,000 0 ≤ arr의 원소 ≤ 100 1 ≤ query의 길이 < min(50, arr의 길이 / 2) query의 각 원소는 0보다 크거나 같고 남아있는 arr의 길이 보다 작습니다. 입출력 예 arr query result [0, 1, 2, 3, 4, 5] [4, 1, 2] [1, 2, 3] 입출력 예 설명 입출력 예 #1 이번에 매번 처리할 query의 값과 처리 전후의 arr의 상태를 표로 나타내면 다음과 같습니다. query의 값 query 처리 전 query 처리 후 비고 4 [0, 1, 2, 3, 4, 5] [0, 1, 2, 3, 4] 0번 인덱스의 쿼리이므로 뒷부분을 자른다. 1 [0, 1, 2, 3, 4] [1, 2, 3, 4] 1번 인덱스의 쿼리이므로 앞부분을 자른다. 2 [1, 2, 3, 4] [1, 2, 3] 2번 인덱스의 쿼리이므로 뒷부분을 자른다. 따라서 [1, 2, 3]을 return 합니다. ※2023년 04월 24일 지문과 테스트 케이스가 수정되었습니다. 기존에 제출한 코드가 통과하지 못할 수 있습니다.",easy,Array
88,"정수 리스트 num_list와 정수 n이 주어질 때, n 번째 원소부터 마지막 원소까지의 모든 원소를 담은 리스트를 return하도록 solution 함수를 완성해주세요. 제한사항 2 ≤ num_list의 길이 ≤ 30 1 ≤ num_list의 원소 ≤ 9 1 ≤ n ≤ num_list의 길이 입출력 예 num_list n result [2, 1, 6] 3 [6] [5, 2, 1, 7, 5] 2 [2, 1, 7, 5] 입출력 예 설명 입출력 예 #1 [2, 1, 6]의 세 번째 원소부터 마지막 원소까지의 모든 원소는 [6]입니다. 입출력 예 #2 [5, 2, 1, 7, 5]의 두 번째 원소부터 마지막 원소까지의 모든 원소는 [2, 1, 7, 5]입니다.",easy,Array
89,"정수 리스트 num_list와 정수 n이 주어질 때, num_list를 n 번째 원소 이후의 원소들과 n 번째까지의 원소들로 나눠 n 번째 원소 이후의 원소들을 n 번째까지의 원소들 앞에 붙인 리스트를 return하도록 solution 함수를 완성해주세요. 제한사항 2 ≤ num_list의 길이 ≤ 30 1 ≤ num_list의 원소 ≤ 9 1 ≤ n ≤ num_list의 길이 입출력 예 num_list n result [2, 1, 6] 1 [1, 6, 2] [5, 2, 1, 7, 5] 3 [7, 5, 5, 2, 1] 입출력 예 설명 입출력 예 #1 [2, 1, 6]에서 첫 번째 이후의 원소는 [1, 6]이고 첫 번째까지의 원소는 [2]입니다. 두 리스트를 이어 붙이면 [1, 6, 2]가 됩니다. 입출력 예 #2 [5, 2, 1, 7, 5]에서 세 번째 이후의 원소는 [7, 5]이고 세 번째까지의 원소는 [5, 2, 1]입니다. 두 리스트를 이어 붙이면 [7, 5, 5, 2, 1]가 됩니다.",easy,Array
90,"문자열 리스트 str_list에는 ""u"", ""d"", ""l"", ""r"" 네 개의 문자열이 여러 개 저장되어 있습니다. str_list에서 ""l""과 ""r"" 중 먼저 나오는 문자열이 ""l""이라면 해당 문자열을 기준으로 왼쪽에 있는 문자열들을 순서대로 담은 리스트를, 먼저 나오는 문자열이 ""r""이라면 해당 문자열을 기준으로 오른쪽에 있는 문자열들을 순서대로 담은 리스트를 return하도록 solution 함수를 완성해주세요. ""l""이나 ""r""이 없다면 빈 리스트를 return합니다. 제한사항 1 ≤ str_list의 길이 ≤ 20 str_list는 ""u"", ""d"", ""l"", ""r"" 네 개의 문자열로 이루어져 있습니다. 입출력 예 str_list result [""u"", ""u"", ""l"", ""r""] [""u"", ""u""] [""l""] [] 입출력 예 설명 입출력 예 #1 ""r""보다 ""l""이 먼저 나왔기 때문에 ""l""의 왼쪽에 있는 문자열들을 담은 리스트인 [""u"", ""u""]를 return합니다. 입출력 예 #2 ""l""의 왼쪽에 문자열이 없기 때문에 빈 리스트를 return합니다.",easy,Array
91,"정수 리스트 num_list와 정수 n이 주어질 때, num_list의 첫 번째 원소부터 n 번째 원소까지의 모든 원소를 담은 리스트를 return하도록 solution 함수를 완성해주세요. 제한사항 2 ≤ num_list의 길이 ≤ 30 1 ≤ num_list의 원소 ≤ 9 1 ≤ n ≤ num_list의 길이 ___ 입출력 예 num_list n result [2, 1, 6] 1 [2] [5, 2, 1, 7, 5] 3 [5, 2, 1] 입출력 예 설명 입출력 예 #1 [2, 1, 6]의 첫 번째 원소부터 첫 번째 원소까지의 모든 원소는 [2]입니다. 입출력 예 #2 [5, 2, 1, 7, 5]의 첫 번째 원소부터 세 번째 원소까지의 모든 원소는 [5, 2, 1]입니다.",easy,Array
92,"정수 리스트 num_list와 정수 n이 주어질 때, num_list의 첫 번째 원소부터 마지막 원소까지 n개 간격으로 저장되어있는 원소들을 차례로 담은 리스트를 return하도록 solution 함수를 완성해주세요. 제한사항 5 ≤ num_list의 길이 ≤ 20 1 ≤ num_list의 원소 ≤ 9 1 ≤ n ≤ 4 입출력 예 num_list n result [4, 2, 6, 1, 7, 6] 2 [4, 6, 7] [4, 2, 6, 1, 7, 6] 4 [4, 7] 입출력 예 설명 입출력 예 #1 [4, 2, 6, 1, 7, 6]에서 2개 간격으로 저장되어 있는 원소들은 [4, 6, 7]입니다. 입출력 예 #2 [4, 2, 6, 1, 7, 6]에서 4개 간격으로 저장되어 있는 원소들은 [4, 7]입니다.",easy,Array
93,"정수 리스트 num_list가 주어집니다. 가장 첫 번째 원소를 1번 원소라고 할 때, 홀수 번째 원소들의 합과 짝수 번째 원소들의 합 중 큰 값을 return 하도록 solution 함수를 완성해주세요. 두 값이 같을 경우 그 값을 return합니다. 제한사항 5 ≤ num_list의 길이 ≤ 50 -9 ≤ num_list의 원소 ≤ 9 입출력 예 num_list result [4, 2, 6, 1, 7, 6] 17 [-1, 2, 5, 6, 3] 8 입출력 예 설명 입출력 예 #1 홀수 번째 원소들의 합은 4 + 6 + 7 = 17, 짝수 번째 원소들의 합은 2 + 1 + 6 = 9 이므로 17을 return합니다. 입출력 예 #2 홀수 번째 원소들의 합은 -1 + 5 + 3 = 7, 짝수 번째 원소들의 합은 2 + 6 = 8 이므로 8을 return합니다. ※2023년 04월 24일 테스트 케이스가 추가되었습니다. 기존에 제출한 코드가 통과하지 못할 수 있습니다.",easy,Array
94,"최대 5명씩 탑승가능한 놀이기구를 타기 위해 줄을 서있는 사람들의 이름이 담긴 문자열 리스트 names가 주어질 때, 앞에서 부터 5명씩 묶은 그룹의 가장 앞에 서있는 사람들의 이름을 담은 리스트를 return하도록 solution 함수를 완성해주세요. 마지막 그룹이 5명이 되지 않더라도 가장 앞에 있는 사람의 이름을 포함합니다. 제한사항 5 ≤ names의 길이 ≤ 30 1 ≤ names의 원소의 길이 ≤ 10 names의 원소는 영어 알파벳 소문자로만 이루어져 있습니다. 입출력 예 names result [""nami"", ""ahri"", ""jayce"", ""garen"", ""ivern"", ""vex"", ""jinx""] [""nami"", ""vex""] 입출력 예 설명 입출력 예 #1 앞에서부터 5명씩 두 그룹으로 묶을 수 있습니다. [""nami"", ""ahri"", ""jayce"", ""garen"", ""ivern""], [""vex"", ""jinx""] 이 두 그룹에서 가장 앞에 서있는 사람들의 이름을 담은 리스트인 [""nami"", ""vex""]를 return합니다.",easy,Array
95,"오늘 해야 할 일이 담긴 문자열 배열 todo_list와 각각의 일을 지금 마쳤는지를 나타내는 boolean 배열 finished가 매개변수로 주어질 때, todo_list에서 아직 마치지 못한 일들을 순서대로 담은 문자열 배열을 return 하는 solution 함수를 작성해 주세요. 제한사항 1 ≤ todo_list의 길이 1 ≤ 100 2 ≤ todo_list의 원소의 길이 ≤ 20 todo_list의 원소는 영소문자로만 이루어져 있습니다. todo_list의 원소는 모두 서로 다릅니다. finished[i]는 true 또는 false이고 true는 todo_list[i]를 마쳤음을, false는 아직 마치지 못했음을 나타냅니다. 아직 마치지 못한 일이 적어도 하나 있습니다. 입출력 예 todo_list finished result [""problemsolving"", ""practiceguitar"", ""swim"", ""studygraph""] [true, false, true, false] [""practiceguitar"", ""studygraph""] 입출력 예 설명 입출력 예 #1 예제 1번의 todo_list 중에서 ""problemsolving""과 ""swim""은 마쳤고, ""practiceguitar""와 ""studygraph""는 아직 마치지 못했으므로 todo_list에서 나온 순서대로 담은 문자열 배열 [""practiceguitar"", ""studygraph""]를 return 합니다.",easy,Array
96,"정수 배열 numbers와 정수 n이 매개변수로 주어집니다. numbers의 원소를 앞에서부터 하나씩 더하다가 그 합이 n보다 커지는 순간 이때까지 더했던 원소들의 합을 return 하는 solution 함수를 작성해 주세요. 제한사항 1 ≤ numbers의 길이 ≤ 100 1 ≤ numbers의 원소 ≤ 100 0 ≤ n < numbers의 모든 원소의 합 입출력 예 numbers n result [34, 5, 71, 29, 100, 34] 123 139 [58, 44, 27, 10, 100] 139 239 입출력 예 설명 입출력 예 #1 예제 1번의 numbers를 문제 설명대로 더해가는 과정을 나타내면 다음의 표와 같습니다. i numbers[i] sum 0 0 34 34 1 5 39 2 71 110 3 29 139 29를 더한 뒤에 sum 값은 139이고 `n` 값인 123보다 크므로 139를 return 합니다. 예제 2번의 numbers의 마지막 원소 전까지의 원소를 sum에 더하면 139입니다. 139는 n 값인 139보다 크지 않고 마지막 원소인 100을 더하면 139보다 커지므로 239를 return 합니다.",easy,Array
97,"정수 배열 arr와 2차원 정수 배열 queries이 주어집니다. queries의 원소는 각각 하나의 query를 나타내며, [s, e] 꼴입니다. 각 query마다 순서대로 s ≤ i ≤ e인 모든 i에 대해 arr[i]에 1을 더합니다. 위 규칙에 따라 queries를 처리한 이후의 arr를 return 하는 solution 함수를 완성해 주세요. 제한사항 1 ≤ arr의 길이 ≤ 1,000 0 ≤ arr의 원소 ≤ 1,000,000 1 ≤ queries의 길이 ≤ 1,000 0 ≤ s ≤ e < arr의 길이 입출력 예 arr queries result [0, 1, 2, 3, 4] [[0, 1],[1, 2],[2, 3]] [1, 3, 4, 4, 4] 입출력 예 설명 입출력 예 #1 각 쿼리에 따라 arr가 다음과 같이 변합니다. i queries[i] arr - - [0, 1, 2, 3, 4] 0 [0,1] [1, 2, 2, 3, 4] 1 [1,2] [1, 3, 3, 3, 4] 2 [2,3] [1, 3, 4, 4, 4] 따라서 [1, 3, 4, 4, 4]를 return 합니다.",easy,Array
98,"정수 배열 arr가 주어집니다. arr의 각 원소에 대해 값이 50보다 크거나 같은 짝수라면 2로 나누고, 50보다 작은 홀수라면 2를 곱합니다. 그 결과인 정수 배열을 return 하는 solution 함수를 완성해 주세요. 제한사항 1 ≤ arr의 길이 ≤ 1,000,000 1 ≤ arr의 원소의 값 ≤ 100 입출력 예 arr result [1, 2, 3, 100, 99, 98] [2, 2, 6, 50, 99, 49] 입출력 예 설명 입출력 예 #1 1, 3은 50 미만의 홀수 이므로 2를 곱하고, 100, 98은 50 이상의 짝수이므로 2로 나눕니다. 나머지 값들은 변경 조건에 해당하지 않으므로 바꾸지 않습니다. 따라서 [2, 2, 6, 50, 99, 49]를 return 합니다.",easy,Array
99,"정수 배열 arr가 주어집니다. arr의 각 원소에 대해 값이 50보다 크거나 같은 짝수라면 2로 나누고, 50보다 작은 홀수라면 2를 곱하고 다시 1을 더합니다. 이러한 작업을 x번 반복한 결과인 배열을 arr(x)라고 표현했을 때, arr(x) = arr(x + 1)인 x가 항상 존재합니다. 이러한 x 중 가장 작은 값을 return 하는 solution 함수를 완성해 주세요. 단, 두 배열에 대한 ""=""는 두 배열의 크기가 서로 같으며, 같은 인덱스의 원소가 각각 서로 같음을 의미합니다. 제한사항 1 ≤ arr의 길이 ≤ 1,000,000 1 ≤ arr의 원소의 값 ≤ 100 입출력 예 arr result [1, 2, 3, 100, 99, 98] 5 입출력 예 설명 입출력 예 #1 위 작업을 반복하면 다음과 같이 arr가 변합니다. 반복 횟수 arr 0 [1, 2, 3, 100, 99, 98] 1 [3, 2, 7, 50, 99, 49] 2 [7, 2, 15, 25, 99, 99] 3 [15, 2, 31, 51, 99, 99] 4 [31, 2, 63, 51, 99, 99] 5 [63, 2, 63, 51, 99, 99] 6 [63, 2, 63, 51, 99, 99] 이후로 arr가 변하지 않으며, arr(5) = arr(6)이므로 5를 return 합니다.",easy,Array
100,"정수가 있을 때, 짝수라면 반으로 나누고, 홀수라면 1을 뺀 뒤 반으로 나누면, 마지막엔 1이 됩니다. 예를 들어 10이 있다면 다음과 같은 과정으로 1이 됩니다. 10 / 2 = 5 (5 - 1) / 2 = 2 2 / 2 = 1 위와 같이 3번의 나누기 연산으로 1이 되었습니다. 정수들이 담긴 리스트 num_list가 주어질 때, num_list의 모든 원소를 1로 만들기 위해서 필요한 나누기 연산의 횟수를 return하도록 solution 함수를 완성해주세요. 제한사항 3 ≤ num_list의 길이 ≤ 15 1 ≤ num_list의 원소 ≤ 30 입출력 예 num_list result [12, 4, 15, 1, 14] 11 입출력 예 설명 입출력 예 #1 12는 3번, 4는 2번, 15는 3번, 1은 0번, 14는 3번의 연산이 필요하기 때문에 총 11번의 연산이 필요합니다.",easy,Array
101,"정수가 담긴 리스트 num_list가 주어질 때, 리스트의 길이가 11 이상이면 리스트에 있는 모든 원소의 합을 10 이하이면 모든 원소의 곱을 return하도록 solution 함수를 완성해주세요. 제한사항 2 ≤ num_list의 길이 ≤ 20 1 ≤ num_list의 원소 ≤ 9 num_list의 원소를 모두 곱했을 때 2,147,483,647를 넘는 입력은 주어지지 않습니다. 입출력 예 num_list result [3, 4, 5, 2, 5, 4, 6, 7, 3, 7, 2, 2, 1] 51 [2, 3, 4, 5] 120 입출력 예 설명 입출력 예 #1 리스트의 길이가 13이므로 모든 원소의 합인 51을 return합니다. 입출력 예 #2 리스트의 길이가 4이므로 모든 원소의 곱인 120을 return합니다.",easy,Array
102,"알파벳으로 이루어진 문자열 myString과 pat이 주어집니다. myString의 연속된 부분 문자열 중 pat이 존재하면 1을 그렇지 않으면 0을 return 하는 solution 함수를 완성해 주세요. 단, 알파벳 대문자와 소문자는 구분하지 않습니다. 제한사항 1 ≤ myString의 길이 ≤ 100,000 1 ≤ pat의 길이 ≤ 300 myString과 pat은 모두 알파벳으로 이루어진 문자열입니다. 입출력 예 myString pat return ""AbCdEfG"" ""aBc"" 1 ""aaAA"" ""aaaaa"" 0 입출력 예 설명 입출력 예 #1 ""AbCdEfG""의 0~2번 인덱스의 문자열은 ""AbC""이며, 이는 pat인 ""aBc""와 같습니다. 따라서 1을 return 합니다. 입출력 예 #2 myString의 길이가 pat보다 더 짧기 때문에 myString의 부분 문자열 중 pat와 같은 문자열이 있을 수 없습니다. 따라서 0을 return 합니다. ※2023년 05월 15일 제한사항이 수정되었습니다.",easy,Array
103,"알파벳으로 이루어진 문자열 myString이 주어집니다. 모든 알파벳을 대문자로 변환하여 return 하는 solution 함수를 완성해 주세요. 제한사항 1 ≤ myString의 길이 ≤ 100,000 myString은 알파벳으로 이루어진 문자열입니다. 입출력 예 myString result ""aBcDeFg"" ""ABCDEFG"" ""AAA"" ""AAA""",easy,String
104,"알파벳으로 이루어진 문자열 myString이 주어집니다. 모든 알파벳을 소문자로 변환하여 return 하는 solution 함수를 완성해 주세요. 제한사항 1 ≤ myString의 길이 ≤ 100,000 myString은 알파벳으로 이루어진 문자열입니다. 입출력 예 myString result ""aBcDeFg"" ""abcdefg"" ""aaa"" ""aaa""",easy,String
105,"문자열 배열 strArr가 주어집니다. 모든 원소가 알파벳으로만 이루어져 있을 때, 배열에서 홀수번째 인덱스의 문자열은 모든 문자를 대문자로, 짝수번째 인덱스의 문자열은 모든 문자를 소문자로 바꿔서 반환하는 solution 함수를 완성해 주세요. 제한사항 1 ≤ strArr ≤ 20 1 ≤ strArr의 원소의 길이 ≤ 20 strArr의 원소는 알파벳으로 이루어진 문자열 입니다. 입출력 예 strArr result [""AAA"",""BBB"",""CCC"",""DDD""] [""aaa"",""BBB"",""ccc"",""DDD""] [""aBc"",""AbC""] [""abc"",""ABC""] 입출력 예 설명 입출력 예 #1 strArr[0]과 strArr[2]는 짝수번째 인덱스의 문자열이므로 모두 소문자로 바꿔서 ""aaa""와 ""ccc""가 됩니다. strArr[1]과 strArr[3]는 홀수번째 인덱스의 문자열인데 원래 대문자이므로 그대로 둡니다. 따라서 [""aaa"",""BBB"",""ccc"",""DDD""]를 return 합니다. 입출력 예 #2 strArr[0]은 짝수번째 인덱스의 문자열이므로 소문자로 바꿔서 ""abc""가 됩니다. strArr[1]은 홀수번째 인덱스의 문자열이므로 대문자로 바꿔서 ""ABC""가 됩니다. 따라서 [""abc"",""ABC""]를 return 합니다. ※ 2023년 05월 15일 제한사항이 수정되었습니다.",easy,Array
106,"문자열 myString이 주어집니다. myString에서 알파벳 ""a""가 등장하면 전부 ""A""로 변환하고, ""A""가 아닌 모든 대문자 알파벳은 소문자 알파벳으로 변환하여 return 하는 solution 함수를 완성하세요. 제한사항 1 ≤ myString의 길이 ≤ 20 myString은 알파벳으로 이루어진 문자열입니다. 입출력 예 myString result ""abstract algebra"" ""AbstrAct AlgebrA"" ""PrOgRaMmErS"" ""progrAmmers"" 입출력 예 설명 입출력 예 #1 0번, 5번, 9번, 15번 인덱스의 ""a""는 소문자이므로 전부 대문자로 고쳐줍니다. 다른 문자들은 전부 ""a""가 아닌 소문자이므로 바꾸지 않습니다. 따라서 ""AbstrAct AlgebrA""를 return 합니다. 입출력 예 #2 0번, 2번, 4번, 6번, 8번, 10번 인덱스의 문자들은 ""A""가 아닌 대문자이므로 전부 소문자로 고쳐줍니다. 5번 인덱스의 ""a""는 소문자이므로 대문자로 고쳐줍니다. 다른 문자들은 전부 ""a""가 아닌 소문자이므로 바꾸지 않습니다. 따라서 ""progrAmmers""를 return 합니다.",easy,Array
107,"영소문자로 이루어진 문자열 my_string과 영소문자 1글자로 이루어진 문자열 alp가 매개변수로 주어질 때, my_string에서 alp에 해당하는 모든 글자를 대문자로 바꾼 문자열을 return 하는 solution 함수를 작성해 주세요. 제한사항 1 ≤ my_string의 길이 ≤ 1,000 입출력 예 my_string alp result ""programmers"" ""p"" ""Programmers"" ""lowercase"" ""x"" ""lowercase"" 입출력 예 설명 입출력 예 #1 예제 1번의 my_string은 ""programmers""이고 alp가 ""p""이므로 my_string에 모든 p를 대문자인 P로 바꾼 문자열 ""Programmers""를 return 합니다. 입출력 예 #2 예제 2번의 alp는 ""x""이고 my_string에 x는 없습니다. 따라서 ""lowercase""를 return 합니다.",easy,String
108,"문자열 myString과 pat가 주어집니다. myString의 부분 문자열중 pat로 끝나는 가장 긴 부분 문자열을 찾아서 return 하는 solution 함수를 완성해 주세요. 제한사항 5 ≤ myString ≤ 20 1 ≤ pat ≤ 5 pat은 반드시 myString의 부분 문자열로 주어집니다. myString과 pat에 등장하는 알파벳은 대문자와 소문자를 구분합니다. 입출력 예 myString pat result ""AbCdEFG"" ""dE"" ""AbCdE"" ""AAAAaaaa"" ""a"" ""AAAAaaaa"" 입출력 예 설명 입출력 예 #1 ""AbCdEFG""에서 ""dE""는 한 번 등장하며 처음부터 해당 위치까지 잘라내면 ""AbCdE""가 됩니다. 따라서 이 문자열이 ""dE""로 끝나는 가장 긴 문자열이며, ""AbCdE""를 return 합니다. 입출력 예 #2 ""AAAAaaaa""에서 ""a""는 총 네 번 등장하며 이 중 가장 마지막에 있는 위치까지 잘라내면 ""AAAAaaaa""가 됩니다. 따라서 이 문자열이 ""a""로 끝나는 가장 긴 문자열이며, ""AAAAaaaa""를 return 합니다.",easy,String
109,"문자열 myString과 pat이 주어집니다. myString에서 pat이 등장하는 횟수를 return 하는 solution 함수를 완성해 주세요. 제한사항 1 ≤ myString ≤ 1000 1 ≤ pat ≤ 10 입출력 예 myString pat result ""banana"" ""ana"" 2 ""aaaa"" ""aa"" 3 입출력 예 설명 입출력 예 #1 ""banana""에서 1 ~ 3번 인덱스에서 한 번, 3 ~ 5번 인덱스에서 또 한 번 ""ana""가 등장해서 총 두 번 등장합니다. 따라서 2를 return 합니다. 입출력 예 #2 ""aaaa""에서 0 ~ 2번 인덱스에서 한 번, 1 ~ 3번 인덱스에서 한 번, 2 ~ 4번 인덱스에서 한 번 ""aa""가 등장해서 총 세 번 등장합니다. 따라서 3을 return 합니다.",easy,Array
110,"문자열 배열 strArr가 주어집니다. 배열 내의 문자열 중 ""ad""라는 부분 문자열을 포함하고 있는 모든 문자열을 제거하고 남은 문자열을 순서를 유지하여 배열로 return 하는 solution 함수를 완성해 주세요. 제한사항 1 ≤ strArr의 길이 ≤ 1,000 1 ≤ strArr의 원소의 길이 ≤ 20 strArr의 원소는 알파벳 소문자로 이루어진 문자열입니다. 입출력 예 strArr result [""and"",""notad"",""abcd""] [""and"",""abcd""] [""there"",""are"",""no"",""a"",""ds""] [""there"",""are"",""no"",""a"",""ds""] 입출력 예 설명 입출력 예 #1 1번 인덱스의 문자열인 ""notad""는 부분 문자열로 ""ad""를 가집니다. 따라서 해당 문자열을 제거하고 나머지는 순서를 유지하여 [""and"",""abcd""]를 return 합니다. 입출력 예 #2 ""ad""가 부분 문자열로 들어간 문자열이 존재하지 않습니다. 따라서 원래 배열을 그대로 return 합니다.",easy,Array
111,"단어가 공백 한 개로 구분되어 있는 문자열 my_string이 매개변수로 주어질 때, my_string에 나온 단어를 앞에서부터 순서대로 담은 문자열 배열을 return 하는 solution 함수를 작성해 주세요. 제한사항 my_string은 영소문자와 공백으로만 이루어져 있습니다. 1 ≤ my_string의 길이 ≤ 1,000 my_string의 맨 앞과 맨 뒤에 글자는 공백이 아닙니다. 입출력 예 my_string result ""i love you"" [""i"", ""love"", ""you""] ""programmers"" [""programmers""] 입출력 예 설명 입출력 예 #1 예제 1번의 my_string은 ""i love you""로 공백 한 칸으로 나누어진 단어들은 앞에서부터 순서대로 ""i"", ""love"", ""you"" 이므로 [""i"", ""love"", ""you""]를 return 합니다. 입출력 예 #2 예제 2번의 my_string은 ""programmers""로 단어가 하나만 있습니다. 따라서 [""programmers""]를 return 합니다.",easy,Array
112,"단어가 공백 한 개 이상으로 구분되어 있는 문자열 my_string이 매개변수로 주어질 때, my_string에 나온 단어를 앞에서부터 순서대로 담은 문자열 배열을 return 하는 solution 함수를 작성해 주세요. 제한사항 my_string은 영소문자와 공백으로만 이루어져 있습니다. 1 ≤ my_string의 길이 ≤ 1,000 my_string의 맨 앞과 맨 뒤에도 공백이 있을 수 있습니다. my_string에는 단어가 하나 이상 존재합니다. 입출력 예 my_string result "" i love you"" [""i"", ""love"", ""you""] "" programmers "" [""programmers""] 입출력 예 설명 입출력 예 #1 예제 1번의 my_string은 "" i love you""로 공백을 기준으로 단어를 나누면 ""i"", ""love"", ""you"" 3개의 단어가 있습니다. 따라서 [""i"", ""love"", ""you""]를 return 합니다. 입출력 예 #2 예제 2번의 my_string은 "" programmers ""로 단어는 ""programmers"" 하나만 있습니다. 따라서 [""programmers""]를 return 합니다.",easy,Array
113,"문자열 myString이 주어집니다. myString을 문자 ""x""를 기준으로 나눴을 때 나눠진 문자열 각각의 길이를 순서대로 저장한 배열을 return 하는 solution 함수를 완성해 주세요. 제한사항 1 ≤ myString의 길이 ≤ 100,000 myString은 알파벳 소문자로 이루어진 문자열입니다. 입출력 예 myString result ""oxooxoxxox"" [1, 2, 1, 0, 1, 0] ""xabcxdefxghi"" [0, 3, 3, 3] 입출력 예 설명 입출력 예 #1 ""x""를 기준으로 문자열을 나누면 [""o"", ""oo"", ""o"", """", ""o"", """"]가 됩니다. 각각의 길이로 배열을 만들면 [1, 2, 1, 0, 1, 0]입니다. 따라서 [1, 2, 1, 0, 1, 0]을 return 합니다. 입출력 예 #2 ""x""를 기준으로 문자열을 나누면 ["""", ""abc"", ""def"", ""ghi""]가 됩니다. 각각의 길이로 배열을 만들면 [0, 3, 3, 3]입니다. 따라서 [0, 3, 3, 3]을 return 합니다.",easy,Array
114,"문자열 myString이 주어집니다. ""x""를 기준으로 해당 문자열을 잘라내 배열을 만든 후 사전순으로 정렬한 배열을 return 하는 solution 함수를 완성해 주세요. 단, 빈 문자열은 반환할 배열에 넣지 않습니다. 제한사항 1 ≤ myString ≤ 100,000 myString은 알파벳 소문자로 이루어진 문자열입니다. 입출력 예 myString result ""axbxcxdx"" [""a"",""b"",""c"",""d""] ""dxccxbbbxaaaa"" [""aaaa"",""bbb"",""cc"",""d""] 입출력 예 설명 입출력 예 #1 myString을 ""x""를 기준으로 자른 배열은 [""a"",""b"",""c"",""d""]이며, 이 배열은 이미 사전순으로 정렬된 상태입니다. 따라서 해당 배열을 return 합니다. 입출력 예 #2 myString을 ""x""를 기준으로 자른 배열은 [""d"",""cc"",""bbb"",""aaaa""]이며, 이 배열을 사전순으로 정렬하면 [""aaaa"",""bbb"",""cc"",""d""]입니다. 따라서 해당 배열을 return 합니다.",easy,Array
115,"문자열 binomial이 매개변수로 주어집니다. binomial은 ""a op b"" 형태의 이항식이고 a와 b는 음이 아닌 정수, op는 '+', '-', '*' 중 하나입니다. 주어진 식을 계산한 정수를 return 하는 solution 함수를 작성해 주세요. 제한사항 0 ≤ a, b ≤ 40,000 0을 제외하고 a, b는 0으로 시작하지 않습니다. 입출력 예 binomial result ""43 + 12"" 55 ""0 - 7777"" -7777 ""40000 * 40000"" 1600000000 입출력 예 설명 입출력 예 #1 예제 1번의 binomial은 ""43 + 12""로 이 식을 계산한 결과인 43 + 12 = 55를 return 합니다. 입출력 예 #2 예제 2번의 binomial은 ""0 - 7777""로 이 식을 계산한 결과인 0 - 7777 = -7777을 return 합니다. 입출력 예 #3 예제 3번의 binomial은 ""40000 * 40000""으로 이 식을 계산한 결과인 40000 × 40000 = 1600000000을 return 합니다.",easy,String
116,"문자 ""A""와 ""B""로 이루어진 문자열 myString과 pat가 주어집니다. myString의 ""A""를 ""B""로, ""B""를 ""A""로 바꾼 문자열의 연속하는 부분 문자열 중 pat이 있으면 1을 아니면 0을 return 하는 solution 함수를 완성하세요. 제한사항 1 ≤ myString의 길이 ≤ 100 1 ≤ pat의 길이 ≤ 10 myString과 pat는 문자 ""A""와 ""B""로만 이루어진 문자열입니다. 입출력 예 myString pat result ""ABBAA"" ""AABB"" 1 ""ABAB"" ""ABAB"" 0 입출력 예 설명 입출력 예 #1 ""ABBAA""에서 ""A""와 ""B""를 서로 바꾸면 ""BAABB""입니다. 여기에는 부분문자열 ""AABB""가 있기 때문에 1을 return 합니다. 입출력 예 #2 ""ABAB""에서 ""A""와 ""B""를 서로 바꾸면 ""BABA""입니다. 여기에는 부분문자열 ""BABA""가 없기 때문에 0을 return 합니다. ※ 2023년 05월 15일 제한사항 및 테스트 케이스가 수정되었습니다. 기존에 제출한 코드가 통과하지 못할 수 있습니다.",easy,String
117,"'m'과 ""rn""이 모양이 비슷하게 생긴 점을 활용해 문자열에 장난을 하려고 합니다. 문자열 rny_string이 주어질 때, rny_string의 모든 'm'을 ""rn""으로 바꾼 문자열을 return 하는 solution 함수를 작성해 주세요. 제한사항 1 ≤ rny_string의 길이 ≤ 100 rny_string은 영소문자로만 이루어져 있습니다. 입출력 예 rny_string result ""masterpiece"" ""rnasterpiece"" ""programmers"" ""prograrnrners"" ""jerry"" ""jerry"" ""burn"" ""burn"" 입출력 예 설명 입출력 예 #1 예제 1번의 rny_string의 'm'을 ""rn""으로 바꾸는 과정을 표로 나타내면 다음과 같습니다. rny_string m a s t e r p i e c e result rn a s t e r p i e c e 따라서 ""rnasterpiece""를 return 합니다. 입출력 예 #2 예제 2번의 rny_string의 'm'을 ""rn""으로 바꾸는 과정을 표로 나타내면 다음과 같습니다. rny_string p r o g r a m m e r s result p r o g r a rn rn e r s 따라서 ""prograrnrners""를 return 합니다. 입출력 예 #3 예제 3번의 rny_string에는 'm'이 없습니다. 따라서 rny_string 그대로인 ""jerry""를 return 합니다. 입출력 예 #4 예제 4번의 rny_string에는 'm'이 없습니다. 따라서 rny_string 그대로인 ""burn""를 return 합니다.",easy,String
118,"임의의 문자열이 주어졌을 때 문자 ""a"", ""b"", ""c""를 구분자로 사용해 문자열을 나누고자 합니다. 예를 들어 주어진 문자열이 ""baconlettucetomato""라면 나눠진 문자열 목록은 [""onlettu"", ""etom"", ""to""] 가 됩니다. 문자열 myStr이 주어졌을 때 위 예시와 같이 ""a"", ""b"", ""c""를 사용해 나눠진 문자열을 순서대로 저장한 배열을 return 하는 solution 함수를 완성해 주세요. 단, 두 구분자 사이에 다른 문자가 없을 경우에는 아무것도 저장하지 않으며, return할 배열이 빈 배열이라면 [""EMPTY""]를 return 합니다. 제한사항 1 ≤ myStr의 길이 ≤ 1,000,000 myStr은 알파벳 소문자로 이루어진 문자열 입니다. 입출력 예 myStr result ""baconlettucetomato"" [""onlettu"", ""etom"", ""to""] ""abcd"" [""d""] ""cabab"" [""EMPTY""] 입출력 예 설명 입출력 예 #1 문제 설명의 예시와 같습니다. 입출력 예 #2 ""c"" 이전에는 ""a"", ""b"", ""c"" 이외의 문자가 없습니다. ""c"" 이후에 문자열 ""d""가 있으므로 ""d""를 저장합니다. 따라서 [""d""]를 return 합니다. 입출력 예 #3 ""a"", ""b"", ""c"" 이외의 문자가 존재하지 않습니다. 따라서 저장할 문자열이 없습니다. 따라서 [""EMPTY""]를 return 합니다. ※ 공지 - 2024년 9월 9일 테스트케이스가 추가 되었습니다. 기존에 제출한 코드가 통과하지 못할 수도 있습니다.",easy,Array
119,"아무 원소도 들어있지 않은 빈 배열 X가 있습니다. 양의 정수 배열 arr가 매개변수로 주어질 때, arr의 앞에서부터 차례대로 원소를 보면서 원소가 a라면 X의 맨 뒤에 a를 a번 추가하는 일을 반복한 뒤의 배열 X를 return 하는 solution 함수를 작성해 주세요. 제한사항 1 ≤ arr의 길이 ≤ 100 1 ≤ arr의 원소 ≤ 100 입출력 예 arr result [5, 1, 4] [5, 5, 5, 5, 5, 1, 4, 4, 4, 4] [6, 6] [6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6] [1] [1] 입출력 예 설명 입출력 예 #1 예제 1번에 대해서 a와 X를 나타내보면 다음 표와 같습니다. a X [] 5 [5, 5, 5, 5, 5] 1 [5, 5, 5, 5, 5, 1] 4 [5, 5, 5, 5, 5, 1, 4, 4, 4, 4] 따라서 [5, 5, 5, 5, 5, 1, 4, 4, 4, 4]를 return 합니다. 입출력 예 #2 예제 2번에 대해서 a와 X를 나타내보면 다음 표와 같습니다. a X [] 6 [6, 6, 6, 6, 6, 6] 6 [6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6] 따라서 [6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6]를 return 합니다. 입출력 예 #3 예제 2번에 대해서 a와 X를 나타내보면 다음 표와 같습니다. a X [] 1 [1] 따라서 [1]을 return 합니다.",easy,Array
120,"아무 원소도 들어있지 않은 빈 배열 X가 있습니다. 길이가 같은 정수 배열 arr과 boolean 배열 flag가 매개변수로 주어질 때, flag를 차례대로 순회하며 flag[i]가 true라면 X의 뒤에 arr[i]를 arr[i] × 2 번 추가하고, flag[i]가 false라면 X에서 마지막 arr[i]개의 원소를 제거한 뒤 X를 return 하는 solution 함수를 작성해 주세요. 제한사항 1 ≤ arr의 길이 = flag의 길이 ≤ 100 arr의 모든 원소는 1 이상 9 이하의 정수입니다. 현재 X의 길이보다 더 많은 원소를 빼는 입력은 주어지지 않습니다. 입출력 예 arr flag result [3, 2, 4, 1, 3] [true, false, true, false, false] [3, 3, 3, 3, 4, 4, 4, 4] 입출력 예 설명 입출력 예 #1 예제 1번에서 X의 변화를 표로 나타내면 다음과 같습니다 i flag[i] arr[i] X [] 0 true 3 [3, 3, 3, 3, 3, 3] 1 false 2 [3, 3, 3, 3] 2 true 4 [3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4] 3 false 1 [3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4] 4 false 3 [3, 3, 3, 3, 4, 4, 4, 4] 따라서 [3, 3, 3, 3, 4, 4, 4, 4]를 return 합니다.",easy,Array
121,"0과 1로만 이루어진 정수 배열 arr가 주어집니다. arr를 이용해 새로운 배열 stk을 만드려고 합니다. i의 초기값을 0으로 설정하고 i가 arr의 길이보다 작으면 다음을 반복합니다. 만약 stk이 빈 배열이라면 arr[i]를 stk에 추가하고 i에 1을 더합니다. stk에 원소가 있고, stk의 마지막 원소가 arr[i]와 같으면 stk의 마지막 원소를 stk에서 제거하고 i에 1을 더합니다. stk에 원소가 있는데 stk의 마지막 원소가 arr[i]와 다르면 stk의 맨 마지막에 arr[i]를 추가하고 i에 1을 더합니다. 위 작업을 마친 후 만들어진 stk을 return 하는 solution 함수를 완성해 주세요. 단, 만약 빈 배열을 return 해야한다면 [-1]을 return 합니다. 제한사항 1 ≤ arr의 길이 ≤ 1,000,000 arr의 원소는 0 또는 1 입니다. 입출력 예 arr result [0, 1, 1, 1, 0] [0, 1, 0] [0, 1, 0, 1, 0] [0, 1, 0, 1, 0] [0, 1, 1, 0] [-1] 입출력 예 설명 입출력 예 #1 각 작업을 마친 후에 배열의 변화를 나타내면 다음 표와 같습니다. idx arr[idx] stk 0 0 [] 1 1 [0] 2 1 [0, 1] 3 1 [0] 4 0 [0, 1] 5 - [0, 1, 0] 따라서 [0, 1, 0]을 return 합니다. 입출력 예 #2 각 작업을 마친 후에 배열의 변화를 나타내면 다음 표와 같습니다. idx arr[idx] stk 0 0 [] 1 1 [0] 2 0 [0, 1] 3 1 [0, 1, 0] 4 0 [0, 1, 0, 1] 5 - [0, 1, 0, 1, 0] 따라서 [0, 1, 0, 1, 0]을 return 합니다. 입출력 예 #3 각 작업을 마친 후에 배열의 변화를 나타내면 다음 표와 같습니다. idx arr[idx] stk 0 0 [] 1 1 [0] 2 1 [0, 1] 3 0 [0] 4 - [] 마지막에 빈 배열이 되었으므로 [-1]을 return 합니다. ※ 2023년 04월 27일 지문이 수정되었습니다.",easy,Array
122,"랜덤으로 서로 다른 k개의 수를 저장한 배열을 만드려고 합니다. 적절한 방법이 떠오르지 않기 때문에 일정한 범위 내에서 무작위로 수를 뽑은 후, 지금까지 나온적이 없는 수이면 배열 맨 뒤에 추가하는 방식으로 만들기로 합니다. 이미 어떤 수가 무작위로 주어질지 알고 있다고 가정하고, 실제 만들어질 길이 k의 배열을 예상해봅시다. 정수 배열 arr가 주어집니다. 문제에서의 무작위의 수는 arr에 저장된 순서대로 주어질 예정이라고 했을 때, 완성될 배열을 return 하는 solution 함수를 완성해 주세요. 단, 완성될 배열의 길이가 k보다 작으면 나머지 값을 전부 -1로 채워서 return 합니다. 제한사항 1 ≤ arr의 길이 ≤ 100,000 0 ≤ arr의 원소 ≤ 100,000 1 ≤ k ≤ 1,000 입출력 예 arr k result [0, 1, 1, 2, 2, 3] 3 [0, 1, 2] [0, 1, 1, 1, 1] 4 [0, 1, -1, -1] 입출력 예 설명 입출력 예 #1 앞에서부터 서로 다른 k개의 수를 골라내면 [0, 1, 2]가 됩니다. 따라서 [0, 1, 2]를 return 합니다. 입출력 예 #2 서로 다른 수의 개수가 2개 뿐이므로 서로 다른 수들을 앞에서부터 차례대로 저장한 [0, 1]에서 이후 2개의 인덱스를 -1로 채워넣은 [0, 1, -1, -1]을 return 합니다.",easy,Array
123,"정수 배열 arr이 매개변수로 주어집니다. arr의 길이가 2의 정수 거듭제곱이 되도록 arr 뒤에 정수 0을 추가하려고 합니다. arr에 최소한의 개수로 0을 추가한 배열을 return 하는 solution 함수를 작성해 주세요. 제한사항 1 ≤ arr의 길이 ≤ 1,000 1 ≤ arr의 원소 ≤ 1,000 입출력 예 arr result [1, 2, 3, 4, 5, 6] [1, 2, 3, 4, 5, 6, 0, 0] [58, 172, 746, 89] [58, 172, 746, 89] 입출력 예 설명 입출력 예 #1 예제 1번의 arr의 길이는 6입니다. arr의 길이를 2의 정수 거듭제곱으로 만드는 방법은 0을 2개, 10개, 26개,..., 추가하는 방법이 있고 그중 최소한으로 0을 추가하는 방법은 2개를 추가하는 것입니다. 따라서 [1, 2, 3, 4, 5, 6, 0, 0]을 return 합니다. 입출력 예 #2 예제 2번의 arr의 길이는 4이고 이미 2의 정수 거듭제곱입니다. 따라서 뒤에 0을 추가하지 않아도 되므로 [58, 172, 746, 89]를 return 합니다.",easy,Array
124,"이 문제에서 두 정수 배열의 대소관계를 다음과 같이 정의합니다. 두 배열의 길이가 다르다면, 배열의 길이가 긴 쪽이 더 큽니다. 배열의 길이가 같다면 각 배열에 있는 모든 원소의 합을 비교하여 다르다면 더 큰 쪽이 크고, 같다면 같습니다. 두 정수 배열 arr1과 arr2가 주어질 때, 위에서 정의한 배열의 대소관계에 대하여 arr2가 크다면 -1, arr1이 크다면 1, 두 배열이 같다면 0을 return 하는 solution 함수를 작성해 주세요. 제한사항 1 ≤ arr1의 길이 ≤ 100 1 ≤ arr2의 길이 ≤ 100 1 ≤ arr1의 원소 ≤ 100 1 ≤ arr2의 원소 ≤ 100 문제에서 정의한 배열의 대소관계가 일반적인 프로그래밍 언어에서 정의된 배열의 대소관계와 다를 수 있는 점에 유의해주세요. 입출력 예 arr1 arr2 result [49, 13] [70, 11, 2] -1 [100, 17, 84, 1] [55, 12, 65, 36] 1 [1, 2, 3, 4, 5] [3, 3, 3, 3, 3] 0 입출력 예 설명 입출력 예 #1 예제 1번에서는 arr1의 길이는 2이고 arr2의 길이는 3으로 arr2의 길이가 더 깁니다. 따라서 arr2가 arr1보다 크므로 -1을 return 합니다. 입출력 예 #2 예제 2번에서는 arr1의 길이과 arr2의 길이가 4로 같습니다. arr1의 모든 원소의 합은 100 + 17 + 84 + 1 = 202이고 arr2의 모든 원소의 합은 55 + 12 + 65 + 36 = 168으로 arr1의 모든 원소의 합이 더 큽니다. 따라서 arr1이 arr2보다 크므로 1을 return 합니다. 입출력 예 #3 예제 3번에서는 arr1의 길이와 arr2의 길이가 5로 같고 각 배열의 모든 원소의 합 또한 15로 같습니다. 따라서 arr1과 arr2가 같으므로 0을 return 합니다. ※ 공지 - 2023년 4월 21일 테스트케이스가 추가되었습니다. 기존에 제출한 코드가 통과하지 못할 수도 있습니다.",easy,Array
125,"문자열 배열 strArr이 주어집니다. strArr의 원소들을 길이가 같은 문자열들끼리 그룹으로 묶었을 때 가장 개수가 많은 그룹의 크기를 return 하는 solution 함수를 완성해 주세요. 제한사항 1 ≤ strArr의 길이 ≤ 100,000 1 ≤ strArr의 원소의 길이 ≤ 30 strArr의 원소들은 알파벳 소문자로 이루어진 문자열입니다. 입출력 예 strArr result [""a"",""bc"",""d"",""efg"",""hi""] 2 입출력 예 설명 입출력 예 #1 각 문자열들을 길이에 맞게 그룹으로 묶으면 다음과 같습니다. 문자열 길이 문자열 목록 개수 1 [""a"",""d""] 2 2 [""bc"",""hi""] 2 3 [""efg""] 1 개수의 최댓값은 2이므로 2를 return 합니다.",easy,Array
126,"정수 배열 arr과 정수 n이 매개변수로 주어집니다. arr의 길이가 홀수라면 arr의 모든 짝수 인덱스 위치에 n을 더한 배열을, arr의 길이가 짝수라면 arr의 모든 홀수 인덱스 위치에 n을 더한 배열을 return 하는 solution 함수를 작성해 주세요. 제한사항 1 ≤ arr의 길이 ≤ 1,000 1 ≤ arr의 원소 ≤ 1,000 1 ≤ n ≤ 1,000 입출력 예 arr n result [49, 12, 100, 276, 33] 27 [76, 12, 127, 276, 60] [444, 555, 666, 777] 100 [444, 655, 666, 877] 입출력 예 설명 입출력 예 #1 예제 1번의 arr의 길이는 5로 홀수입니다. 따라서 arr의 짝수 인덱스 0, 2, 4에 주어진 n 값인 27을 더하면 [76, 12, 127, 276, 60]이 됩니다. 따라서 [76, 12, 127, 276, 60]를 return 합니다. 입출력 예 #1 예제 2번의 arr의 길이는 4로 짝수입니다. 따라서 arr의 홀수 인덱스 1, 3에 주어진 n 값인 100을 더하면 [444, 655, 666, 877]이 됩니다. 따라서 [444, 655, 666, 877]를 return 합니다.",easy,Array
127,"정수로 이루어진 리스트 num_list가 주어집니다. num_list에서 가장 작은 5개의 수를 오름차순으로 담은 리스트를 return하도록 solution 함수를 완성해주세요. 제한사항 6 ≤ num_list의 길이 ≤ 30 1 ≤ num_list의 원소 ≤ 100 입출력 예 num_list result [12, 4, 15, 46, 38, 1, 14] [1, 4, 12, 14, 15] 입출력 예 설명 입출력 예 #1 [12, 4, 15, 46, 38, 1, 14]를 정렬하면 [1, 4, 12, 14, 15, 38, 46]이 되고, 앞에서 부터 5개를 고르면 [1, 4, 12, 14, 15]가 됩니다.",easy,Array
128,"정수로 이루어진 리스트 num_list가 주어집니다. num_list에서 가장 작은 5개의 수를 제외한 수들을 오름차순으로 담은 리스트를 return하도록 solution 함수를 완성해주세요. 제한사항 6 ≤ num_list의 길이 ≤ 30 1 ≤ num_list의 원소 ≤ 100 입출력 예 num_list result [12, 4, 15, 46, 38, 1, 14, 56, 32, 10] [15, 32, 38, 46, 56] 입출력 예 설명 입출력 예 #1 [12, 4, 15, 46, 38, 1, 14, 56, 32, 10]를 정렬하면 [1, 4, 10, 12, 14, 15, 32, 38, 46, 56]이 되고, 앞에서 부터 6번째 이후의 수들을 고르면 [15, 32, 38, 46, 56]가 됩니다.",easy,Array
129,"0번부터 n - 1번까지 n명의 학생 중 3명을 선발하는 전국 대회 선발 고사를 보았습니다. 등수가 높은 3명을 선발해야 하지만, 개인 사정으로 전국 대회에 참여하지 못하는 학생들이 있어 참여가 가능한 학생 중 등수가 높은 3명을 선발하기로 했습니다. 각 학생들의 선발 고사 등수를 담은 정수 배열 rank와 전국 대회 참여 가능 여부가 담긴 boolean 배열 attendance가 매개변수로 주어집니다. 전국 대회에 선발된 학생 번호들을 등수가 높은 순서대로 각각 a, b, c번이라고 할 때 10000 × a + 100 × b + c를 return 하는 solution 함수를 작성해 주세요. 제한사항 3 ≤ rank의 길이 = attendance의 길이 ≤ 100 rank[i]는 i번 학생의 선발 고사 등수를 의미합니다. rank의 원소는 1부터 n까지의 정수로 모두 서로 다릅니다. attendance[i]는 i번 학생의 전국 대회 참석 가능 여부를 나타냅니다. attendance[i]가 true라면 참석 가능, false면 참석 불가능을 의미합니다. attendance의 원소 중 적어도 3개는 true입니다. 입출력 예 rank attendance result [3, 7, 2, 5, 4, 6, 1] [false, true, true, true, true, false, false] 20403 [1, 2, 3] [true, true, true] 102 [6, 1, 5, 2, 3, 4] [true, false, true, false, false, true] 50200 입출력 예 설명 입출력 예 #1 예제 1번에서 1등은 6번 학생이지만 전국 대회에 참석 불가능하므로 넘어갑니다. 2등은 2번 학생이고 전국 대회에 참석 가능하므로 1순위로 선발됩니다. 3등은 0번 학생이고 전국 대회에 참석 불가능 하므로 넘어갑니다. 4등과 5등은 각각 4번, 3번 학생이고 두 학생 모두 전국 대회에 참석 가능하므로 각각 2순위, 3순위로 선발됩니다. 3명을 선발하였으므로 6등과 7등은 확인하지 않아도 됩니다. 따라서 10000 × 2 + 100 × 4 + 3 = 20403을 return 합니다. 입출력 예 #2 예제 2번에서 1, 2, 3등은 각각 0번, 1번, 2번 학생이고 세 학생 모두 전국 대회에 참석 가능하므로 각각 1순위, 2순위, 3순위로 선발됩니다. 따라서 10000 × 0 + 100 × 1 + 2 = 102를 return 합니다. 입출력 예 #3 예제 3번에서 1, 2, 3등은 각각 1번, 3번, 4번 학생이지만 세 학생 모두 전국 대회에 참석 불가능합니다. 다음으로 4, 5, 6등은 각각 5번, 2번, 0번 학생이고 세 학생 모두 전국 대회에 참석 가능하므로 각각 1순위, 2순위, 3순위로 선발됩니다. 따라서 10000 × 5 + 100 × 2 + 0 = 50200을 return 합니다.",easy,Array
130,"실수 flo가 매개 변수로 주어질 때, flo의 정수 부분을 return하도록 solution 함수를 완성해주세요. 제한사항 0 ≤ flo ≤ 100 입출력 예 flo result 1.42 1 69.32 69 입출력 예 설명 입출력 예 #1 1.42의 정수 부분은 1입니다. 입출력 예 #2 69.32의 정수 부분은 69입니다.",easy,Design
131,"한 자리 정수로 이루어진 문자열 num_str이 주어질 때, 각 자리수의 합을 return하도록 solution 함수를 완성해주세요. 제한사항 3 ≤ num_str ≤ 100 입출력 예 num_str result ""123456789"" 45 ""1000000"" 1 입출력 예 설명 입출력 예 #1 문자열 안의 모든 숫자를 더하면 45가 됩니다. 입출력 예 #2 문자열 안의 모든 숫자를 더하면 1이 됩니다.",easy,String
132,"숫자로만 이루어진 문자열 n_str이 주어질 때, n_str을 정수로 변환하여 return하도록 solution 함수를 완성해주세요. 제한사항 1 ≤ n_str ≤ 5 n_str은 0부터 9까지의 정수 문자로만 이루어져 있습니다. 입출력 예 n_str result ""10"" 10 ""8542"" 8542 입출력 예 설명 입출력 예 #1 ""10""을 정수로 바꾸면 10입니다. 입출력 예 #2 ""8542""를 정수로 바꾸면 8542입니다.",easy,String
133,"정수로 이루어진 문자열 n_str이 주어질 때, n_str의 가장 왼쪽에 처음으로 등장하는 0들을 뗀 문자열을 return하도록 solution 함수를 완성해주세요. 제한사항 2 ≤ n_str ≤ 10 n_str이 ""0""으로만 이루어진 경우는 없습니다. 입출력 예 n_str result ""0010"" ""10"" ""854020"" ""854020"" 입출력 예 설명 입출력 예 #1 ""0010""의 가장 왼쪽에 연속으로 등장하는 ""0""을 모두 제거하면 ""10""이 됩니다. 입출력 예 #2 ""854020""는 가장 왼쪽에 0이 없으므로 ""854020""을 return합니다.",easy,String
134,"0 이상의 두 정수가 문자열 a, b로 주어질 때, a + b의 값을 문자열로 return 하는 solution 함수를 작성해 주세요. 제한사항 1 ≤ a의 길이 ≤ 100,000 1 ≤ b의 길이 ≤ 100,000 a와 b는 숫자로만 이루어져 있습니다. a와 b는 정수 0이 아니라면 0으로 시작하지 않습니다. 입출력 예 a b result ""582"" ""734"" ""1316"" ""18446744073709551615"" ""287346502836570928366"" ""305793246910280479981"" ""0"" ""0"" ""0"" 입출력 예 설명 입출력 예 #1 예제 1번의 a, b는 각각 582, 734이고 582 + 734 = 1316입니다. 따라서 ""1316""을 return 합니다. 입출력 예 #2 예제 2번의 a, b는 각각 18446744073709551615, 287346502836570928366이고 18446744073709551615 + 287346502836570928366 = 305793246910280479981입니다. 따라서 ""305793246910280479981""을 return 합니다. 입출력 예 #3 예제 3번의 a, b는 각각 0, 0이고 0 + 0 = 0입니다. 따라서 ""0""을 return 합니다.",easy,String
135,"정수 n이 주어질 때, n을 문자열로 변환하여 return하도록 solution 함수를 완성해주세요. 제한사항 1 ≤ n ≤ 10000 입출력 예 n result 123 ""123"" 2573 ""2573"" 입출력 예 설명 입출력 예 #1 123을 문자열로 변환한 ""123""을 return합니다. 입출력 예 #2 2573을 문자열로 변환한 ""2573""을 return합니다.",easy,String
136,"정수 배열 arr과 delete_list가 있습니다. arr의 원소 중 delete_list의 원소를 모두 삭제하고 남은 원소들은 기존의 arr에 있던 순서를 유지한 배열을 return 하는 solution 함수를 작성해 주세요. 제한사항 1 ≤ arr의 길이 ≤ 100 1 ≤ arr의 원소 ≤ 1,000 arr의 원소는 모두 서로 다릅니다. 1 ≤ delete_list의 길이 ≤ 100 1 ≤ delete_list의 원소 ≤ 1,000 delete_list의 원소는 모두 서로 다릅니다. 입출력 예 arr delete_list result [293, 1000, 395, 678, 94] [94, 777, 104, 1000, 1, 12] [293, 395, 678] [110, 66, 439, 785, 1] [377, 823, 119, 43] [110, 66, 439, 785, 1] 입출력 예 설명 입출력 예 #1 예제 1번의 arr의 원소 중 1000과 94가 delete_list에 있으므로 이 두 원소를 삭제한 [293, 395, 678]을 return 합니다. 입출력 예 #2 예제 2번의 arr의 원소 중 delete_list에 있는 원소는 없습니다. 따라서 arr 그대로인 [110, 66, 439, 785, 1]을 return 합니다.",easy,Array
137,"부분 문자열이란 문자열에서 연속된 일부분에 해당하는 문자열을 의미합니다. 예를 들어, 문자열 ""ana"", ""ban"", ""anana"", ""banana"", ""n""는 모두 문자열 ""banana""의 부분 문자열이지만, ""aaa"", ""bnana"", ""wxyz""는 모두 ""banana""의 부분 문자열이 아닙니다. 문자열 my_string과 target이 매개변수로 주어질 때, target이 문자열 my_string의 부분 문자열이라면 1을, 아니라면 0을 return 하는 solution 함수를 작성해 주세요. 제한사항 1 ≤ my_string의 길이 ≤ 100 my_string은 영소문자로만 이루어져 있습니다. 1 ≤ target의 길이 ≤ 100 target은 영소문자로만 이루어져 있습니다. 입출력 예 my_string target result ""banana"" ""ana"" 1 ""banana"" ""wxyz"" 0 입출력 예 설명 입출력 예 #1 문제 설명과 같습니다. 입출력 예 #2 문제 설명과 같습니다.",easy,String
138,"어떤 문자열 A가 다른 문자열 B안에 속하면 A를 B의 부분 문자열이라고 합니다. 예를 들어 문자열 ""abc""는 문자열 ""aabcc""의 부분 문자열입니다. 문자열 str1과 str2가 주어질 때, str1이 str2의 부분 문자열이라면 1을 부분 문자열이 아니라면 0을 return하도록 solution 함수를 완성해주세요. 제한 사항 1 ≤ str1 ≤ str2 ≤ 20 str1과 str2는 영어 소문자로만 이루어져 있습니다. 입출력 예 str1 str2 result ""abc"" ""aabcc"" 1 ""tbt"" ""tbbttb"" 0 입출력 예 설명 입출력 예 #1 본문과 동일합니다. 입출력 예 #2 ""tbbttb""에는 ""tbt""가 없으므로 0을 return합니다.",easy,String
139,"문자열들이 담긴 리스트가 주어졌을 때, 모든 문자열들을 순서대로 합친 문자열을 꼬리 문자열이라고 합니다. 꼬리 문자열을 만들 때 특정 문자열을 포함한 문자열은 제외시키려고 합니다. 예를 들어 문자열 리스트 [""abc"", ""def"", ""ghi""]가 있고 문자열 ""ef""를 포함한 문자열은 제외하고 꼬리 문자열을 만들면 ""abcghi""가 됩니다. 문자열 리스트 str_list와 제외하려는 문자열 ex가 주어질 때, str_list에서 ex를 포함한 문자열을 제외하고 만든 꼬리 문자열을 return하도록 solution 함수를 완성해주세요. 제한사항 2 ≤ str_list의 길이 ≤ 10 1 ≤ str_list의 원소의 길이 ≤ 10 1 ≤ ex의 길이 ≤ 5 입출력 예 str_list ex result [""abc"", ""def"", ""ghi""] ""ef"" ""abcghi"" [""abc"", ""bbc"", ""cbc""] ""c"" """" 입출력 예 설명 입출력 예 #1 본문과 동일합니다. 입출력 예 #2 리스트 안의 모든 문자열이 ""c""를 포함하므로 빈 문자열을 return합니다.",easy,Array
140,"정수 리스트 num_list와 찾으려는 정수 n이 주어질 때, num_list안에 n이 있으면 1을 없으면 0을 return하도록 solution 함수를 완성해주세요. 제한사항 3 ≤ num_list의 길이 ≤ 100 1 ≤ num_list의 원소 ≤ 100 1 ≤ n ≤ 100 입출력 예 num_list n result [1, 2, 3, 4, 5] 3 1 [15, 98, 23, 2, 15] 20 0 입출력 예 설명 입출력 예 #1 [1, 2, 3, 4, 5] 안에 3이 있으므로 1을 return합니다. 입출력 예 #2 [15, 98, 23, 2, 15] 안에 20이 없으므로 0을 return합니다.",easy,Array
141,"1부터 6까지 숫자가 적힌 주사위가 두 개 있습니다. 두 주사위를 굴렸을 때 나온 숫자를 각각 a, b라고 했을 때 얻는 점수는 다음과 같습니다. a와 b가 모두 홀수라면 a2 + b2 점을 얻습니다. a와 b 중 하나만 홀수라면 2 × (a + b) 점을 얻습니다. a와 b 모두 홀수가 아니라면 |a - b| 점을 얻습니다. 두 정수 a와 b가 매개변수로 주어질 때, 얻는 점수를 return 하는 solution 함수를 작성해 주세요. 제한사항 a와 b는 1 이상 6 이하의 정수입니다. 입출력 예 a b result 3 5 34 6 1 14 2 4 2 입출력 예 설명 입출력 예 #1 예제 1번에서 두 주사위 숫자가 모두 홀수이므로 32 + 52 = 9 + 25 = 34점을 얻습니다. 따라서 34를 return 합니다. 입출력 예 #2 예제 2번에서 두 주사위 숫자 중 하나만 홀수이므로 2 × (6 + 1) = 2 × 7 = 14점을 얻습니다. 따라서 14를 return 합니다. 입출력 예 #3 예제 3번에서 두 주사위 숫자가 모두 홀수가 아니므로 |2 - 4| = |-2| = 2점을 얻습니다. 따라서 2를 return 합니다.",easy,Math
142,"정수 배열 date1과 date2가 주어집니다. 두 배열은 각각 날짜를 나타내며 [year, month, day] 꼴로 주어집니다. 각 배열에서 year는 연도를, month는 월을, day는 날짜를 나타냅니다. 만약 date1이 date2보다 앞서는 날짜라면 1을, 아니면 0을 return 하는 solution 함수를 완성해 주세요. 제한사항 date1의 길이 = date2의 길이 = 3 0 ≤ year ≤ 10,000 1 ≤ month ≤ 12 day는 month에 따라 가능한 날짜로 주어집니다. 입출력 예 date1 date2 result [2021, 12, 28] [2021, 12, 29] 1 [1024, 10, 24] [1024, 10, 24] 0 입출력 예 설명 입출력 예 #1 date1이 date2보다 하루 앞서기 때문에 1을 return 합니다. 입출력 예 #2 date1과 date2는 날짜가 서로 같으므로 date1이 더 앞서는 날짜가 아닙니다. 따라서 0을 return 합니다.",easy,Array
143,"팀의 막내인 철수는 아메리카노와 카페 라테만 판매하는 카페에서 팀원들의 커피를 사려고 합니다. 아메리카노와 카페 라테의 가격은 차가운 것과 뜨거운 것 상관없이 각각 4500, 5000원입니다. 각 팀원에게 마실 메뉴를 적어달라고 하였고, 그 중에서 메뉴만 적은 팀원의 것은 차가운 것으로 통일하고 ""아무거나""를 적은 팀원의 것은 차가운 아메리카노로 통일하기로 하였습니다. 각 직원이 적은 메뉴가 문자열 배열 order로 주어질 때, 카페에서 결제하게 될 금액을 return 하는 solution 함수를 작성해주세요. order의 원소는 아래의 것들만 들어오고, 각각의 의미는 다음과 같습니다. order의 원소 의미 ""iceamericano"", ""americanoice"" 차가운 아메리카노 ""hotamericano"", ""americanohot"" 따뜻한 아메리카노 ""icecafelatte"", ""cafelatteice"" 차가운 카페 라테 ""hotcafelatte"", ""cafelattehot"" 따뜻한 카페 라테 ""americano"" 아메리카노 ""cafelatte"" 카페 라테 ""anything"" 아무거나 제한사항 1 ≤ order의 길이 ≤ 1,000 입출력 예 order result [""cafelatte"", ""americanoice"", ""hotcafelatte"", ""anything""] 19000 [""americanoice"", ""americano"", ""iceamericano""] 13500 입출력 예 설명 입출력 예 #1 예제 1번의 입력을 표로 나타내면 다음과 같습니다. order[i] 팀원의 적은 음료 실제 주문 음료 ""cafelatte"" 카페 라테 차가운 카페 라테 ""americanoice"" 차가운 아메리카노 차가운 아메리카노 ""hotcafelatte"" 따뜻한 카페 라테 따뜻한 카페 라테 ""anything"" 아무거나 차가운 아메리카노 철수는 차가운 아메리카노 2잔, 차가운 카페 라테 1잔, 따뜻한 카페 라테 1잔을 주문하게 되므로 결제 금액은 4500 &times; 2 + 5000 &times; 2 = 19000원입니다. 따라서 19000을 return 합니다. 입출력 예 #2 예제 2번의 입력에서는 모든 음료를 차가운 아메리카노로 시키게 됩니다. 따라서 결제 금액은 4500 × 3 = 13500원이고 13500을 return 합니다.",easy,Array
144,"직사각형 형태의 그림 파일이 있고, 이 그림 파일은 1 × 1 크기의 정사각형 크기의 픽셀로 이루어져 있습니다. 이 그림 파일을 나타낸 문자열 배열 picture과 정수 k가 매개변수로 주어질 때, 이 그림 파일을 가로 세로로 k배 늘린 그림 파일을 나타내도록 문자열 배열을 return 하는 solution 함수를 작성해 주세요. 제한사항 1 ≤ picture의 길이 ≤ 20 1 ≤ picture의 원소의 길이 ≤ 20 모든 picture의 원소의 길이는 같습니다. picture의 원소는 '.'과 'x'로 이루어져 있습니다. 1 ≤ k ≤ 10 입출력 예 picture k result ["".xx...xx."", ""x..x.x..x"", ""x...x...x"", "".x.....x."", ""..x...x.."", ""...x.x..."", ""....x....""] 2 [""..xxxx......xxxx.."", ""..xxxx......xxxx.."", ""xx....xx..xx....xx"", ""xx....xx..xx....xx"", ""xx......xx......xx"", ""xx......xx......xx"", ""..xx..........xx.."", ""..xx..........xx.."", ""....xx......xx...."", ""....xx......xx...."", ""......xx..xx......"", ""......xx..xx......"", ""........xx........"", ""........xx........""] [""x.x"", "".x."", ""x.x""] 3 [""xxx...xxx"", ""xxx...xxx"", ""xxx...xxx"", ""...xxx..."", ""...xxx..."", ""...xxx..."", ""xxx...xxx"", ""xxx...xxx"", ""xxx...xxx""] 입출력 예 설명 입출력 예 #1 예제 1번의 picture는 다음과 같습니다. .xx...xx. x..x.x..x x...x...x .x.....x. ..x...x.. ...x.x... ....x.... 이를 가로 세로로 k배, 즉 2배 확대하면 그림 파일은 다음과 같습니다. ..xxxx......xxxx.. ..xxxx......xxxx.. xx....xx..xx....xx xx....xx..xx....xx xx......xx......xx xx......xx......xx ..xx..........xx.. ..xx..........xx.. ....xx......xx.... ....xx......xx.... ......xx..xx...... ......xx..xx...... ........xx........ ........xx........ 따라서 [""..xxxx......xxxx.."", ""..xxxx......xxxx.."", ""xx....xx..xx....xx"", ""xx....xx..xx....xx"", ""xx......xx......xx"", ""xx......xx......xx"", ""..xx..........xx.."", ""..xx..........xx.."", ""....xx......xx...."", ""....xx......xx...."", ""......xx..xx......"", ""......xx..xx......"", ""........xx........"", ""........xx........""]를 return 합니다. 입출력 예 #2 예제 2번의 picture는 다음과 같습니다. x.x .x. x.x 이를 가로 세로로 k배, 즉 3배 확대하면 그림 파일은 다음과 같습니다. xxx...xxx xxx...xxx xxx...xxx ...xxx... ...xxx... ...xxx... xxx...xxx xxx...xxx xxx...xxx 따라서 [""xxx...xxx"", ""xxx...xxx"", ""xxx...xxx"", ""...xxx..."", ""...xxx..."", ""...xxx..."", ""xxx...xxx"", ""xxx...xxx"", ""xxx...xxx""]를 return 합니다.",easy,Array
145,"정수 배열 arr와 자연수 k가 주어집니다. 만약 k가 홀수라면 arr의 모든 원소에 k를 곱하고, k가 짝수라면 arr의 모든 원소에 k를 더합니다. 이러한 변환을 마친 후의 arr를 return 하는 solution 함수를 완성해 주세요. 제한사항 1 ≤ arr의 길이 ≤ 1,000,000 1 ≤ arr의 원소의 값 ≤ 100 1 ≤ k ≤ 100 입출력 예 arr k result [1, 2, 3, 100, 99, 98] 3 [3, 6, 9, 300, 297, 294] [1, 2, 3, 100, 99, 98] 2 [3, 4, 5, 102, 101, 100] 입출력 예 설명 입출력 예 #1 주어진 k인 3은 홀수이므로, 전체 배열에 3을 곱합니다. 따라서 [3, 6, 9, 300, 297, 294]을 return 합니다. 입출력 예 #2 주어진 k인 2는 짝수이므로, 전체 배열에 2를 더합니다. 따라서 [3, 4, 5, 102, 101, 100]을 return 합니다.",easy,Array
146,"알파벳 소문자로 이루어진 문자열 myString이 주어집니다. 알파벳 순서에서 ""l""보다 앞서는 모든 문자를 ""l""로 바꾼 문자열을 return 하는 solution 함수를 완성해 주세요. 제한사항 1 ≤ myString ≤ 100,000 myString은 알파벳 소문자로 이루어진 문자열입니다. 입출력 예 myString result ""abcdevwxyz"" ""lllllvwxyz"" ""jjnnllkkmm"" ""llnnllllmm"" 입출력 예 설명 입출력 예 #1 0 ~ 4번 인덱스의 문자 ""a"",""b"",""c"",""d"",""e""는 각각 ""l""보다 앞서는 문자입니다. 따라서 ""l""로 고쳐줍니다. 그 외의 문자는 모두 ""l""보다 앞서지 않는 문자입니다. 따라서 바꾸지 않습니다. 따라서 ""lllllvwxyz""을 return 합니다. 입출력 예 #2 0번, 1번, 6번, 7번 인덱스의 문자 ""j"",""j"",""k"",""k""는 각각 ""l""보다 앞서는 문자입니다. 따라서 ""l""로 고쳐줍니다. 그 외의 문자는 모두 ""l""보다 앞서지 않는 문자입니다. 따라서 바꾸지 않습니다. 따라서 ""llnnllllmm""을 return 합니다.",easy,Array
147,"정수 n이 매개변수로 주어질 때, 다음과 같은 n × n 크기의 이차원 배열 arr를 return 하는 solution 함수를 작성해 주세요. arr[i][j] (0 ≤ i, j < n)의 값은 i = j라면 1, 아니라면 0입니다. 제한사항 1 ≤ n ≤ 100 입출력 예 n result 3 [[1, 0, 0], [0, 1, 0], [0, 0, 1]] 6 [[1, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0], [0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 1]] 1 [[1]] 입출력 예 설명 입출력 예 #1 예제 1번의 n의 값은 3으로 다음과 같이 2차원 배열을 채울 수 있습니다. i \ j 0 1 2 0 1 0 0 1 0 1 0 2 0 0 1 따라서 [[1, 0, 0], [0, 1, 0], [0, 0, 1]]을 return 합니다. 입출력 예 #2 예제 2번의 n의 값은 6으로 다음과 같이 2차원 배열을 채울 수 있습니다. i \ j 0 1 2 3 4 5 0 1 0 0 0 0 0 1 0 1 0 0 0 0 2 0 0 1 0 0 0 3 0 0 0 1 0 0 4 0 0 0 0 1 0 5 0 0 0 0 0 1 따라서 [[1, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0], [0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 1]]을 return 합니다. 입출력 예 #3 예제 1번의 n의 값은 1이고 다음과 같이 2차원 배열을 채울 수 있습니다. i \ j 0 0 1 따라서 [[1]]을 return 합니다.",easy,Array
148,"양의 정수 n이 매개변수로 주어집니다. n × n 배열에 1부터 n2 까지 정수를 인덱스 [0][0]부터 시계방향 나선형으로 배치한 이차원 배열을 return 하는 solution 함수를 작성해 주세요. 제한사항 1 ≤ n ≤ 30 입출력 예 n result 4 [[1, 2, 3, 4], [12, 13, 14, 5], [11, 16, 15, 6], [10, 9, 8, 7]] 5 [[1, 2, 3, 4, 5], [16, 17, 18, 19, 6], [15, 24, 25, 20, 7], [14, 23, 22, 21, 8], [13, 12, 11, 10, 9]] 입출력 예 설명 입출력 예 #1 예제 1번의 n의 값은 4로 4 × 4 배열에 다음과 같이 1부터 16까지 숫자를 채울 수 있습니다. 행 \ 열 0 1 2 3 0 1 2 3 4 1 12 13 14 5 2 11 16 15 6 3 10 9 8 7 따라서 [[1, 2, 3, 4], [12, 13, 14, 5], [11, 16, 15, 6], [10, 9, 8, 7]]를 return 합니다. 입출력 예 #2 예제 2번의 n의 값은 5로 5 × 5 배열에 다음과 같이 1부터 25까지 숫자를 채울 수 있습니다. 행 \ 열 0 1 2 3 4 0 1 2 3 4 5 1 16 17 18 19 6 2 15 24 25 20 7 3 14 23 22 21 8 4 13 12 11 10 9 따라서 [[1, 2, 3, 4, 5], [16, 17, 18, 19, 6], [15, 24, 25, 20, 7], [14, 23, 22, 21, 8], [13, 12, 11, 10, 9]]를 return 합니다.",easy,Array
149,"n × n 크기의 이차원 배열 arr이 매개변수로 주어질 때, arr이 다음을 만족하면 1을 아니라면 0을 return 하는 solution 함수를 작성해 주세요. 0 ≤ i, j < n인 정수 i, j에 대하여 arr[i][j] = arr[j][i] 제한사항 1 ≤ arr의 길이 = arr의 원소의 길이 ≤ 100 1 ≤ arr의 원소의 원소 ≤ 1,000 모든 arr의 원소의 길이는 같습니다. 입출력 예 arr result [[5, 192, 33], [192, 72, 95], [33, 95, 999]] 1 [[19, 498, 258, 587], [63, 93, 7, 754], [258, 7, 1000, 723], [587, 754, 723, 81]] 0 입출력 예 설명 입출력 예 #1 예제 1번에서 문제의 조건이 잘 보이도록 표를 만들면 다음과 같습니다. i j arr[i][j] arr[j][i] 0 0 5 5 0 1 192 192 0 2 33 33 1 0 192 192 1 1 72 72 1 2 95 95 2 0 33 33 2 1 95 95 2 2 999 999 조건을 만족하므로 1을 return 합니다. 입출력 예 #2 예제 2번의 arr에서 arr[0][1] = 498 ≠ 63 = arr[1][0]이므로 조건을 만족하지 않습니다. 따라서 0을 return 합니다.",easy,Array
150,"이차원 정수 배열 arr이 매개변수로 주어집니다. arr의 행의 수가 더 많다면 열의 수가 행의 수와 같아지도록 각 행의 끝에 0을 추가하고, 열의 수가 더 많다면 행의 수가 열의 수와 같아지도록 각 열의 끝에 0을 추가한 이차원 배열을 return 하는 solution 함수를 작성해 주세요. 제한사항 1 ≤ arr의 길이 ≤ 100 1 ≤ arr의 원소의 길이 ≤ 100 arr의 모든 원소의 길이는 같습니다. 1 ≤ arr의 원소의 원소 ≤ 1,000 입출력 예 arr result [[572, 22, 37], [287, 726, 384], [85, 137, 292], [487, 13, 876]] [[572, 22, 37, 0], [287, 726, 384, 0], [85, 137, 292, 0], [487, 13, 876, 0]] [[57, 192, 534, 2], [9, 345, 192, 999]] [[57, 192, 534, 2], [9, 345, 192, 999], [0, 0, 0, 0], [0, 0, 0, 0]] [[1, 2], [3, 4]] [[1, 2], [3, 4]] 입출력 예 설명 입출력 예 #1 예제 1번의 arr은 행의 수가 4, 열의 수가 3입니다. 행의 수가 더 많으므로 열의 수를 4로 만들기 위해 arr의 각 행의 끝에 0을 추가한 이차원 배열 [[572, 22, 37, 0], [287, 726, 384, 0], [85, 137, 292, 0], [487, 13, 876, 0]]를 return 합니다. 입출력 예 #2 예제 2번의 arr은 행의 수가 2, 열의 수가 4입니다. 열의 수가 더 많으므로 행의 수를 4로 만들기 위해 arr의 각 열의 끝에 0을 추가한 이차원 배열 [[57, 192, 534, 2], [9, 345, 192, 999], [0, 0, 0, 0], [0, 0, 0, 0]]을 return 합니다. 입출력 예 #3 예제 3번의 arr은 행의 수와 열의 수가 2로 같습니다. 따라서 0을 추가하지 않고 [[1, 2], [3, 4]]을 return 합니다.",easy,Array
151,"2차원 정수 배열 board와 정수 k가 주어집니다. i + j <= k를 만족하는 모든 (i, j)에 대한 board[i][j]의 합을 return 하는 solution 함수를 완성해 주세요. 제한사항 1 ≤ board의 길이 ≤ 100 1 ≤ board[i]의 길이 ≤ 100 1 ≤ board[i][j] ≤ 10,000 모든 board[i]의 길이는 같습니다. 0 ≤ k < board의 길이 + board[i]의 길이 입출력 예 board k result [[0, 1, 2],[1, 2, 3],[2, 3, 4],[3, 4, 5]] 2 8 입출력 예 설명 입출력 예 #1 입출력 예 #1의 board를 표로 나타내면 다음과 같습니다. i \ j 0 1 2 0 0 1 2 1 1 2 3 2 2 3 4 3 3 4 5 i + j가 2보다 작거나 같은 항들의 합은 0 + 1 + 2 + 1 + 2 + 2 = 8이므로 8을 return 합니다.",easy,Array
152,"A 나라가 B 나라를 침공하였습니다. B 나라의 대부분의 전략 자원은 아이기스 군사 기지에 집중되어 있기 때문에 A 나라는 B 나라의 아이기스 군사 기지에 융단폭격을 가했습니다. A 나라의 공격에 대항하여 아이기스 군사 기지에서는 무수히 쏟아지는 폭격 미사일들을 요격하려고 합니다. 이곳에는 백발백중을 자랑하는 요격 시스템이 있지만 운용 비용이 상당하기 때문에 미사일을 최소로 사용해서 모든 폭격 미사일을 요격하려 합니다. A 나라와 B 나라가 싸우고 있는 이 세계는 2 차원 공간으로 이루어져 있습니다. A 나라가 발사한 폭격 미사일은 x 축에 평행한 직선 형태의 모양이며 개구간을 나타내는 정수 쌍 (s, e) 형태로 표현됩니다. B 나라는 특정 x 좌표에서 y 축에 수평이 되도록 미사일을 발사하며, 발사된 미사일은 해당 x 좌표에 걸쳐있는 모든 폭격 미사일을 관통하여 한 번에 요격할 수 있습니다. 단, 개구간 (s, e)로 표현되는 폭격 미사일은 s와 e에서 발사하는 요격 미사일로는 요격할 수 없습니다. 요격 미사일은 실수인 x 좌표에서도 발사할 수 있습니다. 각 폭격 미사일의 x 좌표 범위 목록 targets이 매개변수로 주어질 때, 모든 폭격 미사일을 요격하기 위해 필요한 요격 미사일 수의 최솟값을 return 하도록 solution 함수를 완성해 주세요. 제한 사항 1 ≤ targets의 길이 ≤ 500,000 targets의 각 행은 [s,e] 형태입니다. 이는 한 폭격 미사일의 x 좌표 범위를 나타내며, 개구간 (s, e)에서 요격해야 합니다. 0 ≤ s < e ≤ 100,000,000 입출력 예 targets result [[4,5],[4,8],[10,14],[11,13],[5,12],[3,7],[1,4]] 3 입출력 예 설명 위 그림과 같이 최소 세 번의 요격 미사일 발사로 전부 방어할 수 있습니다.",normal,Math
153,"x축과 y축으로 이루어진 2차원 직교 좌표계에 중심이 원점인 서로 다른 크기의 원이 두 개 주어집니다. 반지름을 나타내는 두 정수 r1, r2가 매개변수로 주어질 때, 두 원 사이의 공간에 x좌표와 y좌표가 모두 정수인 점의 개수를 return하도록 solution 함수를 완성해주세요. ※ 각 원 위의 점도 포함하여 셉니다. 제한 사항 1 ≤ r1 < r2 ≤ 1,000,000 입출력 예 r1 r2 result 2 3 20 입출력 예 설명 그림과 같이 정수 쌍으로 이루어진 점은 총 20개 입니다.",normal,Simulation
154,"정우는 예술적 감각이 뛰어난 타일공입니다. 그는 단순한 타일을 활용하여 불규칙하면서도 화려하게 타일링을 하곤 합니다. 어느 날 정우는 가로 길이 n, 세로 길이 3 인 판을 타일링하는 의뢰를 맡았습니다. 아방가르드한 디자인 영감이 떠오른 정우는 다음과 같은 두 가지 종류의 타일로 타일링을 하기로 결정했습니다. 각 타일은 90도씩 회전할 수 있으며 타일의 개수는 제한이 없습니다. n이 주어졌을 때, 이 두 가지 종류의 타일로 n x 3 크기의 판을 타일링하는 방법의 수를 return 하도록 solution 함수를 완성해주세요. 제한 사항 1 ≤ n ≤ 100,000 결과는 매우 클 수 있으므로 1,000,000,007 로 나눈 나머지를 return합니다. 입출력 예 n result 2 3 3 10 입출력 예 설명 입출력 예 #1 위 그림과 같이 3 가지 방법으로 타일링할 수 있습니다. 입출력 예 #2 위 그림과 같이 10 가지 방법으로 타일링할 수 있습니다.",normal,Math
155,"얀에서는 매년 달리기 경주가 열립니다. 해설진들은 선수들이 자기 바로 앞의 선수를 추월할 때 추월한 선수의 이름을 부릅니다. 예를 들어 1등부터 3등까지 ""mumu"", ""soe"", ""poe"" 선수들이 순서대로 달리고 있을 때, 해설진이 ""soe""선수를 불렀다면 2등인 ""soe"" 선수가 1등인 ""mumu"" 선수를 추월했다는 것입니다. 즉 ""soe"" 선수가 1등, ""mumu"" 선수가 2등으로 바뀝니다. 선수들의 이름이 1등부터 현재 등수 순서대로 담긴 문자열 배열 players와 해설진이 부른 이름을 담은 문자열 배열 callings가 매개변수로 주어질 때, 경주가 끝났을 때 선수들의 이름을 1등부터 등수 순서대로 배열에 담아 return 하는 solution 함수를 완성해주세요. 제한사항 5 ≤ players의 길이 ≤ 50,000 players[i]는 i번째 선수의 이름을 의미합니다. players의 원소들은 알파벳 소문자로만 이루어져 있습니다. players에는 중복된 값이 들어가 있지 않습니다. 3 ≤ players[i]의 길이 ≤ 10 2 ≤ callings의 길이 ≤ 1,000,000 callings는 players의 원소들로만 이루어져 있습니다. 경주 진행중 1등인 선수의 이름은 불리지 않습니다. 입출력 예 players callings result [""mumu"", ""soe"", ""poe"", ""kai"", ""mine""] [""kai"", ""kai"", ""mine"", ""mine""] [""mumu"", ""kai"", ""mine"", ""soe"", ""poe""] 입출력 예 설명 입출력 예 #1 4등인 ""kai"" 선수가 2번 추월하여 2등이 되고 앞서 3등, 2등인 ""poe"", ""soe"" 선수는 4등, 3등이 됩니다. 5등인 ""mine"" 선수가 2번 추월하여 4등, 3등인 ""poe"", ""soe"" 선수가 5등, 4등이 되고 경주가 끝납니다. 1등부터 배열에 담으면 [""mumu"", ""kai"", ""mine"", ""soe"", ""poe""]이 됩니다.",easy,Array
156,"비내림차순으로 정렬된 수열이 주어질 때, 다음 조건을 만족하는 부분 수열을 찾으려고 합니다. 기존 수열에서 임의의 두 인덱스의 원소와 그 사이의 원소를 모두 포함하는 부분 수열이어야 합니다. 부분 수열의 합은 k입니다. 합이 k인 부분 수열이 여러 개인 경우 길이가 짧은 수열을 찾습니다. 길이가 짧은 수열이 여러 개인 경우 앞쪽(시작 인덱스가 작은)에 나오는 수열을 찾습니다. 수열을 나타내는 정수 배열 sequence와 부분 수열의 합을 나타내는 정수 k가 매개변수로 주어질 때, 위 조건을 만족하는 부분 수열의 시작 인덱스와 마지막 인덱스를 배열에 담아 return 하는 solution 함수를 완성해주세요. 이때 수열의 인덱스는 0부터 시작합니다. 제한사항 5 ≤ sequence의 길이 ≤ 1,000,000 1 ≤ sequence의 원소 ≤ 1,000 sequence는 비내림차순으로 정렬되어 있습니다. 5 ≤ k ≤ 1,000,000,000 k는 항상 sequence의 부분 수열로 만들 수 있는 값입니다. 입출력 예 sequence k result [1, 2, 3, 4, 5] 7 [2, 3] [1, 1, 1, 2, 3, 4, 5] 5 [6, 6] [2, 2, 2, 2, 2] 6 [0, 2] 입출력 예 설명 입출력 예 #1 [1, 2, 3, 4, 5]에서 합이 7인 연속된 부분 수열은 [3, 4]뿐이므로 해당 수열의 시작 인덱스인 2와 마지막 인덱스 3을 배열에 담아 [2, 3]을 반환합니다. 입출력 예 #2 [1, 1, 1, 2, 3, 4, 5]에서 합이 5인 연속된 부분 수열은 [1, 1, 1, 2], [2, 3], [5]가 있습니다. 이 중 [5]의 길이가 제일 짧으므로 해당 수열의 시작 인덱스와 마지막 인덱스를 담은 [6, 6]을 반환합니다. 입출력 예 #3 [2, 2, 2, 2, 2]에서 합이 6인 연속된 부분 수열은 [2, 2, 2]로 3가지 경우가 있는데, 길이가 짧은 수열이 여러 개인 경우 앞쪽에 나온 수열을 찾으므로 [0, 2]를 반환합니다.",normal,Array
157,"사진들을 보며 추억에 젖어 있던 루는 사진별로 추억 점수를 매길려고 합니다. 사진 속에 나오는 인물의 그리움 점수를 모두 합산한 값이 해당 사진의 추억 점수가 됩니다. 예를 들어 사진 속 인물의 이름이 [""may"", ""kein"", ""kain""]이고 각 인물의 그리움 점수가 [5점, 10점, 1점]일 때 해당 사진의 추억 점수는 16(5 + 10 + 1)점이 됩니다. 다른 사진 속 인물의 이름이 [""kali"", ""mari"", ""don"", ""tony""]이고 [""kali"", ""mari"", ""don""]의 그리움 점수가 각각 [11점, 1점, 55점]]이고, ""tony""는 그리움 점수가 없을 때, 이 사진의 추억 점수는 3명의 그리움 점수를 합한 67(11 + 1 + 55)점입니다. 그리워하는 사람의 이름을 담은 문자열 배열 name, 각 사람별 그리움 점수를 담은 정수 배열 yearning, 각 사진에 찍힌 인물의 이름을 담은 이차원 문자열 배열 photo가 매개변수로 주어질 때, 사진들의 추억 점수를 photo에 주어진 순서대로 배열에 담아 return하는 solution 함수를 완성해주세요. 제한사항 3 ≤ name의 길이 = yearning의 길이≤ 100 3 ≤ name의 원소의 길이 ≤ 7 name의 원소들은 알파벳 소문자로만 이루어져 있습니다. name에는 중복된 값이 들어가지 않습니다. 1 ≤ yearning[i] ≤ 100 yearning[i]는 i번째 사람의 그리움 점수입니다. 3 ≤ photo의 길이 ≤ 100 1 ≤ photo[i]의 길이 ≤ 100 3 ≤ photo[i]의 원소(문자열)의 길이 ≤ 7 photo[i]의 원소들은 알파벳 소문자로만 이루어져 있습니다. photo[i]의 원소들은 중복된 값이 들어가지 않습니다. 입출력 예 name yearning photo result [""may"", ""kein"", ""kain"", ""radi""] [5, 10, 1, 3] [[""may"", ""kein"", ""kain"", ""radi""],[""may"", ""kein"", ""brin"", ""deny""], [""kon"", ""kain"", ""may"", ""coni""]] [19, 15, 6] [""kali"", ""mari"", ""don""] [11, 1, 55] [[""kali"", ""mari"", ""don""], [""pony"", ""tom"", ""teddy""], [""con"", ""mona"", ""don""]] [67, 0, 55] [""may"", ""kein"", ""kain"", ""radi""] [5, 10, 1, 3] [[""may""],[""kein"", ""deny"", ""may""], [""kon"", ""coni""]] [5, 15, 0] 입출력 예 설명 입출력 예 #1 첫 번째 사진 속 ""may"", ""kein"", ""kain"", ""radi""의 그리움 점수를 합치면 19(5 + 10 + 1 + 3)점 입니다. 두 번째 사진 속 그리워하는 사람들인 ""may""와 ""kein""의 그리움 점수를 합치면 15(5 + 10)점입니다. 세 번째 사진의 경우 ""kain""과 ""may""만 그리워하므로 둘의 그리움 점수를 합한 6(1 + 5)점이 사진의 추억 점수입니다. 따라서 [19, 15, 6]을 반환합니다. 입출력 예 #2 첫 번째 사진 속 그리워하는 사람들인 ""kali"", ""mari"", ""don""의 그리움 점수를 합치면 67(11 + 1 + 55)점입니다. 두 번째 사진 속엔 그리워하는 인물이 없으므로 0점입니다. 세 번째 사진 속 그리워하는 사람은 ""don""만 있으므로 55점입니다. 따라서 [67, 0, 55]를 반환합니다. 입출력 예 #3 설명 생략",easy,Array
158,"과제를 받은 루는 다음과 같은 순서대로 과제를 하려고 계획을 세웠습니다. 과제는 시작하기로 한 시각이 되면 시작합니다. 새로운 과제를 시작할 시각이 되었을 때, 기존에 진행 중이던 과제가 있다면 진행 중이던 과제를 멈추고 새로운 과제를 시작합니다. 진행중이던 과제를 끝냈을 때, 잠시 멈춘 과제가 있다면, 멈춰둔 과제를 이어서 진행합니다. 만약, 과제를 끝낸 시각에 새로 시작해야 되는 과제와 잠시 멈춰둔 과제가 모두 있다면, 새로 시작해야 하는 과제부터 진행합니다. 멈춰둔 과제가 여러 개일 경우, 가장 최근에 멈춘 과제부터 시작합니다. 과제 계획을 담은 이차원 문자열 배열 plans가 매개변수로 주어질 때, 과제를 끝낸 순서대로 이름을 배열에 담아 return 하는 solution 함수를 완성해주세요. 제한사항 3 ≤ plans의 길이 ≤ 1,000 plans의 원소는 [name, start, playtime]의 구조로 이루어져 있습니다. name : 과제의 이름을 의미합니다. 2 ≤ name의 길이 ≤ 10 name은 알파벳 소문자로만 이루어져 있습니다. name이 중복되는 원소는 없습니다. start : 과제의 시작 시각을 나타냅니다. ""hh:mm""의 형태로 ""00:00"" ~ ""23:59"" 사이의 시간값만 들어가 있습니다. 모든 과제의 시작 시각은 달라서 겹칠 일이 없습니다. 과제는 ""00:00"" ... ""23:59"" 순으로 시작하면 됩니다. 즉, 시와 분의 값이 작을수록 더 빨리 시작한 과제입니다. playtime : 과제를 마치는데 걸리는 시간을 의미하며, 단위는 분입니다. 1 ≤ playtime ≤ 100 playtime은 0으로 시작하지 않습니다. 배열은 시간순으로 정렬되어 있지 않을 수 있습니다. 진행중이던 과제가 끝나는 시각과 새로운 과제를 시작해야하는 시각이 같은 경우 진행중이던 과제는 끝난 것으로 판단합니다. 입출력 예 plans result [[""korean"", ""11:40"", ""30""], [""english"", ""12:10"", ""20""], [""math"", ""12:30"", ""40""]] [""korean"", ""english"", ""math""] [[""science"", ""12:40"", ""50""], [""music"", ""12:20"", ""40""], [""history"", ""14:00"", ""30""], [""computer"", ""12:30"", ""100""]] [""science"", ""history"", ""computer"", ""music""] [[""aaa"", ""12:00"", ""20""], [""bbb"", ""12:10"", ""30""], [""ccc"", ""12:40"", ""10""]] [""bbb"", ""ccc"", ""aaa""] 입출력 예 설명 입출력 예 #1 ""korean"", ""english"", ""math""순으로 과제를 시작합니다. ""korean"" 과제를 ""11:40""에 시작하여 30분 후인 ""12:10""에 마치고, 즉시 ""english"" 과제를 시작합니다. 20분 후인 ""12:30""에 ""english"" 과제를 마치고, 즉시 ""math"" 과제를 시작합니다. 40분 후인 ""01:10""에 ""math"" 과제를 마칩니다. 따라서 ""korean"", ""english"", ""math"" 순으로 과제를 끝내므로 차례대로 배열에 담아 반환합니다. 입출력 예 #2 ""music"", ""computer"", ""science"", ""history"" 순으로 과제를 시작합니다. 시각 진행 중 과제 잠시 멈춘 과제 설명 ""12:20"" ""music"" [ ] ""music""을 시작합니다. ""12:30"" ""computer"" [""music""] ""music""을 잠시 멈추고(남은 시간 30분) ""computer""를 시작합니다 ""12:40"" ""science"" [""music"", ""computer""] ""computer""를 잠시 멈추고(남은 시간 90분) ""science""를 시작합니다 ""13:30"" ""computer"" [""music""] ""science""를 끝내고 가장 최근에 멈춘 ""computer""를 다시 시작합니다 ""14:00"" ""history"" [""music"", ""computer""] ""computer""를 잠시 멈추고(남은 시간 60분) ""history""를 시작합니다 ""14:30"" ""computer"" [""music""] ""history""를 끝내고 가장 최근에 멈춘 ""computer""를 다시 시작합니다"" ""15:30"" ""music"" [ ] ""computer""를 끝내고 가장 최근에 멈춘 ""music""을 다시 시작합니다"" ""16:00"" - [ ] ""music""을 끝냅니다 따라서 [""science"", ""history"", ""computer"", ""music""] 순서로 과제를 마칩니다. 입출력 예 #3 설명 생략",normal,Array
159,"지나다니는 길을 'O', 장애물을 'X'로 나타낸 직사각형 격자 모양의 공원에서 로봇 강아지가 산책을 하려합니다. 산책은 로봇 강아지에 미리 입력된 명령에 따라 진행하며, 명령은 다음과 같은 형식으로 주어집니다. [""방향 거리"", ""방향 거리"" … ] 예를 들어 ""E 5""는 로봇 강아지가 현재 위치에서 동쪽으로 5칸 이동했다는 의미입니다. 로봇 강아지는 명령을 수행하기 전에 다음 두 가지를 먼저 확인합니다. 주어진 방향으로 이동할 때 공원을 벗어나는지 확인합니다. 주어진 방향으로 이동 중 장애물을 만나는지 확인합니다. 위 두 가지중 어느 하나라도 해당된다면, 로봇 강아지는 해당 명령을 무시하고 다음 명령을 수행합니다. 공원의 가로 길이가 W, 세로 길이가 H라고 할 때, 공원의 좌측 상단의 좌표는 (0, 0), 우측 하단의 좌표는 (H - 1, W - 1) 입니다. 공원을 나타내는 문자열 배열 park, 로봇 강아지가 수행할 명령이 담긴 문자열 배열 routes가 매개변수로 주어질 때, 로봇 강아지가 모든 명령을 수행 후 놓인 위치를 [세로 방향 좌표, 가로 방향 좌표] 순으로 배열에 담아 return 하도록 solution 함수를 완성해주세요. 제한사항 3 ≤ park의 길이 ≤ 50 3 ≤ park[i]의 길이 ≤ 50 park[i]는 다음 문자들로 이루어져 있으며 시작지점은 하나만 주어집니다. S : 시작 지점 O : 이동 가능한 통로 X : 장애물 park는 직사각형 모양입니다. 1 ≤ routes의 길이 ≤ 50 routes의 각 원소는 로봇 강아지가 수행할 명령어를 나타냅니다. 로봇 강아지는 routes의 첫 번째 원소부터 순서대로 명령을 수행합니다. routes의 원소는 ""op n""과 같은 구조로 이루어져 있으며, op는 이동할 방향, n은 이동할 칸의 수를 의미합니다. op는 다음 네 가지중 하나로 이루어져 있습니다. N : 북쪽으로 주어진 칸만큼 이동합니다. S : 남쪽으로 주어진 칸만큼 이동합니다. W : 서쪽으로 주어진 칸만큼 이동합니다. E : 동쪽으로 주어진 칸만큼 이동합니다. 1 ≤ n ≤ 9 입출력 예 park routes result [""SOO"",""OOO"",""OOO""] [""E 2"",""S 2"",""W 1""] [2,1] [""SOO"",""OXX"",""OOO""] [""E 2"",""S 2"",""W 1""] [0,1] [""OSO"",""OOO"",""OXO"",""OOO""] [""E 2"",""S 3"",""W 1""] [0,0] 입출력 예 설명 입출력 예 #1 입력된 명령대로 동쪽으로 2칸, 남쪽으로 2칸, 서쪽으로 1칸 이동하면 [0,0] -> [0,2] -> [2,2] -> [2,1]이 됩니다. 입출력 예 #2 입력된 명령대로라면 동쪽으로 2칸, 남쪽으로 2칸, 서쪽으로 1칸 이동해야하지만 남쪽으로 2칸 이동할 때 장애물이 있는 칸을 지나기 때문에 해당 명령을 제외한 명령들만 따릅니다. 결과적으로는 [0,0] -> [0,2] -> [0,1]이 됩니다. 입출력 예 #3 처음 입력된 명령은 공원을 나가게 되고 두 번째로 입력된 명령 또한 장애물을 지나가게 되므로 두 입력은 제외한 세 번째 명령만 따르므로 결과는 다음과 같습니다. [0,1] -> [0,0]",easy,Array
160,"마인은 곡괭이로 광산에서 광석을 캐려고 합니다. 마인은 다이아몬드 곡괭이, 철 곡괭이, 돌 곡괭이를 각각 0개에서 5개까지 가지고 있으며, 곡괭이로 광물을 캘 때는 피로도가 소모됩니다. 각 곡괭이로 광물을 캘 때의 피로도는 아래 표와 같습니다. 예를 들어, 철 곡괭이는 다이아몬드를 캘 때 피로도 5가 소모되며, 철과 돌을 캘때는 피로도가 1씩 소모됩니다. 각 곡괭이는 종류에 상관없이 광물 5개를 캔 후에는 더 이상 사용할 수 없습니다. 마인은 다음과 같은 규칙을 지키면서 최소한의 피로도로 광물을 캐려고 합니다. 사용할 수 있는 곡괭이중 아무거나 하나를 선택해 광물을 캡니다. 한 번 사용하기 시작한 곡괭이는 사용할 수 없을 때까지 사용합니다. 광물은 주어진 순서대로만 캘 수 있습니다. 광산에 있는 모든 광물을 캐거나, 더 사용할 곡괭이가 없을 때까지 광물을 캡니다. 즉, 곡괭이를 하나 선택해서 광물 5개를 연속으로 캐고, 다음 곡괭이를 선택해서 광물 5개를 연속으로 캐는 과정을 반복하며, 더 사용할 곡괭이가 없거나 광산에 있는 모든 광물을 캘 때까지 과정을 반복하면 됩니다. 마인이 갖고 있는 곡괭이의 개수를 나타내는 정수 배열 picks와 광물들의 순서를 나타내는 문자열 배열 minerals가 매개변수로 주어질 때, 마인이 작업을 끝내기까지 필요한 최소한의 피로도를 return 하는 solution 함수를 완성해주세요. 제한사항 picks는 [dia, iron, stone]과 같은 구조로 이루어져 있습니다. 0 ≤ dia, iron, stone ≤ 5 dia는 다이아몬드 곡괭이의 수를 의미합니다. iron은 철 곡괭이의 수를 의미합니다. stone은 돌 곡괭이의 수를 의미합니다. 곡괭이는 최소 1개 이상 가지고 있습니다. 5 ≤ minerals의 길이 ≤ 50 minerals는 다음 3개의 문자열로 이루어져 있으며 각각의 의미는 다음과 같습니다. diamond : 다이아몬드 iron : 철 stone : 돌 입출력 예 picks minerals result [1, 3, 2] [""diamond"", ""diamond"", ""diamond"", ""iron"", ""iron"", ""diamond"", ""iron"", ""stone""] 12 [0, 1, 1] [""diamond"", ""diamond"", ""diamond"", ""diamond"", ""diamond"", ""iron"", ""iron"", ""iron"", ""iron"", ""iron"", ""diamond""] 50 입출력 예 설명 입출력 예 #1 다이아몬드 곡괭이로 앞에 다섯 광물을 캐고 철 곡괭이로 남은 다이아몬드, 철, 돌을 1개씩 캐면 12(1 + 1 + 1 + 1+ 1 + 5 + 1 + 1)의 피로도로 캘 수 있으며 이때가 최소값입니다. 입출력 예 #2 철 곡괭이로 다이아몬드 5개를 캐고 돌 곡괭이고 철 5개를 캐면 50의 피로도로 캘 수 있으며, 이때가 최소값입니다.",normal,Array
161,"리코쳇 로봇이라는 보드게임이 있습니다. 이 보드게임은 격자모양 게임판 위에서 말을 움직이는 게임으로, 시작 위치에서 출발한 뒤 목표 위치에 정확하게 멈추기 위해 최소 몇 번의 이동이 필요한지 말하는 게임입니다. 이 게임에서 말의 이동은 현재 위치에서 상, 하, 좌, 우 중 한 방향으로 게임판 위의 장애물이나 게임판 가장자리까지 부딪힐 때까지 미끄러져 움직이는 것을 한 번의 이동으로 정의합니다. 다음은 보드게임판을 나타낸 예시입니다. ("".""은 빈 공간을, ""R""은 로봇의 처음 위치를, ""D""는 장애물의 위치를, ""G""는 목표지점을 나타냅니다.) ...D..R .D.G... ....D.D D....D. ..D.... 이때 최소 움직임은 7번이며 ""R"" 위치에서 아래, 왼쪽, 위, 왼쪽, 아래, 오른쪽, 위 순서로 움직이면 ""G"" 위치에 멈춰 설 수 있습니다. 게임판의 상태를 나타내는 문자열 배열 board가 주어졌을 때, 말이 목표위치에 도달하는데 최소 몇 번 이동해야 하는지 return 하는 solution함수를 완성해주세요. 만약 목표위치에 도달할 수 없다면 -1을 return 해주세요. 제한 사항 3 ≤ board의 길이 ≤ 100 3 ≤ board의 원소의 길이 ≤ 100 board의 원소의 길이는 모두 동일합니다. 문자열은 ""."", ""D"", ""R"", ""G""로만 구성되어 있으며 각각 빈 공간, 장애물, 로봇의 처음 위치, 목표 지점을 나타냅니다. ""R""과 ""G""는 한 번씩 등장합니다. 입출력 예 board result [""...D..R"", "".D.G..."", ""....D.D"", ""D....D."", ""..D....""] 7 ["".D.R"", ""...."", "".G.."", ""...D""] -1 입출력 예 설명 입출력 예 #1 문제 설명의 예시와 같습니다. 입출력 예 #2 .D.R .... .G.. ...D ""R"" 위치에 있는 말을 어떻게 움직여도 ""G"" 에 도달시킬 수 없습니다. 따라서 -1을 return 합니다. ※ 공지 - 2024년 9월 19일 문제 지문이 리뉴얼되었습니다.",normal,Array
162,"프로그래머스의 마스코트인 머쓱이는 최근 취미로 당구를 치기 시작했습니다. 머쓱이는 손 대신 날개를 사용해야 해서 당구를 잘 못 칩니다. 하지만 끈기가 강한 머쓱이는 열심히 노력해서 당구를 잘 치려고 당구 학원에 다니고 있습니다. 오늘도 당구 학원에 나온 머쓱이에게 당구 선생님이""원쿠션""(당구에서 공을 쳐서 벽에 맞히는 걸 쿠션이라고 부르고, 벽에 한 번 맞힌 후 공에 맞히면 원쿠션이라고 부릅니다) 연습을 하라면서 당구공의 위치가 담긴 리스트를 건네줬습니다. 리스트에는 머쓱이가 맞춰야 하는 공들의 위치가 담겨있습니다. 머쓱이는 리스트에 담긴 각 위치에 순서대로 공을 놓아가며 ""원쿠션"" 연습을 하면 됩니다. 이때, 머쓱이는 항상 같은 위치에 공을 놓고 쳐서 리스트에 담긴 위치에 놓인 공을 맞춥니다. 머쓱이와 달리 최근 취미로 알고리즘 문제를 풀기 시작한 당신은, 머쓱이가 친 공이 각각의 목표로한 공에 맞을 때까지 최소 얼마의 거리를 굴러가야 하는지가 궁금해졌습니다. 당구대의 가로 길이 m, 세로 길이 n과 머쓱이가 쳐야 하는 공이 놓인 위치 좌표를 나타내는 두 정수 startX, startY, 그리고 매 회마다 목표로 해야하는 공들의 위치 좌표를 나타내는 정수 쌍들이 들어있는 2차원 정수배열 balls가 주어집니다. ""원쿠션"" 연습을 위해 머쓱이가 공을 적어도 벽에 한 번은 맞춘 후 목표 공에 맞힌다고 할 때, 각 회마다 머쓱이가 친 공이 굴러간 거리의 최솟값의 제곱을 배열에 담아 return 하도록 solution 함수를 완성해 주세요. 단, 머쓱이가 친 공이 벽에 부딪힐 때 진행 방향은 항상 입사각과 반사각이 동일하며, 만약 꼭짓점에 부딪힐 경우 진입 방향의 반대방향으로 공이 진행됩니다. 공의 크기는 무시하며, 두 공의 좌표가 정확히 일치하는 경우에만 두 공이 서로 맞았다고 판단합니다. 공이 목표 공에 맞기 전에 멈추는 경우는 없으며, 목표 공에 맞으면 바로 멈춘다고 가정합니다. 위 그림은 친 공이 벽에 맞았을 때의 움직임을 나타낸 그림입니다. 치기 전 공의 위치가 점 A입니다. 위 그림은 친 공이 꼭짓점에 맞았을 때의 움직임을 나타낸 그림입니다. 치기 전 공의 위치가 점 A입니다. 제한사항 3 ≤ m, n ≤ 1,000 0 < startX < m 0 < startY < n 2 ≤ balls의 길이 ≤ 1,000 balls의 원소는 [a, b] 형태입니다. a, b는 머쓱이가 맞춰야 할 공이 놓인 좌표를 의미합니다. 0 < a < m, 0 < b < n (a, b) = ( startX, startY )인 입력은 들어오지 않습니다. 입출력 예 m n startX startY balls result 10 10 3 7 [[7, 7], [2, 7], [7, 3]] [52, 37, 116] 입출력 예 설명 입출력 예 #1 첫 번째 예시의 첫번째 공에 대한 그림은 다음과 같습니다. 당구대의 좌측 하단 좌표가 (0, 0) 입니다. 점 A는 머쓱이가 칠 공이 놓인 위치입니다. 점 A → 점[0] : 점선을 따라 이동하면 거리의 제곱이 52로 최소가 됩니다. 같은 예시의 두 번째 공에 대한 그림은 다음과 같습니다. 점 A → 점[1] : 점선을 따라 이동하면 거리의 제곱이 37로 최소가 됩니다. 점 A에 놓인 공을 왼쪽 방향으로 x축과 수평이 되도록 보내면 벽에 맞고 점 [1]에 닿아 이동 거리가 더 짧아보이지만, A가 벽으로 이동하는 경로에 점 [1]이 있으므로, 벽에 맞기전에 공에 먼저 맞게 됩니다. 같은 예시의 세 번째 공에 대한 그림은 다음과 같습니다. 점 A → 점[2] : 점선을 따라 이동하면 거리의 제곱이 116으로 최소가 됩니다. 따라서 [52, 37, 116]을 return 합니다. ※ 공지 - 2023년 3월 20일 문제 난이도가 Lv. 1 → Lv. 2로 변경되었습니다.",normal,Array
163,"다음은 중고거래 게시판 정보를 담은 USED_GOODS_BOARD 테이블과 중고거래 게시판 첨부파일 정보를 담은 USED_GOODS_REPLY 테이블입니다. USED_GOODS_BOARD 테이블은 다음과 같으며 BOARD_ID, WRITER_ID, TITLE, CONTENTS, PRICE, CREATED_DATE, STATUS, VIEWS은 게시글 ID, 작성자 ID, 게시글 제목, 게시글 내용, 가격, 작성일, 거래상태, 조회수를 의미합니다. Column name Type Nullable BOARD_ID VARCHAR(5) FALSE WRITER_ID VARCHAR(50) FALSE TITLE VARCHAR(100) FALSE CONTENTS VARCHAR(1000) FALSE PRICE NUMBER FALSE CREATED_DATE DATE FALSE STATUS VARCHAR(10) FALSE VIEWS NUMBER FALSE USED_GOODS_REPLY 테이블은 다음과 같으며 REPLY_ID, BOARD_ID, WRITER_ID, CONTENTS, CREATED_DATE는 각각 댓글 ID, 게시글 ID, 작성자 ID, 댓글 내용, 작성일을 의미합니다. Column name Type Nullable REPLY_ID VARCHAR(10) FALSE BOARD_ID VARCHAR(5) FALSE WRITER_ID VARCHAR(50) FALSE CONTENTS VARCHAR(1000) TRUE CREATED_DATE DATE FALSE 문제 USED_GOODS_BOARD와 USED_GOODS_REPLY 테이블에서 2022년 10월에 작성된 게시글 제목, 게시글 ID, 댓글 ID, 댓글 작성자 ID, 댓글 내용, 댓글 작성일을 조회하는 SQL문을 작성해주세요. 결과는 댓글 작성일을 기준으로 오름차순 정렬해주시고, 댓글 작성일이 같다면 게시글 제목을 기준으로 오름차순 정렬해주세요. 예시 USED_GOODS_BOARD 테이블이 다음과 같고 BOARD_ID WRITER_ID TITLE CONTENTS PRICE CREATED_DATE STATUS VIEWS B0001 kwag98 반려견 배변패드 팝니다 정말 저렴히 판매합니다. 전부 미개봉 새상품입니다. 12000 2022-10-01 DONE 250 B0002 lee871201 국내산 볶음참깨 직접 농사지은 참깨입니다. 3000 2022-10-02 DONE 121 B0003 goung12 배드민턴 라켓 사놓고 방치만 해서 팝니다. 9000 2022-10-02 SALE 212 B0004 keel1990 디올 귀걸이 신세계강남점에서 구입. 정품 아닐시 백퍼센트 환불 130000 2022-10-02 SALE 199 B0005 haphli01 스팸클래식 팔아요 유통기한 2025년까지에요 10000 2022-10-02 SALE 121 USED_GOODS_REPLY 테이블이 다음과 같을 때 REPLY_ID BOARD_ID WRITER_ID CONTENTS CREATED_DATE R000000001 B0001 s2s2123 구매하겠습니다. 쪽지 드립니다. 2022-10-02 R000000002 B0002 hoho1112 쪽지 주세요. 2022-10-03 R000000003 B0006 hwahwa2 삽니다. 연락주세요. 2022-10-03 R000000004 B0007 hong02 예약중 2022-10-06 R000000005 B0009 hanju23 구매완료 2022-10-07 SQL을 실행하면 다음과 같이 출력되어야 합니다. TITLE BOARD_ID REPLY_ID WRITER_ID CONTENTS CREATED_DATE 반려견 배변패드 팝니다 B0001 R000000001 s2s2123 구매하겠습니다. 쪽지 드립니다. 2022-10-02 국내산 볶음참깨 B0002 R000000002 hoho1112 쪽지 주세요. 2022-10-03 주의사항 CREATED_DATE의 포맷이 예시의 포맷과 일치해야 정답처리 됩니다.",easy,database
164,"다음은 중고거래 게시판 정보를 담은 USED_GOODS_BOARD 테이블입니다. USED_GOODS_BOARD 테이블은 다음과 같으며 BOARD_ID, WRITER_ID, TITLE, CONTENTS, PRICE, CREATED_DATE, STATUS, VIEWS은 게시글 ID, 작성자 ID, 게시글 제목, 게시글 내용, 가격, 작성일, 거래상태, 조회수를 의미합니다. Column name Type Nullable BOARD_ID VARCHAR(5) FALSE WRITER_ID VARCHAR(50) FALSE TITLE VARCHAR(100) FALSE CONTENTS VARCHAR(1000) FALSE PRICE NUMBER FALSE CREATED_DATE DATE FALSE STATUS VARCHAR(10) FALSE VIEWS NUMBER FALSE 문제 USED_GOODS_BOARD 테이블에서 2022년 10월 5일에 등록된 중고거래 게시물의 게시글 ID, 작성자 ID, 게시글 제목, 가격, 거래상태를 조회하는 SQL문을 작성해주세요. 거래상태가 SALE 이면 판매중, RESERVED이면 예약중, DONE이면 거래완료 분류하여 출력해주시고, 결과는 게시글 ID를 기준으로 내림차순 정렬해주세요. 예시 USED_GOODS_BOARD 테이블이 다음과 같을 때 BOARD_ID WRITER_ID TITLE CONTENTS PRICE CREATED_DATE STATUS VIEWS B0007 s2s2123 커피글라인더 새상품처럼 깨끗합니다. 7000 2022-10-04 DONE 210 B0008 hong02 자전거 판매합니다 출퇴근용으로 구매했다가 사용하지 않아서 내놔요 40000 2022-10-04 SALE 301 B0009 yawoong67 선반 팝니다 6단 선반. 환불 반품 안됩니다. 12000 2022-10-05 DONE 202 B0010 keel1990 철제선반5단 철제선반 5단 조립식 팜 10000 2022-10-05 SALE 194 SQL을 실행하면 다음과 같이 출력되어야 합니다. BOARD_ID WRITER_ID TITLE PRICE STATUS B0010 keel1990 철제선반5단 10000 판매중 B0009 yawoong67 선반 팝니다 12000 거래완료",normal,database
165,"다음은 중고거래 게시판 정보를 담은 USED_GOODS_BOARD 테이블과 중고거래 게시판 첨부파일 정보를 담은 USED_GOODS_FILE 테이블입니다. USED_GOODS_BOARD 테이블은 다음과 같으며 BOARD_ID, WRITER_ID, TITLE, CONTENTS, PRICE, CREATED_DATE, STATUS, VIEWS은 게시글 ID, 작성자 ID, 게시글 제목, 게시글 내용, 가격, 작성일, 거래상태, 조회수를 의미합니다. Column name Type Nullable BOARD_ID VARCHAR(5) FALSE WRITER_ID VARCHAR(50) FALSE TITLE VARCHAR(100) FALSE CONTENTS VARCHAR(1000) FALSE PRICE NUMBER FALSE CREATED_DATE DATE FALSE STATUS VARCHAR(10) FALSE VIEWS NUMBER FALSE USED_GOODS_FILE 테이블은 다음과 같으며 FILE_ID, FILE_EXT, FILE_NAME, BOARD_ID는 각각 파일 ID, 파일 확장자, 파일 이름, 게시글 ID를 의미합니다. Column name Type Nullable FILE_ID VARCHAR(10) FALSE FILE_EXT VARCHAR(5) FALSE FILE_NAME VARCHAR(256) FALSE BOARD_ID VARCHAR(10) FALSE 문제 USED_GOODS_BOARD와 USED_GOODS_FILE 테이블에서 조회수가 가장 높은 중고거래 게시물에 대한 첨부파일 경로를 조회하는 SQL문을 작성해주세요. 첨부파일 경로는 FILE ID를 기준으로 내림차순 정렬해주세요. 기본적인 파일경로는 /home/grep/src/ 이며, 게시글 ID를 기준으로 디렉토리가 구분되고, 파일이름은 파일 ID, 파일 이름, 파일 확장자로 구성되도록 출력해주세요. 조회수가 가장 높은 게시물은 하나만 존재합니다. 예시 USED_GOODS_BOARD 테이블이 다음과 같고 BOARD_ID WRITER_ID TITLE CONTENTS PRICE CREATED_DATE STATUS VIEWS B0001 kwag98 반려견 배변패드 팝니다 정말 저렴히 판매합니다. 전부 미개봉 새상품입니다. 12000 2022-10-01 DONE 250 B0002 lee871201 국내산 볶음참깨 직접 농사지은 참깨입니다. 3000 2022-10-02 DONE 121 B0003 goung12 배드민턴 라켓 사놓고 방치만 해서 팝니다. 9000 2022-10-02 SALE 212 B0004 keel1990 디올 귀걸이 신세계강남점에서 구입. 정품 아닐시 백퍼센트 환불 130000 2022-10-02 SALE 199 B0005 haphli01 스팸클래식 팔아요 유통기한 2025년까지에요 10000 2022-10-02 SALE 121 USED_GOODS_FILE 테이블이 다음과 같을 때 FILE_ID FILE_EXT FILE_NAME BOARD_ID IMG_000001 .jpg photo1 B0001 IMG_000002 .jpg photo2 B0001 IMG_000003 .png 사진 B0002 IMG_000004 .jpg 사진 B0003 IMG_000005 .jpg photo B0004 SQL을 실행하면 다음과 같이 출력되어야 합니다. FILE_PATH /home/grep/src/B0001/IMG_000001photo1.jpg /home/grep/src/B0001/IMG_000002photo2.jpg",normal,database
166,"다음은 중고 거래 게시판 정보를 담은 USED_GOODS_BOARD 테이블과 중고 거래 게시판 첨부파일 정보를 담은 USED_GOODS_USER 테이블입니다. USED_GOODS_BOARD 테이블은 다음과 같으며 BOARD_ID, WRITER_ID, TITLE, CONTENTS, PRICE, CREATED_DATE, STATUS, VIEWS는 게시글 ID, 작성자 ID, 게시글 제목, 게시글 내용, 가격, 작성일, 거래상태, 조회수를 의미합니다. Column name Type Nullable BOARD_ID VARCHAR(5) FALSE WRITER_ID VARCHAR(50) FALSE TITLE VARCHAR(100) FALSE CONTENTS VARCHAR(1000) FALSE PRICE NUMBER FALSE CREATED_DATE DATE FALSE STATUS VARCHAR(10) FALSE VIEWS NUMBER FALSE USED_GOODS_USER 테이블은 다음과 같으며 USER_ID, NICKNAME, CITY, STREET_ADDRESS1, STREET_ADDRESS2, TLNO는 각각 회원 ID, 닉네임, 시, 도로명 주소, 상세 주소, 전화번호를 의미합니다. Column name Type Nullable USER_ID VARCHAR(50) FALSE NICKANME VARCHAR(100) FALSE CITY VARCHAR(100) FALSE STREET_ADDRESS1 VARCHAR(100) FALSE STREET_ADDRESS2 VARCHAR(100) TRUE TLNO VARCHAR(20) FALSE 문제 USED_GOODS_BOARD와 USED_GOODS_USER 테이블에서 중고 거래 게시물을 3건 이상 등록한 사용자의 사용자 ID, 닉네임, 전체주소, 전화번호를 조회하는 SQL문을 작성해주세요. 이때, 전체 주소는 시, 도로명 주소, 상세 주소가 함께 출력되도록 해주시고, 전화번호의 경우 xxx-xxxx-xxxx 같은 형태로 하이픈 문자열(-)을 삽입하여 출력해주세요. 결과는 회원 ID를 기준으로 내림차순 정렬해주세요. 예시 USED_GOODS_BOARD 테이블이 다음과 같고 BOARD_ID WRITER_ID TITLE CONTENTS PRICE CREATED_DATE STATUS VIEWS B0001 dhfkzmf09 칼라거펠트 코트 양모 70%이상 코트입니다. 120000 2022-10-14 DONE 104 B0002 lee871201 국내산 볶음참깨 직접 농사지은 참깨입니다. 3000 2022-10-02 DONE 121 B0003 dhfkzmf09 나이키 숏패팅 사이즈는 M입니다. 40000 2022-10-17 DONE 98 B0004 kwag98 반려견 배변패드 팝니다 정말 저렴히 판매합니다. 전부 미개봉 새상품입니다. 12000 2022-10-01 DONE 250 B0005 dhfkzmf09 PS4 PS5 구매로인해 팝니다. 250000 2022-11-03 DONE 111 USED_GOODS_USER 테이블이 다음과 같을 때 USER_ID NICKNAME CITY STREET_ADDRESS1 STREET_ADDRESS2 TLNO dhfkzmf09 찐찐 성남시 분당구 수내로 13 A동 1107호 01053422914 dlPcks90 썹썹 성남시 분당구 수내로 74 401호 01034573944 cjfwls91 점심만금식 성남시 분당구 내정로 185 501호 01036344964 dlfghks94 희망 성남시 분당구 내정로 101 203동 102호 01032634154 rkdhs95 용기 성남시 분당구 수내로 23 501호 01074564564 SQL을 실행하면 다음과 같이 출력되어야 합니다. USER_ID NICKNAME 전체주소 전화번호 dhfkzmf09 찐찐 성남시 분당구 수내로 13 A동 1107호 010-5342-2914",normal,database
167,"다음은 중고 거래 게시판 정보를 담은 USED_GOODS_BOARD 테이블과 중고 거래 게시판 사용자 정보를 담은 USED_GOODS_USER 테이블입니다. USED_GOODS_BOARD 테이블은 다음과 같으며 BOARD_ID, WRITER_ID, TITLE, CONTENTS, PRICE, CREATED_DATE, STATUS, VIEWS는 게시글 ID, 작성자 ID, 게시글 제목, 게시글 내용, 가격, 작성일, 거래상태, 조회수를 의미합니다. Column name Type Nullable BOARD_ID VARCHAR(5) FALSE WRITER_ID VARCHAR(50) FALSE TITLE VARCHAR(100) FALSE CONTENTS VARCHAR(1000) FALSE PRICE NUMBER FALSE CREATED_DATE DATE FALSE STATUS VARCHAR(10) FALSE VIEWS NUMBER FALSE USED_GOODS_USER 테이블은 다음과 같으며 USER_ID, NICKNAME, CITY, STREET_ADDRESS1, STREET_ADDRESS2, TLNO는 각각 회원 ID, 닉네임, 시, 도로명 주소, 상세 주소, 전화번호를 를 의미합니다. Column name Type Nullable USER_ID VARCHAR(50) FALSE NICKNAME VARCHAR(100) FALSE CITY VARCHAR(100) FALSE STREET_ADDRESS1 VARCHAR(100) FALSE STREET_ADDRESS2 VARCHAR(100) TRUE TLNO VARCHAR(20) FALSE 문제 USED_GOODS_BOARD와 USED_GOODS_USER 테이블에서 완료된 중고 거래의 총금액이 70만 원 이상인 사람의 회원 ID, 닉네임, 총거래금액을 조회하는 SQL문을 작성해주세요. 결과는 총거래금액을 기준으로 오름차순 정렬해주세요. 예시 USED_GOODS_BOARD 테이블이 다음과 같고 BOARD_ID WRITER_ID TITLE CONTENTS PRICE CREATED_DATE STATUS VIEWS B0001 zkzkdh1 캠핑의자 가벼워요 깨끗한 상태입니다. 2개 25000 2022-11-29 SALE 34 B0002 miyeon89 벽걸이 에어컨 엘지 휘센 7평 100000 2022-11-29 SALE 55 B0003 dhfkzmf09 에어팟 맥스 에어팟 맥스 스카이 블루 색상 판매합니다. 450000 2022-11-26 DONE 67 B0004 sangjune1 파파야나인 포르쉐 푸쉬카 예민하신분은 피해주세요 30000 2022-11-30 DONE 78 B0005 zkzkdh1 애플워치7 애플워치7 실버 스텐 45미리 판매합니다. 700000 2022-11-30 DONE 99 USED_GOODS_USER 테이블이 다음과 같을 때 USER_ID NICKNAME CITY STREET_ADDRESS1 STREET_ADDRESS2 TLNO cjfwls91 점심만금식 성남시 분당구 내정로 185 501호 01036344964 zkzkdh1 후후후 성남시 분당구 내정로 35 가동 1202호 01032777543 spdlqj12 크크큭 성남시 분당구 수내로 206 2019동 801호 01087234922 xlqpfh2 잉여킹 성남시 분당구 수내로 1 001-004 01064534911 dhfkzmf09 찐찐 성남시 분당구 수내로 13 A동 1107호 01053422914 SQL을 실행하면 다음과 같이 출력되어야 합니다. USER_ID NICKNAME TOTAL_SALES zkzkdh1 후후후 700000",normal,database
168,"코딩테스트를 준비하는 머쓱이는 프로그래머스에서 문제를 풀고 나중에 다시 코드를 보면서 공부하려고 작성한 코드를 컴퓨터 바탕화면에 아무 위치에나 저장해 둡니다. 저장한 코드가 많아지면서 머쓱이는 본인의 컴퓨터 바탕화면이 너무 지저분하다고 생각했습니다. 프로그래머스에서 작성했던 코드는 그 문제에 가서 다시 볼 수 있기 때문에 저장해 둔 파일들을 전부 삭제하기로 했습니다. 컴퓨터 바탕화면은 각 칸이 정사각형인 격자판입니다. 이때 컴퓨터 바탕화면의 상태를 나타낸 문자열 배열 wallpaper가 주어집니다. 파일들은 바탕화면의 격자칸에 위치하고 바탕화면의 격자점들은 바탕화면의 가장 왼쪽 위를 (0, 0)으로 시작해 (세로 좌표, 가로 좌표)로 표현합니다. 빈칸은 ""."", 파일이 있는 칸은 ""#""의 값을 가집니다. 드래그를 하면 파일들을 선택할 수 있고, 선택된 파일들을 삭제할 수 있습니다. 머쓱이는 최소한의 이동거리를 갖는 한 번의 드래그로 모든 파일을 선택해서 한 번에 지우려고 하며 드래그로 파일들을 선택하는 방법은 다음과 같습니다. 드래그는 바탕화면의 격자점 S(lux, luy)를 마우스 왼쪽 버튼으로 클릭한 상태로 격자점 E(rdx, rdy)로 이동한 뒤 마우스 왼쪽 버튼을 떼는 행동입니다. 이때, ""점 S에서 점 E로 드래그한다""고 표현하고 점 S와 점 E를 각각 드래그의 시작점, 끝점이라고 표현합니다. 점 S(lux, luy)에서 점 E(rdx, rdy)로 드래그를 할 때, ""드래그 한 거리""는 |rdx - lux| + |rdy - luy|로 정의합니다. 점 S에서 점 E로 드래그를 하면 바탕화면에서 두 격자점을 각각 왼쪽 위, 오른쪽 아래로 하는 직사각형 내부에 있는 모든 파일이 선택됩니다. 예를 들어 wallpaper = ["".#..."", ""..#.."", ""...#.""]인 바탕화면을 그림으로 나타내면 다음과 같습니다. 이러한 바탕화면에서 다음 그림과 같이 S(0, 1)에서 E(3, 4)로 드래그하면 세 개의 파일이 모두 선택되므로 드래그 한 거리 (3 - 0) + (4 - 1) = 6을 최솟값으로 모든 파일을 선택 가능합니다. (0, 0)에서 (3, 5)로 드래그해도 모든 파일을 선택할 수 있지만 이때 드래그 한 거리는 (3 - 0) + (5 - 0) = 8이고 이전의 방법보다 거리가 늘어납니다. 머쓱이의 컴퓨터 바탕화면의 상태를 나타내는 문자열 배열 wallpaper가 매개변수로 주어질 때 바탕화면의 파일들을 한 번에 삭제하기 위해 최소한의 이동거리를 갖는 드래그의 시작점과 끝점을 담은 정수 배열을 return하는 solution 함수를 작성해 주세요. 드래그의 시작점이 (lux, luy), 끝점이 (rdx, rdy)라면 정수 배열 [lux, luy, rdx, rdy]를 return하면 됩니다. 제한사항 1 ≤ wallpaper의 길이 ≤ 50 1 ≤ wallpaper[i]의 길이 ≤ 50 wallpaper의 모든 원소의 길이는 동일합니다. wallpaper[i][j]는 바탕화면에서 i + 1행 j + 1열에 해당하는 칸의 상태를 나타냅니다. wallpaper[i][j]는 ""#"" 또는 "".""의 값만 가집니다. 바탕화면에는 적어도 하나의 파일이 있습니다. 드래그 시작점 (lux, luy)와 끝점 (rdx, rdy)는 lux < rdx, luy < rdy를 만족해야 합니다. 입출력 예 wallpaper result ["".#..."", ""..#.."", ""...#.""] [0, 1, 3, 4] ["".........."", "".....#...."", ""......##.."", ""...##....."", ""....#.....""] [1, 3, 5, 8] ["".##...##."", ""#..#.#..#"", ""#...#...#"", "".#.....#."", ""..#...#.."", ""...#.#..."", ""....#....""] [0, 0, 7, 9] ["".."", ""#.""] [1, 0, 2, 1] 입출력 예 설명 입출력 예 #1 문제 설명의 예시와 같은 예제입니다. (0, 1)에서 (3, 4)로 드래그 하면 모든 파일을 선택할 수 있고 드래그 한 거리는 6이었고, 6보다 적은 거리로 모든 파일을 선택하는 방법은 없습니다. 따라서 [0, 1, 3, 4]를 return합니다. 입출력 예 #2 예제 2번의 바탕화면은 다음과 같습니다. (1, 3)에서 (5, 8)로 드래그하면 모든 파일을 선택할 수 있고 이보다 적은 이동거리로 모든 파일을 선택하는 방법은 없습니다. 따라서 가장 적은 이동의 드래그로 모든 파일을 선택하는 방법인 [1, 3, 5, 8]을 return합니다. 입출력 예 #3 예제 3번의 바탕화면은 다음과 같습니다. 모든 파일을 선택하기 위해선 바탕화면의 가장 왼쪽 위 (0, 0)에서 가장 오른쪽 아래 (7, 9)로 드래그 해야만 합니다. 따라서 [0, 0, 7, 9]를 return합니다. 입출력 예 #4 예제 4번의 바탕화면은 다음과 같이 2행 1열에만 아이콘이 있습니다. 이를 드래그로 선택하기 위해서는 그 칸의 왼쪽 위 (1, 0)에서 오른쪽 아래 (2, 1)로 드래그 하면 됩니다. (1, 0)에서 (2, 2)로 드래그 해도 아이콘을 선택할 수 있지만 이전보다 이동거리가 늘어납니다. 따라서 [1, 0, 2, 1]을 return합니다.",easy,Array
169,"어느 학교에 페인트가 칠해진 길이가 n미터인 벽이 있습니다. 벽에 동아리 · 학회 홍보나 회사 채용 공고 포스터 등을 게시하기 위해 테이프로 붙였다가 철거할 때 떼는 일이 많고 그 과정에서 페인트가 벗겨지곤 합니다. 페인트가 벗겨진 벽이 보기 흉해져 학교는 벽에 페인트를 덧칠하기로 했습니다. 넓은 벽 전체에 페인트를 새로 칠하는 대신, 구역을 나누어 일부만 페인트를 새로 칠 함으로써 예산을 아끼려 합니다. 이를 위해 벽을 1미터 길이의 구역 n개로 나누고, 각 구역에 왼쪽부터 순서대로 1번부터 n번까지 번호를 붙였습니다. 그리고 페인트를 다시 칠해야 할 구역들을 정했습니다. 벽에 페인트를 칠하는 롤러의 길이는 m미터이고, 롤러로 벽에 페인트를 한 번 칠하는 규칙은 다음과 같습니다. 롤러가 벽에서 벗어나면 안 됩니다. 구역의 일부분만 포함되도록 칠하면 안 됩니다. 즉, 롤러의 좌우측 끝을 구역의 경계선 혹은 벽의 좌우측 끝부분에 맞춘 후 롤러를 위아래로 움직이면서 벽을 칠합니다. 현재 페인트를 칠하는 구역들을 완전히 칠한 후 벽에서 롤러를 떼며, 이를 벽을 한 번 칠했다고 정의합니다. 한 구역에 페인트를 여러 번 칠해도 되고 다시 칠해야 할 구역이 아닌 곳에 페인트를 칠해도 되지만 다시 칠하기로 정한 구역은 적어도 한 번 페인트칠을 해야 합니다. 예산을 아끼기 위해 다시 칠할 구역을 정했듯 마찬가지로 롤러로 페인트칠을 하는 횟수를 최소화하려고 합니다. 정수 n, m과 다시 페인트를 칠하기로 정한 구역들의 번호가 담긴 정수 배열 section이 매개변수로 주어질 때 롤러로 페인트칠해야 하는 최소 횟수를 return 하는 solution 함수를 작성해 주세요. 제한사항 1 ≤ m ≤ n ≤ 100,000 1 ≤ section의 길이 ≤ n 1 ≤ section의 원소 ≤ n section의 원소는 페인트를 다시 칠해야 하는 구역의 번호입니다. section에서 같은 원소가 두 번 이상 나타나지 않습니다. section의 원소는 오름차순으로 정렬되어 있습니다. 입출력 예 n m section result 8 4 [2, 3, 6] 2 5 4 [1, 3] 1 4 1 [1, 2, 3, 4] 4 입출력 예 설명 입출력 예 #1 예제 1번은 2, 3, 6번 영역에 페인트를 다시 칠해야 합니다. 롤러의 길이가 4미터이므로 한 번의 페인트칠에 연속된 4개의 구역을 칠할 수 있습니다. 처음에 3, 4, 5, 6번 영역에 페인트칠을 하면 칠해야 할 곳으로 2번 구역만 남고 1, 2, 3, 4번 구역에 페인트칠을 하면 2번 만에 다시 칠해야 할 곳에 모두 페인트칠을 할 수 있습니다. 2번보다 적은 횟수로 2, 3, 6번 영역에 페인트를 덧칠하는 방법은 없습니다. 따라서 최소 횟수인 2를 return 합니다. 입출력 예 #2 예제 2번은 1, 3번 영역에 페인트를 다시 칠해야 합니다. 롤러의 길이가 4미터이므로 한 번의 페인트칠에 연속된 4개의 구역을 칠할 수 있고 1, 2, 3, 4번 영역에 페인트칠을 하면 한 번에 1, 3번 영역을 모두 칠할 수 있습니다. 따라서 최소 횟수인 1을 return 합니다. 입출력 예 #3 예제 3번은 모든 구역에 페인트칠을 해야 합니다. 롤러의 길이가 1미터이므로 한 번에 한 구역밖에 칠할 수 없습니다. 구역이 4개이므로 각 구역을 한 번씩만 칠하는 4번이 최소 횟수가 됩니다. 따라서 4를 return 합니다. ※ 공지 - 2023년 3월 20일 문제 난이도가 Lv. 2 → Lv. 1로 변경되었습니다. ※ 공지 - 2023년 8월 17일 문제 지문의 오탈자를 수정했습니다.",easy,Array
170,"어떤 수열의 연속 부분 수열에 같은 길이의 펄스 수열을 각 원소끼리 곱하여 연속 펄스 부분 수열을 만들려 합니다. 펄스 수열이란 [1, -1, 1, -1 …] 또는 [-1, 1, -1, 1 …] 과 같이 1 또는 -1로 시작하면서 1과 -1이 번갈아 나오는 수열입니다. 예를 들어 수열 [2, 3, -6, 1, 3, -1, 2, 4]의 연속 부분 수열 [3, -6, 1]에 펄스 수열 [1, -1, 1]을 곱하면 연속 펄스 부분수열은 [3, 6, 1]이 됩니다. 또 다른 예시로 연속 부분 수열 [3, -1, 2, 4]에 펄스 수열 [-1, 1, -1, 1]을 곱하면 연속 펄스 부분수열은 [-3, -1, -2, 4]이 됩니다. 정수 수열 sequence가 매개변수로 주어질 때, 연속 펄스 부분 수열의 합 중 가장 큰 것을 return 하도록 solution 함수를 완성해주세요. 제한 사항 1 ≤ sequence의 길이 ≤ 500,000 -100,000 ≤ sequence의 원소 ≤ 100,000 sequence의 원소는 정수입니다. 입출력 예 sequence result [2, 3, -6, 1, 3, -1, 2, 4] 10 입출력 예 설명 주어진 수열의 연속 부분 수열 [3, -6, 1]에 펄스 수열 [1, -1, 1]을 곱하여 연속 펄스 부분 수열 [3, 6, 1]을 얻을 수 있고 그 합은 10으로서 가장 큽니다.",normal,Math
171,"휴대폰의 자판은 컴퓨터 키보드 자판과는 다르게 하나의 키에 여러 개의 문자가 할당될 수 있습니다. 키 하나에 여러 문자가 할당된 경우, 동일한 키를 연속해서 빠르게 누르면 할당된 순서대로 문자가 바뀝니다. 예를 들어, 1번 키에 ""A"", ""B"", ""C"" 순서대로 문자가 할당되어 있다면 1번 키를 한 번 누르면 ""A"", 두 번 누르면 ""B"", 세 번 누르면 ""C""가 되는 식입니다. 같은 규칙을 적용해 아무렇게나 만든 휴대폰 자판이 있습니다. 이 휴대폰 자판은 키의 개수가 1개부터 최대 100개까지 있을 수 있으며, 특정 키를 눌렀을 때 입력되는 문자들도 무작위로 배열되어 있습니다. 또, 같은 문자가 자판 전체에 여러 번 할당된 경우도 있고, 키 하나에 같은 문자가 여러 번 할당된 경우도 있습니다. 심지어 아예 할당되지 않은 경우도 있습니다. 따라서 몇몇 문자열은 작성할 수 없을 수도 있습니다. 이 휴대폰 자판을 이용해 특정 문자열을 작성할 때, 키를 최소 몇 번 눌러야 그 문자열을 작성할 수 있는지 알아보고자 합니다. 1번 키부터 차례대로 할당된 문자들이 순서대로 담긴 문자열배열 keymap과 입력하려는 문자열들이 담긴 문자열 배열 targets가 주어질 때, 각 문자열을 작성하기 위해 키를 최소 몇 번씩 눌러야 하는지 순서대로 배열에 담아 return 하는 solution 함수를 완성해 주세요. 단, 목표 문자열을 작성할 수 없을 때는 -1을 저장합니다. 제한사항 1 ≤ keymap의 길이 ≤ 100 1 ≤ keymap의 원소의 길이 ≤ 100 keymap[i]는 i + 1번 키를 눌렀을 때 순서대로 바뀌는 문자를 의미합니다. 예를 들어 keymap[0] = ""ABACD"" 인 경우 1번 키를 한 번 누르면 A, 두 번 누르면 B, 세 번 누르면 A 가 됩니다. keymap의 원소의 길이는 서로 다를 수 있습니다. keymap의 원소는 알파벳 대문자로만 이루어져 있습니다. 1 ≤ targets의 길이 ≤ 100 1 ≤ targets의 원소의 길이 ≤ 100 targets의 원소는 알파벳 대문자로만 이루어져 있습니다. 입출력 예 keymap targets result [""ABACD"", ""BCEFD""] [""ABCD"",""AABB""] [9, 4] [""AA""] [""B""] [-1] [""AGZ"", ""BSSS""] [""ASA"",""BGZ""] [4, 6] 입출력 예 설명 입출력 예 #1 ""ABCD""의 경우, 1번 키 한 번 → A 2번 키 한 번 → B 2번 키 두 번 → C 1번 키 다섯 번 → D 따라서 총합인 9를 첫 번째 인덱스에 저장합니다. ""AABB""의 경우, 1번 키 한 번 → A 1번 키 한 번 → A 2번 키 한 번 → B 2번 키 한 번 → B 따라서 총합인 4를 두 번째 인덱스에 저장합니다. 결과적으로 [9,4]를 return 합니다. 입출력 예 #2 ""B""의 경우, 'B'가 어디에도 존재하지 않기 때문에 -1을 첫 번째 인덱스에 저장합니다. 결과적으로 [-1]을 return 합니다. 입출력 예 #3 ""ASA""의 경우, 1번 키 한 번 → A 2번 키 두 번 → S 1번 키 한 번 → A 따라서 총합인 4를 첫 번째 인덱스에 저장합니다. ""BGZ""의 경우, 2번 키 한 번 → B 1번 키 두 번 → G 1번 키 세 번 → Z 따라서 총합인 6을 두 번째 인덱스에 저장합니다. 결과적으로 [4, 6]을 return 합니다.",easy,Array
172,"틱택토는 두 사람이 하는 게임으로 처음에 3x3의 빈칸으로 이루어진 게임판에 선공이 ""O"", 후공이 ""X""를 번갈아가면서 빈칸에 표시하는 게임입니다. 가로, 세로, 대각선으로 3개가 같은 표시가 만들어지면 같은 표시를 만든 사람이 승리하고 게임이 종료되며 9칸이 모두 차서 더 이상 표시를 할 수 없는 경우에는 무승부로 게임이 종료됩니다. 할 일이 없어 한가한 머쓱이는 두 사람이 하는 게임인 틱택토를 다음과 같이 혼자서 하려고 합니다. 혼자서 선공과 후공을 둘 다 맡는다. 틱택토 게임을 시작한 후 ""O""와 ""X""를 혼자서 번갈아 가면서 표시를 하면서 진행한다. 틱택토는 단순한 규칙으로 게임이 금방 끝나기에 머쓱이는 한 게임이 종료되면 다시 3x3 빈칸을 그린 뒤 다시 게임을 반복했습니다. 그렇게 틱택토 수 십 판을 했더니 머쓱이는 게임 도중에 다음과 같이 규칙을 어기는 실수를 했을 수도 있습니다. ""O""를 표시할 차례인데 ""X""를 표시하거나 반대로 ""X""를 표시할 차례인데 ""O""를 표시한다. 선공이나 후공이 승리해서 게임이 종료되었음에도 그 게임을 진행한다. 게임 도중 게임판을 본 어느 순간 머쓱이는 본인이 실수를 했는지 의문이 생겼습니다. 혼자서 틱택토를 했기에 게임하는 과정을 지켜본 사람이 없어 이를 알 수는 없습니다. 그러나 게임판만 봤을 때 실제로 틱택토 규칙을 지켜서 진행했을 때 나올 수 있는 상황인지는 판단할 수 있을 것 같고 문제가 없다면 게임을 이어서 하려고 합니다. 머쓱이가 혼자서 게임을 진행하다 의문이 생긴 틱택토 게임판의 정보를 담고 있는 문자열 배열 board가 매개변수로 주어질 때, 이 게임판이 규칙을 지켜서 틱택토를 진행했을 때 나올 수 있는 게임 상황이면 1을 아니라면 0을 return 하는 solution 함수를 작성해 주세요. 제한사항 board의 길이 = board[i]의 길이 = 3 board의 원소는 모두 ""O"", ""X"", "".""으로만 이루어져 있습니다. board[i][j]는 i + 1행 j + 1열에 해당하는 칸의 상태를 나타냅니다. "".""은 빈칸을, ""O""와 ""X""는 해당 문자로 칸이 표시되어 있다는 의미입니다. 입출력 예 board result [""O.X"", "".O."", ""..X""] 1 [""OOO"", ""..."", ""XXX""] 0 [""..."", "".X."", ""...""] 0 [""..."", ""..."", ""...""] 1 입출력 예 설명 입출력 예 #1 예제 1번의 게임판은 다음과 같습니다. O.X .O. ..X 선공 후공이 번갈아가면서 다음과 같이 놓았을 때 이러한 게임판이 나올 수 있습니다. 1행 1열 → 1행 3열 → 2행 2열 → 3행 3열 1행 1열 → 3행 3열 → 2행 2열 → 1행 3열 2행 2열 → 1행 3열 → 1행 1열 → 3행 3열 2행 2열 → 3행 3열 → 1행 1열 → 1행 3열 물론 위와 다르게 머쓱이가 2행 2열에 O, 3행 3열에 X, 1행 3열에 X, 1행 1열에 O 순서로 표시를 해서 실수를 했을 가능성도 있지만 ""실수를 했을 가능성이 있는가""를 묻는 게 아닌 ""이 게임판이 규칙을 지켜서 진행한 틱택토에서 나올 수 있는 상황인가""를 묻는 문제라는 것에 유의해주세요. 따라서 1을 return 합니다. 입출력 예 #2 예제 2번의 게임판은 다음과 같습니다. OOO ... XXX 규칙을 지켜서 진행한 틱택토라면 선공과 후공이 번갈아가면서 각각 1행, 3행 중 두 칸씩에 표시를 한 뒤 5번째 차례에 선공이 1행에 가로로 3개의 O를 완성했을 때 종료되므로 적어도 머쓱이가 게임이 종료된 후에도 계속 진행하는 실수를 했다는 것을 추론해 볼 수 있고, 정상적인 틱택토에서는 이러한 상황이 나올 수 없습니다. 따라서 0을 return 합니다. 입출력 예 #3 예제 3번은 2행 2열에만 X가 표시가 되어있습니다. 선공 O 표시가 없이 X만 있으므로 머쓱이가 O를 표시해야 할 때 X를 표시하는 실수를 했다는 것을 추론해 볼 수 있고, 규칙을 지켜서 진행했을 때는 이러한 상황이 나올 수 없습니다. 따라서 0을 return 합니다. 입출력 예 #4 예제 4번은 빈 3x3 게임판입니다. 선공이 아직 빈칸에 표시하기 전에 이러한 상황이 나올 수 있습니다. 따라서 1을 return 합니다.",normal,Array
173,"코니는 영어 단어가 적힌 카드 뭉치 두 개를 선물로 받았습니다. 코니는 다음과 같은 규칙으로 카드에 적힌 단어들을 사용해 원하는 순서의 단어 배열을 만들 수 있는지 알고 싶습니다. 원하는 카드 뭉치에서 카드를 순서대로 한 장씩 사용합니다. 한 번 사용한 카드는 다시 사용할 수 없습니다. 카드를 사용하지 않고 다음 카드로 넘어갈 수 없습니다. 기존에 주어진 카드 뭉치의 단어 순서는 바꿀 수 없습니다. 예를 들어 첫 번째 카드 뭉치에 순서대로 [""i"", ""drink"", ""water""], 두 번째 카드 뭉치에 순서대로 [""want"", ""to""]가 적혀있을 때 [""i"", ""want"", ""to"", ""drink"", ""water""] 순서의 단어 배열을 만들려고 한다면 첫 번째 카드 뭉치에서 ""i""를 사용한 후 두 번째 카드 뭉치에서 ""want""와 ""to""를 사용하고 첫 번째 카드뭉치에 ""drink""와 ""water""를 차례대로 사용하면 원하는 순서의 단어 배열을 만들 수 있습니다. 문자열로 이루어진 배열 cards1, cards2와 원하는 단어 배열 goal이 매개변수로 주어질 때, cards1과 cards2에 적힌 단어들로 goal를 만들 있다면 ""Yes""를, 만들 수 없다면 ""No""를 return하는 solution 함수를 완성해주세요. 제한사항 1 ≤ cards1의 길이, cards2의 길이 ≤ 10 1 ≤ cards1[i]의 길이, cards2[i]의 길이 ≤ 10 cards1과 cards2에는 서로 다른 단어만 존재합니다. 2 ≤ goal의 길이 ≤ cards1의 길이 + cards2의 길이 1 ≤ goal[i]의 길이 ≤ 10 goal의 원소는 cards1과 cards2의 원소들로만 이루어져 있습니다. cards1, cards2, goal의 문자열들은 모두 알파벳 소문자로만 이루어져 있습니다. 입출력 예 cards1 cards2 goal result [""i"", ""drink"", ""water""] [""want"", ""to""] [""i"", ""want"", ""to"", ""drink"", ""water""] ""Yes"" [""i"", ""water"", ""drink""] [""want"", ""to""] [""i"", ""want"", ""to"", ""drink"", ""water""] ""No"" 입출력 예 설명 입출력 예 #1 본문과 같습니다. 입출력 예 #2 cards1에서 ""i""를 사용하고 cards2에서 ""want""와 ""to""를 사용하여 ""i want to""까지는 만들 수 있지만 ""water""가 ""drink""보다 먼저 사용되어야 하기 때문에 해당 문장을 완성시킬 수 없습니다. 따라서 ""No""를 반환합니다.",easy,Array
174,"1 x 1 크기의 칸들로 이루어진 직사각형 격자 형태의 미로에서 탈출하려고 합니다. 각 칸은 통로 또는 벽으로 구성되어 있으며, 벽으로 된 칸은 지나갈 수 없고 통로로 된 칸으로만 이동할 수 있습니다. 통로들 중 한 칸에는 미로를 빠져나가는 문이 있는데, 이 문은 레버를 당겨서만 열 수 있습니다. 레버 또한 통로들 중 한 칸에 있습니다. 따라서, 출발 지점에서 먼저 레버가 있는 칸으로 이동하여 레버를 당긴 후 미로를 빠져나가는 문이 있는 칸으로 이동하면 됩니다. 이때 아직 레버를 당기지 않았더라도 출구가 있는 칸을 지나갈 수 있습니다. 미로에서 한 칸을 이동하는데 1초가 걸린다고 할 때, 최대한 빠르게 미로를 빠져나가는데 걸리는 시간을 구하려 합니다. 미로를 나타낸 문자열 배열 maps가 매개변수로 주어질 때, 미로를 탈출하는데 필요한 최소 시간을 return 하는 solution 함수를 완성해주세요. 만약, 탈출할 수 없다면 -1을 return 해주세요. 제한사항 5 ≤ maps의 길이 ≤ 100 5 ≤ maps[i]의 길이 ≤ 100 maps[i]는 다음 5개의 문자들로만 이루어져 있습니다. S : 시작 지점 E : 출구 L : 레버 O : 통로 X : 벽 시작 지점과 출구, 레버는 항상 다른 곳에 존재하며 한 개씩만 존재합니다. 출구는 레버가 당겨지지 않아도 지나갈 수 있으며, 모든 통로, 출구, 레버, 시작점은 여러 번 지나갈 수 있습니다. 입출력 예 maps result [""SOOOL"",""XXXXO"",""OOOOO"",""OXXXX"",""OOOOE""] 16 [""LOOXS"",""OOOOX"",""OOOOO"",""OOOOO"",""EOOOO""] -1 입출력 예 설명 입출력 예 #1 주어진 문자열은 다음과 같은 미로이며 다음과 같이 이동하면 가장 빠른 시간에 탈출할 수 있습니다. 4번 이동하여 레버를 당기고 출구까지 이동하면 총 16초의 시간이 걸립니다. 따라서 16을 반환합니다. 입출력 예 #2 주어진 문자열은 다음과 같은 미로입니다. 시작 지점에서 이동할 수 있는 공간이 없어서 탈출할 수 없습니다. 따라서 -1을 반환합니다.",normal,Array
175,"다음은 어느 자동차 대여 회사에서 대여중인 자동차들의 정보를 담은 CAR_RENTAL_COMPANY_CAR 테이블입니다. CAR_RENTAL_COMPANY_CAR 테이블은 아래와 같은 구조로 되어있으며, CAR_ID, CAR_TYPE, DAILY_FEE, OPTIONS 는 각각 자동차 ID, 자동차 종류, 일일 대여 요금(원), 자동차 옵션 리스트를 나타냅니다. Column name Type Nullable CAR_ID INTEGER FALSE CAR_TYPE VARCHAR(255) FALSE DAILY_FEE INTEGER FALSE OPTIONS VARCHAR(255) FALSE 자동차 종류는 '세단', 'SUV', '승합차', '트럭', '리무진' 이 있습니다. 자동차 옵션 리스트는 콤마(',')로 구분된 키워드 리스트(옵션 리스트 값 예시: '열선시트', '스마트키', '주차감지센서')로 되어있으며, 키워드 종류는 '주차감지센서', '스마트키', '네비게이션', '통풍시트', '열선시트', '후방카메라', '가죽시트' 가 있습니다. 문제 CAR_RENTAL_COMPANY_CAR 테이블에서 '네비게이션' 옵션이 포함된 자동차 리스트를 출력하는 SQL문을 작성해주세요. 결과는 자동차 ID를 기준으로 내림차순 정렬해주세요. 예시 예를 들어 CAR_RENTAL_COMPANY_CAR 테이블이 다음과 같다면 CAR_ID CAR_TYPE DAILY_FEE OPTIONS 1 세단 16000 가죽시트,열선시트,후방카메라 2 SUV 14000 스마트키,네비게이션,열선시트 3 SUV 22000 주차감지센서,후방카메라,네비게이션 '네비게이션' 옵션이 포함된 자동차는 자동차 ID가 2, 3인 자동차이고, 자동차 ID를 기준으로 내림차순 정렬하면 다음과 같은 결과가 나와야 합니다. CAR_ID CAR_TYPE DAILY_FEE OPTIONS 3 SUV 22000 주차감지센서,후방카메라,네비게이션 2 SUV 14000 스마트키,네비게이션,열선시트",easy,database
176,"다음은 어느 자동차 대여 회사의 자동차 대여 기록 정보를 담은 CAR_RENTAL_COMPANY_RENTAL_HISTORY 테이블입니다. CAR_RENTAL_COMPANY_RENTAL_HISTORY 테이블은 아래와 같은 구조로 되어있으며, HISTORY_ID, CAR_ID, START_DATE, END_DATE 는 각각 자동차 대여 기록 ID, 자동차 ID, 대여 시작일, 대여 종료일을 나타냅니다. Column name Type Nullable HISTORY_ID INTEGER FALSE CAR_ID INTEGER FALSE START_DATE DATE FALSE END_DATE DATE FALSE 문제 CAR_RENTAL_COMPANY_RENTAL_HISTORY 테이블에서 평균 대여 기간이 7일 이상인 자동차들의 자동차 ID와 평균 대여 기간(컬럼명: AVERAGE_DURATION) 리스트를 출력하는 SQL문을 작성해주세요. 평균 대여 기간은 소수점 두번째 자리에서 반올림하고, 결과는 평균 대여 기간을 기준으로 내림차순 정렬해주시고, 평균 대여 기간이 같으면 자동차 ID를 기준으로 내림차순 정렬해주세요. 예시 예를 들어 CAR_RENTAL_COMPANY_RENTAL_HISTORY 테이블이 다음과 같다면 HISTORY_ID CAR_ID START_DATE END_DATE 1 1 2022-09-27 2022-10-01 2 1 2022-10-03 2022-11-04 3 2 2022-09-05 2022-09-05 4 2 2022-09-08 2022-09-10 5 3 2022-09-16 2022-10-15 6 1 2022-11-07 2022-12-06 자동차 별 평균 대여 기간은 자동차 ID가 1인 자동차의 경우, 대여 기간이 각각 5일, 33일, 30일인 기록이 존재하므로 평균 22.7일 자동차 ID가 2인 자동차의 경우, 대여 기간이 각각 1일, 3일인 기록이 존재하므로 평균 2일 자동차 ID가 3인 자동차의 경우, 대여 기간이 30일인 기록만 존재하므로 평균 30일 입니다. 평균 대여 기간이 7일 이상인 자동차는 자동차 ID가 1, 3인 자동차이고, 평균 대여 기간 내림차순 및 자동차 ID를 기준으로 내림차순 정렬하면 다음과 같이 나와야 합니다. CAR_ID AVERAGE_DURATION 3 30.0 1 22.7 ※ 공지 - 2024년 10월 2일 채점코드가 수정되었습니다. 기존에 제출한 코드가 통과하지 못할 수도 있습니다.",normal,database
177,"다음은 어느 자동차 대여 회사에서 대여 중인 자동차들의 정보를 담은 CAR_RENTAL_COMPANY_CAR 테이블과 자동차 대여 기록 정보를 담은 CAR_RENTAL_COMPANY_RENTAL_HISTORY 테이블입니다. CAR_RENTAL_COMPANY_CAR 테이블은 아래와 같은 구조로 되어있으며, CAR_ID, CAR_TYPE, DAILY_FEE, OPTIONS 는 각각 자동차 ID, 자동차 종류, 일일 대여 요금(원), 자동차 옵션 리스트를 나타냅니다. Column name Type Nullable CAR_ID INTEGER FALSE CAR_TYPE VARCHAR(255) FALSE DAILY_FEE INTEGER FALSE OPTIONS VARCHAR(255) FALSE 자동차 종류는 '세단', 'SUV', '승합차', '트럭', '리무진' 이 있습니다. 자동차 옵션 리스트는 콤마(',')로 구분된 키워드 리스트(예: '열선시트', '스마트키', '주차감지센서')로 되어있으며, 키워드 종류는 '주차감지센서', '스마트키', '네비게이션', '통풍시트', '열선시트', '후방카메라', '가죽시트' 가 있습니다. CAR_RENTAL_COMPANY_RENTAL_HISTORY 테이블은 아래와 같은 구조로 되어있으며, HISTORY_ID, CAR_ID, START_DATE, END_DATE 는 각각 자동차 대여 기록 ID, 자동차 ID, 대여 시작일, 대여 종료일을 나타냅니다. Column name Type Nullable HISTORY_ID INTEGER FALSE CAR_ID INTEGER FALSE START_DATE DATE FALSE END_DATE DATE FALSE 문제 CAR_RENTAL_COMPANY_CAR 테이블과 CAR_RENTAL_COMPANY_RENTAL_HISTORY 테이블에서 자동차 종류가 '세단'인 자동차들 중 10월에 대여를 시작한 기록이 있는 자동차 ID 리스트를 출력하는 SQL문을 작성해주세요. 자동차 ID 리스트는 중복이 없어야 하며, 자동차 ID를 기준으로 내림차순 정렬해주세요. 예시 예를 들어 CAR_RENTAL_COMPANY_CAR 테이블이 다음과 같고 CAR_ID CAR_TYPE DAILY_FEE OPTIONS 1 세단 16000 가죽시트,열선시트,후방카메라 2 SUV 14000 스마트키,네비게이션,열선시트 3 세단 22000 주차감지센서,후방카메라,가죽시트 4 세단 12000 주차감지센서 CAR_RENTAL_COMPANY_RENTAL_HISTORY 테이블이 다음과 같다면 HISTORY_ID CAR_ID START_DATE END_DATE 1 4 2022-09-27 2022-09-27 2 3 2022-10-03 2022-10-04 3 2 2022-10-05 2022-10-05 4 1 2022-10-11 2022-10-14 5 3 2022-10-13 2022-10-15 10월에 대여를 시작한 기록이 있는 '세단' 종류의 자동차는 자동차 ID가 1, 3 인 자동차이고, 자동차 ID를 기준으로 내림차순 정렬하면 다음과 같이 나와야 합니다. CAR_ID 3 1",normal,database
178,"다음은 어느 자동차 대여 회사의 자동차 대여 기록 정보를 담은 CAR_RENTAL_COMPANY_RENTAL_HISTORY 테이블입니다. CAR_RENTAL_COMPANY_RENTAL_HISTORY 테이블은 아래와 같은 구조로 되어있으며, HISTORY_ID, CAR_ID, START_DATE, END_DATE 는 각각 자동차 대여 기록 ID, 자동차 ID, 대여 시작일, 대여 종료일을 나타냅니다. Column name Type Nullable HISTORY_ID INTEGER FALSE CAR_ID INTEGER FALSE START_DATE DATE FALSE END_DATE DATE FALSE 문제 CAR_RENTAL_COMPANY_RENTAL_HISTORY 테이블에서 2022년 10월 16일에 대여 중인 자동차인 경우 '대여중' 이라고 표시하고, 대여 중이지 않은 자동차인 경우 '대여 가능'을 표시하는 컬럼(컬럼명: AVAILABILITY)을 추가하여 자동차 ID와 AVAILABILITY 리스트를 출력하는 SQL문을 작성해주세요. 이때 반납 날짜가 2022년 10월 16일인 경우에도 '대여중'으로 표시해주시고 결과는 자동차 ID를 기준으로 내림차순 정렬해주세요. 예시 예를 들어 CAR_RENTAL_COMPANY_RENTAL_HISTORY 테이블이 다음과 같다면 HISTORY_ID CAR_ID START_DATE END_DATE 1 4 2022-09-27 2022-09-27 2 3 2022-10-03 2022-10-04 3 2 2022-10-05 2022-10-05 4 1 2022-10-11 2022-10-16 5 3 2022-10-13 2022-10-15 6 2 2022-10-15 2022-10-17 2022년 10월 16일에 대여 중인 자동차는 자동차 ID가 1, 2인 자동차이고, 대여 가능한 자동차는 자동차 ID가 3, 4이므로, '대여중' 또는 '대여 가능' 을 표시하는 컬럼을 추가하고, 자동차 ID를 기준으로 내림차순 정렬하면 다음과 같이 나와야 합니다. CAR_ID AVAILABILITY 4 대여 가능 3 대여 가능 2 대여중 1 대여중",normal,database
179,"다음은 어느 자동차 대여 회사에서 대여 중인 자동차들의 정보를 담은 CAR_RENTAL_COMPANY_CAR 테이블과 자동차 대여 기록 정보를 담은 CAR_RENTAL_COMPANY_RENTAL_HISTORY 테이블과 자동차 종류 별 대여 기간 종류 별 할인 정책 정보를 담은 CAR_RENTAL_COMPANY_DISCOUNT_PLAN 테이블 입니다. CAR_RENTAL_COMPANY_CAR 테이블은 아래와 같은 구조로 되어있으며, CAR_ID, CAR_TYPE, DAILY_FEE, OPTIONS 는 각각 자동차 ID, 자동차 종류, 일일 대여 요금(원), 자동차 옵션 리스트를 나타냅니다. Column name Type Nullable CAR_ID INTEGER FALSE CAR_TYPE VARCHAR(255) FALSE DAILY_FEE INTEGER FALSE OPTIONS VARCHAR(255) FALSE 자동차 종류는 '세단', 'SUV', '승합차', '트럭', '리무진' 이 있습니다. 자동차 옵션 리스트는 콤마(',')로 구분된 키워드 리스트(예: ''열선시트,스마트키,주차감지센서'')로 되어있으며, 키워드 종류는 '주차감지센서', '스마트키', '네비게이션', '통풍시트', '열선시트', '후방카메라', '가죽시트' 가 있습니다. CAR_RENTAL_COMPANY_RENTAL_HISTORY 테이블은 아래와 같은 구조로 되어있으며, HISTORY_ID, CAR_ID, START_DATE, END_DATE 는 각각 자동차 대여 기록 ID, 자동차 ID, 대여 시작일, 대여 종료일을 나타냅니다. Column name Type Nullable HISTORY_ID INTEGER FALSE CAR_ID INTEGER FALSE START_DATE DATE FALSE END_DATE DATE FALSE CAR_RENTAL_COMPANY_DISCOUNT_PLAN 테이블은 아래와 같은 구조로 되어있으며, PLAN_ID, CAR_TYPE, DURATION_TYPE, DISCOUNT_RATE 는 각각 요금 할인 정책 ID, 자동차 종류, 대여 기간 종류, 할인율(%)을 나타냅니다. Column name Type Nullable PLAN_ID INTEGER FALSE CAR_TYPE VARCHAR(255) FALSE DURATION_TYPE VARCHAR(255) FALSE DISCOUNT_RATE INTEGER FALSE 할인율이 적용되는 대여 기간 종류로는 '7일 이상' (대여 기간이 7일 이상 30일 미만인 경우), '30일 이상' (대여 기간이 30일 이상 90일 미만인 경우), '90일 이상' (대여 기간이 90일 이상인 경우) 이 있습니다. 대여 기간이 7일 미만인 경우 할인정책이 없습니다. 문제 CAR_RENTAL_COMPANY_CAR 테이블과 CAR_RENTAL_COMPANY_RENTAL_HISTORY 테이블과 CAR_RENTAL_COMPANY_DISCOUNT_PLAN 테이블에서 자동차 종류가 '세단' 또는 'SUV' 인 자동차 중 2022년 11월 1일부터 2022년 11월 30일까지 대여 가능하고 30일간의 대여 금액이 50만원 이상 200만원 미만인 자동차에 대해서 자동차 ID, 자동차 종류, 대여 금액(컬럼명: FEE) 리스트를 출력하는 SQL문을 작성해주세요. 결과는 대여 금액을 기준으로 내림차순 정렬하고, 대여 금액이 같은 경우 자동차 종류를 기준으로 오름차순 정렬, 자동차 종류까지 같은 경우 자동차 ID를 기준으로 내림차순 정렬해주세요. 예시 예를 들어 CAR_RENTAL_COMPANY_CAR 테이블과 CAR_RENTAL_COMPANY_RENTAL_HISTORY 테이블과 CAR_RENTAL_COMPANY_DISCOUNT_PLAN 테이블이 다음과 같다면 CAR_ID CAR_TYPE DAILY_FEE OPTIONS 1 SUV 25000 가죽시트,열선시트,후방카메라 2 세단 14000 스마트키,네비게이션,열선시트 3 트럭 32000 주차감지센서,후방카메라,가죽시트 4 세단 12000 열선시트,후방카메라 5 세단 22000 스마트키,주차감지센서 HISTORY_ID CAR_ID START_DATE END_DATE 1 1 2022-08-27 2022-09-02 2 1 2022-10-03 2022-10-04 3 2 2022-10-05 2022-10-20 4 2 2022-10-10 2022-11-12 5 3 2022-10-16 2022-10-17 PLAN_ID CAR_TYPE DURATION_TYPE DISCOUNT_RATE 1 트럭 7일 이상 5% 2 트럭 30일 이상 7% 3 트럭 90일 이상 10% 4 세단 7일 이상 5% 5 세단 30일 이상 10% 6 세단 90일 이상 15% 7 SUV 7일 이상 3% 8 SUV 30일 이상 8% 9 SUV 90일 이상 12% 자동차 종류가 '세단' 또는 'SUV' 인 자동차 중 2022년 11월 1일 부터 2022년 11월 30일까지 대여가능한 자동차는 자동차 ID가 1, 4, 5인 자동차입니다. 일일 대여 요금에 자동차 종류 별 대여기간이 30일 이상인 경우의 할인율을 적용하여 30일간의 대여 금액을 구하면, 자동차 ID가 1인 경우, 일일 대여 금액 25,000원에서 8% 할인율을 적용하고 30일을 곱하면 총 대여 금액은 690,000원 자동차 ID가 4인 경우, 일일 대여 금액 12,000원에서 10% 할인율을 적용하고 30일을 곱하면 총 대여 금액은 324,000원 자동차 ID가 5인 경우, 일일 대여 금액 22,000원에서 10% 할인율을 적용하고 30일을 곱하면 총 대여 금액은 621,000원이고, 대여 금액이 50만원 이상 200만원 미만인 경우에 대해서 대여 금액을 기준으로 내림차순, 자동차 종류를 기준으로 오름차순 및 자동차 ID를 기준으로 내림차순 정렬하면 다음과 같아야 합니다. CAR_ID CAR_TYPE FEE 5 세단 690000 1 SUV 621000 주의사항 FEE의 경우 예시처럼 정수부분만 출력되어야 합니다.",hard,database
180,"두 문자열 s와 skip, 그리고 자연수 index가 주어질 때, 다음 규칙에 따라 문자열을 만들려 합니다. 암호의 규칙은 다음과 같습니다. 문자열 s의 각 알파벳을 index만큼 뒤의 알파벳으로 바꿔줍니다. index만큼의 뒤의 알파벳이 z를 넘어갈 경우 다시 a로 돌아갑니다. skip에 있는 알파벳은 제외하고 건너뜁니다. 예를 들어 s = ""aukks"", skip = ""wbqd"", index = 5일 때, a에서 5만큼 뒤에 있는 알파벳은 f지만 [b, c, d, e, f]에서 'b'와 'd'는 skip에 포함되므로 세지 않습니다. 따라서 'b', 'd'를 제외하고 'a'에서 5만큼 뒤에 있는 알파벳은 [c, e, f, g, h] 순서에 의해 'h'가 됩니다. 나머지 ""ukks"" 또한 위 규칙대로 바꾸면 ""appy""가 되며 결과는 ""happy""가 됩니다. 두 문자열 s와 skip, 그리고 자연수 index가 매개변수로 주어질 때 위 규칙대로 s를 변환한 결과를 return하도록 solution 함수를 완성해주세요. 제한사항 5 ≤ s의 길이 ≤ 50 1 ≤ skip의 길이 ≤ 10 s와 skip은 알파벳 소문자로만 이루어져 있습니다. skip에 포함되는 알파벳은 s에 포함되지 않습니다. 1 ≤ index ≤ 20 입출력 예 s skip index result ""aukks"" ""wbqd"" 5 ""happy"" 입출력 예 설명 입출력 예 #1 본문 내용과 일치합니다.",easy,Array
181,"호텔을 운영 중인 코니는 최소한의 객실만을 사용하여 예약 손님들을 받으려고 합니다. 한 번 사용한 객실은 퇴실 시간을 기준으로 10분간 청소를 하고 다음 손님들이 사용할 수 있습니다. 예약 시각이 문자열 형태로 담긴 2차원 배열 book_time이 매개변수로 주어질 때, 코니에게 필요한 최소 객실의 수를 return 하는 solution 함수를 완성해주세요. 제한사항 1 ≤ book_time의 길이 ≤ 1,000 book_time[i]는 [""HH:MM"", ""HH:MM""]의 형태로 이루어진 배열입니다 [대실 시작 시각, 대실 종료 시각] 형태입니다. 시각은 HH:MM 형태로 24시간 표기법을 따르며, ""00:00"" 부터 ""23:59"" 까지로 주어집니다. 예약 시각이 자정을 넘어가는 경우는 없습니다. 시작 시각은 항상 종료 시각보다 빠릅니다. 입출력 예 book_time result [[""15:00"", ""17:00""], [""16:40"", ""18:20""], [""14:20"", ""15:20""], [""14:10"", ""19:20""], [""18:20"", ""21:20""]] 3 [[""09:10"", ""10:10""], [""10:20"", ""12:20""]] 1 [[""10:20"", ""12:30""], [""10:20"", ""12:30""], [""10:20"", ""12:30""]] 3 입출력 예 설명 입출력 예 #1 위 사진과 같습니다. 입출력 예 #2 첫 번째 손님이 10시 10분에 퇴실 후 10분간 청소한 뒤 두 번째 손님이 10시 20분에 입실하여 사용할 수 있으므로 방은 1개만 필요합니다. 입출력 예 #3 세 손님 모두 동일한 시간대를 예약했기 때문에 3개의 방이 필요합니다.",normal,Array
182,"메리는 여름을 맞아 무인도로 여행을 가기 위해 지도를 보고 있습니다. 지도에는 바다와 무인도들에 대한 정보가 표시돼 있습니다. 지도는 1 x 1크기의 사각형들로 이루어진 직사각형 격자 형태이며, 격자의 각 칸에는 'X' 또는 1에서 9 사이의 자연수가 적혀있습니다. 지도의 'X'는 바다를 나타내며, 숫자는 무인도를 나타냅니다. 이때, 상, 하, 좌, 우로 연결되는 땅들은 하나의 무인도를 이룹니다. 지도의 각 칸에 적힌 숫자는 식량을 나타내는데, 상, 하, 좌, 우로 연결되는 칸에 적힌 숫자를 모두 합한 값은 해당 무인도에서 최대 며칠동안 머물 수 있는지를 나타냅니다. 어떤 섬으로 놀러 갈지 못 정한 메리는 우선 각 섬에서 최대 며칠씩 머물 수 있는지 알아본 후 놀러갈 섬을 결정하려 합니다. 지도를 나타내는 문자열 배열 maps가 매개변수로 주어질 때, 각 섬에서 최대 며칠씩 머무를 수 있는지 배열에 오름차순으로 담아 return 하는 solution 함수를 완성해주세요. 만약 지낼 수 있는 무인도가 없다면 -1을 배열에 담아 return 해주세요. 제한사항 3 ≤ maps의 길이 ≤ 100 3 ≤ maps[i]의 길이 ≤ 100 maps[i]는 'X' 또는 1 과 9 사이의 자연수로 이루어진 문자열입니다. 지도는 직사각형 형태입니다. 입출력 예 maps result [""X591X"",""X1X5X"",""X231X"", ""1XXX1""] [1, 1, 27] [""XXX"",""XXX"",""XXX""] [-1] 입출력 예 설명 입출력 예 #1 위 문자열은 다음과 같은 지도를 나타냅니다. 연결된 땅들의 값을 합치면 다음과 같으며 이를 오름차순으로 정렬하면 [1, 1, 27]이 됩니다. 입출력 예 #2 위 문자열은 다음과 같은 지도를 나타냅니다. 섬이 존재하지 않기 때문에 -1을 배열에 담아 반환합니다.",normal,Array
183,"정수로 이루어진 배열 numbers가 있습니다. 배열 의 각 원소들에 대해 자신보다 뒤에 있는 숫자 중에서 자신보다 크면서 가장 가까이 있는 수를 뒷 큰수라고 합니다. 정수 배열 numbers가 매개변수로 주어질 때, 모든 원소에 대한 뒷 큰수들을 차례로 담은 배열을 return 하도록 solution 함수를 완성해주세요. 단, 뒷 큰수가 존재하지 않는 원소는 -1을 담습니다. 제한사항 4 ≤ numbers의 길이 ≤ 1,000,000 1 ≤ numbers[i] ≤ 1,000,000 입출력 예 numbers result [2, 3, 3, 5] [3, 5, 5, -1] [9, 1, 5, 3, 6, 2] [-1, 5, 6, 6, -1, -1] 입출력 예 설명 입출력 예 #1 2의 뒷 큰수는 3입니다. 첫 번째 3의 뒷 큰수는 5입니다. 두 번째 3 또한 마찬가지입니다. 5는 뒷 큰수가 없으므로 -1입니다. 위 수들을 차례대로 배열에 담으면 [3, 5, 5, -1]이 됩니다. 입출력 예 #2 9는 뒷 큰수가 없으므로 -1입니다. 1의 뒷 큰수는 5이며, 5와 3의 뒷 큰수는 6입니다. 6과 2는 뒷 큰수가 없으므로 -1입니다. 위 수들을 차례대로 배열에 담으면 [-1, 5, 6, 6, -1, -1]이 됩니다. ※ 공지 - 2025년 2월 10일 테스트케이스가 추가되었습니다.",normal,Array
184,"자연수 x를 y로 변환하려고 합니다. 사용할 수 있는 연산은 다음과 같습니다. x에 n을 더합니다 x에 2를 곱합니다. x에 3을 곱합니다. 자연수 x, y, n이 매개변수로 주어질 때, x를 y로 변환하기 위해 필요한 최소 연산 횟수를 return하도록 solution 함수를 완성해주세요. 이때 x를 y로 만들 수 없다면 -1을 return 해주세요. 제한사항 1 ≤ x ≤ y ≤ 1,000,000 1 ≤ n < y 입출력 예 x y n result 10 40 5 2 10 40 30 1 2 5 4 -1 입출력 예 설명 입출력 예 #1 x에 2를 2번 곱하면 40이 되고 이때가 최소 횟수입니다. 입출력 예 #2 x에 n인 30을 1번 더하면 40이 되고 이때가 최소 횟수입니다. 입출력 예 #3 x를 y로 변환할 수 없기 때문에 -1을 return합니다.",normal,Math
185,"어느 공원 놀이터에는 시소가 하나 설치되어 있습니다. 이 시소는 중심으로부터 2(m), 3(m), 4(m) 거리의 지점에 좌석이 하나씩 있습니다. 이 시소를 두 명이 마주 보고 탄다고 할 때, 시소가 평형인 상태에서 각각에 의해 시소에 걸리는 토크의 크기가 서로 상쇄되어 완전한 균형을 이룰 수 있다면 그 두 사람을 시소 짝꿍이라고 합니다. 즉, 탑승한 사람의 무게와 시소 축과 좌석 간의 거리의 곱이 양쪽 다 같다면 시소 짝꿍이라고 할 수 있습니다. 사람들의 몸무게 목록 weights이 주어질 때, 시소 짝꿍이 몇 쌍 존재하는지 구하여 return 하도록 solution 함수를 완성해주세요. 제한 사항 2 ≤ weights의 길이 ≤ 100,000 100 ≤ weights[i] ≤ 1,000 몸무게 단위는 N(뉴턴)으로 주어집니다. 몸무게는 모두 정수입니다. 입출력 예 weights result [100,180,360,100,270] 4 입출력 예 설명 {100, 100} 은 서로 같은 거리에 마주보고 앉으면 균형을 이룹니다. {180, 360} 은 각각 4(m), 2(m) 거리에 마주보고 앉으면 균형을 이룹니다. {180, 270} 은 각각 3(m), 2(m) 거리에 마주보고 앉으면 균형을 이룹니다. {270, 360} 은 각각 4(m), 3(m) 거리에 마주보고 앉으면 균형을 이룹니다.",normal,Math
186,"완호네 회사는 연말마다 1년 간의 인사고과에 따라 인센티브를 지급합니다. 각 사원마다 근무 태도 점수와 동료 평가 점수가 기록되어 있는데 만약 어떤 사원이 다른 임의의 사원보다 두 점수가 모두 낮은 경우가 한 번이라도 있다면 그 사원은 인센티브를 받지 못합니다. 그렇지 않은 사원들에 대해서는 두 점수의 합이 높은 순으로 석차를 내어 석차에 따라 인센티브가 차등 지급됩니다. 이때, 두 점수의 합이 동일한 사원들은 동석차이며, 동석차의 수만큼 다음 석차는 건너 뜁니다. 예를 들어 점수의 합이 가장 큰 사원이 2명이라면 1등이 2명이고 2등 없이 다음 석차는 3등부터입니다. 각 사원의 근무 태도 점수와 동료 평가 점수 목록 scores이 주어졌을 때, 완호의 석차를 return 하도록 solution 함수를 완성해주세요. 제한 사항 1 ≤ scores의 길이 ≤ 100,000 scores의 각 행은 한 사원의 근무 태도 점수와 동료 평가 점수를 나타내며 [a, b] 형태입니다. scores[0]은 완호의 점수입니다. 0 ≤ a, b ≤ 100,000 완호가 인센티브를 받지 못하는 경우 -1을 return 합니다. 입출력 예 scores result [[2,2],[1,4],[3,2],[3,2],[2,1]] 4 입출력 예 설명 5 번째 사원은 3 번째 또는 4 번째 사원보다 근무 태도 점수와 동료 평가 점수가 모두 낮기 때문에 인센티브를 받을 수 없습니다. 2 번째 사원, 3 번째 사원, 4 번째 사원은 두 점수의 합이 5 점으로 최고점이므로 1 등입니다. 1 등이 세 명이므로 2 등과 3 등은 없고 1 번째 사원인 완호는 두 점수의 합이 4 점으로 4 등입니다. ※ 공지 - 2024년 11월 4일 테스트케이스가 추가되었습니다. 기존에 제출한 코드가 통과하지 못할 수도 있습니다.",normal,Math
187,"다음은 어느 자동차 대여 회사에서 대여 중인 자동차들의 정보를 담은 CAR_RENTAL_COMPANY_CAR 테이블과 자동차 대여 기록 정보를 담은 CAR_RENTAL_COMPANY_RENTAL_HISTORY 테이블과 자동차 종류 별 대여 기간 종류 별 할인 정책 정보를 담은 CAR_RENTAL_COMPANY_DISCOUNT_PLAN 테이블 입니다. CAR_RENTAL_COMPANY_CAR 테이블은 아래와 같은 구조로 되어있으며, CAR_ID, CAR_TYPE, DAILY_FEE, OPTIONS 는 각각 자동차 ID, 자동차 종류, 일일 대여 요금(원), 자동차 옵션 리스트를 나타냅니다. Column name Type Nullable CAR_ID INTEGER FALSE CAR_TYPE VARCHAR(255) FALSE DAILY_FEE INTEGER FALSE OPTIONS VARCHAR(255) FALSE 자동차 종류는 '세단', 'SUV', '승합차', '트럭', '리무진' 이 있습니다. 자동차 옵션 리스트는 콤마(',')로 구분된 키워드 리스트(예: ''열선시트,스마트키,주차감지센서'')로 되어있으며, 키워드 종류는 '주차감지센서', '스마트키', '네비게이션', '통풍시트', '열선시트', '후방카메라', '가죽시트' 가 있습니다. CAR_RENTAL_COMPANY_RENTAL_HISTORY 테이블은 아래와 같은 구조로 되어있으며, HISTORY_ID, CAR_ID, START_DATE, END_DATE 는 각각 자동차 대여 기록 ID, 자동차 ID, 대여 시작일, 대여 종료일을 나타냅니다. Column name Type Nullable HISTORY_ID INTEGER FALSE CAR_ID INTEGER FALSE START_DATE DATE FALSE END_DATE DATE FALSE CAR_RENTAL_COMPANY_DISCOUNT_PLAN 테이블은 아래와 같은 구조로 되어있으며, PLAN_ID, CAR_TYPE, DURATION_TYPE, DISCOUNT_RATE 는 각각 요금 할인 정책 ID, 자동차 종류, 대여 기간 종류, 할인율(%)을 나타냅니다. Column name Type Nullable PLAN_ID INTEGER FALSE CAR_TYPE VARCHAR(255) FALSE DURATION_TYPE VARCHAR(255) FALSE DISCOUNT_RATE INTEGER FALSE 할인율이 적용되는 대여 기간 종류로는 '7일 이상' (대여 기간이 7일 이상 30일 미만인 경우), '30일 이상' (대여 기간이 30일 이상 90일 미만인 경우), '90일 이상' (대여 기간이 90일 이상인 경우) 이 있습니다. 대여 기간이 7일 미만인 경우 할인정책이 없습니다. 문제 CAR_RENTAL_COMPANY_CAR 테이블과 CAR_RENTAL_COMPANY_RENTAL_HISTORY 테이블과 CAR_RENTAL_COMPANY_DISCOUNT_PLAN 테이블에서 자동차 종류가 '트럭'인 자동차의 대여 기록에 대해서 대여 기록 별로 대여 금액(컬럼명: FEE)을 구하여 대여 기록 ID와 대여 금액 리스트를 출력하는 SQL문을 작성해주세요. 결과는 대여 금액을 기준으로 내림차순 정렬하고, 대여 금액이 같은 경우 대여 기록 ID를 기준으로 내림차순 정렬해주세요. 예시 예를 들어 CAR_RENTAL_COMPANY_CAR 테이블과 CAR_RENTAL_COMPANY_RENTAL_HISTORY 테이블과 CAR_RENTAL_COMPANY_DISCOUNT_PLAN 테이블이 다음과 같다면 CAR_ID CAR_TYPE DAILY_FEE OPTIONS 1 트럭 26000 가죽시트,열선시트,후방카메라 2 SUV 14000 스마트키,네비게이션,열선시트 3 트럭 32000 주차감지센서,후방카메라,가죽시트 HISTORY_ID CAR_ID START_DATE END_DATE 1 1 2022-07-27 2022-08-02 2 1 2022-08-03 2022-08-04 3 2 2022-08-05 2022-08-05 4 2 2022-08-09 2022-08-12 5 3 2022-09-16 2022-10-15 PLAN_ID CAR_TYPE DURATION_TYPE DISCOUNT_RATE 1 트럭 7일 이상 5% 2 트럭 30일 이상 7% 3 트럭 90일 이상 10% 4 세단 7일 이상 5% 5 세단 30일 이상 10% 6 세단 90일 이상 15% 자동차 종류가 '트럭' 인 자동차의 대여 기록에 대해서 대여 기간을 구하면, 대여 기록 ID가 1인 경우, 7일 대여 기록 ID가 2인 경우, 2일 대여 기록 ID가 5인 경우, 30일입니다. 대여 기간 별로 일일 대여 요금에 알맞은 할인율을 곱하여 금액을 구하면 다음과 같습니다. 대여 기록 ID가 1인 경우, 일일 대여 금액 26,000원에서 5% 할인율을 적용하고 7일을 곱하면 총 대여 금액은 172,900원 대여 기록 ID가 2인 경우, 일일 대여 금액 26,000원에 2일을 곱하면 총 대여 금액은 52,000원 대여 기록 ID가 5인 경우, 일일 대여 금액 32,000원에서 7% 할인율을 적용하고 30일을 곱하면 총 대여 금액은 892,800원이 되므로, 대여 금액을 기준으로 내림차순 정렬 및 대여 기록 ID를 기준으로 내림차순 정렬하면 다음과 같아야 합니다. HISTORY_ID FEE 5 892800 1 172900 2 52000 주의사항 FEE의 경우 예시처럼 정수부분만 출력되어야 합니다.",hard,database
188,"다음은 어느 자동차 대여 회사의 자동차 대여 기록 정보를 담은 CAR_RENTAL_COMPANY_RENTAL_HISTORY 테이블입니다. CAR_RENTAL_COMPANY_RENTAL_HISTORY 테이블은 아래와 같은 구조로 되어있으며, HISTORY_ID, CAR_ID, START_DATE, END_DATE 는 각각 자동차 대여 기록 ID, 자동차 ID, 대여 시작일, 대여 종료일을 나타냅니다. Column name Type Nullable HISTORY_ID INTEGER FALSE CAR_ID INTEGER FALSE START_DATE DATE FALSE END_DATE DATE FALSE 문제 CAR_RENTAL_COMPANY_RENTAL_HISTORY 테이블에서 대여 시작일을 기준으로 2022년 8월부터 2022년 10월까지 총 대여 횟수가 5회 이상인 자동차들에 대해서 해당 기간 동안의 월별 자동차 ID 별 총 대여 횟수(컬럼명: RECORDS) 리스트를 출력하는 SQL문을 작성해주세요. 결과는 월을 기준으로 오름차순 정렬하고, 월이 같다면 자동차 ID를 기준으로 내림차순 정렬해주세요. 특정 월의 총 대여 횟수가 0인 경우에는 결과에서 제외해주세요. 예시 예를 들어 CAR_RENTAL_COMPANY_RENTAL_HISTORY 테이블이 다음과 같다면 HISTORY_ID CAR_ID START_DATE END_DATE 1 1 2022-07-27 2022-08-02 2 1 2022-08-03 2022-08-04 3 2 2022-08-05 2022-08-05 4 2 2022-08-09 2022-08-12 5 3 2022-09-16 2022-10-15 6 1 2022-08-24 2022-08-30 7 3 2022-10-16 2022-10-19 8 1 2022-09-03 2022-09-07 9 1 2022-09-18 2022-09-19 10 2 2022-09-08 2022-09-10 11 2 2022-10-16 2022-10-19 12 1 2022-09-29 2022-10-06 13 2 2022-10-30 2022-11-01 14 2 2022-11-05 2022-11-05 15 3 2022-11-11 2022-11-11 대여 시작일을 기준으로 총 대여 횟수가 5회 이상인 자동차는 자동차 ID가 1, 2인 자동차입니다. 월 별 자동차 ID별 총 대여 횟수를 구하고 월 오름차순, 자동차 ID 내림차순으로 정렬하면 다음과 같이 나와야 합니다. MONTH CAR_ID RECORDS 8 2 2 8 1 2 9 2 1 9 1 3 10 2 2",normal,database
189,"다음은 어느 자동차 대여 회사의 자동차 대여 기록 정보를 담은 CAR_RENTAL_COMPANY_RENTAL_HISTORY 테이블입니다. CAR_RENTAL_COMPANY_RENTAL_HISTORY 테이블은 아래와 같은 구조로 되어있으며, HISTORY_ID, CAR_ID, START_DATE, END_DATE 는 각각 자동차 대여 기록 ID, 자동차 ID, 대여 시작일, 대여 종료일을 나타냅니다. Column name Type Nullable HISTORY_ID INTEGER FALSE CAR_ID INTEGER FALSE START_DATE DATE FALSE END_DATE DATE FALSE 문제 CAR_RENTAL_COMPANY_RENTAL_HISTORY 테이블에서 대여 시작일이 2022년 9월에 속하는 대여 기록에 대해서 대여 기간이 30일 이상이면 '장기 대여' 그렇지 않으면 '단기 대여' 로 표시하는 컬럼(컬럼명: RENT_TYPE)을 추가하여 대여기록을 출력하는 SQL문을 작성해주세요. 결과는 대여 기록 ID를 기준으로 내림차순 정렬해주세요. 예시 예를 들어 CAR_RENTAL_COMPANY_RENTAL_HISTORY 테이블이 다음과 같다면 HISTORY_ID CAR_ID START_DATE END_DATE 1 4 2022-09-27 2022-11-27 2 3 2022-10-03 2022-11-04 3 2 2022-09-05 2022-09-05 4 1 2022-09-01 2022-09-30 5 3 2022-09-16 2022-10-15 2022년 9월의 대여 기록 중 '장기 대여' 에 해당하는 기록은 대여 기록 ID가 1, 4인 기록이고, '단기 대여' 에 해당하는 기록은 대여 기록 ID가 3, 5 인 기록이므로 대여 기록 ID를 기준으로 내림차순 정렬하면 다음과 같이 나와야 합니다. HISTORY_ID CAR_ID START_DATE END_DATE RENT_TYPE 5 3 2022-09-16 2022-10-13 단기 대여 4 1 2022-09-01 2022-09-30 장기 대여 3 2 2022-09-05 2022-09-05 단기 대여 1 4 2022-09-27 2022-10-26 장기 대여 주의사항 START_DATE와 END_DATE의 경우 예시의 데이트 포맷과 동일해야 정답처리 됩니다.",easy,database
190,"다음은 어느 자동차 대여 회사에서 대여중인 자동차들의 정보를 담은 CAR_RENTAL_COMPANY_CAR 테이블입니다. CAR_RENTAL_COMPANY_CAR 테이블은 아래와 같은 구조로 되어있으며, CAR_ID, CAR_TYPE, DAILY_FEE, OPTIONS 는 각각 자동차 ID, 자동차 종류, 일일 대여 요금(원), 자동차 옵션 리스트를 나타냅니다. Column name Type Nullable CAR_ID INTEGER FALSE CAR_TYPE VARCHAR(255) FALSE DAILY_FEE INTEGER FALSE OPTIONS VARCHAR(255) FALSE 자동차 종류는 '세단', 'SUV', '승합차', '트럭', '리무진' 이 있습니다. 자동차 옵션 리스트는 콤마(',')로 구분된 키워드 리스트(옵션 리스트 값 예시: '열선시트', '스마트키', '주차감지센서')로 되어있으며, 키워드 종류는 '주차감지센서', '스마트키', '네비게이션', '통풍시트', '열선시트', '후방카메라', '가죽시트' 가 있습니다. 문제 CAR_RENTAL_COMPANY_CAR 테이블에서 '통풍시트', '열선시트', '가죽시트' 중 하나 이상의 옵션이 포함된 자동차가 자동차 종류 별로 몇 대인지 출력하는 SQL문을 작성해주세요. 이때 자동차 수에 대한 컬럼명은 CARS로 지정하고, 결과는 자동차 종류를 기준으로 오름차순 정렬해주세요. 예시 예를 들어 CAR_RENTAL_COMPANY_CAR 테이블이 다음과 같다면 CAR_ID CAR_TYPE DAILY_FEE OPTIONS 1 세단 16000 가죽시트,열선시트,후방카메라 2 SUV 14000 스마트키,네비게이션,열선시트 3 SUV 22000 주차감지센서,후방카메라 4 트럭 35000 주차감지센서,네비게이션,열선시트 5 SUV 16000 가죽시트,네비게이션,열선시트,후방카메라,주차감지센서 '통풍시트', '열선시트', '가죽시트' 중 하나 이상의 옵션이 포함된 자동차는 자동차 ID가 1, 2, 4, 5인 자동차이고, 자동차 종류 별로 몇 대인지 구하고 자동차 종류를 기준으로 오름차순 정렬하면 다음과 같은 결과가 나와야 합니다. CAR_TYPE CARS SUV 2 세단 1 트럭 1",normal,database
191,"다음은 어느 자동차 대여 회사에서 대여중인 자동차들의 정보를 담은 CAR_RENTAL_COMPANY_CAR 테이블입니다. CAR_RENTAL_COMPANY_CAR 테이블은 아래와 같은 구조로 되어있으며, CAR_ID, CAR_TYPE, DAILY_FEE, OPTIONS 는 각각 자동차 ID, 자동차 종류, 일일 대여 요금(원), 자동차 옵션 리스트를 나타냅니다. Column name Type Nullable CAR_ID INTEGER FALSE CAR_TYPE VARCHAR(255) FALSE DAILY_FEE INTEGER FALSE OPTIONS VARCHAR(255) FALSE 자동차 종류는 '세단', 'SUV', '승합차', '트럭', '리무진' 이 있습니다. 자동차 옵션 리스트는 콤마(',')로 구분된 키워드 리스트(예: '열선시트', '스마트키', '주차감지센서')로 되어있으며, 키워드 종류는 '주차감지센서', '스마트키', '네비게이션', '통풍시트', '열선시트', '후방카메라', '가죽시트' 가 있습니다. 문제 CAR_RENTAL_COMPANY_CAR 테이블에서 자동차 종류가 'SUV'인 자동차들의 평균 일일 대여 요금을 출력하는 SQL문을 작성해주세요. 이때 평균 일일 대여 요금은 소수 첫 번째 자리에서 반올림하고, 컬럼명은 AVERAGE_FEE 로 지정해주세요. 예시 예를 들어 CAR_RENTAL_COMPANY_CAR 테이블이 다음과 같다면 CAR_ID CAR_TYPE DAILY_FEE OPTIONS 1 세단 16000 가죽시트,열선시트,후방카메라 2 SUV 14000 스마트키,네비게이션,열선시트 3 SUV 22000 주차감지센서,후방카메라,가죽시트 'SUV' 에 해당하는 자동차들의 평균 일일 대여 요금은 18,000 원 이므로, 다음과 같은 결과가 나와야 합니다. AVERAGE_FEE 18000",easy,database
192,"고객의 약관 동의를 얻어서 수집된 1~n번으로 분류되는 개인정보 n개가 있습니다. 약관 종류는 여러 가지 있으며 각 약관마다 개인정보 보관 유효기간이 정해져 있습니다. 당신은 각 개인정보가 어떤 약관으로 수집됐는지 알고 있습니다. 수집된 개인정보는 유효기간 전까지만 보관 가능하며, 유효기간이 지났다면 반드시 파기해야 합니다. 예를 들어, A라는 약관의 유효기간이 12 달이고, 2021년 1월 5일에 수집된 개인정보가 A약관으로 수집되었다면 해당 개인정보는 2022년 1월 4일까지 보관 가능하며 2022년 1월 5일부터 파기해야 할 개인정보입니다. 당신은 오늘 날짜로 파기해야 할 개인정보 번호들을 구하려 합니다. 모든 달은 28일까지 있다고 가정합니다. 다음은 오늘 날짜가 2022.05.19일 때의 예시입니다. 약관 종류 유효기간 A 6 달 B 12 달 C 3 달 번호 개인정보 수집 일자 약관 종류 1 2021.05.02 A 2 2021.07.01 B 3 2022.02.19 C 4 2022.02.20 C 첫 번째 개인정보는 A약관에 의해 2021년 11월 1일까지 보관 가능하며, 유효기간이 지났으므로 파기해야 할 개인정보입니다. 두 번째 개인정보는 B약관에 의해 2022년 6월 28일까지 보관 가능하며, 유효기간이 지나지 않았으므로 아직 보관 가능합니다. 세 번째 개인정보는 C약관에 의해 2022년 5월 18일까지 보관 가능하며, 유효기간이 지났으므로 파기해야 할 개인정보입니다. 네 번째 개인정보는 C약관에 의해 2022년 5월 19일까지 보관 가능하며, 유효기간이 지나지 않았으므로 아직 보관 가능합니다. 따라서 파기해야 할 개인정보 번호는 [1, 3]입니다. 오늘 날짜를 의미하는 문자열 today, 약관의 유효기간을 담은 1차원 문자열 배열 terms와 수집된 개인정보의 정보를 담은 1차원 문자열 배열 privacies가 매개변수로 주어집니다. 이때 파기해야 할 개인정보의 번호를 오름차순으로 1차원 정수 배열에 담아 return 하도록 solution 함수를 완성해 주세요. 제한사항 today는 ""YYYY.MM.DD"" 형태로 오늘 날짜를 나타냅니다. 1 ≤ terms의 길이 ≤ 20 terms의 원소는 ""약관 종류 유효기간"" 형태의 약관 종류와 유효기간을 공백 하나로 구분한 문자열입니다. 약관 종류는 A~Z중 알파벳 대문자 하나이며, terms 배열에서 약관 종류는 중복되지 않습니다. 유효기간은 개인정보를 보관할 수 있는 달 수를 나타내는 정수이며, 1 이상 100 이하입니다. 1 ≤ privacies의 길이 ≤ 100 privacies[i]는 i+1번 개인정보의 수집 일자와 약관 종류를 나타냅니다. privacies의 원소는 ""날짜 약관 종류"" 형태의 날짜와 약관 종류를 공백 하나로 구분한 문자열입니다. 날짜는 ""YYYY.MM.DD"" 형태의 개인정보가 수집된 날짜를 나타내며, today 이전의 날짜만 주어집니다. privacies의 약관 종류는 항상 terms에 나타난 약관 종류만 주어집니다. today와 privacies에 등장하는 날짜의 YYYY는 연도, MM은 월, DD는 일을 나타내며 점(.) 하나로 구분되어 있습니다. 2000 ≤ YYYY ≤ 2022 1 ≤ MM ≤ 12 MM이 한 자릿수인 경우 앞에 0이 붙습니다. 1 ≤ DD ≤ 28 DD가 한 자릿수인 경우 앞에 0이 붙습니다. 파기해야 할 개인정보가 하나 이상 존재하는 입력만 주어집니다. 입출력 예 today terms privacies result ""2022.05.19"" [""A 6"", ""B 12"", ""C 3""] [""2021.05.02 A"", ""2021.07.01 B"", ""2022.02.19 C"", ""2022.02.20 C""] [1, 3] ""2020.01.01"" [""Z 3"", ""D 5""] [""2019.01.01 D"", ""2019.11.15 Z"", ""2019.08.02 D"", ""2019.07.01 D"", ""2018.12.28 Z""] [1, 4, 5] 입출력 예 설명 입출력 예 #1 문제 예시와 같습니다. 입출력 예 #2 약관 종류 유효기간 Z 3 달 D 5 달 번호 개인정보 수집 일자 약관 종류 1 2019.01.01 D 2 2019.11.15 Z 3 2019.08.02 D 4 2019.07.01 D 5 2018.12.28 Z 오늘 날짜는 2020년 1월 1일입니다. 첫 번째 개인정보는 D약관에 의해 2019년 5월 28일까지 보관 가능하며, 유효기간이 지났으므로 파기해야 할 개인정보입니다. 두 번째 개인정보는 Z약관에 의해 2020년 2월 14일까지 보관 가능하며, 유효기간이 지나지 않았으므로 아직 보관 가능합니다. 세 번째 개인정보는 D약관에 의해 2020년 1월 1일까지 보관 가능하며, 유효기간이 지나지 않았으므로 아직 보관 가능합니다. 네 번째 개인정보는 D약관에 의해 2019년 11월 28일까지 보관 가능하며, 유효기간이 지났으므로 파기해야 할 개인정보입니다. 다섯 번째 개인정보는 Z약관에 의해 2019년 3월 27일까지 보관 가능하며, 유효기간이 지났으므로 파기해야 할 개인정보입니다.",easy,Array
193,"당신은 일렬로 나열된 n개의 집에 택배를 배달하려 합니다. 배달할 물건은 모두 크기가 같은 재활용 택배 상자에 담아 배달하며, 배달을 다니면서 빈 재활용 택배 상자들을 수거하려 합니다. 배달할 택배들은 모두 재활용 택배 상자에 담겨서 물류창고에 보관되어 있고, i번째 집은 물류창고에서 거리 i만큼 떨어져 있습니다. 또한 i번째 집은 j번째 집과 거리 j - i만큼 떨어져 있습니다. (1 ≤ i ≤ j ≤ n) 트럭에는 재활용 택배 상자를 최대 cap개 실을 수 있습니다. 트럭은 배달할 재활용 택배 상자들을 실어 물류창고에서 출발해 각 집에 배달하면서, 빈 재활용 택배 상자들을 수거해 물류창고에 내립니다. 각 집마다 배달할 재활용 택배 상자의 개수와 수거할 빈 재활용 택배 상자의 개수를 알고 있을 때, 트럭 하나로 모든 배달과 수거를 마치고 물류창고까지 돌아올 수 있는 최소 이동 거리를 구하려 합니다. 각 집에 배달 및 수거할 때, 원하는 개수만큼 택배를 배달 및 수거할 수 있습니다. 다음은 cap=4 일 때, 최소 거리로 이동하면서 5개의 집에 배달 및 수거하는 과정을 나타낸 예시입니다. 배달 및 수거할 재활용 택배 상자 개수 집 #1 집 #2 집 #3 집 #4 집 #5 배달 1개 0개 3개 1개 2개 수거 0개 3개 0개 4개 0개 배달 및 수거 과정 집 #1 집 #2 집 #3 집 #4 집 #5 설명 남은 배달/수거 1/0 0/3 3/0 1/4 2/0 물류창고에서 택배 3개를 트럭에 실어 출발합니다. 남은 배달/수거 1/0 0/3 3/0 0/4 0/0 물류창고에서 5번째 집까지 이동하면서(거리 5) 4번째 집에 택배 1개를 배달하고, 5번째 집에 택배 2개를 배달합니다. 남은 배달/수거 1/0 0/3 3/0 0/0 0/0 5번째 집에서 물류창고까지 이동하면서(거리 5) 4번째 집에서 빈 택배 상자 4개를 수거한 후, 수거한 빈 택배 상자를 물류창고에 내리고 택배 4개를 트럭에 싣습니다. 남은 배달/수거 0/0 0/3 0/0 0/0 0/0 물류창고에서 3번째 집까지 이동하면서(거리 3) 1번째 집에 택배 1개를 배달하고, 3번째 집에 택배 3개를 배달합니다. 남은 배달/수거 0/0 0/0 0/0 0/0 0/0 3번째 집에서 물류창고까지 이동하면서(거리 3) 2번째 집에서 빈 택배 상자 3개를 수거한 후, 수거한 빈 택배 상자를 물류창고에 내립니다. 16(=5+5+3+3)의 거리를 이동하면서 모든 배달 및 수거를 마쳤습니다. 같은 거리로 모든 배달 및 수거를 마치는 다른 방법이 있지만, 이보다 짧은 거리로 모든 배달 및 수거를 마치는 방법은 없습니다. 트럭에 실을 수 있는 재활용 택배 상자의 최대 개수를 나타내는 정수 cap, 배달할 집의 개수를 나타내는 정수 n, 각 집에 배달할 재활용 택배 상자의 개수를 담은 1차원 정수 배열 deliveries와 각 집에서 수거할 빈 재활용 택배 상자의 개수를 담은 1차원 정수 배열 pickups가 매개변수로 주어집니다. 이때, 트럭 하나로 모든 배달과 수거를 마치고 물류창고까지 돌아올 수 있는 최소 이동 거리를 return 하도록 solution 함수를 완성해 주세요. 제한사항 1 ≤ cap ≤ 50 1 ≤ n ≤ 100,000 deliveries의 길이 = pickups의 길이 = n deliveries[i]는 i+1번째 집에 배달할 재활용 택배 상자의 개수를 나타냅니다. pickups[i]는 i+1번째 집에서 수거할 빈 재활용 택배 상자의 개수를 나타냅니다. 0 ≤ deliveries의 원소 ≤ 50 0 ≤ pickups의 원소 ≤ 50 트럭의 초기 위치는 물류창고입니다. 입출력 예 cap n deliveries pickups result 4 5 [1, 0, 3, 1, 2] [0, 3, 0, 4, 0] 16 2 7 [1, 0, 2, 0, 1, 0, 2] [0, 2, 0, 1, 0, 2, 0] 30 입출력 예 설명 입출력 예 #1 문제 예시와 동일합니다. 입출력 예 #2 배달 및 수거할 재활용 택배 상자 개수 집 #1 집 #2 집 #3 집 #4 집 #5 집 #6 집 #7 배달 1개 0개 2개 0개 1개 0개 2개 수거 0개 2개 0개 1개 0개 2개 0개 배달 및 수거 과정 집 #1 집 #2 집 #3 집 #4 집 #5 집 #6 집 #7 설명 남은 배달/수거 1/0 0/2 2/0 0/1 1/0 0/2 2/0 물류창고에서 택배 2개를 트럭에 실어 출발합니다. 남은 배달/수거 1/0 0/2 2/0 0/1 1/0 0/2 0/0 물류창고에서 7번째 집까지 이동하면서(거리 7) 7번째 집에 택배 2개를 배달합니다. 남은 배달/수거 1/0 0/2 2/0 0/1 1/0 0/0 0/0 7번째 집에서 물류창고까지 이동하면서(거리 7) 6번째 집에서 빈 택배 상자 2개를 수거한 후, 수거한 빈 택배 상자를 물류창고에 내리고 택배 2개를 트럭에 싣습니다. 남은 배달/수거 1/0 0/2 1/0 0/1 0/0 0/0 0/0 물류창고에서 5번째 집까지 이동하면서(거리 5) 3번째 집에 택배 1개를 배달하고, 5번째 집에 택배 1개를 배달합니다. 남은 배달/수거 1/0 0/1 1/0 0/0 0/0 0/0 0/0 5번째 집에서 물류창고까지 이동하면서(거리 5) 4번째 집에서 빈 택배 상자 1개를 수거하고 2번째 집에서 빈 택배 상자 1개를 수거한 후, 수거한 빈 택배 상자를 물류창고에 내리고 택배 2개를 트럭에 싣습니다. 남은 배달/수거 0/0 0/1 0/0 0/0 0/0 0/0 0/0 물류창고에서 3번째 집까지 이동하면서(거리 3) 1번째 집에 택배 1개를 배달하고, 3번째 집에 택배 1개를 배달합니다. 남은 배달/수거 0/0 0/0 0/0 0/0 0/0 0/0 0/0 3번째 집에서 물류창고까지 이동하면서(거리 3) 2번째 집에서 빈 택배 상자 1개를 수거한 후, 수거한 빈 택배 상자를 물류창고에 내립니다. 30(=7+7+5+5+3+3)의 거리를 이동하면서 모든 배달 및 수거를 마쳤습니다. 같은 거리로 모든 배달 및 수거를 마치는 다른 방법이 있지만, 이보다 짧은 거리로 모든 배달 및 수거를 마치는 방법은 없습니다. 따라서, 30을 return 하면 됩니다.",normal,Array
194,"카카오톡에서는 이모티콘을 무제한으로 사용할 수 있는 이모티콘 플러스 서비스 가입자 수를 늘리려고 합니다. 이를 위해 카카오톡에서는 이모티콘 할인 행사를 하는데, 목표는 다음과 같습니다. 이모티콘 플러스 서비스 가입자를 최대한 늘리는 것. 이모티콘 판매액을 최대한 늘리는 것. 1번 목표가 우선이며, 2번 목표가 그 다음입니다. 이모티콘 할인 행사는 다음과 같은 방식으로 진행됩니다. n명의 카카오톡 사용자들에게 이모티콘 m개를 할인하여 판매합니다. 이모티콘마다 할인율은 다를 수 있으며, 할인율은 10%, 20%, 30%, 40% 중 하나로 설정됩니다. 카카오톡 사용자들은 다음과 같은 기준을 따라 이모티콘을 사거나, 이모티콘 플러스 서비스에 가입합니다. 각 사용자들은 자신의 기준에 따라 일정 비율 이상 할인하는 이모티콘을 모두 구매합니다. 각 사용자들은 자신의 기준에 따라 이모티콘 구매 비용의 합이 일정 가격 이상이 된다면, 이모티콘 구매를 모두 취소하고 이모티콘 플러스 서비스에 가입합니다. 다음은 2명의 카카오톡 사용자와 2개의 이모티콘이 있을때의 예시입니다. 사용자 비율 가격 1 40 10,000 2 25 10,000 이모티콘 가격 1 7,000 2 9,000 1번 사용자는 40%이상 할인하는 이모티콘을 모두 구매하고, 이모티콘 구매 비용이 10,000원 이상이 되면 이모티콘 구매를 모두 취소하고 이모티콘 플러스 서비스에 가입합니다. 2번 사용자는 25%이상 할인하는 이모티콘을 모두 구매하고, 이모티콘 구매 비용이 10,000원 이상이 되면 이모티콘 구매를 모두 취소하고 이모티콘 플러스 서비스에 가입합니다. 1번 이모티콘의 가격은 7,000원, 2번 이모티콘의 가격은 9,000원입니다. 만약, 2개의 이모티콘을 모두 40%씩 할인한다면, 1번 사용자와 2번 사용자 모두 1,2번 이모티콘을 구매하게 되고, 결과는 다음과 같습니다. 사용자 구매한 이모티콘 이모티콘 구매 비용 이모티콘 플러스 서비스 가입 여부 1 1, 2 9,600 X 2 1, 2 9,600 X 이모티콘 플러스 서비스 가입자는 0명이 늘어나고 이모티콘 판매액은 19,200원이 늘어납니다. 하지만, 1번 이모티콘을 30% 할인하고 2번 이모티콘을 40% 할인한다면 결과는 다음과 같습니다. 사용자 구매한 이모티콘 이모티콘 구매 비용 이모티콘 플러스 서비스 가입 여부 1 2 5,400 X 2 1, 2 10,300 O 2번 사용자는 이모티콘 구매 비용을 10,000원 이상 사용하여 이모티콘 구매를 모두 취소하고 이모티콘 플러스 서비스에 가입하게 됩니다. 따라서, 이모티콘 플러스 서비스 가입자는 1명이 늘어나고 이모티콘 판매액은 5,400원이 늘어나게 됩니다. 카카오톡 사용자 n명의 구매 기준을 담은 2차원 정수 배열 users, 이모티콘 m개의 정가를 담은 1차원 정수 배열 emoticons가 주어집니다. 이때, 행사 목적을 최대한으로 달성했을 때의 이모티콘 플러스 서비스 가입 수와 이모티콘 매출액을 1차원 정수 배열에 담아 return 하도록 solution 함수를 완성해주세요. 제한사항 1 ≤ users의 길이 = n ≤ 100 users의 원소는 [비율, 가격]의 형태입니다. users[i]는 i+1번 고객의 구매 기준을 의미합니다. 비율% 이상의 할인이 있는 이모티콘을 모두 구매한다는 의미입니다. 1 ≤ 비율 ≤ 40 가격이상의 돈을 이모티콘 구매에 사용한다면, 이모티콘 구매를 모두 취소하고 이모티콘 플러스 서비스에 가입한다는 의미입니다. 100 ≤ 가격 ≤ 1,000,000 가격은 100의 배수입니다. 1 ≤ emoticons의 길이 = m ≤ 7 emoticons[i]는 i+1번 이모티콘의 정가를 의미합니다. 100 ≤ emoticons의 원소 ≤ 1,000,000 emoticons의 원소는 100의 배수입니다. 입출력 예 users emoticons result [[40, 10000], [25, 10000]] [7000, 9000] [1, 5400] [[40, 2900], [23, 10000], [11, 5200], [5, 5900], [40, 3100], [27, 9200], [32, 6900]] [1300, 1500, 1600, 4900] [4, 13860] 입출력 예 설명 입출력 예 #1 문제의 예시와 같습니다. 입출력 예 #2 다음과 같이 할인하는 것이 이모티콘 플러스 서비스 가입자를 최대한 늘리면서, 이모티콘 판매액 또한 최대로 늘리는 방법입니다. 이모티콘 할인율 1 40 2 40 3 20 4 40 위와 같이 할인하면 4명의 이모티콘 플러스 가입자와 13,860원의 판매액을 달성할 수 있습니다. 다른 할인율을 적용하여 이모티콘을 판매할 수 있지만 이보다 이모티콘 플러스 서비스 가입자를 최대한 늘리면서, 이모티콘 판매액 또한 최대로 늘리는 방법은 없습니다. 따라서, [4, 13860]을 return 하면 됩니다.",normal,Array
195,"당신은 이진트리를 수로 표현하는 것을 좋아합니다. 이진트리를 수로 표현하는 방법은 다음과 같습니다. 이진수를 저장할 빈 문자열을 생성합니다. 주어진 이진트리에 더미 노드를 추가하여 포화 이진트리로 만듭니다. 루트 노드는 그대로 유지합니다. 만들어진 포화 이진트리의 노드들을 가장 왼쪽 노드부터 가장 오른쪽 노드까지, 왼쪽에 있는 순서대로 살펴봅니다. 노드의 높이는 살펴보는 순서에 영향을 끼치지 않습니다. 살펴본 노드가 더미 노드라면, 문자열 뒤에 0을 추가합니다. 살펴본 노드가 더미 노드가 아니라면, 문자열 뒤에 1을 추가합니다. 문자열에 저장된 이진수를 십진수로 변환합니다. 이진트리에서 리프 노드가 아닌 노드는 자신의 왼쪽 자식이 루트인 서브트리의 노드들보다 오른쪽에 있으며, 자신의 오른쪽 자식이 루트인 서브트리의 노드들보다 왼쪽에 있다고 가정합니다. 다음은 이진트리를 수로 표현하는 예시입니다. 주어진 이진트리는 다음과 같습니다. 주어진 이진트리에 더미노드를 추가하여 포화 이진트리로 만들면 다음과 같습니다. 더미 노드는 점선으로 표시하였고, 노드 안의 수는 살펴보는 순서를 의미합니다. 노드들을 왼쪽에 있는 순서대로 살펴보며 0과 1을 생성한 문자열에 추가하면 ""0111010""이 됩니다. 이 이진수를 십진수로 변환하면 58입니다. 당신은 수가 주어졌을때, 하나의 이진트리로 해당 수를 표현할 수 있는지 알고 싶습니다. 이진트리로 만들고 싶은 수를 담은 1차원 정수 배열 numbers가 주어집니다. numbers에 주어진 순서대로 하나의 이진트리로 해당 수를 표현할 수 있다면 1을, 표현할 수 없다면 0을 1차원 정수 배열에 담아 return 하도록 solution 함수를 완성해주세요. 제한사항 1 ≤ numbers의 길이 ≤ 10,000 1 ≤ numbers의 원소 ≤ 1015 입출력 예 numbers result [7, 42, 5] [1, 1, 0] [63, 111, 95] [1, 1, 0] 입출력 예 설명 입출력 예 #1 7은 다음과 같은 이진트리로 표현할 수 있습니다. 42는 다음과 같은 이진트리로 표현할 수 있습니다. 5는 이진트리로 표현할 수 없습니다. 따라서, [1, 0]을 return 하면 됩니다. 입출력 예 #2 63은 다음과 같은 이진트리로 표현할 수 있습니다. 111은 다음과 같은 이진트리로 표현할 수 있습니다. 95는 이진트리로 표현할 수 없습니다. 따라서, [1, 1, 0]을 return 하면 됩니다.",normal,Array
196,"당신은 표 편집 프로그램을 작성하고 있습니다. 표의 크기는 50 × 50으로 고정되어있고 초기에 모든 셀은 비어 있습니다. 각 셀은 문자열 값을 가질 수 있고, 다른 셀과 병합될 수 있습니다. 위에서 r번째, 왼쪽에서 c번째 위치를 (r, c)라고 표현할 때, 당신은 다음 명령어들에 대한 기능을 구현하려고 합니다. ""UPDATE r c value"" (r, c) 위치의 셀을 선택합니다. 선택한 셀의 값을 value로 바꿉니다. ""UPDATE value1 value2"" value1을 값으로 가지고 있는 모든 셀을 선택합니다. 선택한 셀의 값을 value2로 바꿉니다. ""MERGE r1 c1 r2 c2"" (r1, c1) 위치의 셀과 (r2, c2) 위치의 셀을 선택하여 병합합니다. 선택한 두 위치의 셀이 같은 셀일 경우 무시합니다. 선택한 두 셀은 서로 인접하지 않을 수도 있습니다. 이 경우 (r1, c1) 위치의 셀과 (r2, c2) 위치의 셀만 영향을 받으며, 그 사이에 위치한 셀들은 영향을 받지 않습니다. 두 셀 중 한 셀이 값을 가지고 있을 경우 병합된 셀은 그 값을 가지게 됩니다. 두 셀 모두 값을 가지고 있을 경우 병합된 셀은 (r1, c1) 위치의 셀 값을 가지게 됩니다. 이후 (r1, c1) 와 (r2, c2) 중 어느 위치를 선택하여도 병합된 셀로 접근합니다. ""UNMERGE r c"" (r, c) 위치의 셀을 선택하여 해당 셀의 모든 병합을 해제합니다. 선택한 셀이 포함하고 있던 모든 셀은 프로그램 실행 초기의 상태로 돌아갑니다. 병합을 해제하기 전 셀이 값을 가지고 있었을 경우 (r, c) 위치의 셀이 그 값을 가지게 됩니다. ""PRINT r c"" (r, c) 위치의 셀을 선택하여 셀의 값을 출력합니다. 선택한 셀이 비어있을 경우 ""EMPTY""를 출력합니다. 아래는 UPDATE 명령어를 실행하여 빈 셀에 값을 입력하는 예시입니다. commands 효과 UPDATE 1 1 menu (1,1)에 ""menu"" 입력 UPDATE 1 2 category (1,2)에 ""category"" 입력 UPDATE 2 1 bibimbap (2,1)에 ""bibimbap"" 입력 UPDATE 2 2 korean (2,2)에 ""korean"" 입력 UPDATE 2 3 rice (2,3)에 ""rice"" 입력 UPDATE 3 1 ramyeon (3,1)에 ""ramyeon"" 입력 UPDATE 3 2 korean (3,2)에 ""korean"" 입력 UPDATE 3 3 noodle (3,3)에 ""noodle"" 입력 UPDATE 3 4 instant (3,4)에 ""instant"" 입력 UPDATE 4 1 pasta (4,1)에 ""pasta"" 입력 UPDATE 4 2 italian (4,2)에 ""italian"" 입력 UPDATE 4 3 noodle (4,3)에 ""noodle"" 입력 위 명령어를 실행하면 아래 그림과 같은 상태가 됩니다. 아래는 MERGE 명령어를 실행하여 셀을 병합하는 예시입니다. commands 효과 MERGE 1 2 1 3 (1,2)와 (1,3) 병합 MERGE 1 3 1 4 (1,3)과 (1,4) 병합 위 명령어를 실행하면 아래와 같은 상태가 됩니다. 병합한 셀은 ""category"" 값을 가지게 되며 (1,2), (1,3), (1,4) 중 어느 위치를 선택하더라도 접근할 수 있습니다. 아래는 UPDATE 명령어를 실행하여 셀의 값을 변경하는 예시입니다. commands 효과 UPDATE korean hansik ""korean""을 ""hansik""으로 변경 UPDATE 1 3 group (1,3) 위치의 셀 값을 ""group""으로 변경 위 명령어를 실행하면 아래와 같은 상태가 됩니다. 아래는 UNMERGE 명령어를 실행하여 셀의 병합을 해제하는 예시입니다. commands 효과 UNMERGE 1 4 셀 병합 해제 후 원래 값은 (1,4)가 가짐 위 명령어를 실행하면 아래와 같은 상태가 됩니다. 실행할 명령어들이 담긴 1차원 문자열 배열 commands가 매개변수로 주어집니다. commands의 명령어들을 순서대로 실행하였을 때, ""PRINT r c"" 명령어에 대한 실행결과를 순서대로 1차원 문자열 배열에 담아 return 하도록 solution 함수를 완성해주세요. 제한사항 1 ≤ commands의 길이 ≤ 1,000 commands의 각 원소는 아래 5가지 형태 중 하나입니다. ""UPDATE r c value"" r, c는 선택할 셀의 위치를 나타내며, 1~50 사이의 정수입니다. value는 셀에 입력할 내용을 나타내며, 알파벳 소문자와 숫자로 구성된 길이 1~10 사이인 문자열입니다. ""UPDATE value1 value2"" value1은 선택할 셀의 값, value2는 셀에 입력할 내용을 나타내며, 알파벳 소문자와 숫자로 구성된 길이 1~10 사이인 문자열입니다. ""MERGE r1 c1 r2 c2"" r1, c1, r2, c2는 선택할 셀의 위치를 나타내며, 1~50 사이의 정수입니다. ""UNMERGE r c"" r, c는 선택할 셀의 위치를 나타내며, 1~50 사이의 정수입니다. ""PRINT r c"" r, c는 선택할 셀의 위치를 나타내며, 1~50 사이의 정수입니다. commands는 1개 이상의 ""PRINT r c"" 명령어를 포함하고 있습니다. 입출력 예 commands result [""UPDATE 1 1 menu"", ""UPDATE 1 2 category"", ""UPDATE 2 1 bibimbap"", ""UPDATE 2 2 korean"", ""UPDATE 2 3 rice"", ""UPDATE 3 1 ramyeon"", ""UPDATE 3 2 korean"", ""UPDATE 3 3 noodle"", ""UPDATE 3 4 instant"", ""UPDATE 4 1 pasta"", ""UPDATE 4 2 italian"", ""UPDATE 4 3 noodle"", ""MERGE 1 2 1 3"", ""MERGE 1 3 1 4"", ""UPDATE korean hansik"", ""UPDATE 1 3 group"", ""UNMERGE 1 4"", ""PRINT 1 3"", ""PRINT 1 4""] [""EMPTY"", ""group""] [""UPDATE 1 1 a"", ""UPDATE 1 2 b"", ""UPDATE 2 1 c"", ""UPDATE 2 2 d"", ""MERGE 1 1 1 2"", ""MERGE 2 2 2 1"", ""MERGE 2 1 1 1"", ""PRINT 1 1"", ""UNMERGE 2 2"", ""PRINT 1 1""] [""d"", ""EMPTY""] 입출력 예 설명 입출력 예 #1 문제 예시와 같습니다. (1,3) 위치의 셀은 비어있고 (1,4) 위치의 셀 값은 ""group""입니다. 따라서 [""EMPTY"", ""group""]을 return 해야 합니다. 입출력 예 #2 모든 UPDATE 명령어를 실행하면 아래와 같은 상태가 됩니다. ""MERGE 1 1 1 2"" 명령어를 실행하면 아래와 같은 상태가 됩니다. ""MERGE 2 2 2 1"" 명령어를 실행하면 아래와 같은 상태가 됩니다. ""MERGE 2 1 1 1"" 명령어를 실행하면 아래와 같은 상태가 됩니다. ""UNMERGE 2 2"" 명령어를 실행하면 아래와 같은 상태가 됩니다.",normal,Array
197,"n x m 격자 미로가 주어집니다. 당신은 미로의 (x, y)에서 출발해 (r, c)로 이동해서 탈출해야 합니다. 단, 미로를 탈출하는 조건이 세 가지 있습니다. 격자의 바깥으로는 나갈 수 없습니다. (x, y)에서 (r, c)까지 이동하는 거리가 총 k여야 합니다. 이때, (x, y)와 (r, c)격자를 포함해, 같은 격자를 두 번 이상 방문해도 됩니다. 미로에서 탈출한 경로를 문자열로 나타냈을 때, 문자열이 사전 순으로 가장 빠른 경로로 탈출해야 합니다. 이동 경로는 다음과 같이 문자열로 바꿀 수 있습니다. l: 왼쪽으로 한 칸 이동 r: 오른쪽으로 한 칸 이동 u: 위쪽으로 한 칸 이동 d: 아래쪽으로 한 칸 이동 예를 들어, 왼쪽으로 한 칸, 위로 한 칸, 왼쪽으로 한 칸 움직였다면, 문자열 ""lul""로 나타낼 수 있습니다. 미로에서는 인접한 상, 하, 좌, 우 격자로 한 칸씩 이동할 수 있습니다. 예를 들어 다음과 같이 3 x 4 격자가 있다고 가정해 보겠습니다. .... ..S. E... 미로의 좌측 상단은 (1, 1)이고 우측 하단은 (3, 4)입니다. .은 빈 공간, S는 출발 지점, E는 탈출 지점입니다. 탈출까지 이동해야 하는 거리 k가 5라면 다음과 같은 경로로 탈출할 수 있습니다. lldud ulldd rdlll dllrl dllud ... 이때 dllrl보다 사전 순으로 빠른 경로로 탈출할 수는 없습니다. 격자의 크기를 뜻하는 정수 n, m, 출발 위치를 뜻하는 정수 x, y, 탈출 지점을 뜻하는 정수 r, c, 탈출까지 이동해야 하는 거리를 뜻하는 정수 k가 매개변수로 주어집니다. 이때, 미로를 탈출하기 위한 경로를 return 하도록 solution 함수를 완성해주세요. 단, 위 조건대로 미로를 탈출할 수 없는 경우 ""impossible""을 return 해야 합니다. 제한사항 2 ≤ n (= 미로의 세로 길이) ≤ 50 2 ≤ m (= 미로의 가로 길이) ≤ 50 1 ≤ x ≤ n 1 ≤ y ≤ m 1 ≤ r ≤ n 1 ≤ c ≤ m (x, y) ≠ (r, c) 1 ≤ k ≤ 2,500 입출력 예 n m x y r c k result 3 4 2 3 3 1 5 ""dllrl"" 2 2 1 1 2 2 2 ""dr"" 3 3 1 2 3 3 4 ""impossible"" 입출력 예 설명 입출력 예 #1 문제 예시와 동일합니다. 입출력 예 #2 미로의 크기는 2 x 2입니다. 출발 지점은 (1, 1)이고, 탈출 지점은 (2, 2)입니다. 빈 공간은 ., 출발 지점을 S, 탈출 지점을 E로 나타내면 다음과 같습니다. S. .E 미로의 좌측 상단은 (1, 1)이고 우측 하단은 (2, 2)입니다. 탈출까지 이동해야 하는 거리 k가 2이므로 다음과 같은 경로로 탈출할 수 있습니다. rd dr ""dr""이 사전 순으로 가장 빠른 경로입니다. 따라서 ""dr""을 return 해야 합니다. 입출력 예 #3 미로의 크기는 3 x 3입니다. 출발 지점은 (1, 2)이고, 탈출 지점은 (3, 3)입니다. 빈 공간은 ., 출발 지점을 S, 탈출 지점을 E로 나타내면 다음과 같습니다. .S. ... ..E 미로의 좌측 상단은 (1, 1)이고 우측 하단은 (3, 3)입니다. 탈출까지 이동해야 하는 거리 k가 4입니다. 이때, 이동 거리가 4이면서, S에서 E까지 이동할 수 있는 경로는 존재하지 않습니다. 따라서 ""impossible""을 return 해야 합니다.",normal,String
198,"춘식이는 트리의 1번 노드에 숫자 1, 2, 3 중 하나씩을 계속해서 떨어트려 트리의 리프 노드1에 숫자를 쌓는 게임을 하려고 합니다. 아래 그림은 게임의 예시를 나타냅니다. 트리의 모든 간선은 부모 노드가 자식 노드를 가리키는 단방향 간선입니다. 모든 부모 노드는 자식 노드와 연결된 간선 중 하나를 길로 설정합니다. 실선 화살표는 길인 간선입니다. 점선 화살표는 길이 아닌 간선입니다. 모든 부모 노드는 자신의 자식 노드 중 가장 번호가 작은 노드를 가리키는 간선을 초기 길로 설정합니다. [게임의 규칙]은 아래와 같습니다. 1번 노드(루트 노드)에 숫자 1, 2, 3 중 하나를 떨어트립니다. 숫자는 길인 간선을 따라 리프 노드까지 떨어집니다. 숫자가 리프 노드에 도착하면, 숫자가 지나간 각 노드는 현재 길로 연결된 자식 노드 다음으로 번호가 큰 자식 노드를 가리키는 간선을 새로운 길로 설정하고 기존의 길은 끊습니다. 만약 현재 길로 연결된 노드의 번호가 가장 크면, 번호가 가장 작은 노드를 가리키는 간선을 길로 설정합니다. 노드의 간선이 하나라면 계속 하나의 간선을 길로 설정합니다. 원하는 만큼 계속해서 루트 노드에 숫자를 떨어트릴 수 있습니다. 단, 앞서 떨어트린 숫자가 리프 노드까지 떨어진 후에 새로운 숫자를 떨어트려야 합니다. [게임의 목표]는 각각의 리프 노드에 쌓인 숫자의 합을 target에서 가리키는 값과 같게 만드는 것입니다. 예를 들어, target이 [0, 0, 0, 3, 0, 0, 5, 1, 2, 3]일 경우 아래 표와 같은 의미를 가집니다. 노드 번호 노드에 쌓인 숫자의 합 1 0 2 0 3 0 4 3 5 0 6 0 7 5 8 1 9 2 10 3 target대로 리프 노드에 쌓인 숫자의 합을 맞추기 위해서는 [2, 1, 2, 2, 1, 3, 3]순으로 숫자를 떨어트리면 됩니다. 아래 두 그림은 순서대로 1, 2번째 숫자 [2, 1]을 떨어트린 뒤의 길 상황을 나타냅니다. 숫자 2는 떨어지면서 1번 노드와 2번 노드를 지나갔습니다. 1번 노드는 3번 노드를 가리키는 간선을 길로 설정합니다. 2번 노드는 5번 노드를 가리키는 간선을 길로 설정합니다. 숫자 1은 떨어지면서 1번 노드, 3번 노드, 6번 노드를 지나갔습니다. 1번 노드는 3번 노드보다 번호가 큰 노드를 가리키는 간선이 없으므로 다시 2번 노드를 가리키는 간선을 길로 설정합니다. 3번 노드는 간선이 하나이므로 계속해서 6번 노드를 가리키는 간선을 길로 설정합니다. 6번 노드는 9번 노드를 가리키는 간선을 길로 설정합니다. 아래 두 그림은 순서대로 3, 4번째 숫자 [2, 2]를 떨어트린 뒤의 길 상황을 나타냅니다. 아래 세 그림은 순서대로 5, 6, 7번째 숫자 [1, 3, 3]을 떨어트린 뒤의 길 상황을 나타냅니다. 각 리프 노드에 쌓인 숫자를 모두 더해 배열로 나타내면 target과 같습니다. 트리의 각 노드들의 연결 관계를 담은 2차원 정수 배열 edges, 각 노드별로 만들어야 하는 숫자의 합을 담은 1차원 정수 배열 target이 매개변수로 주어집니다. 이때, target 대로 리프 노드에 쌓인 숫자의 합을 맞추기 위해 숫자를 떨어트리는 모든 경우 중 가장 적은 숫자를 사용하며 그중 사전 순으로 가장 빠른 경우를 1차원 정수 배열에 담아 return 하도록 solution 함수를 완성해주세요. 만약, target대로 숫자의 합을 만들 수 없는 경우 [-1]을 return 해주세요. 제한사항 1 ≤ edges의 길이 ≤ 100 edges[i]는 [부모 노드 번호, 자식 노드 번호] 형태로, 단방향으로 연결된 두 노드를 나타냅니다. 1 ≤ 노드 번호 ≤ edges의 길이 + 1 동일한 간선에 대한 정보가 중복해서 주어지지 않습니다. 항상 하나의 트리 형태로 입력이 주어지며, 잘못된 데이터가 주어지는 경우는 없습니다. 1번 노드는 항상 루트 노드입니다. target의 길이 = edges의 길이 + 1 target[i]는 i + 1번 노드에 쌓인 숫자의 합으로 만들어야 하는 수를 나타냅니다. 0 ≤ 리프 노드의 target값 ≤ 100 리프 노드를 제외한 노드의 target값 = 0 target의 원소의 합은 1 이상입니다. 입출력 예 edges target result [[2, 4], [1, 2], [6, 8], [1, 3], [5, 7], [2, 5], [3, 6], [6, 10], [6, 9]] [0, 0, 0, 3, 0, 0, 5, 1, 2, 3] [1, 1, 2, 2, 2, 3, 3] [[1, 2], [1, 3]] [0, 7, 3] [1, 1, 3, 2, 3] [[1, 3], [1, 2]] [0, 7, 1] [-1] 입출력 예 설명 입출력 예 #1 문제 예시와 같습니다. 위의 설명처럼 [2, 1, 2, 2, 1, 3, 3]순으로 숫자를 떨어트리면 target과 같게 만들 수 있지만, 가장 적은 숫자를 사용하며 그중 사전 순으로 가장 빠른 경우는 [1, 1, 2, 2, 2, 3, 3]입니다. 입출력 예 #2 [3, 2, 1, 1, 3]순으로 숫자를 떨어트리거나 [1, 1, 1, 1, 2, 1, 3]순으로 숫자를 떨어트려도 target과 같게 만들 수 있지만, 가장 적은 숫자를 사용하며 그중 사전 순으로 가장 빠른 경우는 [1, 1, 3, 2, 3]입니다. 입출력 예 #3 예제 3번의 트리는 주어지는 edges의 순서만 다를 뿐, 예제 2번과 같은 트리입니다. 2번 노드에 쌓인 숫자의 합을 7로 만들면서 3번 노드에 쌓인 숫자의 합을 1로 만들도록 숫자를 떨어트리는 방법은 없습니다. 따라서 [-1]을 return 해야 합니다. 리프 노드는 자식 노드가 없는 노드를 뜻합니다. ↩",hard,Array
199,"마법의 세계에 사는 민수는 아주 높은 탑에 살고 있습니다. 탑이 너무 높아서 걸어 다니기 힘든 민수는 마법의 엘리베이터를 만들었습니다. 마법의 엘리베이터의 버튼은 특별합니다. 마법의 엘리베이터에는 -1, +1, -10, +10, -100, +100 등과 같이 절댓값이 10c (c ≥ 0 인 정수) 형태인 정수들이 적힌 버튼이 있습니다. 마법의 엘리베이터의 버튼을 누르면 현재 층 수에 버튼에 적혀 있는 값을 더한 층으로 이동하게 됩니다. 단, 엘리베이터가 위치해 있는 층과 버튼의 값을 더한 결과가 0보다 작으면 엘리베이터는 움직이지 않습니다. 민수의 세계에서는 0층이 가장 아래층이며 엘리베이터는 현재 민수가 있는 층에 있습니다. 마법의 엘리베이터를 움직이기 위해서 버튼 한 번당 마법의 돌 한 개를 사용하게 됩니다.예를 들어, 16층에 있는 민수가 0층으로 가려면 -1이 적힌 버튼을 6번, -10이 적힌 버튼을 1번 눌러 마법의 돌 7개를 소모하여 0층으로 갈 수 있습니다. 하지만, +1이 적힌 버튼을 4번, -10이 적힌 버튼 2번을 누르면 마법의 돌 6개를 소모하여 0층으로 갈 수 있습니다. 마법의 돌을 아끼기 위해 민수는 항상 최소한의 버튼을 눌러서 이동하려고 합니다. 민수가 어떤 층에서 엘리베이터를 타고 0층으로 내려가는데 필요한 마법의 돌의 최소 개수를 알고 싶습니다. 민수와 마법의 엘리베이터가 있는 층을 나타내는 정수 storey 가 주어졌을 때, 0층으로 가기 위해 필요한 마법의 돌의 최소값을 return 하도록 solution 함수를 완성하세요. 제한사항 1 ≤ storey ≤ 100,000,000 입출력 예 storey result 16 6 2554 16 입출력 예 설명 입출력 예 #1 문제 예시와 같습니다. 입출력 예 #2 -1, +100이 적힌 버튼을 4번, +10이 적힌 버튼을 5번, -1000이 적힌 버튼을 3번 누르면 0층에 도착 할 수 있습니다. 그러므로 16을 return 합니다.",normal,Math
200,"수학에서 칸토어 집합은 0과 1 사이의 실수로 이루어진 집합으로, [0, 1]부터 시작하여 각 구간을 3등분하여 가운데 구간을 반복적으로 제외하는 방식으로 만들어집니다. 남아는 칸토어 집합을 조금 변형하여 유사 칸토어 비트열을 만들었습니다. 유사 칸토어 비트열은 다음과 같이 정의됩니다. 0 번째 유사 칸토어 비트열은 ""1"" 입니다. n(1 ≤ n) 번째 유사 칸토어 비트열은 n - 1 번째 유사 칸토어 비트열에서의 1을 11011로 치환하고 0을 00000로 치환하여 만듭니다. 남아는 n 번째 유사 칸토어 비트열에서 특정 구간 내의 1의 개수가 몇 개인지 궁금해졌습니다. n과 1의 개수가 몇 개인지 알고 싶은 구간을 나타내는 l, r이 주어졌을 때 그 구간 내의 1의 개수를 return 하도록 solution 함수를 완성해주세요. 제한사항 1 ≤ n ≤ 20 1 ≤ l, r ≤ 5n l ≤ r < l + 10,000,000 l과 r은 비트열에서의 인덱스(1-base)이며 폐구간 [l, r]을 나타냅니다. 입출력 예 n l r result 2 4 17 8 입출력 예 설명 2 번째 유사 칸토어 비트열은 ""1101111011000001101111011"" 입니다. 음영 표시된 부분은 폐구간 [4, 17] 이며 구간 내의 1은 8개 있습니다.",normal,Array
201,"숫자로 이루어진 문자열 t와 p가 주어질 때, t에서 p와 길이가 같은 부분문자열 중에서, 이 부분문자열이 나타내는 수가 p가 나타내는 수보다 작거나 같은 것이 나오는 횟수를 return하는 함수 solution을 완성하세요. 예를 들어, t=""3141592""이고 p=""271"" 인 경우, t의 길이가 3인 부분 문자열은 314, 141, 415, 159, 592입니다. 이 문자열이 나타내는 수 중 271보다 작거나 같은 수는 141, 159 2개 입니다. 제한사항 1 ≤ p의 길이 ≤ 18 p의 길이 ≤ t의 길이 ≤ 10,000 t와 p는 숫자로만 이루어진 문자열이며, 0으로 시작하지 않습니다. 입출력 예 t p result ""3141592"" ""271"" 2 ""500220839878"" ""7"" 8 ""10203"" ""15"" 3 입출력 예 설명 입출력 예 #1 본문과 같습니다. 입출력 예 #2 p의 길이가 1이므로 t의 부분문자열은 ""5"", ""0"", 0"", ""2"", ""2"", ""0"", ""8"", ""3"", ""9"", ""8"", ""7"", ""8""이며 이중 7보다 작거나 같은 숫자는 ""5"", ""0"", ""0"", ""2"", ""2"", ""0"", ""3"", ""7"" 이렇게 8개가 있습니다. 입출력 예 #3 p의 길이가 2이므로 t의 부분문자열은 ""10"", ""02"", ""20"", ""03""이며, 이중 15보다 작거나 같은 숫자는 ""10"", ""02"", ""03"" 이렇게 3개입니다. ""02""와 ""03""은 각각 2, 3에 해당한다는 점에 주의하세요",easy,String
202,"완호가 관리하는 어떤 데이터베이스의 한 테이블은 모두 정수 타입인 컬럼들로 이루어져 있습니다. 테이블은 2차원 행렬로 표현할 수 있으며 열은 컬럼을 나타내고, 행은 튜플을 나타냅니다. 첫 번째 컬럼은 기본키로서 모든 튜플에 대해 그 값이 중복되지 않도록 보장됩니다. 완호는 이 테이블에 대한 해시 함수를 다음과 같이 정의하였습니다. 해시 함수는 col, row_begin, row_end을 입력으로 받습니다. 테이블의 튜플을 col번째 컬럼의 값을 기준으로 오름차순 정렬을 하되, 만약 그 값이 동일하면 기본키인 첫 번째 컬럼의 값을 기준으로 내림차순 정렬합니다. 정렬된 데이터에서 S_i를 i 번째 행의 튜플에 대해 각 컬럼의 값을 i 로 나눈 나머지들의 합으로 정의합니다. row_begin ≤ i ≤ row_end 인 모든 S_i를 누적하여 bitwise XOR 한 값을 해시 값으로서 반환합니다. 테이블의 데이터 data와 해시 함수에 대한 입력 col, row_begin, row_end이 주어졌을 때 테이블의 해시 값을 return 하도록 solution 함수를 완성해주세요. 제한 사항 1 ≤ data의 길이 ≤ 2,500 1 ≤ data의 원소의 길이 ≤ 500 1 ≤ data[i][j] ≤ 1,000,000 data[i][j]는 i + 1 번째 튜플의 j + 1 번째 컬럼의 값을 의미합니다. 1 ≤ col ≤ data의 원소의 길이 1 ≤ row_begin ≤ row_end ≤ data의 길이 입출력 예 data col row_begin row_end result [[2,2,6],[1,5,10],[4,2,9],[3,8,3]] 2 2 3 4 입출력 예 설명 정해진 방법에 따라 튜플을 정렬하면 {4, 2, 9}, {2, 2, 6}, {1, 5, 10}, {3, 8, 3} 이 됩니다. S_2 = (2 mod 2) + (2 mod 2) + (6 mod 2) = 0 입니다. S_3 = (1 mod 3) + (5 mod 3) + (10 mod 3) = 4 입니다. 따라서 해시 값은 S_2 XOR S_ 3 = 4 입니다. ※ 공지 - 2025년 3월 14일 테스트케이스가 추가되었습니다.",normal,Hash Table
203,"다음은 어느 한 서점에서 판매중인 도서들의 도서 정보(BOOK), 저자 정보(AUTHOR) 테이블입니다. BOOK 테이블은 각 도서의 정보를 담은 테이블로 아래와 같은 구조로 되어있습니다. Column name Type Nullable Description BOOK_ID INTEGER FALSE 도서 ID CATEGORY VARCHAR(N) FALSE 카테고리 (경제, 인문, 소설, 생활, 기술) AUTHOR_ID INTEGER FALSE 저자 ID PRICE INTEGER FALSE 판매가 (원) PUBLISHED_DATE DATE FALSE 출판일 AUTHOR 테이블은 도서의 저자의 정보를 담은 테이블로 아래와 같은 구조로 되어있습니다. Column name Type Nullable Description AUTHOR_ID INTEGER FALSE 저자 ID AUTHOR_NAME VARCHAR(N) FALSE 저자명 BOOK_SALES 테이블은 각 도서의 날짜 별 판매량 정보를 담은 테이블로 아래와 같은 구조로 되어있습니다. Column name Type Nullable Description BOOK_ID INTEGER FALSE 도서 ID SALES_DATE DATE FALSE 판매일 SALES INTEGER FALSE 판매량 문제 2022년 1월의 도서 판매 데이터를 기준으로 저자 별, 카테고리 별 매출액(TOTAL_SALES = 판매량 * 판매가) 을 구하여, 저자 ID(AUTHOR_ID), 저자명(AUTHOR_NAME), 카테고리(CATEGORY), 매출액(SALES) 리스트를 출력하는 SQL문을 작성해주세요. 결과는 저자 ID를 오름차순으로, 저자 ID가 같다면 카테고리를 내림차순 정렬해주세요. 예시 예를 들어 BOOK 테이블과 AUTHOR 테이블, BOOK_SALES 테이블이 다음과 같다면 BOOK_ID CATEGORY AUTHOR_ID PRICE PUBLISHED_DATE 1 인문 1 10000 2020-01-01 2 경제 1 9000 2021-02-05 3 경제 2 9000 2021-03-11 AUTHOR_ID AUTHOR_NAME 1 홍길동 2 김영호 BOOK_ID SALES_DATE SALES 1 2022-01-01 2 2 2022-01-02 3 1 2022-01-05 1 2 2022-01-20 5 2 2022-01-21 6 3 2022-01-22 2 2 2022-02-11 3 2022년 1월의 도서 별 총 매출액은 도서 ID 가 1 인 도서가 총 3권 * 10,000원 = 30,000원, 도서 ID 가 2 인 도서가 총 14권 * 9,000 = 126,000원 이고, 도서 ID 가 3 인 도서가 총 2권 * 9,000 = 18,000원 입니다. 저자 별 카테고리 별로 매출액을 집계하면 결과는 다음과 같습니다. AUTHOR_ID AUTHOR_NAME CATEGORY TOTAL_SALES 1 홍길동 인문 30000 1 홍길동 경제 126000 2 김영호 경제 18000 그리고 저자 ID, 카테고리 순으로 내림차순 정렬하면 다음과 같이 나와야 합니다. AUTHOR_ID AUTHOR_NAME CATEGORY TOTAL_SALES 1 홍길동 인문 30000 1 홍길동 경제 126000 2 김영호 경제 18000",hard,database
204,"다음은 어느 한 서점에서 판매중인 도서들의 도서 정보(BOOK), 판매 정보(BOOK_SALES) 테이블입니다. BOOK 테이블은 각 도서의 정보를 담은 테이블로 아래와 같은 구조로 되어있습니다. Column name Type Nullable Description BOOK_ID INTEGER FALSE 도서 ID CATEGORY VARCHAR(N) FALSE 카테고리 (경제, 인문, 소설, 생활, 기술) AUTHOR_ID INTEGER FALSE 저자 ID PRICE INTEGER FALSE 판매가 (원) PUBLISHED_DATE DATE FALSE 출판일 BOOK_SALES 테이블은 각 도서의 날짜 별 판매량 정보를 담은 테이블로 아래와 같은 구조로 되어있습니다. Column name Type Nullable Description BOOK_ID INTEGER FALSE 도서 ID SALES_DATE DATE FALSE 판매일 SALES INTEGER FALSE 판매량 문제 2022년 1월의 카테고리 별 도서 판매량을 합산하고, 카테고리(CATEGORY), 총 판매량(TOTAL_SALES) 리스트를 출력하는 SQL문을 작성해주세요. 결과는 카테고리명을 기준으로 오름차순 정렬해주세요. 예시 예를 들어 BOOK 테이블과 BOOK_SALES 테이블이 다음과 같다면 BOOK_ID CATEGORY AUTHOR_ID PRICE PUBLISHED_DATE 1 인문 1 10000 2020-01-01 2 경제 1 9000 2021-02-05 3 경제 2 9000 2021-03-11 BOOK_ID SALES_DATE SALES 1 2022-01-01 2 2 2022-01-02 3 1 2022-01-05 1 2 2022-01-20 5 2 2022-01-21 6 3 2022-01-22 2 2 2022-02-11 3 2022년 1월의 도서 별 총 판매량은 도서 ID 가 1 인 도서가 총 3권, 도서 ID 가 2 인 도서가 총 14권 이고, 도서 ID 가 3 인 도서가 총 2권 입니다. 카테고리 별로 판매량을 집계한 결과는 다음과 같습니다. CATEGORY TOTAL_SALES 인문 3 경제 16 카테고리명을 오름차순으로 정렬하면 다음과 같이 나와야 합니다. CATEGORY TOTAL_SALES 경제 16 인문 3",normal,database
205,"다음은 어느 한 서점에서 판매중인 도서들의 도서 정보(BOOK), 저자 정보(AUTHOR) 테이블입니다. BOOK 테이블은 각 도서의 정보를 담은 테이블로 아래와 같은 구조로 되어있습니다. Column name Type Nullable Description BOOK_ID INTEGER FALSE 도서 ID CATEGORY VARCHAR(N) FALSE 카테고리 (경제, 인문, 소설, 생활, 기술) AUTHOR_ID INTEGER FALSE 저자 ID PRICE INTEGER FALSE 판매가 (원) PUBLISHED_DATE DATE FALSE 출판일 AUTHOR 테이블은 도서의 저자의 정보를 담은 테이블로 아래와 같은 구조로 되어있습니다. Column name Type Nullable Description AUTHOR_ID INTEGER FALSE 저자 ID AUTHOR_NAME VARCHAR(N) FALSE 저자명 문제 '경제' 카테고리에 속하는 도서들의 도서 ID(BOOK_ID), 저자명(AUTHOR_NAME), 출판일(PUBLISHED_DATE) 리스트를 출력하는 SQL문을 작성해주세요. 결과는 출판일을 기준으로 오름차순 정렬해주세요. 예시 예를 들어 BOOK 테이블과 AUTHOR 테이블이 다음과 같다면 BOOK_ID CATEGORY AUTHOR_ID PRICE PUBLISHED_DATE 1 인문 1 10000 2020-01-01 2 경제 1 9000 2021-04-11 3 경제 2 11000 2021-02-05 AUTHOR_ID AUTHOR_NAME 1 홍길동 2 김영호 '경제' 카테고리에 속하는 도서는 도서 ID가 2, 3인 도서이고, 출판일을 기준으로 오름차순으로 정렬하면 다음과 같은 결과가 나와야 합니다. BOOK_ID AUTHOR_NAME PUBLISHED_DATE 3 김영호 2021-02-05 2 홍길동 2021-04-11 주의사항 PUBLISHED_DATE의 데이트 포맷이 예시와 동일해야 정답처리 됩니다.",normal,database
206,"다음은 어느 한 서점에서 판매중인 도서들의 도서 정보(BOOK) 테이블입니다. BOOK 테이블은 각 도서의 정보를 담은 테이블로 아래와 같은 구조로 되어있습니다. Column name Type Nullable Description BOOK_ID INTEGER FALSE 도서 ID CATEGORY VARCHAR(N) FALSE 카테고리 (경제, 인문, 소설, 생활, 기술) AUTHOR_ID INTEGER FALSE 저자 ID PRICE INTEGER FALSE 판매가 (원) PUBLISHED_DATE DATE FALSE 출판일 문제 BOOK 테이블에서 2021년에 출판된 '인문' 카테고리에 속하는 도서 리스트를 찾아서 도서 ID(BOOK_ID), 출판일 (PUBLISHED_DATE)을 출력하는 SQL문을 작성해주세요. 결과는 출판일을 기준으로 오름차순 정렬해주세요. 예시 예를 들어 BOOK 테이블이 다음과 같다면 BOOK_ID CATEGORY AUTHOR_ID PRICE PUBLISHED_DATE 1 인문 1 10000 2020-01-01 2 경제 2 9000 2021-02-05 3 인문 2 11000 2021-04-11 4 인문 3 10000 2021-03-15 5 생활 1 12000 2021-01-10 조건에 속하는 도서는 도서 ID 가 3, 4인 도서이므로 다음과 같습니다. BOOK_ID PUBLISHED_DATE 3 2021-04-11 4 2021-03-15 그리고 출판일 오름차순으로 정렬하여야 하므로 다음과 같은 결과가 나와야 합니다. BOOK_ID PUBLISHED_DATE 4 2021-03-15 3 2021-04-11 주의사항 PUBLISHED_DATE의 데이트 포맷이 예시와 동일해야 정답처리 됩니다.",easy,database
207,"문자열 s가 주어졌을 때, s의 각 위치마다 자신보다 앞에 나왔으면서, 자신과 가장 가까운 곳에 있는 같은 글자가 어디 있는지 알고 싶습니다. 예를 들어, s=""banana""라고 할 때, 각 글자들을 왼쪽부터 오른쪽으로 읽어 나가면서 다음과 같이 진행할 수 있습니다. b는 처음 나왔기 때문에 자신의 앞에 같은 글자가 없습니다. 이는 -1로 표현합니다. a는 처음 나왔기 때문에 자신의 앞에 같은 글자가 없습니다. 이는 -1로 표현합니다. n은 처음 나왔기 때문에 자신의 앞에 같은 글자가 없습니다. 이는 -1로 표현합니다. a는 자신보다 두 칸 앞에 a가 있습니다. 이는 2로 표현합니다. n도 자신보다 두 칸 앞에 n이 있습니다. 이는 2로 표현합니다. a는 자신보다 두 칸, 네 칸 앞에 a가 있습니다. 이 중 가까운 것은 두 칸 앞이고, 이는 2로 표현합니다. 따라서 최종 결과물은 [-1, -1, -1, 2, 2, 2]가 됩니다. 문자열 s이 주어질 때, 위와 같이 정의된 연산을 수행하는 함수 solution을 완성해주세요. 제한사항 1 ≤ s의 길이 ≤ 10,000 s은 영어 소문자로만 이루어져 있습니다. 입출력 예 s result ""banana"" [-1, -1, -1, 2, 2, 2] ""foobar"" [-1, -1, 1, -1, -1, -1] 입출력 예 설명 입출력 예 #1 지문과 같습니다. 입출력 예 #2 설명 생략",easy,String
208,"준호는 요즘 디펜스 게임에 푹 빠져 있습니다. 디펜스 게임은 준호가 보유한 병사 n명으로 연속되는 적의 공격을 순서대로 막는 게임입니다. 디펜스 게임은 다음과 같은 규칙으로 진행됩니다. 준호는 처음에 병사 n명을 가지고 있습니다. 매 라운드마다 enemy[i]마리의 적이 등장합니다. 남은 병사 중 enemy[i]명 만큼 소모하여 enemy[i]마리의 적을 막을 수 있습니다. 예를 들어 남은 병사가 7명이고, 적의 수가 2마리인 경우, 현재 라운드를 막으면 7 - 2 = 5명의 병사가 남습니다. 남은 병사의 수보다 현재 라운드의 적의 수가 더 많으면 게임이 종료됩니다. 게임에는 무적권이라는 스킬이 있으며, 무적권을 사용하면 병사의 소모없이 한 라운드의 공격을 막을 수 있습니다. 무적권은 최대 k번 사용할 수 있습니다. 준호는 무적권을 적절한 시기에 사용하여 최대한 많은 라운드를 진행하고 싶습니다. 준호가 처음 가지고 있는 병사의 수 n, 사용 가능한 무적권의 횟수 k, 매 라운드마다 공격해오는 적의 수가 순서대로 담긴 정수 배열 enemy가 매개변수로 주어집니다. 준호가 몇 라운드까지 막을 수 있는지 return 하도록 solution 함수를 완성해주세요. 제한사항 1 ≤ n ≤ 1,000,000,000 1 ≤ k ≤ 500,000 1 ≤ enemy의 길이 ≤ 1,000,000 1 ≤ enemy[i] ≤ 1,000,000 enemy[i]에는 i + 1 라운드에서 공격해오는 적의 수가 담겨있습니다. 모든 라운드를 막을 수 있는 경우에는 enemy[i]의 길이를 return 해주세요. 입출력 예 n k enemy result 7 3 [4, 2, 4, 5, 3, 3, 1] 5 2 4 [3, 3, 3, 3] 4 입출력 예 설명 입출력 예#1 1, 3, 5 라운드의 공격을 무적권으로 막아내고, 2, 4 라운드에 각각 병사를 2명, 5명 소모하면 5라운드까지 공격을 막을 수 있습니다. 또, 1, 3, 4번째 공격을 무적권으로 막아내고, 2, 5 번째 공격에 각각 병사를 2명, 3명 소모하여 5라운드까지 공격을 막을 수 있습니다. 그보다 많은 라운드를 막는 방법은 없으므로 5를 return 합니다. 입출력 예#2 준호는 모든 공격에 무적권을 사용하여 4라운드까지 막을 수 있습니다.",normal,Array
209,"문자열 s가 입력되었을 때 다음 규칙을 따라서 이 문자열을 여러 문자열로 분해하려고 합니다. 먼저 첫 글자를 읽습니다. 이 글자를 x라고 합시다. 이제 이 문자열을 왼쪽에서 오른쪽으로 읽어나가면서, x와 x가 아닌 다른 글자들이 나온 횟수를 각각 셉니다. 처음으로 두 횟수가 같아지는 순간 멈추고, 지금까지 읽은 문자열을 분리합니다. s에서 분리한 문자열을 빼고 남은 부분에 대해서 이 과정을 반복합니다. 남은 부분이 없다면 종료합니다. 만약 두 횟수가 다른 상태에서 더 이상 읽을 글자가 없다면, 역시 지금까지 읽은 문자열을 분리하고, 종료합니다. 문자열 s가 매개변수로 주어질 때, 위 과정과 같이 문자열들로 분해하고, 분해한 문자열의 개수를 return 하는 함수 solution을 완성하세요. 제한사항 1 ≤ s의 길이 ≤ 10,000 s는 영어 소문자로만 이루어져 있습니다. 입출력 예 s result ""banana"" 3 ""abracadabra"" 6 ""aaabbaccccabba"" 3 입출력 예 설명 입출력 예 #1 s=""banana""인 경우 ba - na - na와 같이 분해됩니다. 입출력 예 #2 s=""abracadabra""인 경우 ab - ra - ca - da - br - a와 같이 분해됩니다. 입출력 예 #3 s=""aaabbaccccabba""인 경우 aaabbacc - ccab - ba와 같이 분해됩니다.",easy,String
210,"좌표평면을 좋아하는 진수는 x축과 y축이 직교하는 2차원 좌표평면에 점을 찍으면서 놀고 있습니다. 진수는 두 양의 정수 k, d가 주어질 때 다음과 같이 점을 찍으려 합니다. 원점(0, 0)으로부터 x축 방향으로 a*k(a = 0, 1, 2, 3 ...), y축 방향으로 b*k(b = 0, 1, 2, 3 ...)만큼 떨어진 위치에 점을 찍습니다. 원점과 거리가 d를 넘는 위치에는 점을 찍지 않습니다. 예를 들어, k가 2, d가 4인 경우에는 (0, 0), (0, 2), (0, 4), (2, 0), (2, 2), (4, 0) 위치에 점을 찍어 총 6개의 점을 찍습니다. 정수 k와 원점과의 거리를 나타내는 정수 d가 주어졌을 때, 점이 총 몇 개 찍히는지 return 하는 solution 함수를 완성하세요. 제한사항 1 ≤ k ≤ 1,000,000 1 ≤ d ≤ 1,000,000 입출력 예 k d result 2 4 6 1 5 26 입출력 예 설명 입출력 예 #1 본문의 예시와 같습니다. 입출력 예 #2 (0, 0), (0, 1), (0, 2), (0, 3), (0, 4), (0, 5), (1, 0), (1, 1), (1, 2), (1, 3), (1, 4), (2, 0), (2, 1), (2, 2), (2, 3), (2, 4), (3, 0), (3, 1), (3, 2), (3, 3), (3, 4), (4, 0), (4, 1), (4, 2), (4, 3), (5, 0) 위치에 점을 찍을 수 있으며, 총 26개 입니다.",normal,Math
211,"은비는 길을 걷다가 관광 명소인 쌍둥이 빌딩 숲을 보게 되었습니다. 쌍둥이 빌딩 숲은 일렬로 빌딩들이 줄지어 서있는 곳입니다. 쌍둥이 빌딩 숲에는 높이가 1부터 n까지 각각 2 채씩 총 2n채의 빌딩이 존재하기 때문에 그러한 이름이 붙게 되었으며, 같은 높이를 가지는 빌딩 사이에는 그보다 높은 빌딩이 존재하지 않습니다. 은비는 쌍둥이 빌딩 숲을 한쪽 측면에서(열 방향으로) 바라보고 있습니다. 이때 count 채의 빌딩이 구분되어 보였습니다. 은비의 세계는 안타깝게도 원근감이 존재하지 않지만, 다행히 서로 다른 높이를 가지는 빌딩들은 각각 고유한 색깔을 가지고 있어 어떤 빌딩이 다른 빌딩에 의해 전체가 가려지지 않는다면 볼 수 있습니다. 예를 들어 은비가 바라본 방향에서 가까운 빌딩부터 차례로 높이가 1,1,3,2,2,3 순이라면 높이가 2인 빌딩은 가려져서 보이지 않고, 높이가 1인 빌딩과 높이가 3인 빌딩만 구분되어 보입니다. n과 count가 주어졌을 때, 빌딩들이 배치될 수 있는 방법의 수를 return 하도록 solution 함수를 완성해주세요. 제한 사항 1 ≤ n ≤ 100 1 ≤ count ≤ n 같은 높이의 빌딩은 같은 색이므로 서로 구분하지 않습니다. 결과는 매우 클 수 있으므로 1,000,000,007 로 나눈 나머지를 return합니다. 입출력 예 n count result 3 1 8 3 2 6 3 3 1 입출력 예 설명 입출력 예 #1 가능한 방법마다 가장 가까운 빌딩부터 차례로 높이를 나열해보면 311223, 311322, 321123, 322113, 322311, 331122, 332112, 332211 으로 총 8 가지 방법이 있습니다. 입출력 예 #2 가능한 방법마다 가장 가까운 빌딩부터 차례로 높이를 나열해보면 113223, 113322, 211233, 221133, 223113, 223311 으로 총 6 가지 방법이 있습니다. 입출력 예 #1 가능한 방법마다 가장 가까운 빌딩부터 차례로 높이를 나열해보면 112233 으로 총 1 가지 방법이 있습니다. ※ 공지 - 2022년 12월 12일 문제 지문 수정 및 테스트 케이스가 추가되었습니다.",hard,Math
212,"""명예의 전당""이라는 TV 프로그램에서는 매일 1명의 가수가 노래를 부르고, 시청자들의 문자 투표수로 가수에게 점수를 부여합니다. 매일 출연한 가수의 점수가 지금까지 출연 가수들의 점수 중 상위 k번째 이내이면 해당 가수의 점수를 명예의 전당이라는 목록에 올려 기념합니다. 즉 프로그램 시작 이후 초기에 k일까지는 모든 출연 가수의 점수가 명예의 전당에 오르게 됩니다. k일 다음부터는 출연 가수의 점수가 기존의 명예의 전당 목록의 k번째 순위의 가수 점수보다 더 높으면, 출연 가수의 점수가 명예의 전당에 오르게 되고 기존의 k번째 순위의 점수는 명예의 전당에서 내려오게 됩니다. 이 프로그램에서는 매일 ""명예의 전당""의 최하위 점수를 발표합니다. 예를 들어, k = 3이고, 7일 동안 진행된 가수의 점수가 [10, 100, 20, 150, 1, 100, 200]이라면, 명예의 전당에서 발표된 점수는 아래의 그림과 같이 [10, 10, 10, 20, 20, 100, 100]입니다. 명예의 전당 목록의 점수의 개수 k, 1일부터 마지막 날까지 출연한 가수들의 점수인 score가 주어졌을 때, 매일 발표된 명예의 전당의 최하위 점수를 return하는 solution 함수를 완성해주세요. 제한사항 3 ≤ k ≤ 100 7 ≤ score의 길이 ≤ 1,000 0 ≤ score[i] ≤ 2,000 입출력 예 k score result 3 [10, 100, 20, 150, 1, 100, 200] [10, 10, 10, 20, 20, 100, 100] 4 [0, 300, 40, 300, 20, 70, 150, 50, 500, 1000] [0, 0, 0, 0, 20, 40, 70, 70, 150, 300] 입출력 예 설명 입출력 예 #1 문제의 예시와 같습니다. 입출력 예 #2 아래와 같이, [0, 0, 0, 0, 20, 40, 70, 70, 150, 300]을 return합니다.",easy,Math
213,"경화는 과수원에서 귤을 수확했습니다. 경화는 수확한 귤 중 'k'개를 골라 상자 하나에 담아 판매하려고 합니다. 그런데 수확한 귤의 크기가 일정하지 않아 보기에 좋지 않다고 생각한 경화는 귤을 크기별로 분류했을 때 서로 다른 종류의 수를 최소화하고 싶습니다. 예를 들어, 경화가 수확한 귤 8개의 크기가 [1, 3, 2, 5, 4, 5, 2, 3] 이라고 합시다. 경화가 귤 6개를 판매하고 싶다면, 크기가 1, 4인 귤을 제외한 여섯 개의 귤을 상자에 담으면, 귤의 크기의 종류가 2, 3, 5로 총 3가지가 되며 이때가 서로 다른 종류가 최소일 때입니다. 경화가 한 상자에 담으려는 귤의 개수 k와 귤의 크기를 담은 배열 tangerine이 매개변수로 주어집니다. 경화가 귤 k개를 고를 때 크기가 서로 다른 종류의 수의 최솟값을 return 하도록 solution 함수를 작성해주세요. 제한사항 1 ≤ k ≤ tangerine의 길이 ≤ 100,000 1 ≤ tangerine의 원소 ≤ 10,000,000 입출력 예 k tangerine result 6 [1, 3, 2, 5, 4, 5, 2, 3] 3 4 [1, 3, 2, 5, 4, 5, 2, 3] 2 2 [1, 1, 1, 1, 2, 2, 2, 3] 1 입출력 예 설명 입출력 예 #1 본문에서 설명한 예시입니다. 입출력 예 #2 경화는 크기가 2인 귤 2개와 3인 귤 2개 또는 2인 귤 2개와 5인 귤 2개 또는 3인 귤 2개와 5인 귤 2개로 귤을 판매할 수 있습니다. 이때의 크기 종류는 2가지로 이 값이 최소가 됩니다. 입출력 예 #3 경화는 크기가 1인 귤 2개를 판매하거나 2인 귤 2개를 판매할 수 있습니다. 이때의 크기 종류는 1가지로, 이 값이 최소가 됩니다.",normal,Array
214,"영우는 천하제일 암산대회를 앞두고 있습니다. 암산보다는 암기에 일가견이 있는 영우는 구구단을 확장하여 억억단을 만들고 외워버리기로 하였습니다. 억억단은 1억 x 1억 크기의 행렬입니다. 억억단을 외우던 영우는 친구 수연에게 퀴즈를 내달라고 부탁하였습니다. 수연은 평범하게 문제를 내봐야 영우가 너무 쉽게 맞히기 때문에 좀 어렵게 퀴즈를 내보려고 합니다. 적당한 수 e를 먼저 정하여 알려주고 e 이하의 임의의 수 s를 여러 개 얘기합니다. 영우는 각 s에 대해서 s보다 크거나 같고 e 보다 작거나 같은 수 중에서 억억단에서 가장 많이 등장한 수를 답해야 합니다. 만약 가장 많이 등장한 수가 여러 개라면 그 중 가장 작은 수를 답해야 합니다. 수연은 영우가 정답을 말하는지 확인하기 위해 당신에게 프로그램 제작을 의뢰하였습니다. e와 s의 목록 starts가 매개변수로 주어질 때 각 퀴즈의 답 목록을 return 하도록 solution 함수를 완성해주세요. 제한사항 1 ≤ e ≤ 5,000,000 1 ≤ starts의 길이 ≤ min {e,100,000} 1 ≤ starts의 원소 ≤ e starts에는 중복되는 원소가 존재하지 않습니다. 입출력 예 e starts result 8 [1,3,7] [6,6,8] 입출력 예 설명 억억단에서 1 ~ 8이 등장하는 횟수는 다음과 같습니다. 1번 등장 : 1 2번 등장 : 2, 3, 5, 7 3번 등장 : 4 4번 등장 : 6, 8 [1, 8] 범위에서는 6과 8이 각각 4번씩 등장하여 가장 많은데 6이 더 작은 수이므로 6이 정답입니다. [3, 8] 범위에서도 위와 같으므로 6이 정답입니다. [7, 8] 범위에서는 7은 2번, 8은 4번 등장하므로 8이 정답입니다.",normal,Math
215,"숫자나라 기사단의 각 기사에게는 1번부터 number까지 번호가 지정되어 있습니다. 기사들은 무기점에서 무기를 구매하려고 합니다. 각 기사는 자신의 기사 번호의 약수 개수에 해당하는 공격력을 가진 무기를 구매하려 합니다. 단, 이웃나라와의 협약에 의해 공격력의 제한수치를 정하고, 제한수치보다 큰 공격력을 가진 무기를 구매해야 하는 기사는 협약기관에서 정한 공격력을 가지는 무기를 구매해야 합니다. 예를 들어, 15번으로 지정된 기사단원은 15의 약수가 1, 3, 5, 15로 4개 이므로, 공격력이 4인 무기를 구매합니다. 만약, 이웃나라와의 협약으로 정해진 공격력의 제한수치가 3이고 제한수치를 초과한 기사가 사용할 무기의 공격력이 2라면, 15번으로 지정된 기사단원은 무기점에서 공격력이 2인 무기를 구매합니다. 무기를 만들 때, 무기의 공격력 1당 1kg의 철이 필요합니다. 그래서 무기점에서 무기를 모두 만들기 위해 필요한 철의 무게를 미리 계산하려 합니다. 기사단원의 수를 나타내는 정수 number와 이웃나라와 협약으로 정해진 공격력의 제한수치를 나타내는 정수 limit와 제한수치를 초과한 기사가 사용할 무기의 공격력을 나타내는 정수 power가 주어졌을 때, 무기점의 주인이 무기를 모두 만들기 위해 필요한 철의 무게를 return 하는 solution 함수를 완성하시오. 제한사항 1 ≤ number ≤ 100,000 2 ≤ limit ≤ 100 1 ≤ power ≤ limit 입출력 예 number limit power result 5 3 2 10 10 3 2 21 입출력 예 설명 입출력 예 #1 1부터 5까지의 약수의 개수는 순서대로 [1, 2, 2, 3, 2]개입니다. 모두 공격력 제한 수치인 3을 넘지 않기 때문에 필요한 철의 무게는 해당 수들의 합인 10이 됩니다. 따라서 10을 return 합니다. 입출력 예 #2 1부터 10까지의 약수의 개수는 순서대로 [1, 2, 2, 3, 2, 4, 2, 4, 3, 4]개입니다. 공격력의 제한수치가 3이기 때문에, 6, 8, 10번 기사는 공격력이 2인 무기를 구매합니다. 따라서 해당 수들의 합인 21을 return 합니다.",easy,Math
216,"위와 같은 모양으로 배열된 숫자 자판이 있습니다. 숫자 타자 대회는 이 동일한 자판을 사용하여 숫자로만 이루어진 긴 문자열을 누가 가장 빠르게 타이핑하는지 겨루는 대회입니다. 대회에 참가하려는 민희는 두 엄지 손가락을 이용하여 타이핑을 합니다. 민희는 항상 왼손 엄지를 4 위에, 오른손 엄지를 6 위에 두고 타이핑을 시작합니다. 엄지 손가락을 움직여 다음 숫자를 누르는 데에는 일정 시간이 듭니다. 민희는 어떤 두 숫자를 연속으로 입력하는 시간 비용을 몇몇 가중치로 분류하였습니다. 이동하지 않고 제자리에서 다시 누르는 것은 가중치가 1입니다. 상하좌우로 인접한 숫자로 이동하여 누르는 것은 가중치가 2입니다. 대각선으로 인접한 숫자로 이동하여 누르는 것은 가중치가 3입니다. 같지 않고 인접하지 않은 숫자를 누를 때는 위 규칙에 따라 가중치 합이 최소가 되는 경로를 따릅니다. 예를 들어 1 위에 있던 손가락을 0 으로 이동하여 누르는 것은 2 + 2 + 3 = 7 만큼의 가중치를 갖습니다. 단, 숫자 자판은 버튼의 크기가 작기 때문에 같은 숫자 버튼 위에 동시에 두 엄지 손가락을 올려놓을 수 없습니다. 즉, 어떤 숫자를 눌러야 할 차례에 그 숫자 위에 올려져 있는 손가락이 있다면 반드시 그 손가락으로 눌러야 합니다. 숫자로 이루어진 문자열 numbers가 주어졌을 때 최소한의 시간으로 타이핑을 하는 경우의 가중치 합을 return 하도록 solution 함수를 완성해주세요. 제한사항 1 ≤ numbers의 길이 ≤ 100,000 numbers는 아라비아 숫자로만 이루어진 문자열입니다. 입출력 예 numbers result ""1756"" 10 ""5123"" 8 입출력 예 설명 입출력 예 #1 왼손 엄지로 17, 오른손 엄지로 56을 누르면 가중치 10으로 최소입니다. 입출력 예 #2 오른손 엄지로 5, 왼손 엄지로 123을 누르거나 오른손 엄지로 5, 왼손 엄지로 1, 오른손 엄지로 23을 누르면 가중치 8로 최소입니다.",normal,Array
217,"과일 장수가 사과 상자를 포장하고 있습니다. 사과는 상태에 따라 1점부터 k점까지의 점수로 분류하며, k점이 최상품의 사과이고 1점이 최하품의 사과입니다. 사과 한 상자의 가격은 다음과 같이 결정됩니다. 한 상자에 사과를 m개씩 담아 포장합니다. 상자에 담긴 사과 중 가장 낮은 점수가 p (1 ≤ p ≤ k)점인 경우, 사과 한 상자의 가격은 p * m 입니다. 과일 장수가 가능한 많은 사과를 팔았을 때, 얻을 수 있는 최대 이익을 계산하고자 합니다.(사과는 상자 단위로만 판매하며, 남는 사과는 버립니다) 예를 들어, k = 3, m = 4, 사과 7개의 점수가 [1, 2, 3, 1, 2, 3, 1]이라면, 다음과 같이 [2, 3, 2, 3]으로 구성된 사과 상자 1개를 만들어 판매하여 최대 이익을 얻을 수 있습니다. (최저 사과 점수) x (한 상자에 담긴 사과 개수) x (상자의 개수) = 2 x 4 x 1 = 8 사과의 최대 점수 k, 한 상자에 들어가는 사과의 수 m, 사과들의 점수 score가 주어졌을 때, 과일 장수가 얻을 수 있는 최대 이익을 return하는 solution 함수를 완성해주세요. 제한사항 3 ≤ k ≤ 9 3 ≤ m ≤ 10 7 ≤ score의 길이 ≤ 1,000,000 1 ≤ score[i] ≤ k 이익이 발생하지 않는 경우에는 0을 return 해주세요. 입출력 예 k m score result 3 4 [1, 2, 3, 1, 2, 3, 1] 8 4 3 [4, 1, 2, 2, 4, 4, 4, 4, 1, 2, 4, 2] 33 입출력 예 설명 입출력 예 #1 문제의 예시와 같습니다. 입출력 예 #2 다음과 같이 사과 상자를 포장하여 모두 팔면 최대 이익을 낼 수 있습니다. 사과 상자 가격 [1, 1, 2] 1 x 3 = 3 [2, 2, 2] 2 x 3 = 6 [4, 4, 4] 4 x 3 = 12 [4, 4, 4] 4 x 3 = 12 따라서 (1 x 3 x 1) + (2 x 3 x 1) + (4 x 3 x 2) = 33을 return합니다.",easy,Math
218,"철수와 영희는 선생님으로부터 숫자가 하나씩 적힌 카드들을 절반씩 나눠서 가진 후, 다음 두 조건 중 하나를 만족하는 가장 큰 양의 정수 a의 값을 구하려고 합니다. 철수가 가진 카드들에 적힌 모든 숫자를 나눌 수 있고 영희가 가진 카드들에 적힌 모든 숫자들 중 하나도 나눌 수 없는 양의 정수 a 영희가 가진 카드들에 적힌 모든 숫자를 나눌 수 있고, 철수가 가진 카드들에 적힌 모든 숫자들 중 하나도 나눌 수 없는 양의 정수 a 예를 들어, 카드들에 10, 5, 20, 17이 적혀 있는 경우에 대해 생각해 봅시다. 만약, 철수가 [10, 17]이 적힌 카드를 갖고, 영희가 [5, 20]이 적힌 카드를 갖는다면 두 조건 중 하나를 만족하는 양의 정수 a는 존재하지 않습니다. 하지만, 철수가 [10, 20]이 적힌 카드를 갖고, 영희가 [5, 17]이 적힌 카드를 갖는다면, 철수가 가진 카드들의 숫자는 모두 10으로 나눌 수 있고, 영희가 가진 카드들의 숫자는 모두 10으로 나눌 수 없습니다. 따라서 철수와 영희는 각각 [10, 20]이 적힌 카드, [5, 17]이 적힌 카드로 나눠 가졌다면 조건에 해당하는 양의 정수 a는 10이 됩니다. 철수가 가진 카드에 적힌 숫자들을 나타내는 정수 배열 arrayA와 영희가 가진 카드에 적힌 숫자들을 나타내는 정수 배열 arrayB가 주어졌을 때, 주어진 조건을 만족하는 가장 큰 양의 정수 a를 return하도록 solution 함수를 완성해 주세요. 만약, 조건을 만족하는 a가 없다면, 0을 return 해 주세요. 제한사항 제한사항 1 ≤ arrayA의 길이 = arrayB의 길이 ≤ 500,000 1 ≤ arrayA의 원소, arrayB의 원소 ≤ 100,000,000 arrayA와 arrayB에는 중복된 원소가 있을 수 있습니다. 입출력 예 arrayA arrayB result [10, 17] [5, 20] 0 [10, 20] [5, 17] 10 [14, 35, 119] [18, 30, 102] 7 입출력 예 설명 입출력 예 #1 문제 예시와 같습니다. 입출력 예 #2 문제 예시와 같습니다. 입출력 예 #3 철수가 가진 카드에 적힌 숫자들은 모두 3으로 나눌 수 없고, 영희가 가진 카드에 적힌 숫자는 모두 3으로 나눌 수 있습니다. 따라서 3은 조건에 해당하는 양의 정수입니다. 하지만, 철수가 가진 카드들에 적힌 숫자들은 모두 7로 나눌 수 있고, 영희가 가진 카드들에 적힌 숫자는 모두 7로 나눌 수 없습니다. 따라서 최대값인 7을 return 합니다.",normal,Array
219,"수웅이는 매달 주어진 음식을 빨리 먹는 푸드 파이트 대회를 개최합니다. 이 대회에서 선수들은 1대 1로 대결하며, 매 대결마다 음식의 종류와 양이 바뀝니다. 대결은 준비된 음식들을 일렬로 배치한 뒤, 한 선수는 제일 왼쪽에 있는 음식부터 오른쪽으로, 다른 선수는 제일 오른쪽에 있는 음식부터 왼쪽으로 순서대로 먹는 방식으로 진행됩니다. 중앙에는 물을 배치하고, 물을 먼저 먹는 선수가 승리하게 됩니다. 이때, 대회의 공정성을 위해 두 선수가 먹는 음식의 종류와 양이 같아야 하며, 음식을 먹는 순서도 같아야 합니다. 또한, 이번 대회부터는 칼로리가 낮은 음식을 먼저 먹을 수 있게 배치하여 선수들이 음식을 더 잘 먹을 수 있게 하려고 합니다. 이번 대회를 위해 수웅이는 음식을 주문했는데, 대회의 조건을 고려하지 않고 음식을 주문하여 몇 개의 음식은 대회에 사용하지 못하게 되었습니다. 예를 들어, 3가지의 음식이 준비되어 있으며, 칼로리가 적은 순서대로 1번 음식을 3개, 2번 음식을 4개, 3번 음식을 6개 준비했으며, 물을 편의상 0번 음식이라고 칭한다면, 두 선수는 1번 음식 1개, 2번 음식 2개, 3번 음식 3개씩을 먹게 되므로 음식의 배치는 ""1223330333221""이 됩니다. 따라서 1번 음식 1개는 대회에 사용하지 못합니다. 수웅이가 준비한 음식의 양을 칼로리가 적은 순서대로 나타내는 정수 배열 food가 주어졌을 때, 대회를 위한 음식의 배치를 나타내는 문자열을 return 하는 solution 함수를 완성해주세요. 제한사항 2 ≤ food의 길이 ≤ 9 1 ≤ food의 각 원소 ≤ 1,000 food에는 칼로리가 적은 순서대로 음식의 양이 담겨 있습니다. food[i]는 i번 음식의 수입니다. food[0]은 수웅이가 준비한 물의 양이며, 항상 1입니다. 정답의 길이가 3 이상인 경우만 입력으로 주어집니다. 입출력 예 food result [1, 3, 4, 6] ""1223330333221"" [1, 7, 1, 2] ""111303111"" 입출력 예 설명 입출력 예 #1 문제 예시와 같습니다. 입출력 예 #2 두 선수는 1번 음식 3개, 3번 음식 1개를 먹게 되므로 음식의 배치는 ""111303111""입니다.",easy,Array
220,"콜라츠 추측이란 로타르 콜라츠(Lothar Collatz)가 1937년에 제기한 추측으로 모든 자연수 k에 대해 다음 작업을 반복하면 항상 1로 만들 수 있다는 추측입니다. 1-1. 입력된 수가 짝수라면 2로 나눕니다. 1-2. 입력된 수가 홀수라면 3을 곱하고 1을 더합니다. 2.결과로 나온 수가 1보다 크다면 1번 작업을 반복합니다. 예를 들어 주어진 수가 5 라면 5 ⇒ 16 ⇒ 8 ⇒ 4 ⇒2 ⇒ 1 이되어 총 5번만에 1이 됩니다. 수가 커졌다 작아지기를 반복하는 모습이 비구름에서 빗방울이 오르락내리락하며 우박이 되는 모습과 비슷하다고 하여 우박수 또는 우박수열로 불리기도 합니다. 현재 이 추측이 참인지 거짓인지 증명되지 않았지만 약 1해까지의 수에서 반례가 없음이 밝혀져 있습니다. 은지는 우박수열을 좌표 평면 위에 꺾은선 그래프로 나타내보려고 합니다. 초항이 k인 우박수열이 있다면, x = 0일때 y = k이고 다음 우박수는 x = 1에 표시합니다. 이런 식으로 우박수가 1이 될 때까지 점들을 찍고 인접한 점들끼리 직선으로 연결하면 다음과 같이 꺾은선 그래프를 만들 수 있습니다. 은지는 이렇게 만든 꺾은선 그래프를 정적분 해보고 싶어졌습니다. x에 대한 어떤 범위 [a, b]가 주어진다면 이 범위에 대한 정적분 결과는 꺾은선 그래프와 x = a, x = b, y = 0 으로 둘러 쌓인 공간의 면적과 같습니다. 은지는 이것을 우박수열 정적분이라고 정의하였고 다양한 구간에 대해서 우박수열 정적분을 해보려고 합니다. 0 이상의 수 b에 대해 [a, -b]에 대한 정적분 결과는 x = a, x = n - b, y = 0 으로 둘러 쌓인 공간의 면적으로 정의하며, 이때 n은 k가 초항인 우박수열이 1이 될때 까지의 횟수를 의미합니다. 예를 들어, 5를 초항으로 하는 우박수열은 5 ⇒ 16 ⇒ 8 ⇒ 4 ⇒ 2 ⇒ 1 입니다. 이를 좌표 평면으로 옮기면 (0, 5), (1, 16), (2, 8), (3, 4), (4, 2), (5, 1) 에 점이 찍히고 점들을 연결하면 꺾은선 그래프가 나옵니다. 이를 [0,0] 구간에 대해 정적분 한다면 전체 구간에 대한 정적분이며, [1,-2] 구간에 대해 정적분 한다면 1 ≤ x ≤ 3인 구간에 대한 정적분입니다. 우박수의 초항 k와, 정적분을 구하는 구간들의 목록 ranges가 주어졌을 때 정적분의 결과 목록을 return 하도록 solution을 완성해주세요. 단, 주어진 구간의 시작점이 끝점보다 커서 유효하지 않은 구간이 주어질 수 있으며 이때의 정적분 결과는 -1로 정의합니다. 제한사항 2 ≤ k ≤ 10,000 1 ≤ ranges의 길이 ≤ 10,000 ranges의 원소는 [a, b] 형식이며 0 ≤ a < 200, -200 < b ≤ 0 입니다. 주어진 모든 입력에 대해 정적분의 결과는 227 을 넘지 않습니다. 본 문제는 정답에 실수형이 포함되는 문제입니다. 입출력 예의 소수 부분 .0이 코드 실행 버튼 클릭 후 나타나는 결괏값, 기댓값 표시와 다를 수 있습니다. 입출력 예 k ranges result 5 [[0,0],[0,-1],[2,-3],[3,-3]] [33.0,31.5,0.0,-1.0] 3 [[0,0], [1,-2], [3,-3]] [47.0,36.0,12.0] 입출력 예 설명 입출력 예 #1 5로 시작하는 우박수열은 5 ⇒ 16 ⇒ 8 ⇒ 4 ⇒ 2 ⇒ 1 입니다. 그래프에서 꺾이는 지점을 경계로 5개의 구역 넓이를 구하면 각각 10.5, 12, 6, 3, 1.5 입니다. 입출력 예 #2 3으로 시작하는 우박수열은 3 ⇒ 10 ⇒ 5 ⇒ 16 ⇒ 8 ⇒ 4 ⇒ 2 ⇒ 1 입니다. 그래프에서 꺾이는 지점을 경계로 3개의 구역 넓이를 구하면 각각 47, 36, 12 입니다. ※ 공지 - 2023년 08월 11일 문제 지문이 리뉴얼되었습니다. 기존에 제출한 코드가 통과하지 못할 수도 있습니다. ※ 공지 - 2023년 09월 06일 지문 오탈자가 수정되었습니다.",normal,Math
221,"햄버거 가게에서 일을 하는 상수는 햄버거를 포장하는 일을 합니다. 함께 일을 하는 다른 직원들이 햄버거에 들어갈 재료를 조리해 주면 조리된 순서대로 상수의 앞에 아래서부터 위로 쌓이게 되고, 상수는 순서에 맞게 쌓여서 완성된 햄버거를 따로 옮겨 포장을 하게 됩니다. 상수가 일하는 가게는 정해진 순서(아래서부터, 빵 – 야채 – 고기 - 빵)로 쌓인 햄버거만 포장을 합니다. 상수는 손이 굉장히 빠르기 때문에 상수가 포장하는 동안 속 재료가 추가적으로 들어오는 일은 없으며, 재료의 높이는 무시하여 재료가 높이 쌓여서 일이 힘들어지는 경우는 없습니다. 예를 들어, 상수의 앞에 쌓이는 재료의 순서가 [야채, 빵, 빵, 야채, 고기, 빵, 야채, 고기, 빵]일 때, 상수는 여섯 번째 재료가 쌓였을 때, 세 번째 재료부터 여섯 번째 재료를 이용하여 햄버거를 포장하고, 아홉 번째 재료가 쌓였을 때, 두 번째 재료와 일곱 번째 재료부터 아홉 번째 재료를 이용하여 햄버거를 포장합니다. 즉, 2개의 햄버거를 포장하게 됩니다. 상수에게 전해지는 재료의 정보를 나타내는 정수 배열 ingredient가 주어졌을 때, 상수가 포장하는 햄버거의 개수를 return 하도록 solution 함수를 완성하시오. 제한사항 1 ≤ ingredient의 길이 ≤ 1,000,000 ingredient의 원소는 1, 2, 3 중 하나의 값이며, 순서대로 빵, 야채, 고기를 의미합니다. 입출력 예 ingredient result [2, 1, 1, 2, 3, 1, 2, 3, 1] 2 [1, 3, 2, 1, 2, 1, 3, 1, 2] 0 입출력 예 설명 입출력 예 #1 문제 예시와 같습니다. 입출력 예 #2 상수가 포장할 수 있는 햄버거가 없습니다.",easy,Array
222,"인천 앞바다에는 1부터 n까지 서로 다른 번호가 매겨진 등대 n개가 존재합니다. 등대와 등대 사이를 오가는 뱃길이 n-1개 존재하여, 어느 등대에서 출발해도 다른 모든 등대까지 이동할 수 있습니다. 등대 관리자 윤성이는 전력을 아끼기 위하여, 이 중 몇 개의 등대만 켜 두려고 합니다. 하지만 등대를 아무렇게나 꺼버리면, 뱃길을 오가는 배들이 위험할 수 있습니다. 한 뱃길의 양쪽 끝 등대 중 적어도 하나는 켜져 있도록 등대를 켜 두어야 합니다. 예를 들어, 아래 그림과 같이 등대 8개와 7개의 뱃길들이 있다고 합시다. 이 경우 1번 등대와 5번 등대 두 개만 켜 두어도 모든 뱃길은 양쪽 끝 등대 중 하나가 켜져 있으므로, 배들은 안전하게 운항할 수 있습니다. 등대의 개수 n과 각 뱃길이 연결된 등대의 번호를 담은 이차원 배열 lighthouse가 매개변수로 주어집니다. 윤성이가 켜 두어야 하는 등대 개수의 최솟값을 return 하도록 solution 함수를 작성해주세요. 제한사항 2 ≤ n ≤ 100,000 lighthouse의 길이 = n – 1 lighthouse 배열의 각 행 [a, b]는 a번 등대와 b번 등대가 뱃길로 연결되어 있다는 의미입니다. 1 ≤ a ≠ b ≤ n 모든 등대는 서로 다른 등대로 이동할 수 있는 뱃길이 존재하도록 입력이 주어집니다. 입출력 예 n lighthouse result 8 [[1, 2], [1, 3], [1, 4], [1, 5], [5, 6], [5, 7], [5, 8]] 2 10 [[4, 1], [5, 1], [5, 6], [7, 6], [1, 2], [1, 3], [6, 8], [2, 9], [9, 10]] 3 입출력 예 설명 입출력 예 #1 본문에서 설명한 예시입니다. 입출력 예 #2 뱃길은 아래 그림과 같이 연결되어 있습니다. 윤성이가 이중 1, 6, 9번 등대 3개만 켜 두어도 모든 뱃길은 양쪽 끝 등대 중 하나가 켜져 있게 되고, 이때의 등대 개수 3개가 최소가 됩니다.",normal,Array
223,"머쓱이는 태어난 지 11개월 된 조카를 돌보고 있습니다. 조카는 아직 ""aya"", ""ye"", ""woo"", ""ma"" 네 가지 발음과 네 가지 발음을 조합해서 만들 수 있는 발음밖에 하지 못하고 연속해서 같은 발음을 하는 것을 어려워합니다. 문자열 배열 babbling이 매개변수로 주어질 때, 머쓱이의 조카가 발음할 수 있는 단어의 개수를 return하도록 solution 함수를 완성해주세요. 제한사항 1 ≤ babbling의 길이 ≤ 100 1 ≤ babbling[i]의 길이 ≤ 30 문자열은 알파벳 소문자로만 이루어져 있습니다. 입출력 예 babbling result [""aya"", ""yee"", ""u"", ""maa""] 1 [""ayaye"", ""uuu"", ""yeye"", ""yemawoo"", ""ayaayaa""] 2 입출력 예 설명 입출력 예 #1 [""aya"", ""yee"", ""u"", ""maa""]에서 발음할 수 있는 것은 ""aya""뿐입니다. 따라서 1을 return합니다. 입출력 예 #2 [""ayaye"", ""uuu"", ""yeye"", ""yemawoo"", ""ayaayaa""]에서 발음할 수 있는 것은 ""aya"" + ""ye"" = ""ayaye"", ""ye"" + ""ma"" + ""woo"" = ""yemawoo""로 2개입니다. ""yeye""는 같은 발음이 연속되므로 발음할 수 없습니다. 따라서 2를 return합니다. 유의사항 네 가지를 붙여 만들 수 있는 발음 이외에는 어떤 발음도 할 수 없는 것으로 규정합니다. 예를 들어 ""woowo""는 ""woo""는 발음할 수 있지만 ""wo""를 발음할 수 없기 때문에 할 수 없는 발음입니다. ※ 공지 - 2024년 2월 20일 문제 지문의 오탈자가 수정되었습니다.",easy,Array
224,"다음은 아이스크림 가게의 상반기 주문 정보를 담은 FIRST_HALF 테이블과 7월의 아이스크림 주문 정보를 담은 JULY 테이블입니다. FIRST_HALF 테이블 구조는 다음과 같으며, SHIPMENT_ID, FLAVOR, TOTAL_ORDER는 각각 아이스크림 공장에서 아이스크림 가게까지의 출하 번호, 아이스크림 맛, 상반기 아이스크림 총주문량을 나타냅니다. FIRST_HALF 테이블의 기본 키는 FLAVOR입니다. FIRST_HALF테이블의 SHIPMENT_ID는 JULY테이블의 SHIPMENT_ID의 외래 키입니다. NAME TYPE NULLABLE SHIPMENT_ID INT(N) FALSE FLAVOR VARCHAR(N) FALSE TOTAL_ORDER INT(N) FALSE JULY 테이블 구조는 다음과 같으며, SHIPMENT_ID, FLAVOR, TOTAL_ORDER 은 각각 아이스크림 공장에서 아이스크림 가게까지의 출하 번호, 아이스크림 맛, 7월 아이스크림 총주문량을 나타냅니다. JULY 테이블의 기본 키는 SHIPMENT_ID입니다. JULY테이블의 FLAVOR는 FIRST_HALF 테이블의 FLAVOR의 외래 키입니다. 7월에는 아이스크림 주문량이 많아 같은 아이스크림에 대하여 서로 다른 두 공장에서 아이스크림 가게로 출하를 진행하는 경우가 있습니다. 이 경우 같은 맛의 아이스크림이라도 다른 출하 번호를 갖게 됩니다. NAME TYPE NULLABLE SHIPMENT_ID INT(N) FALSE FLAVOR VARCHAR(N) FALSE TOTAL_ORDER INT(N) FALSE 문제 7월 아이스크림 총 주문량과 상반기의 아이스크림 총 주문량을 더한 값이 큰 순서대로 상위 3개의 맛을 조회하는 SQL 문을 작성해주세요. 예시 예를 들어 FIRST_HALF 테이블이 다음과 같고 SHIPMENT_ID FLAVOR TOTAL_ORDER 101 chocolate 3200 102 vanilla 2800 103 mint_chocolate 1700 104 caramel 2600 105 white_chocolate 3100 106 peach 2450 107 watermelon 2150 108 mango 2900 109 strawberry 3100 110 melon 3150 111 orange 2900 112 pineapple 2900 JULY테이블이 다음과 같다면 SHIPMENT_ID FLAVOR TOTAL_ORDER 101 chocolate 520 102 vanilla 560 103 mint_chocolate 400 104 caramel 460 105 white_chocolate 350 106 peach 500 107 watermelon 780 108 mango 790 109 strawberry 520 110 melon 400 111 orange 250 112 pineapple 200 208 mango 110 209 strawberry 220 7월 아이스크림 총주문량과 상반기의 아이스크림 총 주문량을 더한 값이 큰 순서대로 상위 3개의 맛을 조회하면 strawberry(520 + 220 + 3,100 = 3,840), mango(790 + 110 + 2,900 = 3,800), chocolate(520 + 3,200 = 3,720) 순입니다. 따라서 SQL 문을 실행하면 다음과 같이 나와야 합니다. FLAVOR strawberry mango chocolate",hard,database
225,"다음은 아이스크림 가게의 상반기 주문 정보를 담은 FIRST_HALF 테이블과 아이스크림 성분에 대한 정보를 담은 ICECREAM_INFO 테이블입니다. FIRST_HALF 테이블 구조는 다음과 같으며, SHIPMENT_ID, FLAVOR, TOTAL_ORDER 는 각각 아이스크림 공장에서 아이스크림 가게까지의 출하 번호, 아이스크림 맛, 상반기 아이스크림 총주문량을 나타냅니다. FIRST_HALF 테이블의 기본 키는 FLAVOR입니다. NAME TYPE NULLABLE SHIPMENT_ID INT(N) FALSE FLAVOR VARCHAR(N) FALSE TOTAL_ORDER INT(N) FALSE ICECREAM_INFO 테이블 구조는 다음과 같으며, FLAVOR, INGREDITENT_TYPE 은 각각 아이스크림 맛, 아이스크림의 성분 타입을 나타냅니다. INGREDIENT_TYPE에는 아이스크림의 주 성분이 설탕이면 sugar_based라고 입력되고, 아이스크림의 주 성분이 과일이면 fruit_based라고 입력됩니다. ICECREAM_INFO의 기본 키는 FLAVOR입니다. ICECREAM_INFO테이블의 FLAVOR는 FIRST_HALF 테이블의 FLAVOR의 외래 키입니다. NAME TYPE NULLABLE FLAVOR VARCHAR(N) FALSE INGREDIENT_TYPE VARCHAR(N) FALSE 문제 상반기 동안 각 아이스크림 성분 타입과 성분 타입에 대한 아이스크림의 총주문량을 총주문량이 작은 순서대로 조회하는 SQL 문을 작성해주세요. 이때 총주문량을 나타내는 컬럼명은 TOTAL_ORDER로 지정해주세요. 예시 예를 들어 FIRST_HALF 테이블이 다음과 같고 SHIPMENT_ID FLAVOR TOTAL_ORDER 101 chocolate 3200 102 vanilla 2800 103 mint_chocolate 1700 104 caramel 2600 105 white_chocolate 3100 106 peach 2450 107 watermelon 2150 108 mango 2900 109 strawberry 3100 110 melon 3150 111 orange 2900 112 pineapple 2900 ICECREAM_INFO 테이블이 다음과 같다면 FLAVOR INGREDIENT_TYPE chocolate sugar_based vanilla sugar_based mint_chocolate sugar_based caramel sugar_based white_chocolate sugar_based peach fruit_based watermelon fruit_based mango fruit_based strawberry fruit_based melon fruit_based orange fruit_based pineapple fruit_based 상반기에 아이스크림의 주 성분이 설탕인 아이스크림들에 대한 총주문량을 구하면 3,200 + 2,800 + 1,700 + 2,600 + 3,100 = 13,400입니다. 아이스크림의 주 성분이 과일인 아이스크림들에 대한 총주문량을 구하면 3,100 + 2,450 + 2,150 + 2,900 + 3,150 + 2,900 + 2,900 = 19,550입니다. 따라서 총주문량이 작은 순서대로 조회하는 SQL 문을 실행하면 다음과 같이 나와야 합니다. INGREDIENT_TYPE TOTAL_ORDER sugar_based 13400 fruit_based 19550",normal,database
226,"다음은 아이스크림 가게의 상반기 주문 정보를 담은 FIRST_HALF 테이블과 아이스크림 성분에 대한 정보를 담은 ICECREAM_INFO 테이블입니다. FIRST_HALF 테이블 구조는 다음과 같으며, SHIPMENT_ID, FLAVOR, TOTAL_ORDER 는 각각 아이스크림 공장에서 아이스크림 가게까지의 출하 번호, 아이스크림 맛, 상반기 아이스크림 총주문량을 나타냅니다. FIRST_HALF 테이블의 기본 키는 FLAVOR입니다. NAME TYPE NULLABLE SHIPMENT_ID INT(N) FALSE FLAVOR VARCHAR(N) FALSE TOTAL_ORDER INT(N) FALSE ICECREAM_INFO 테이블 구조는 다음과 같으며, FLAVOR, INGREDITENT_TYPE 은 각각 아이스크림 맛, 아이스크림의 성분 타입을 나타냅니다. INGREDIENT_TYPE에는 아이스크림의 주 성분이 설탕이면 sugar_based라고 입력되고, 아이스크림의 주 성분이 과일이면 fruit_based라고 입력됩니다. ICECREAM_INFO의 기본 키는 FLAVOR입니다. ICECREAM_INFO테이블의 FLAVOR는 FIRST_HALF 테이블의 FLAVOR의 외래 키입니다. NAME TYPE NULLABLE FLAVOR VARCHAR(N) FALSE INGREDIENT_TYPE VARCHAR(N) FALSE 문제 상반기 아이스크림 총주문량이 3,000보다 높으면서 아이스크림의 주 성분이 과일인 아이스크림의 맛을 총주문량이 큰 순서대로 조회하는 SQL 문을 작성해주세요. 예시 예를 들어 FIRST_HALF 테이블이 다음과 같고 SHIPMENT_ID FLAVOR TOTAL_ORDER 101 chocolate 3200 102 vanilla 2800 103 mint_chocolate 1700 104 caramel 2600 105 white_chocolate 3100 106 peach 2450 107 watermelon 2150 108 mango 2900 109 strawberry 3100 110 melon 3150 111 orange 2900 112 pineapple 2900 ICECREAM_INFO 테이블이 다음과 같다면 FLAVOR INGREDIENT_TYPE chocolate sugar_based vanilla sugar_based mint_chocolate sugar_based caramel sugar_based white_chocolate sugar_based peach fruit_based watermelon fruit_based mango fruit_based strawberry fruit_based melon fruit_based orange fruit_based pineapple fruit_based 상반기 아이스크림 총주문량이 3,000보다 높은 아이스크림 맛은 chocolate, strawberry, melon, white_chocolate입니다. 이 중에 아이스크림의 주 성분이 과일인 아이스크림 맛은 strawberry와 melon이고 총주문량이 큰 순서대로 아이스크림 맛을 조회하면 melon, strawberry 순으로 조회되어야 합니다. 따라서 SQL 문을 실행하면 다음과 같이 나와야 합니다. FLAVOR melon strawberry",easy,database
227,"FIRST_HALF 테이블은 아이스크림 가게의 상반기 주문 정보를 담은 테이블입니다.FIRST_HALF 테이블 구조는 다음과 같으며, SHIPMENT_ID, FLAVOR, TOTAL_ORDER는 각각 아이스크림 공장에서 아이스크림 가게까지의 출하 번호, 아이스크림 맛, 상반기 아이스크림 총주문량을 나타냅니다. NAME TYPE NULLABLE SHIPMENT_ID INT(N) FALSE FLAVOR VARCHAR(N) FALSE TOTAL_ORDER INT(N) FALSE 문제 상반기에 판매된 아이스크림의 맛을 총주문량을 기준으로 내림차순 정렬하고 총주문량이 같다면 출하 번호를 기준으로 오름차순 정렬하여 조회하는 SQL 문을 작성해주세요. 예시 예를 들어 FIRST_HALF 테이블이 다음과 같을 때 SHIPMENT_ID FLAVOR TOTAL_ORDER 101 chocolate 3200 102 vanilla 2800 103 mint_chocolate 1700 104 caramel 2600 105 white_chocolate 3100 106 peach 2450 107 watermelon 2150 108 mango 2900 109 strawberry 3100 110 melon 3150 111 orange 2900 112 pineapple 2900 상반기 아이스크림 맛을 총주문량을 기준으로 내림차순 정렬하고 총주문량이 같은 경우 출하 번호를 기준으로 오름차순 정렬하면 chocolate, melon, white_chocolate, strawberry, mango, orange, pineapple, vanilla, caramel, peach, watermelon, mint_chocolate 순서대로 조회되어야 합니다. 따라서 SQL문을 실행하면 다음과 같이 나와야 합니다. FLAVOR chocolate melon white_chocolate strawberry mango orange pineapple vanilla caramel peach watermelon mint_chocolate",easy,database
228,"오래전 유행했던 콜라 문제가 있습니다. 콜라 문제의 지문은 다음과 같습니다. 정답은 아무에게도 말하지 마세요. 콜라 빈 병 2개를 가져다주면 콜라 1병을 주는 마트가 있다. 빈 병 20개를 가져다주면 몇 병을 받을 수 있는가? 단, 보유 중인 빈 병이 2개 미만이면, 콜라를 받을 수 없다. 문제를 풀던 상빈이는 콜라 문제의 완벽한 해답을 찾았습니다. 상빈이가 푼 방법은 아래 그림과 같습니다. 우선 콜라 빈 병 20병을 가져가서 10병을 받습니다. 받은 10병을 모두 마신 뒤, 가져가서 5병을 받습니다. 5병 중 4병을 모두 마신 뒤 가져가서 2병을 받고, 또 2병을 모두 마신 뒤 가져가서 1병을 받습니다. 받은 1병과 5병을 받았을 때 남은 1병을 모두 마신 뒤 가져가면 1병을 또 받을 수 있습니다. 이 경우 상빈이는 총 10 + 5 + 2 + 1 + 1 = 19병의 콜라를 받을 수 있습니다. 문제를 열심히 풀던 상빈이는 일반화된 콜라 문제를 생각했습니다. 이 문제는 빈 병 a개를 가져다주면 콜라 b병을 주는 마트가 있을 때, 빈 병 n개를 가져다주면 몇 병을 받을 수 있는지 계산하는 문제입니다. 기존 콜라 문제와 마찬가지로, 보유 중인 빈 병이 a개 미만이면, 추가적으로 빈 병을 받을 순 없습니다. 상빈이는 열심히 고심했지만, 일반화된 콜라 문제의 답을 찾을 수 없었습니다. 상빈이를 도와, 일반화된 콜라 문제를 해결하는 프로그램을 만들어 주세요. 콜라를 받기 위해 마트에 주어야 하는 병 수 a, 빈 병 a개를 가져다 주면 마트가 주는 콜라 병 수 b, 상빈이가 가지고 있는 빈 병의 개수 n이 매개변수로 주어집니다. 상빈이가 받을 수 있는 콜라의 병 수를 return 하도록 solution 함수를 작성해주세요. 제한사항 1 ≤ b < a ≤ n ≤ 1,000,000 정답은 항상 int 범위를 넘지 않게 주어집니다. 입출력 예 a b n result 2 1 20 19 3 1 20 9 입출력 예 설명 입출력 예 #1 본문에서 설명한 예시입니다. 입출력 예 #2 빈 병 20개 중 18개를 마트에 가져가서, 6병의 콜라를 받습니다. 이때 상빈이가 가지고 있는 콜라 병의 수는 8(20 – 18 + 6 = 8)개 입니다. 빈 병 8개 중 6개를 마트에 가져가서, 2병의 콜라를 받습니다. 이때 상빈이가 가지고 있는 콜라 병의 수는 4(8 – 6 + 2 = 4)개 입니다. 빈 병 4 개중 3개를 마트에 가져가서, 1병의 콜라를 받습니다. 이때 상빈이가 가지고 있는 콜라 병의 수는 2(4 – 3 + 1 = 2)개 입니다. 3번의 교환 동안 상빈이는 9(6 + 2 + 1 = 9)병의 콜라를 받았습니다.",easy,Math
229,"강철부대의 각 부대원이 여러 지역에 뿔뿔이 흩어져 특수 임무를 수행 중입니다. 지도에서 강철부대가 위치한 지역을 포함한 각 지역은 유일한 번호로 구분되며, 두 지역 간의 길을 통과하는 데 걸리는 시간은 모두 1로 동일합니다. 임무를 수행한 각 부대원은 지도 정보를 이용하여 최단시간에 부대로 복귀하고자 합니다. 다만 적군의 방해로 인해, 임무의 시작 때와 다르게 되돌아오는 경로가 없어져 복귀가 불가능한 부대원도 있을 수 있습니다. 강철부대가 위치한 지역을 포함한 총지역의 수 n, 두 지역을 왕복할 수 있는 길 정보를 담은 2차원 정수 배열 roads, 각 부대원이 위치한 서로 다른 지역들을 나타내는 정수 배열 sources, 강철부대의 지역 destination이 주어졌을 때, 주어진 sources의 원소 순서대로 강철부대로 복귀할 수 있는 최단시간을 담은 배열을 return하는 solution 함수를 완성해주세요. 복귀가 불가능한 경우 해당 부대원의 최단시간은 -1입니다. 제한사항 3 ≤ n ≤ 100,000 각 지역은 정수 1부터 n까지의 번호로 구분됩니다. 2 ≤ roads의 길이 ≤ 500,000 roads의 원소의 길이 = 2 roads의 원소는 [a, b] 형태로 두 지역 a, b가 서로 왕복할 수 있음을 의미합니다.(1 ≤ a, b ≤ n, a ≠ b) 동일한 정보가 중복해서 주어지지 않습니다. 동일한 [a, b]가 중복해서 주어지지 않습니다. [a, b]가 있다면 [b, a]는 주어지지 않습니다. 1 ≤ sources의 길이 ≤ 500 1 ≤ sources[i] ≤ n 1 ≤ destination ≤ n 입출력 예 n roads sources destination result 3 [[1, 2], [2, 3]] [2, 3] 1 [1, 2] 5 [[1, 2], [1, 4], [2, 4], [2, 5], [4, 5]] [1, 3, 5] 5 [2, -1, 0] 입출력 예 설명 입출력 예 #1 지역 2는 지역 1과 길로 연결되어 있기 때문에, 지역 2에서 지역 1의 최단거리는 1입니다. 지역 3에서 지역 1로 이동할 수 있는 최단경로는 지역 3 → 지역 2 → 지역 1 순으로 이동하는 것이기 때문에, 지역 3에서 지역 1의 최단거리는 2입니다. 따라서 [1, 2]를 return합니다. 입출력 예 #2 지역 1에서 지역 5의 최단경로는 지역 1 → 지역 2 → 지역 5 또는 지역 1 → 지역 4 → 지역 5 순으로 이동하는 것이기 때문에, 최단거리는 2입니다. 지역 3에서 지역 5로 가는 경로가 없기 때문에, 지역 3에서 지역 5로 가는 최단거리는 -1입니다. 지역 5에서 지역 5는 이동할 필요가 없기 때문에, 최단거리는 0입니다. 따라서 [2, -1, 0]을 return합니다.",normal,Array
230,"철수는 롤케이크를 두 조각으로 잘라서 동생과 한 조각씩 나눠 먹으려고 합니다. 이 롤케이크에는 여러가지 토핑들이 일렬로 올려져 있습니다. 철수와 동생은 롤케이크를 공평하게 나눠먹으려 하는데, 그들은 롤케이크의 크기보다 롤케이크 위에 올려진 토핑들의 종류에 더 관심이 많습니다. 그래서 잘린 조각들의 크기와 올려진 토핑의 개수에 상관없이 각 조각에 동일한 가짓수의 토핑이 올라가면 공평하게 롤케이크가 나누어진 것으로 생각합니다. 예를 들어, 롤케이크에 4가지 종류의 토핑이 올려져 있다고 합시다. 토핑들을 1, 2, 3, 4와 같이 번호로 표시했을 때, 케이크 위에 토핑들이 [1, 2, 1, 3, 1, 4, 1, 2] 순서로 올려져 있습니다. 만약 세 번째 토핑(1)과 네 번째 토핑(3) 사이를 자르면 롤케이크의 토핑은 [1, 2, 1], [3, 1, 4, 1, 2]로 나뉘게 됩니다. 철수가 [1, 2, 1]이 놓인 조각을, 동생이 [3, 1, 4, 1, 2]가 놓인 조각을 먹게 되면 철수는 두 가지 토핑(1, 2)을 맛볼 수 있지만, 동생은 네 가지 토핑(1, 2, 3, 4)을 맛볼 수 있으므로, 이는 공평하게 나누어진 것이 아닙니다. 만약 롤케이크의 네 번째 토핑(3)과 다섯 번째 토핑(1) 사이를 자르면 [1, 2, 1, 3], [1, 4, 1, 2]로 나뉘게 됩니다. 이 경우 철수는 세 가지 토핑(1, 2, 3)을, 동생도 세 가지 토핑(1, 2, 4)을 맛볼 수 있으므로, 이는 공평하게 나누어진 것입니다. 공평하게 롤케이크를 자르는 방법은 여러가지 일 수 있습니다. 위의 롤케이크를 [1, 2, 1, 3, 1], [4, 1, 2]으로 잘라도 공평하게 나뉩니다. 어떤 경우에는 롤케이크를 공평하게 나누지 못할 수도 있습니다. 롤케이크에 올려진 토핑들의 번호를 저장한 정수 배열 topping이 매개변수로 주어질 때, 롤케이크를 공평하게 자르는 방법의 수를 return 하도록 solution 함수를 완성해주세요. 제한사항 1 ≤ topping의 길이 ≤ 1,000,000 1 ≤ topping의 원소 ≤ 10,000 입출력 예 topping result [1, 2, 1, 3, 1, 4, 1, 2] 2 [1, 2, 3, 1, 4] 0 입출력 예 설명 입출력 예 #1 롤케이크를 [1, 2, 1, 3], [1, 4, 1, 2] 또는 [1, 2, 1, 3, 1], [4, 1, 2]와 같이 자르면 철수와 동생은 각각 세 가지 토핑을 맛볼 수 있습니다. 이 경우 공평하게 롤케이크를 나누는 방법은 위의 두 가지만 존재합니다. 입출력 예 #2 롤케이크를 공평하게 나눌 수 없습니다.",normal,Array
231,"다음은 환자 정보를 담은 PATIENT 테이블과 의사 정보를 담은 DOCTOR 테이블, 그리고 진료 예약목록을 담은 APPOINTMENT에 대한 테이블입니다. PATIENT 테이블은 다음과 같으며 PT_NO, PT_NAME, GEND_CD, AGE, TLNO는 각각 환자번호, 환자이름, 성별코드, 나이, 전화번호를 의미합니다. Column name Type Nullable PT_NO VARCHAR(N) FALSE PT_NAME VARCHAR(N) FALSE GEND_CD VARCHAR(N) FALSE AGE INTEGER FALSE TLNO VARCHAR(N) TRUE DOCTOR 테이블은 다음과 같으며 DR_NAME, DR_ID, LCNS_NO, HIRE_YMD, MCDP_CD, TLNO는 각각 의사이름, 의사ID, 면허번호, 고용일자, 진료과코드, 전화번호를 나타냅니다. Column name Type Nullable DR_NAME VARCHAR(N) FALSE DR_ID VARCHAR(N) FALSE LCNS_NO VARCHAR(N) FALSE HIRE_YMD DATE FALSE MCDP_CD VARCHAR(N) TRUE TLNO VARCHAR(N) TRUE APPOINTMENT 테이블은 다음과 같으며 APNT_YMD, APNT_NO, PT_NO, MCDP_CD, MDDR_ID, APNT_CNCL_YN, APNT_CNCL_YMD는 각각 진료 예약일시, 진료예약번호, 환자번호, 진료과코드, 의사ID, 예약취소여부, 예약취소날짜를 나타냅니다. Column name Type Nullable APNT_YMD TIMESTAMP FALSE APNT_NO INTEGER FALSE PT_NO VARCHAR(N) FALSE MCDP_CD VARCHAR(N) FALSE MDDR_ID VARCHAR(N) FALSE APNT_CNCL_YN VARCHAR(N) TRUE APNT_CNCL_YMD DATE TRUE 문제 PATIENT, DOCTOR 그리고 APPOINTMENT 테이블에서 2022년 4월 13일 취소되지 않은 흉부외과(CS) 진료 예약 내역을 조회하는 SQL문을 작성해주세요. 진료예약번호, 환자이름, 환자번호, 진료과코드, 의사이름, 진료예약일시 항목이 출력되도록 작성해주세요. 결과는 진료예약일시를 기준으로 오름차순 정렬해주세요. 예시 PATIENT 테이블이 다음과 같고, PT_NO PT_NAME GEND_CD AGE TLNO PT22000019 바라 W 10 01079068799 PT22000043 오스왈드 M 68 01031294124 PT22000052 제니 W 60 NULL PT22000071 몬몬 M 31 01076489209 PT22000097 슈가 M 19 NULL DOCTOR 테이블이 다음과 같고, DR_NAME DR_ID LCNS_NO HIRE_YMD MCDP_CD TLNO 루피 DR20090029 LC00010001 2009-03-01 CS 01085482011 니모 DR20200012 LC00911162 2020-03-01 CS 01089483921 핑크퐁 DR20140011 LC00082201 2014-03-01 NP 01098428957 젤라비 DR20160031 LC00340327 2016-11-01 OB 01023981922 토리 DR20190129 LC00099911 2019-03-01 NS 01058390758 APPOINTMENT 테이블이 다음과 같을 때, APNT_YMD APNT_NO PT_NO MCDP_CD MDDR_ID APNT_CNCL_YN APNT_CNCL_YMD 2022-04-13 12:30:00.000000 42 PT22000071 CS DR20090029 N NULL 2022-04-13 15:30:00.000000 43 PT22000019 CS DR20200012 N NULL 2022-04-13 09:00:00.000000 46 PT22000043 CS DR20090029 N NULL 2022-07-09 11:00:00.000000 74 PT22000042 NP DR20100011 N NULL 2022-12-13 12:30:00.000000 110 PT22000097 NP DR20160011 Y 2022-12-03 SQL을 실행하면 다음과 같이 출력되어야 합니다. APNT_NO PT_NAME PT_NO MCDP_CD DR_NAME APNT_YMD 46 오스왈드 PT22000043 CS 루피 2022-04-13 09:00:00.000000 42 몬몬 PT22000071 CS 루피 2022-04-13 12:30:00.000000 43 바라 PT22000019 CS 니모 2022-04-13 15:30:00.000000",hard,database
232,"다음은 종합병원에 속한 의사 정보를 담은DOCTOR 테이블입니다. DOCTOR 테이블은 다음과 같으며 DR_NAME, DR_ID, LCNS_NO, HIRE_YMD, MCDP_CD, TLNO는 각각 의사이름, 의사ID, 면허번호, 고용일자, 진료과코드, 전화번호를 나타냅니다. Column name Type Nullable DR_NAME VARCHAR(20) FALSE DR_ID VARCHAR(10) FALSE LCNS_NO VARCHAR(30) FALSE HIRE_YMD DATE FALSE MCDP_CD VARCHAR(6) TRUE TLNO VARCHAR(50) TRUE 문제 DOCTOR 테이블에서 진료과가 흉부외과(CS)이거나 일반외과(GS)인 의사의 이름, 의사ID, 진료과, 고용일자를 조회하는 SQL문을 작성해주세요. 이때 결과는 고용일자를 기준으로 내림차순 정렬하고, 고용일자가 같다면 이름을 기준으로 오름차순 정렬해주세요. 예시 DOCTOR 테이블이 다음과 같을 때 DR_NAME DR_ID LCNS_NO HIRE_YMD MCDP_CD TLNO 루피 DR20090029 LC00010001 2009-03-01 CS 01085482011 패티 DR20090001 LC00010901 2009-07-01 CS 01085220122 뽀로로 DR20170123 LC00091201 2017-03-01 GS 01034969210 티거 DR20100011 LC00011201 2010-03-01 NP 01034229818 품바 DR20090231 LC00011302 2015-11-01 OS 01049840278 티몬 DR20090112 LC00011162 2010-03-01 FM 01094622190 니모 DR20200012 LC00911162 2020-03-01 CS 01089483921 오로라 DR20100031 LC00010327 2010-11-01 OS 01098428957 자스민 DR20100032 LC00010192 2010-03-01 GS 01023981922 벨 DR20100039 LC00010562 2010-07-01 GS 01058390758 SQL을 실행하면 다음과 같이 출력되어야 합니다. DR_NAME DR_ID MCDP_CD HIRE_YMD 니모 DR20200012 CS 2020-03-01 뽀로로 DR20170123 GS 2017-03-01 벨 DR20100039 GS 2010-07-01 자스민 DR20100032 GS 2010-03-01 패티 DR20090001 CS 2009-07-01 루피 DR20090029 CS 2009-03-01 주의사항 날짜 포맷은 예시와 동일하게 나와야합니다.",easy,database
233,"다음은 종합병원의 진료 예약정보를 담은 APPOINTMENT 테이블 입니다. APPOINTMENT 테이블은 다음과 같으며 APNT_YMD, APNT_NO, PT_NO, MCDP_CD, MDDR_ID, APNT_CNCL_YN, APNT_CNCL_YMD는 각각 진료예약일시, 진료예약번호, 환자번호, 진료과코드, 의사ID, 예약취소여부, 예약취소날짜를 나타냅니다. Column name Type Nullable APNT_YMD TIMESTAMP FALSE APNT_NO NUMBER(5) FALSE PT_NO VARCHAR(10) FALSE MCDP_CD VARCHAR(6) FALSE MDDR_ID VARCHAR(10) FALSE APNT_CNCL_YN VARCHAR(1) TRUE APNT_CNCL_YMD DATE TRUE 문제 APPOINTMENT 테이블에서 2022년 5월에 예약한 환자 수를 진료과코드 별로 조회하는 SQL문을 작성해주세요. 이때, 컬럼명은 '진료과 코드', '5월예약건수'로 지정해주시고 결과는 진료과별 예약한 환자 수를 기준으로 오름차순 정렬하고, 예약한 환자 수가 같다면 진료과 코드를 기준으로 오름차순 정렬해주세요. 예시 APPOINTMENT 테이블이 다음과 같을 때 APNT_YMD APNT_NO PT_NO MCDP_CD MDDR_ID APNT_CNCL_YN APNT_CNCL_YMD 2022-04-14 09:30:00.000000 47 PT22000064 GS DR20170123 N NULL 2022-04-15 10:30:00.000000 48 PT22000065 OB DR20100231 N NULL 2022-05-15 17:30:00.000000 49 PT22000086 OB DR20100231 N NULL 2022-05-18 10:30:00.000000 52 PT22000019 GS DR20100039 N NULL 2022-05-19 12:00:00.000000 53 PT22000020 FM DR20010112 N NULL 2022-05-22 08:30:00.000000 54 PT22000021 GS DR20100039 N NULL 2022-05-04 10:30:00.000000 56 PT22000023 FM DR20090112 N NULL 2022-05-14 15:30:00.000000 57 PT22000074 CS DR20200012 N NULL 2022-05-24 15:30:00.000000 58 PT22000085 CS DR20200012 N NULL 2022-05-28 10:00:00.000000 60 PT22000092 OS DR20100031 N NULL SQL을 실행하면 다음과 같이 출력되어야 합니다. 진료과코드 5월예약건수 OB 1 OS 1 CS 2 FM 2 GS 2",normal,database
234,"다음은 종합병원에 등록된 환자정보를 담은 PATIENT 테이블입니다. PATIENT 테이블은 다음과 같으며 PT_NO, PT_NAME, GEND_CD, AGE, TLNO는 각각 환자번호, 환자이름, 성별코드, 나이, 전화번호를 의미합니다. Column name Type Nullable PT_NO VARCHAR(10) FALSE PT_NAME VARCHAR(20) FALSE GEND_CD VARCHAR(1) FALSE AGE INTEGER FALSE TLNO VARCHAR(50) TRUE 문제 PATIENT 테이블에서 12세 이하인 여자환자의 환자이름, 환자번호, 성별코드, 나이, 전화번호를 조회하는 SQL문을 작성해주세요. 이때 전화번호가 없는 경우, 'NONE'으로 출력시켜 주시고 결과는 나이를 기준으로 내림차순 정렬하고, 나이 같다면 환자이름을 기준으로 오름차순 정렬해주세요. 예시 PATIENT 테이블이 다음과 같을 때 PT_NO PT_NAME GEND_CD AGE TLNO PT22000003 브라운 M 18 01031246641 PT22000004 크롱 M 7 NULL PT22000006 뽀뽀 W 8 NULL PT22000009 한나 W 12 01032323117 PT22000012 뿡뿡이 M 5 NULL PT22000013 크리스 M 30 01059341192 PT22000014 토프 W 22 01039458213 PT22000018 안나 W 11 NULL PT22000019 바라 W 10 01079068799 PT22000021 릴로 W 33 01023290767 SQL을 실행하면 다음과 같이 출력되어야 합니다. PT_NAME PT_NO GEND_CD AGE TLNO 한나 PT22000009 W 12 01032323117 안나 PT22000018 W 11 NONE 바라 PT22000019 W 10 01079068799 뽀뽀 PT22000006 W 8 NONE",easy,database
235,"한국중학교에 다니는 학생들은 각자 정수 번호를 갖고 있습니다. 이 학교 학생 3명의 정수 번호를 더했을 때 0이 되면 3명의 학생은 삼총사라고 합니다. 예를 들어, 5명의 학생이 있고, 각각의 정수 번호가 순서대로 -2, 3, 0, 2, -5일 때, 첫 번째, 세 번째, 네 번째 학생의 정수 번호를 더하면 0이므로 세 학생은 삼총사입니다. 또한, 두 번째, 네 번째, 다섯 번째 학생의 정수 번호를 더해도 0이므로 세 학생도 삼총사입니다. 따라서 이 경우 한국중학교에서는 두 가지 방법으로 삼총사를 만들 수 있습니다. 한국중학교 학생들의 번호를 나타내는 정수 배열 number가 매개변수로 주어질 때, 학생들 중 삼총사를 만들 수 있는 방법의 수를 return 하도록 solution 함수를 완성하세요. 제한사항 3 ≤ number의 길이 ≤ 13 -1,000 ≤ number의 각 원소 ≤ 1,000 서로 다른 학생의 정수 번호가 같을 수 있습니다. 입출력 예 number result [-2, 3, 0, 2, -5] 2 [-3, -2, -1, 0, 1, 2, 3] 5 [-1, 1, -1, 1] 0 입출력 예 설명 입출력 예 #1 문제 예시와 같습니다. 입출력 예 #2 학생들의 정수 번호 쌍 (-3, 0, 3), (-2, 0, 2), (-1, 0, 1), (-2, -1, 3), (-3, 1, 2) 이 삼총사가 될 수 있으므로, 5를 return 합니다. 입출력 예 #3 삼총사가 될 수 있는 방법이 없습니다.",easy,Array
236,"영재는 택배상자를 트럭에 싣는 일을 합니다. 영재가 실어야 하는 택배상자는 크기가 모두 같으며 1번 상자부터 n번 상자까지 번호가 증가하는 순서대로 컨테이너 벨트에 일렬로 놓여 영재에게 전달됩니다. 컨테이너 벨트는 한 방향으로만 진행이 가능해서 벨트에 놓인 순서대로(1번 상자부터) 상자를 내릴 수 있습니다. 하지만 컨테이너 벨트에 놓인 순서대로 택배상자를 내려 바로 트럭에 싣게 되면 택배 기사님이 배달하는 순서와 택배상자가 실려 있는 순서가 맞지 않아 배달에 차질이 생깁니다. 따라서 택배 기사님이 미리 알려준 순서에 맞게 영재가 택배상자를 실어야 합니다. 만약 컨테이너 벨트의 맨 앞에 놓인 상자가 현재 트럭에 실어야 하는 순서가 아니라면 그 상자를 트럭에 실을 순서가 될 때까지 잠시 다른 곳에 보관해야 합니다. 하지만 고객의 물건을 함부로 땅에 둘 수 없어 보조 컨테이너 벨트를 추가로 설치하였습니다. 보조 컨테이너 벨트는 앞 뒤로 이동이 가능하지만 입구 외에 다른 면이 막혀 있어서 맨 앞의 상자만 뺄 수 있습니다(즉, 가장 마지막에 보조 컨테이너 벨트에 보관한 상자부터 꺼내게 됩니다). 보조 컨테이너 벨트를 이용해도 기사님이 원하는 순서대로 상자를 싣지 못 한다면, 더 이상 상자를 싣지 않습니다. 예를 들어, 영재가 5개의 상자를 실어야 하며, 택배 기사님이 알려준 순서가 기존의 컨테이너 벨트에 네 번째, 세 번째, 첫 번째, 두 번째, 다섯 번째 놓인 택배상자 순서인 경우, 영재는 우선 첫 번째, 두 번째, 세 번째 상자를 보조 컨테이너 벨트에 보관합니다. 그 후 네 번째 상자를 트럭에 싣고 보조 컨테이너 벨트에서 세 번째 상자 빼서 트럭에싣습니다. 다음으로 첫 번째 상자를 실어야 하지만 보조 컨테이너 벨트에서는 두 번째 상자를, 기존의 컨테이너 벨트에는 다섯 번째 상자를 꺼낼 수 있기 때문에 더이상의 상자는 실을 수 없습니다. 따라서 트럭에는 2개의 상자만 실리게 됩니다. 택배 기사님이 원하는 상자 순서를 나타내는 정수 배열 order가 주어졌을 때, 영재가 몇 개의 상자를 실을 수 있는지 return 하는 solution 함수를 완성하세요. 제한사항 1 ≤ order의 길이 ≤ 1,000,000 order는 1이상 order의 길이 이하의 모든 정수가 한번씩 등장합니다. order[i]는 기존의 컨테이너 벨트에 order[i]번째 상자를 i+1번째로 트럭에 실어야 함을 의미합니다. 입출력 예 order result [4, 3, 1, 2, 5] 2 [5, 4, 3, 2, 1] 5 입출력 예 설명 입출력 예 #1 문제 예시와 같습니다. 입출력 예 #2 모든 상자를 보조 컨테이너 벨트에 모두 넣고, 역순으로 하나씩 빼서 트럭에 싣습니다.",normal,Array
237,"한수는 직사각형 모양의 공간에 놓인 동전들을 뒤집는 놀이를 하고 있습니다. 모든 동전들은 앞과 뒤가 구분되어 있으며, 동전을 뒤집기 위해서는 같은 줄에 있는 모든 동전을 뒤집어야 합니다. 동전들의 초기 상태와 목표 상태가 주어졌을 때, 초기 상태에서 최소 몇 번의 동전을 뒤집어야 목표 상태가 되는지 알아봅시다. 예를 들어, 위 그림에서 맨 왼쪽이 초기 상태, 맨 오른쪽이 목표 상태인 경우에 대해 알아봅시다. 그림에서 검은색 원은 앞면인 동전, 흰색 원은 뒷면인 동전을 의미합니다. 초기 상태에서 2행과 4행의 돌들을 뒤집으면, 두 번째 그림이 됩니다. 그 후, 2열, 4열, 5열의 돌들을 순서대로 뒤집는 다면, 총 5번의 동전 뒤집기를 통해 목표 상태가 되며, 이 경우가 최소인 경우입니다. 직사각형 모양의 공간에 놓인 동전들의 초기 상태를 나타내는 2차원 정수 배열 beginning, 목표 상태를 나타내는 target이 주어졌을 때, 초기 상태에서 목표 상태로 만들기 위해 필요한 동전 뒤집기 횟수의 최솟값을 return 하는 solution 함수를 완성하세요. 단, 목표 상태를 만들지 못하는 경우에는 -1을 return 합니다. 제한사항 1 ≤ beginning의 길이 = target의 길이 ≤ 10 1 ≤ beginning[i]의 길이 = target[i]의 길이 ≤ 10 beginning[i][j]와 target[i][j]는 i + 1행 j + 1열의 동전의 상태를 나타내며, 0 또는 1의 값으로 주어집니다. 0은 동전의 앞면을, 1은 동전의 뒷면을 의미합니다. 입출력 예 beginning target result [[0, 1, 0, 0, 0], [1, 0, 1, 0, 1], [0, 1, 1, 1, 0], [1, 0, 1, 1, 0], [0, 1, 0, 1, 0]] [[0, 0, 0, 1, 1], [0, 0, 0, 0, 1], [0, 0, 1, 0, 1], [0, 0, 0, 1, 0], [0, 0, 0, 0, 1]] 5 [[0, 0, 0], [0, 0, 0], [0, 0, 0]] [[1, 0, 1], [0, 0, 0], [0, 0, 0]] -1 입출력 예 설명 입출력 예 #1 문제 예시와 같습니다. 입출력 예 #2 목표 상태를 만들지 못합니다. 따라서 -1을 return 합니다.",normal,Array
238,"고고학자인 혜선은 오래전부터 성궤의 행방을 추적해왔습니다. 그동안 그의 연구는 주류 학자들로부터 인정받지 못했었지만, 혜선이는 포기하지 않고 조사를 계속했고 마침내 성궤의 행방을 알아내었습니다. 그러나 오래전 누군가로부터 봉인된 성궤는 특별한 잠금장치에 의해 보호되고 있었습니다. 잠금장치는 일종의 퍼즐과 연결되어 퍼즐을 해결하면 열리는 것으로 보입니다. 퍼즐은 시계들이 행렬을 이루는 구조물인데 하나의 시계에 시곗바늘은 하나씩만 있습니다. 각 시곗바늘은 시계방향으로만 돌릴 수 있고 한 번의 조작으로 90도씩 돌릴 수 있습니다. 시계들은 기계장치에 의해 연결되어 있어 어떤 시계의 시곗바늘을 돌리면 그 시계의 상하좌우로 인접한 시계들의 시곗바늘도 함께 돌아갑니다. 행렬의 모서리에 위치한 시계의 시곗바늘을 돌리는 경우에는 인접한 세 시계의 시곗바늘들이 함께 돌아가며, 꼭짓점에 위치한 시계의 시곗바늘을 돌리는 경우에는 인접한 두 시계의 시곗바늘들이 함께 돌아갑니다. 각 시계는 12시, 3시, 6시, 9시 방향 중의 한 방향을 가리키고 있습니다. 각 시계의 시곗바늘을 적절히 조작하여 모든 시곗바늘이 12시 방향을 가리키면 퍼즐이 해결되어 성궤를 봉인하고 있는 잠금장치가 열릴 것입니다. 노후화된 퍼즐 기계장치가 걱정되었던 혜선은 가능한 최소한의 조작으로 퍼즐을 해결하려고 합니다. 시곗바늘들의 행렬 clockHands가 매개변수로 주어질 때, 퍼즐을 해결하기 위한 최소한의 조작 횟수를 return 하도록 solution 함수를 완성해주세요. 제한사항 2 ≤ clockHands의 길이 ≤ 8 clockHands는 2차원 배열이며 행과 열의 크기가 동일합니다. 0 ≤ clockHands의 원소 ≤ 3 clockHands[i]의 원소들은 시곗바늘의 방향을 나타내며 0은 12시 방향, 1은 3시 방향, 2는 6시 방향, 3은 9시 방향을 나타냅니다. 해결 가능한 퍼즐만 주어집니다. 입출력 예 clockHands result [[0,3,3,0],[3,2,2,3],[0,3,2,0],[0,3,3,3]] 3 입출력 예 설명 입출력 예 #1 2행 2열의 시곗바늘, 2행 3열의 시곗바늘, 4행 3열의 시곗바늘을 각각 한 번씩 돌리면 최소 조작 횟수로 퍼즐을 해결할 수 있습니다.",normal,Array
239,"철호는 수열을 가지고 놀기 좋아합니다. 어느 날 철호는 어떤 자연수로 이루어진 원형 수열의 연속하는 부분 수열의 합으로 만들 수 있는 수가 모두 몇 가지인지 알아보고 싶어졌습니다. 원형 수열이란 일반적인 수열에서 처음과 끝이 연결된 형태의 수열을 말합니다. 예를 들어 수열 [7, 9, 1, 1, 4] 로 원형 수열을 만들면 다음과 같습니다. 원형 수열은 처음과 끝이 연결되어 끊기는 부분이 없기 때문에 연속하는 부분 수열도 일반적인 수열보다 많아집니다. 원형 수열의 모든 원소 elements가 순서대로 주어질 때, 원형 수열의 연속 부분 수열 합으로 만들 수 있는 수의 개수를 return 하도록 solution 함수를 완성해주세요. 제한사항 3 ≤ elements의 길이 ≤ 1,000 1 ≤ elements의 원소 ≤ 1,000 입출력 예 elements result [7,9,1,1,4] 18 입출력 예 설명 입출력 예 #1 길이가 1인 연속 부분 수열로부터 [1, 4, 7, 9] 네 가지의 합이 나올 수 있습니다. 길이가 2인 연속 부분 수열로부터 [2, 5, 10, 11, 16] 다섯 가지의 합이 나올 수 있습니다. 길이가 3인 연속 부분 수열로부터 [6, 11, 12, 17, 20] 다섯 가지의 합이 나올 수 있습니다. 길이가 4인 연속 부분 수열로부터 [13, 15, 18, 21] 네 가지의 합이 나올 수 있습니다. 길이가 5인 연속 부분 수열로부터 [22] 한 가지의 합이 나올 수 있습니다. 이들 중 중복되는 값을 제외하면 다음과 같은 18가지의 수들을 얻습니다. [1, 2, 4, 5, 6, 7, 9, 10, 11, 12, 13, 15, 16, 17, 18, 20, 21, 22]",normal,Math
240,"다음은 어느 의류 쇼핑몰에서 판매 중인 상품들의 정보를 담은 PRODUCT 테이블입니다. PRODUCT 테이블은 아래와 같은 구조로 되어있으며, PRODUCT_ID, PRODUCT_CODE, PRICE는 각각 상품 ID, 상품코드, 판매가를 나타냅니다. Column name Type Nullable PRODUCT_ID INTEGER FALSE PRODUCT_CODE VARCHAR(8) FALSE PRICE INTEGER FALSE 상품 별로 중복되지 않는 8자리 상품코드 값을 가지며, 앞 2자리는 카테고리 코드를 의미합니다. 문제 PRODUCT 테이블에서 판매 중인 상품 중 가장 높은 판매가를 출력하는 SQL문을 작성해주세요. 이때 컬럼명은 MAX_PRICE로 지정해주세요. 예시 예를 들어 PRODUCT 테이블이 다음과 같다면 PRODUCT_ID PRODUCT_CODE PRICE 1 A1000001 10000 2 A2000005 9000 3 C1000006 22000 가장 높은 판매가는 22,000 원 이므로, 다음과 같은 결과가 나와야 합니다. MAX_PRICE 22000",easy,database
241,"다음은 어느 의류 쇼핑몰의 온라인 상품 판매 정보를 담은 ONLINE_SALE 테이블과 오프라인 상품 판매 정보를 담은 OFFLINE_SALE 테이블 입니다. ONLINE_SALE 테이블은 아래와 같은 구조로 되어있으며 ONLINE_SALE_ID, USER_ID, PRODUCT_ID, SALES_AMOUNT, SALES_DATE는 각각 온라인 상품 판매 ID, 회원 ID, 상품 ID, 판매량, 판매일을 나타냅니다. Column name Type Nullable ONLINE_SALE_ID INTEGER FALSE USER_ID INTEGER FALSE PRODUCT_ID INTEGER FALSE SALES_AMOUNT INTEGER FALSE SALES_DATE DATE FALSE 동일한 날짜, 회원 ID, 상품 ID 조합에 대해서는 하나의 판매 데이터만 존재합니다. OFFLINE_SALE 테이블은 아래와 같은 구조로 되어있으며 OFFLINE_SALE_ID, PRODUCT_ID, SALES_AMOUNT, SALES_DATE는 각각 오프라인 상품 판매 ID, 상품 ID, 판매량, 판매일을 나타냅니다. Column name Type Nullable OFFLINE_SALE_ID INTEGER FALSE PRODUCT_ID INTEGER FALSE SALES_AMOUNT INTEGER FALSE SALES_DATE DATE FALSE 동일한 날짜, 상품 ID 조합에 대해서는 하나의 판매 데이터만 존재합니다. 문제 ONLINE_SALE 테이블과 OFFLINE_SALE 테이블에서 2022년 3월의 오프라인/온라인 상품 판매 데이터의 판매 날짜, 상품ID, 유저ID, 판매량을 출력하는 SQL문을 작성해주세요. OFFLINE_SALE 테이블의 판매 데이터의 USER_ID 값은 NULL 로 표시해주세요. 결과는 판매일을 기준으로 오름차순 정렬해주시고 판매일이 같다면 상품 ID를 기준으로 오름차순, 상품ID까지 같다면 유저 ID를 기준으로 오름차순 정렬해주세요. 예시 예를 들어 ONLINE_SALE 테이블이 다음과 같고 ONLINE_SALE_ID USER_ID PRODUCT_ID SALES_AMOUNT SALES_DATE 1 1 3 2 2022-02-25 2 4 4 1 2022-03-01 4 2 2 2 2022-03-02 3 6 3 3 2022-03-02 5 5 5 1 2022-03-03 6 5 7 1 2022-04-06 OFFLINE_SALE 테이블이 다음과 같다면 OFFLINE_SALE_ID PRODUCT_ID SALES_AMOUNT SALES_DATE 1 1 2 2022-02-21 4 1 2 2022-03-01 3 3 3 2022-03-01 2 4 1 2022-03-01 5 2 1 2022-03-03 6 2 1 2022-04-01 각 테이블의 2022년 3월의 판매 데이터를 합쳐서, 정렬한 결과는 다음과 같아야 합니다. SALES_DATE PRODUCT_ID USER_ID SALES_AMOUNT 2022-03-01 1 NULL 2 2022-03-01 3 NULL 3 2022-03-01 4 NULL 1 2022-03-01 4 4 1 2022-03-02 2 2 2 2022-03-02 3 6 3 2022-03-03 2 NULL 1 2022-03-03 5 5 1",hard,database
242,"다음은 어느 의류 쇼핑몰의 온라인 상품 판매 정보를 담은 ONLINE_SALE 테이블 입니다. ONLINE_SALE 테이블은 아래와 같은 구조로 되어있으며 ONLINE_SALE_ID, USER_ID, PRODUCT_ID, SALES_AMOUNT, SALES_DATE는 각각 온라인 상품 판매 ID, 회원 ID, 상품 ID, 판매량, 판매일을 나타냅니다. Column name Type Nullable ONLINE_SALE_ID INTEGER FALSE USER_ID INTEGER FALSE PRODUCT_ID INTEGER FALSE SALES_AMOUNT INTEGER FALSE SALES_DATE DATE FALSE 동일한 날짜, 회원 ID, 상품 ID 조합에 대해서는 하나의 판매 데이터만 존재합니다. 문제 ONLINE_SALE 테이블에서 동일한 회원이 동일한 상품을 재구매한 데이터를 구하여, 재구매한 회원 ID와 재구매한 상품 ID를 출력하는 SQL문을 작성해주세요. 결과는 회원 ID를 기준으로 오름차순 정렬해주시고 회원 ID가 같다면 상품 ID를 기준으로 내림차순 정렬해주세요. 예시 예를 들어 ONLINE_SALE 테이블이 다음과 같다면 ONLINE_SALE_ID USER_ID PRODUCT_ID SALES_AMOUNT SALES_DATE 1 1 3 2 2022-02-25 2 1 4 1 2022-03-01 4 2 4 2 2022-03-12 3 1 3 3 2022-03-31 5 3 5 1 2022-04-03 6 2 4 1 2022-04-06 2 1 4 2 2022-05-11 USER_ID 가 1인 유저가 PRODUCT_ID 가 3, 4인 상품들을 재구매하고, USER_ID 가 2인 유저가 PRODUCT_ID 가 4인 상품을 재구매 하였으므로, 다음과 같이 결과가 나와야합니다. USER_ID PRODUCT_ID 1 4 1 3 2 4",normal,database
243,"다음은 어느 의류 쇼핑몰에 가입한 회원 정보를 담은 USER_INFO 테이블입니다. USER_INFO 테이블은 아래와 같은 구조로 되어있으며 USER_ID, GENDER, AGE, JOINED는 각각 회원 ID, 성별, 나이, 가입일을 나타냅니다. Column name Type Nullable USER_ID INTEGER FALSE GENDER TINYINT(1) TRUE AGE INTEGER TRUE JOINED DATE FALSE GENDER 컬럼은 비어있거나 0 또는 1의 값을 가지며 0인 경우 남자를, 1인 경우는 여자를 나타냅니다. 문제 USER_INFO 테이블에서 2021년에 가입한 회원 중 나이가 20세 이상 29세 이하인 회원이 몇 명인지 출력하는 SQL문을 작성해주세요. 예시 예를 들어 USER_INFO 테이블이 다음과 같다면 USER_ID GENDER AGE JOINED 1 1 26 2021-10-05 2 0 NULL 2021-11-25 3 1 22 2021-11-30 4 0 31 2021-12-03 5 0 28 2021-12-16 6 1 24 2022-01-03 7 1 NULL 2022-01-09 2021년에 가입한 회원 중 나이가 20세 이상 29세 이하인 회원은 USER_ID 가 1, 3, 5 인 회원들 이므로, 다음과 같이 결과가 나와야 합니다. USERS 3",easy,database
244,"다음은 어느 의류 쇼핑몰에 가입한 회원 정보를 담은 USER_INFO 테이블과 온라인 상품 판매 정보를 담은 ONLINE_SALE 테이블 입니다. USER_INFO 테이블은 아래와 같은 구조로 되어있으며 USER_ID, GENDER, AGE, JOINED는 각각 회원 ID, 성별, 나이, 가입일을 나타냅니다. Column name Type Nullable USER_ID INTEGER FALSE GENDER TINYINT(1) TRUE AGE INTEGER TRUE JOINED DATE FALSE GENDER 컬럼은 비어있거나 0 또는 1의 값을 가지며 0인 경우 남자를, 1인 경우는 여자를 나타냅니다. ONLINE_SALE 테이블은 아래와 같은 구조로 되어있으며 ONLINE_SALE_ID, USER_ID, PRODUCT_ID, SALES_AMOUNT, SALES_DATE는 각각 온라인 상품 판매 ID, 회원 ID, 상품 ID, 판매량, 판매일을 나타냅니다. Column name Type Nullable ONLINE_SALE_ID INTEGER FALSE USER_ID INTEGER FALSE PRODUCT_ID INTEGER FALSE SALES_AMOUNT INTEGER FALSE SALES_DATE DATE FALSE 동일한 날짜, 회원 ID, 상품 ID 조합에 대해서는 하나의 판매 데이터만 존재합니다. 문제 USER_INFO 테이블과 ONLINE_SALE 테이블에서 2021년에 가입한 전체 회원들 중 상품을 구매한 회원수와 상품을 구매한 회원의 비율(=2021년에 가입한 회원 중 상품을 구매한 회원수 / 2021년에 가입한 전체 회원 수)을 년, 월 별로 출력하는 SQL문을 작성해주세요. 상품을 구매한 회원의 비율은 소수점 두번째자리에서 반올림하고, 전체 결과는 년을 기준으로 오름차순 정렬해주시고 년이 같다면 월을 기준으로 오름차순 정렬해주세요. 예시 예를 들어 USER_INFO 테이블이 다음과 같고 USER_ID GENDER AGE JOINED 1 1 26 2021-06-01 2 NULL NULL 2021-06-25 3 0 NULL 2021-06-30 4 0 31 2021-07-03 5 1 25 2022-01-09 6 1 33 2022-02-14 ONLINE_SALE 이 다음과 같다면 ONLINE_SALE_ID USER_ID PRODUCT_ID SALES_AMOUNT SALES_DATE 1 1 54 1 2022-01-01 2 1 3 2 2022-01-25 3 4 34 1 2022-01-30 4 6 253 3 2022-02-03 5 2 31 2 2022-02-09 6 5 35 1 2022-02-14 7 5 57 1 2022-02-18 2021년에 가입한 회원은 USER_ID가 1, 2, 3, 4 인 회원들로 총 4명 입니다. ONLINE_SALE 테이블에서 해당 회원들에 대한 판매 데이터는 다음과 같습니다. ONLINE_SALE_ID USER_ID PRODUCT_ID SALES_AMOUNT SALES_DATE 1 1 54 1 2022-01-01 2 1 3 2 2022-01-25 3 4 34 1 2022-01-30 5 2 31 2 2022-02-09 그러므로 년, 월 별로 상품을 구매한 회원수와 상품을 구매한 회원의 비율을 구하고 결과를 정렬하면 다음과 같아야 합니다. YEAR MONTH PURCHASED_USERS PUCHASED_RATIO 2022 1 2 0.5 2022 2 1 0.3",hard,database
245,"다음은 어느 의류 쇼핑몰에서 판매중인 상품들의 상품 정보를 담은 PRODUCT 테이블과 오프라인 상품 판매 정보를 담은 OFFLINE_SALE 테이블 입니다. PRODUCT 테이블은 아래와 같은 구조로 PRODUCT_ID, PRODUCT_CODE, PRICE는 각각 상품 ID, 상품코드, 판매가를 나타냅니다. Column name Type Nullable PRODUCT_ID INTEGER FALSE PRODUCT_CODE VARCHAR(8) FALSE PRICE INTEGER FALSE 상품 별로 중복되지 않는 8자리 상품코드 값을 가지며, 앞 2자리는 카테고리 코드를 의미합니다. OFFLINE_SALE 테이블은 아래와 같은 구조로 되어있으며 OFFLINE_SALE_ID, PRODUCT_ID, SALES_AMOUNT, SALES_DATE는 각각 오프라인 상품 판매 ID, 상품 ID, 판매량, 판매일을 나타냅니다. Column name Type Nullable OFFLINE_SALE_ID INTEGER FALSE PRODUCT_ID INTEGER FALSE SALES_AMOUNT INTEGER FALSE SALES_DATE DATE FALSE 동일한 날짜, 상품 ID 조합에 대해서는 하나의 판매 데이터만 존재합니다. 문제 PRODUCT 테이블과 OFFLINE_SALE 테이블에서 상품코드 별 매출액(판매가 * 판매량) 합계를 출력하는 SQL문을 작성해주세요. 결과는 매출액을 기준으로 내림차순 정렬해주시고 매출액이 같다면 상품코드를 기준으로 오름차순 정렬해주세요. 예시 예를 들어 PRODUCT 테이블이 다음과 같고 PRODUCT_ID PRODUCT_CODE PRICE 1 A1000011 15000 2 A1000045 8000 3 C3000002 42000 OFFLINE_SALE 테이블이 다음과 같다면 OFFLINE_SALE_ID PRODUCT_ID SALES_AMOUNT SALES_DATE 1 1 2 2022-02-21 2 1 2 2022-03-02 3 3 3 2022-05-01 4 2 1 2022-05-24 5 1 2 2022-07-14 6 2 1 2022-09-22 각 상품 별 총 판매량과 판매가는 다음과 같습니다. PRODUCT_CODE 가 A1000011인 상품은 총 판매량이 6개, 판매가가 15,000원 PRODUCT_CODE 가 A1000045인 상품은 총 판매량이 2개, 판매가가 8,000원 PRODUCT_CODE 가 C3000002인 상품은 총 판매량이 3개, 판매가가 42,000원 그러므로 각 상품 별 매출액을 계산하고 정렬하면 결과가 다음과 같이 나와야 합니다. PRODUCT_CODE SALES C3000002 126000 A1000011 90000 A1000045 16000",normal,database
246,"다음은 어느 의류 쇼핑몰에 가입한 회원 정보를 담은 USER_INFO 테이블과 온라인 상품 판매 정보를 담은 ONLINE_SALE 테이블 입니다.USER_INFO 테이블은 아래와 같은 구조로 되어있으며 USER_ID, GENDER, AGE, JOINED는 각각 회원 ID, 성별, 나이, 가입일을 나타냅니다. Column name Type Nullable USER_ID INTEGER FALSE GENDER TINYINT(1) TRUE AGE INTEGER TRUE JOINED DATE FALSE GENDER 컬럼은 비어있거나 0 또는 1의 값을 가지며 0인 경우 남자를, 1인 경우는 여자를 나타냅니다. ONLINE_SALE 테이블은 아래와 같은 구조로 되어있으며, ONLINE_SALE_ID, USER_ID, PRODUCT_ID, SALES_AMOUNT, SALES_DATE는 각각 온라인 상품 판매 ID, 회원 ID, 상품 ID, 판매량, 판매일을 나타냅니다. Column name Type Nullable ONLINE_SALE_ID INTEGER FALSE USER_ID INTEGER FALSE PRODUCT_ID INTEGER FALSE SALES_AMOUNT INTEGER FALSE SALES_DATE DATE FALSE 동일한 날짜, 회원 ID, 상품 ID 조합에 대해서는 하나의 판매 데이터만 존재합니다. 문제 USER_INFO 테이블과 ONLINE_SALE 테이블에서 년, 월, 성별 별로 상품을 구매한 회원수를 집계하는 SQL문을 작성해주세요. 결과는 년, 월, 성별을 기준으로 오름차순 정렬해주세요. 이때, 성별 정보가 없는 경우 결과에서 제외해주세요. 예시 예를 들어 USER_INFO 테이블이 다음과 같고 USER_ID GENDER AGE JOINED 1 1 26 2021-06-01 2 NULL NULL 2021-06-25 3 0 NULL 2021-06-30 4 0 31 2021-07-03 5 1 25 2021-07-09 6 1 33 2021-07-14 ONLINE_SALE 테이블이 다음과 같다면 ONLINE_SALE_ID USER_ID PRODUCT_ID SALES_AMOUNT SALES_DATE 1 1 54 1 2022-01-01 2 1 3 2 2022-01-25 3 4 34 1 2022-01-30 4 6 253 3 2022-02-03 5 2 31 2 2022-02-09 6 5 35 1 2022-02-14 7 5 57 1 2022-02-18 2022년 1월에 상품을 구매한 회원은 USER_ID 가 1(GENDER=1), 4(GENDER=0)인 회원들이고, 2022년 2월에 상품을 구매한 회원은 USER_ID 가 2(GENDER=NULL), 5(GENDER=1), 6(GENDER=1)인 회원들 이므로, 년, 월, 성별 별로 상품을 구매한 회원수를 집계하고, 년, 월, 성별을 기준으로 오름차순 정렬하면 다음과 같은 결과가 나와야 합니다. YEAR MONTH GENDER USERS 2022 1 0 1 2022 1 1 1 2022 2 1 2",hard,database
247,"다음은 어느 의류 쇼핑몰에서 판매중인 상품들의 정보를 담은 PRODUCT 테이블입니다. PRODUCT 테이블은 아래와 같은 구조로 되어있으며, PRODUCT_ID, PRODUCT_CODE, PRICE는 각각 상품 ID, 상품코드, 판매가를 나타냅니다. Column name Type Nullable PRODUCT_ID INTEGER FALSE PRODUCT_CODE VARCHAR(8) FALSE PRICE INTEGER FALSE 상품 별로 중복되지 않는 8자리 상품코드 값을 가지며 앞 2자리는 카테고리 코드를 나타냅니다. 문제 PRODUCT 테이블에서 만원 단위의 가격대 별로 상품 개수를 출력하는 SQL 문을 작성해주세요. 이때 컬럼명은 각각 컬럼명은 PRICE_GROUP, PRODUCTS로 지정해주시고 가격대 정보는 각 구간의 최소금액(10,000원 이상 ~ 20,000 미만인 구간인 경우 10,000)으로 표시해주세요. 결과는 가격대를 기준으로 오름차순 정렬해주세요. 예시 예를 들어 PRODUCT 테이블이 다음과 같다면 PRODUCT_ID PRODUCT_CODE PRICE 1 A1000011 10000 2 A1000045 9000 3 C3000002 22000 4 C3000006 15000 5 C3000010 30000 6 K1000023 17000 만원 단위의 가격대 별로 상품을 나누면 가격대가 0원 ~ 1만원 미만인 상품은 PRODUCT_ID 가 2인 상품 1개, 가격대가 1만원 이상 ~ 2만원 미만인 상품들은 PRODUCT_ID 가 1, 4, 6인 상품 3개, 가격대가 2만원 이상 ~ 3만원 미만인 상품은 PRODUCT_ID 가 3인 상품 1개, 가격대가 3만원 이상 ~ 4만원 미만인 상품은 PRODUCT_ID 가 5인 상품 1개, 에 각각 해당하므로 다음과 같이 결과가 나와야 합니다. PRICE_GROUP PRODUCTS 0 1 10000 3 20000 1 30000 1",normal,database
248,"다음은 어느 의류 쇼핑몰에서 판매중인 상품들의 정보를 담은 PRODUCT 테이블입니다. PRODUCT 테이블은 아래와 같은 구조로 되어있으며, PRODUCT_ID, PRODUCT_CODE, PRICE는 각각 상품 ID, 상품코드, 판매가를 나타냅니다. Column name Type Nullable PRODUCT_ID INTEGER FALSE PRODUCT_CODE VARCHAR(8) FALSE PRICE INTEGER FALSE 상품 별로 중복되지 않는 8자리 상품코드 값을 가지며, 앞 2자리는 카테고리 코드를 의미합니다. 문제 PRODUCT 테이블에서 상품 카테고리 코드(PRODUCT_CODE 앞 2자리) 별 상품 개수를 출력하는 SQL문을 작성해주세요. 결과는 상품 카테고리 코드를 기준으로 오름차순 정렬해주세요. 예시 예를 들어 PRODUCT 테이블이 다음과 같다면 PRODUCT_ID PRODUCT_CODE PRICE 1 A1000011 10000 2 A1000045 9000 3 C3000002 22000 4 C3000006 15000 5 C3000010 30000 6 K1000023 17000 상품 카테고리 코드 별 상품은 아래와 같으므로, A1: PRODUCT_ID가 1, 2 인 상품 C3: PRODUCT_ID가 3, 4, 5 인 상품 K1: PRODUCT_ID가 6 인 상품 다음과 같은 결과가 나와야 합니다. CATEGORY PRODUCTS A1 2 C3 3 K1 1",normal,database
249,"다음은 어느 의류 쇼핑몰에 가입한 회원 정보를 담은 USER_INFO 테이블입니다. USER_INFO 테이블은 아래와 같은 구조로 되어있으며, USER_ID, GENDER, AGE, JOINED는 각각 회원 ID, 성별, 나이, 가입일을 나타냅니다. Column name Type Nullable USER_ID INTEGER FALSE GENDER TINYINT(1) TRUE AGE INTEGER TRUE JOINED DATE FALSE GENDER 컬럼은 비어있거나 0 또는 1의 값을 가지며 0인 경우 남자를, 1인 경우는 여자를 나타냅니다. 문제 USER_INFO 테이블에서 나이 정보가 없는 회원이 몇 명인지 출력하는 SQL문을 작성해주세요. 이때 컬럼명은 USERS로 지정해주세요. 예시 예를 들어 USER_INFO 테이블이 다음과 같다면 USER_ID GENDER AGE JOINED 1 1 26 2021-06-01 2 NULL NULL 2021-07-25 3 1 NULL 2021-07-30 4 0 31 2021-08-03 나이 정보가 없는 회원은 2명 이므로, 다음과 같은 결과가 나와야 합니다. USERS 2",easy,database
250,"혼자서도 잘 노는 범희는 어느 날 방구석에 있는 숫자 카드 더미를 보더니 혼자 할 수 있는 재미있는 게임을 생각해냈습니다. 숫자 카드 더미에는 카드가 총 100장 있으며, 각 카드에는 1부터 100까지 숫자가 하나씩 적혀있습니다. 2 이상 100 이하의 자연수를 하나 정해 그 수보다 작거나 같은 숫자 카드들을 준비하고, 준비한 카드의 수만큼 작은 상자를 준비하면 게임을 시작할 수 있으며 게임 방법은 다음과 같습니다. 준비된 상자에 카드를 한 장씩 넣고, 상자를 무작위로 섞어 일렬로 나열합니다. 상자가 일렬로 나열되면 상자가 나열된 순서에 따라 1번부터 순차적으로 증가하는 번호를 붙입니다. 그 다음 임의의 상자를 하나 선택하여 선택한 상자 안의 숫자 카드를 확인합니다. 다음으로 확인한 카드에 적힌 번호에 해당하는 상자를 열어 안에 담긴 카드에 적힌 숫자를 확인합니다. 마찬가지로 숫자에 해당하는 번호를 가진 상자를 계속해서 열어가며, 열어야 하는 상자가 이미 열려있을 때까지 반복합니다. 이렇게 연 상자들은 1번 상자 그룹입니다. 이제 1번 상자 그룹을 다른 상자들과 섞이지 않도록 따로 둡니다. 만약 1번 상자 그룹을 제외하고 남는 상자가 없으면 그대로 게임이 종료되며, 이때 획득하는 점수는 0점입니다. 그렇지 않다면 남은 상자 중 다시 임의의 상자 하나를 골라 같은 방식으로 이미 열려있는 상자를 만날 때까지 상자를 엽니다. 이렇게 연 상자들은 2번 상자 그룹입니다. 1번 상자 그룹에 속한 상자의 수와 2번 상자 그룹에 속한 상자의 수를 곱한 값이 게임의 점수입니다. 상자 안에 들어있는 카드 번호가 순서대로 담긴 배열 cards가 매개변수로 주어질 때, 범희가 이 게임에서 얻을 수 있는 최고 점수를 구해서 return 하도록 solution 함수를 완성해주세요. 제한사항 2 ≤ cards의 길이 ≤ 100 cards의 원소는 cards의 길이 이하인 임의의 자연수입니다. cards에는 중복되는 원소가 존재하지 않습니다. cards[i]는 i + 1번 상자에 담긴 카드에 적힌 숫자를 의미합니다. 입출력 예 cards result [8,6,3,7,2,5,1,4] 12 입출력 예 설명 1, 4, 7, 8이 속하는 상자의 그룹과 2, 5, 6이 속하는 상자의 그룹과 3이 속하는 상자의 그룹이 존재합니다. 따라서 3번 상자를 고르지 않았을 때, 두 번의 시행에서 3과 4를 기록하며 최고 점수 12를 얻을 수 있습니다. ※ 공지 - 2025년 3월 19일 테스트케이스가 추가되었습니다.",normal,Array
251,"프로그래머스 다트 협회에서는 매년마다 새로운 특수 룰으로 다트 대회를 개최합니다. 이번 대회의 룰은 ""카운트 다운""으로 ""제로원"" 룰의 변형 룰입니다. ""카운트 다운""은 게임이 시작되면 무작위로 점수가 정해지고, 다트를 던지면서 점수를 깎아서 정확히 0점으로 만드는 게임입니다. 단, 남은 점수보다 큰 점수로 득점하면 버스트가 되며 실격 합니다. 다음 그림은 다트 과녁입니다. 다트 과녁에는 1 부터 20 까지의 수가 하나씩 있고 각 수마다 ""싱글"", ""더블"", ""트리플"" 칸이 있습니다. ""싱글""을 맞히면 해당 수만큼 점수를 얻고 ""더블""을 맞히면 해당 수의 두 배만큼 점수를 얻고 ""트리플""을 맞히면 해당 수의 세 배만큼 점수를 얻습니다. 가운데에는 ""불""과 ""아우터 불""이 있는데 ""카운트 다운"" 게임에서는 구분 없이 50점을 얻습니다. 대회는 토너먼트로 진행되며 한 게임에는 두 선수가 참가하게 됩니다. 게임은 두 선수가 교대로 한 번씩 던지는 라운드 방식으로 진행됩니다. 가장 먼저 0점을 만든 선수가 승리하는데 만약 두 선수가 같은 라운드에 0점을 만들면 두 선수 중 ""싱글"" 또는 ""불""을 더 많이 던진 선수가 승리하며 그마저도 같다면 선공인 선수가 승리합니다. 다트 실력에 자신 있던 종호는 이 대회에 출전하기로 하였습니다. 최소한의 다트로 0점을 만드는 게 가장 중요하고, 그러한 방법이 여러가지가 있다면 ""싱글"" 또는 ""불""을 최대한 많이 던지는 방법을 선택해야 합니다. 목표 점수 target이 매개변수로 주어졌을 때 최선의 경우 던질 다트 수와 그 때의 ""싱글"" 또는 ""불""을 맞춘 횟수(합)를 순서대로 배열에 담아 return 하도록 solution 함수를 완성해 주세요. 제한사항 1 ≤ target ≤ 100,000 입출력 예 target result 21 [1,0] 58 [2,2] 입출력 예 설명 입출력 예 #1 7 트리플로 21점을 만들 수 있습니다. 입출력 예 #2 불 + 8 싱글로 58점을 만들 수 있습니다.",normal,Array
252,"두 정수 X, Y의 임의의 자리에서 공통으로 나타나는 정수 k(0 ≤ k ≤ 9)들을 이용하여 만들 수 있는 가장 큰 정수를 두 수의 짝꿍이라 합니다(단, 공통으로 나타나는 정수 중 서로 짝지을 수 있는 숫자만 사용합니다). X, Y의 짝꿍이 존재하지 않으면, 짝꿍은 -1입니다. X, Y의 짝꿍이 0으로만 구성되어 있다면, 짝꿍은 0입니다. 예를 들어, X = 3403이고 Y = 13203이라면, X와 Y의 짝꿍은 X와 Y에서 공통으로 나타나는 3, 0, 3으로 만들 수 있는 가장 큰 정수인 330입니다. 다른 예시로 X = 5525이고 Y = 1255이면 X와 Y의 짝꿍은 X와 Y에서 공통으로 나타나는 2, 5, 5로 만들 수 있는 가장 큰 정수인 552입니다(X에는 5가 3개, Y에는 5가 2개 나타나므로 남는 5 한 개는 짝 지을 수 없습니다.) 두 정수 X, Y가 주어졌을 때, X, Y의 짝꿍을 return하는 solution 함수를 완성해주세요. 제한사항 3 ≤ X, Y의 길이(자릿수) ≤ 3,000,000입니다. X, Y는 0으로 시작하지 않습니다. X, Y의 짝꿍은 상당히 큰 정수일 수 있으므로, 문자열로 반환합니다. 입출력 예 X Y result ""100"" ""2345"" ""-1"" ""100"" ""203045"" ""0"" ""100"" ""123450"" ""10"" ""12321"" ""42531"" ""321"" ""5525"" ""1255"" ""552"" 입출력 예 설명 입출력 예 #1 X, Y의 짝꿍은 존재하지 않습니다. 따라서 ""-1""을 return합니다. 입출력 예 #2 X, Y의 공통된 숫자는 0으로만 구성되어 있기 때문에, 두 수의 짝꿍은 정수 0입니다. 따라서 ""0""을 return합니다. 입출력 예 #3 X, Y의 짝꿍은 10이므로, ""10""을 return합니다. 입출력 예 #4 X, Y의 짝꿍은 321입니다. 따라서 ""321""을 return합니다. 입출력 예 #5 지문에 설명된 예시와 같습니다.",easy,String
253,"XYZ 마트는 일정한 금액을 지불하면 10일 동안 회원 자격을 부여합니다. XYZ 마트에서는 회원을 대상으로 매일 한 가지 제품을 할인하는 행사를 합니다. 할인하는 제품은 하루에 하나씩만 구매할 수 있습니다. 알뜰한 정현이는 자신이 원하는 제품과 수량이 할인하는 날짜와 10일 연속으로 일치할 경우에 맞춰서 회원가입을 하려 합니다. 예를 들어, 정현이가 원하는 제품이 바나나 3개, 사과 2개, 쌀 2개, 돼지고기 2개, 냄비 1개이며, XYZ 마트에서 14일간 회원을 대상으로 할인하는 제품이 날짜 순서대로 치킨, 사과, 사과, 바나나, 쌀, 사과, 돼지고기, 바나나, 돼지고기, 쌀, 냄비, 바나나, 사과, 바나나인 경우에 대해 알아봅시다. 첫째 날부터 열흘 간에는 냄비가 할인하지 않기 때문에 첫째 날에는 회원가입을 하지 않습니다. 둘째 날부터 열흘 간에는 바나나를 원하는 만큼 할인구매할 수 없기 때문에 둘째 날에도 회원가입을 하지 않습니다. 셋째 날, 넷째 날, 다섯째 날부터 각각 열흘은 원하는 제품과 수량이 일치하기 때문에 셋 중 하루에 회원가입을 하려 합니다. 정현이가 원하는 제품을 나타내는 문자열 배열 want와 정현이가 원하는 제품의 수량을 나타내는 정수 배열 number, XYZ 마트에서 할인하는 제품을 나타내는 문자열 배열 discount가 주어졌을 때, 회원등록시 정현이가 원하는 제품을 모두 할인 받을 수 있는 회원등록 날짜의 총 일수를 return 하는 solution 함수를 완성하시오. 가능한 날이 없으면 0을 return 합니다. 제한사항 1 ≤ want의 길이 = number의 길이 ≤ 10 1 ≤ number의 원소 ≤ 10 number[i]는 want[i]의 수량을 의미하며, number의 원소의 합은 10입니다. 10 ≤ discount의 길이 ≤ 100,000 want와 discount의 원소들은 알파벳 소문자로 이루어진 문자열입니다. 1 ≤ want의 원소의 길이, discount의 원소의 길이 ≤ 12 입출력 예 want number discount result [""banana"", ""apple"", ""rice"", ""pork"", ""pot""] [3, 2, 2, 2, 1] [""chicken"", ""apple"", ""apple"", ""banana"", ""rice"", ""apple"", ""pork"", ""banana"", ""pork"", ""rice"", ""pot"", ""banana"", ""apple"", ""banana""] 3 [""apple""] [10] [""banana"", ""banana"", ""banana"", ""banana"", ""banana"", ""banana"", ""banana"", ""banana"", ""banana"", ""banana""] 0 입출력 예 설명 입출력 예 #1 문제 예시와 같습니다. 입출력 예 #2 사과가 할인하는 날이 없으므로 0을 return 합니다. ※ 공지 - 2024년 1월 26일 문제 지문의 오탈자가 수정되었습니다.",normal,Array
254,"다음은 고객의 정보를 담은 MEMBER_PROFILE테이블과 식당의 리뷰 정보를 담은 REST_REVIEW 테이블입니다. MEMBER_PROFILE 테이블은 다음과 같으며 MEMBER_ID, MEMBER_NAME, TLNO, GENDER, DATE_OF_BIRTH는 회원 ID, 회원 이름, 회원 연락처, 성별, 생년월일을 의미합니다. Column name Type Nullable MEMBER_ID VARCHAR(100) FALSE MEMBER_NAME VARCHAR(50) FALSE TLNO VARCHAR(50) TRUE GENDER VARCHAR(1) TRUE DATE_OF_BIRTH DATE TRUE REST_REVIEW 테이블은 다음과 같으며 REVIEW_ID, REST_ID, MEMBER_ID, REVIEW_SCORE, REVIEW_TEXT,REVIEW_DATE는 각각 리뷰 ID, 식당 ID, 회원 ID, 점수, 리뷰 텍스트, 리뷰 작성일을 의미합니다. Column name Type Nullable REVIEW_ID VARCHAR(10) FALSE REST_ID VARCHAR(10) TRUE MEMBER_ID VARCHAR(100) TRUE REVIEW_SCORE NUMBER TRUE REVIEW_TEXT VARCHAR(1000) TRUE REVIEW_DATE DATE TRUE 문제 MEMBER_PROFILE와 REST_REVIEW 테이블에서 리뷰를 가장 많이 작성한 회원의 리뷰들을 조회하는 SQL문을 작성해주세요. 회원 이름, 리뷰 텍스트, 리뷰 작성일이 출력되도록 작성해주시고, 결과는 리뷰 작성일을 기준으로 오름차순, 리뷰 작성일이 같다면 리뷰 텍스트를 기준으로 오름차순 정렬해주세요. 예시 MEMBER_PROFILE 테이블이 다음과 같고 MEMBER_ID MEMBER_NAME TLNO GENDER DATE_OF_BIRTH jiho92@naver.com 이지호 01076432111 W 1992-02-12 jiyoon22@hotmail.com 김지윤 01032324117 W 1992-02-22 jihoon93@hanmail.net 김지훈 01023258688 M 1993-02-23 seoyeons@naver.com 박서연 01076482209 W 1993-03-16 yelin1130@gmail.com 조예린 01017626711 W 1990-11-30 REST_REVIEW 테이블이 다음과 같을 때 REVIEW_ID REST_ID MEMBER_ID REVIEW_SCORE REVIEW_TEXT REVIEW_DATE R000000065 00028 soobin97@naver.com 5 부찌 국물에서 샤브샤브 맛이나고 깔끔 2022-04-12 R000000066 00039 yelin1130@gmail.com 5 김치찌개 최곱니다. 2022-02-12 R000000067 00028 yelin1130@gmail.com 5 햄이 많아서 좋아요 2022-02-22 R000000068 00035 ksyi0316@gmail.com 5 숙성회가 끝내줍니다. 2022-02-15 R000000069 00035 yoonsy95@naver.com 4 비린내가 전혀없어요. 2022-04-16 SQL을 실행하면 다음과 같이 출력되어야 합니다. MEMBER_NAME REVIEW_TEXT REVIEW_DATE 조예린 김치찌개 최곱니다. 2022-02-12 조예린 햄이 많아서 좋아요 2022-02-22 주의사항 REVIEW_DATE의 데이트 포맷이 예시와 동일해야 정답처리 됩니다.",hard,database
255,"다음은 식당의 정보를 담은 REST_INFO 테이블입니다. REST_INFO 테이블은 다음과 같으며 REST_ID, REST_NAME, FOOD_TYPE, VIEWS, FAVORITES, PARKING_LOT, ADDRESS, TEL은 식당 ID, 식당 이름, 음식 종류, 조회수, 즐겨찾기수, 주차장 유무, 주소, 전화번호를 의미합니다. Column name Type Nullable REST_ID VARCHAR(5) FALSE REST_NAME VARCHAR(50) FALSE FOOD_TYPE VARCHAR(20) TRUE VIEWS NUMBER TRUE FAVORITES NUMBER TRUE PARKING_LOT VARCHAR(1) TRUE ADDRESS VARCHAR(100) TRUE TEL VARCHAR(100) TRUE 문제 REST_INFO 테이블에서 음식종류별로 즐겨찾기수가 가장 많은 식당의 음식 종류, ID, 식당 이름, 즐겨찾기수를 조회하는 SQL문을 작성해주세요. 이때 결과는 음식 종류를 기준으로 내림차순 정렬해주세요. 예시 REST_INFO 테이블이 다음과 같을 때 REST_ID REST_NAME FOOD_TYPE VIEWS FAVORITES PARKING_LOT ADDRESS TEL 00001 은돼지식당 한식 1150345 734 N 서울특별시 중구 다산로 149 010-4484-8751 00002 하이가쯔네 일식 120034 112 N 서울시 중구 신당동 375-21 NULL 00003 따띠따띠뜨 양식 1234023 102 N 서울시 강남구 신사동 627-3 1F 02-6397-1023 00004 스시사카우스 일식 1522074 230 N 서울시 서울시 강남구 신사동 627-27 010-9394-2554 00005 코슌스 일식 15301 123 N 서울특별시 강남구 언주로153길 010-1315-8729 SQL을 실행하면 다음과 같이 출력되어야 합니다. FOOD_TYPE REST_ID REST_NAME FAVORITES 한식 00001 은돼지식당 734 일식 00004 스시사카우스 230 양식 00003 따띠따띠뜨 102",normal,database
256,"다음은 식당 리뷰 사이트의 회원 정보를 담은 MEMBER_PROFILE 테이블입니다. MEMBER_PROFILE 테이블은 다음과 같으며 MEMBER_ID, MEMBER_NAME, TLNO, GENDER, DATE_OF_BIRTH는 회원 ID, 회원 이름, 회원 연락처, 성별, 생년월일을 의미합니다. Column name Type Nullable MEMBER_ID VARCHAR(100) FALSE MEMBER_NAME VARCHAR(50) FALSE TLNO VARCHAR(50) TRUE GENDER VARCHAR(1) TRUE DATE_OF_BIRTH DATE TRUE 문제 MEMBER_PROFILE 테이블에서 생일이 3월인 여성 회원의 ID, 이름, 성별, 생년월일을 조회하는 SQL문을 작성해주세요. 이때 전화번호가 NULL인 경우는 출력대상에서 제외시켜 주시고, 결과는 회원ID를 기준으로 오름차순 정렬해주세요. 예시 MEMBER_PROFILE 테이블이 다음과 같을 때 MEMBER_ID MEMBER_NAME TLNO GENDER DATE_OF_BIRTH jiho92@naver.com 이지호 01076432111 W 1992-02-12 jiyoon22@hotmail.com 김지윤 01032324117 W 1992-02-22 jihoon93@hanmail.net 김지훈 01023258688 M 1993-02-23 seoyeons@naver.com 박서연 01076482209 W 1993-03-16 yoonsy94@gmail.com 윤서연 NULL W 1994-03-19 SQL을 실행하면 다음과 같이 출력되어야 합니다. MEMBER_ID MEMBER_NAME GENDER DATE_OF_BIRTH seoyeons@naver.com 박서연 W 1993-03-16 주의사항 DATE_OF_BIRTH의 데이트 포맷이 예시와 동일해야 정답처리 됩니다.",normal,database
257,"다음은 식당의 정보를 담은 REST_INFO 테이블과 식당의 리뷰 정보를 담은 REST_REVIEW 테이블입니다. REST_INFO 테이블은 다음과 같으며 REST_ID, REST_NAME, FOOD_TYPE, VIEWS, FAVORITES, PARKING_LOT, ADDRESS, TEL은 식당 ID, 식당 이름, 음식 종류, 조회수, 즐겨찾기수, 주차장 유무, 주소, 전화번호를 의미합니다. Column name Type Nullable REST_ID VARCHAR(5) FALSE REST_NAME VARCHAR(50) FALSE FOOD_TYPE VARCHAR(20) TRUE VIEWS NUMBER TRUE FAVORITES NUMBER TRUE PARKING_LOT VARCHAR(1) TRUE ADDRESS VARCHAR(100) TRUE TEL VARCHAR(100) TRUE REST_REVIEW 테이블은 다음과 같으며 REVIEW_ID, REST_ID, MEMBER_ID, REVIEW_SCORE, REVIEW_TEXT,REVIEW_DATE는 각각 리뷰 ID, 식당 ID, 회원 ID, 점수, 리뷰 텍스트, 리뷰 작성일을 의미합니다. Column name Type Nullable REVIEW_ID VARCHAR(10) FALSE REST_ID VARCHAR(10) TRUE MEMBER_ID VARCHAR(100) TRUE REVIEW_SCORE NUMBER TRUE REVIEW_TEXT VARCHAR(1000) TRUE REVIEW_DATE DATE TRUE 문제 REST_INFO와 REST_REVIEW 테이블에서 서울에 위치한 식당들의 식당 ID, 식당 이름, 음식 종류, 즐겨찾기수, 주소, 리뷰 평균 점수를 조회하는 SQL문을 작성해주세요. 이때 리뷰 평균점수는 소수점 세 번째 자리에서 반올림 해주시고 결과는 평균점수를 기준으로 내림차순 정렬해주시고, 평균점수가 같다면 즐겨찾기수를 기준으로 내림차순 정렬해주세요. 예시 REST_INFO 테이블이 다음과 같고 REST_ID REST_NAME FOOD_TYPE VIEWS FAVORITES PARKING_LOT ADDRESS TEL 00028 대우부대찌개 한식 52310 10 N 경기도 용인시 처인구 남사읍 처인성로 309 031-235-1235 00039 광주식당 한식 23001 20 N 경기도 부천시 산업로8번길 60 031-235-6423 00035 삼촌식당 일식 532123 80 N 서울특별시 강서구 가로공원로76가길 02-135-1266 REST_REVIEW 테이블이 다음과 같을 때 REVIEW_ID REST_ID MEMBER_ID REVIEW_SCORE REVIEW_TEXT REVIEW_DATE R000000065 00028 soobin97@naver.com 5 부찌 국물에서 샤브샤브 맛이나고 깔끔 2022-04-12 R000000066 00039 yelin1130@gmail.com 5 김치찌개 최곱니다. 2022-02-12 R000000067 00028 yelin1130@gmail.com 5 햄이 많아서 좋아요 2022-02-22 R000000068 00035 ksyi0316@gmail.com 5 숙성회가 끝내줍니다. 2022-02-15 R000000069 00035 yoonsy95@naver.com 4 비린내가 전혀없어요. 2022-04-16 SQL을 실행하면 다음과 같이 출력되어야 합니다. REST_ID REST_NAME FOOD_TYPE FAVORITES ADDRESS SCORE 00035 삼촌식당 일식 80 서울특별시 강서구 가로공원로76가길 4.50",hard,database
258,"다음은 식품의 정보를 담은 FOOD_PRODUCT 테이블과 식품의 주문 정보를 담은 FOOD_ORDER 테이블입니다. FOOD_PRODUCT 테이블은 다음과 같으며 PRODUCT_ID, PRODUCT_NAME, PRODUCT_CD, CATEGORY, PRICE는 식품 ID, 식품 이름, 식품코드, 식품분류, 식품 가격을 의미합니다. Column name Type Nullable PRODUCT_ID VARCHAR(10) FALSE PRODUCT_NAME VARCHAR(50) FALSE PRODUCT_CD VARCHAR(10) TRUE CATEGORY VARCHAR(10) TRUE PRICE NUMBER TRUE FOOD_ORDER 테이블은 다음과 같으며 ORDER_ID, PRODUCT_ID, AMOUNT, PRODUCE_DATE, IN_DATE, OUT_DATE, FACTORY_ID, WAREHOUSE_ID는 각각 주문 ID, 제품 ID, 주문량, 생산일자, 입고일자, 출고일자, 공장 ID, 창고 ID를 의미합니다. Column name Type Nullable ORDER_ID VARCHAR(10) FALSE PRODUCT_ID VARCHAR(5) FALSE AMOUNT NUMBER FALSE PRODUCE_DATE DATE TRUE IN_DATE DATE TRUE OUT_DATE DATE TRUE FACTORY_ID VARCHAR(10) FALSE WAREHOUSE_ID VARCHAR(10) FALSE 문제 FOOD_PRODUCT와 FOOD_ORDER 테이블에서 생산일자가 2022년 5월인 식품들의 식품 ID, 식품 이름, 총매출을 조회하는 SQL문을 작성해주세요. 이때 결과는 총매출을 기준으로 내림차순 정렬해주시고 총매출이 같다면 식품 ID를 기준으로 오름차순 정렬해주세요. 예시 FOOD_PRODUCT 테이블이 다음과 같고 PRODUCT_ID PRODUCT_NAME PRODUCT_CD CATEGORY PRICE P0011 맛있는콩기름 CD_OL00001 식용유 4880 P0012 맛있는올리브유 CD_OL00002 식용유 7200 P0013 맛있는포도씨유 CD_OL00003 식용유 5950 P0014 맛있는마조유 CD_OL00004 식용유 8950 P0015 맛있는화조유 CD_OL00005 식용유 8800 P0016 맛있는참기름 CD_OL00006 식용유 7100 P0017 맛있는들기름 CD_OL00007 식용유 7900 P0018 맛있는고추기름 CD_OL00008 식용유 6100 P0019 맛있는카놀라유 CD_OL00009 식용유 5100 P0020 맛있는산초유 CD_OL00010 식용유 6500 FOOD_ORDER 테이블이 다음과 같을 때 ORDER_ID PRODUCT_ID AMOUNT PRODUCE_DATE IN_DATE OUT_DATE FACTORY_ID WAREHOUSE_ID OD00000056 P0012 1000 2022-04-04 2022-04-21 2022-04-25 FT19980002 WH0032 OD00000057 P0014 2500 2022-04-14 2022-04-27 2022-05-01 FT19980002 WH0033 OD00000058 P0017 1200 2022-05-19 2022-05-28 2022-05-28 FT20070002 WH0033 OD00000059 P0017 1000 2022-05-24 2022-05-30 2022-05-30 FT20070002 WH0038 OD00000060 P0019 2000 2022-05-29 2022-06-08 2022-06-08 FT20070002 WH0035 SQL을 실행하면 다음과 같이 출력되어야 합니다. PRODUCT_ID PRODUCT_NAME TOTAL_SALES P0017 맛있는들기름 17380000 P0019 맛있는카놀라유 10200000",hard,database
259,"다음은 식품의 정보를 담은 FOOD_PRODUCT 테이블입니다. FOOD_PRODUCT 테이블은 다음과 같으며 PRODUCT_ID, PRODUCT_NAME, PRODUCT_CD, CATEGORY, PRICE는 식품 ID, 식품 이름, 식품코드, 식품분류, 식품 가격을 의미합니다. Column name Type Nullable PRODUCT_ID VARCHAR(10) FALSE PRODUCT_NAME VARCHAR(50) FALSE PRODUCT_CD VARCHAR(10) TRUE CATEGORY VARCHAR(10) TRUE PRICE NUMBER TRUE 문제 FOOD_PRODUCT 테이블에서 식품분류별로 가격이 제일 비싼 식품의 분류, 가격, 이름을 조회하는 SQL문을 작성해주세요. 이때 식품분류가 '과자', '국', '김치', '식용유'인 경우만 출력시켜 주시고 결과는 식품 가격을 기준으로 내림차순 정렬해주세요. 예시 FOOD_PRODUCT 테이블이 다음과 같을 때 PRODUCT_ID PRODUCT_NAME PRODUCT_CD CATEGORY PRICE P0018 맛있는고추기름 CD_OL00008 식용유 6100 P0019 맛있는카놀라유 CD_OL00009 식용유 5100 P0020 맛있는산초유 CD_OL00010 식용유 6500 P0021 맛있는케첩 CD_SC00001 소스 4500 P0022 맛있는마요네즈 CD_SC00002 소스 4700 P0039 맛있는황도 CD_CN00008 캔 4100 P0040 맛있는명이나물 CD_CN00009 캔 3500 P0041 맛있는보리차 CD_TE00010 차 3400 P0042 맛있는메밀차 CD_TE00001 차 3500 P0099 맛있는맛동산 CD_CK00002 과자 1800 SQL을 실행하면 다음과 같이 출력되어야 합니다. CATEGORY MAX_PRICE PRODUCT_NAME 식용유 6500 맛있는산초유 과자 1800 맛있는맛동산",hard,database
260,"다음은 식품의 정보를 담은 FOOD_PRODUCT 테이블입니다. FOOD_PRODUCT 테이블은 다음과 같으며 PRODUCT_ID, PRODUCT_NAME, PRODUCT_CD, CATEGORY, PRICE는 식품 ID, 식품 이름, 식품 코드, 식품분류, 식품 가격을 의미합니다. Column name Type Nullable PRODUCT_ID VARCHAR(10) FALSE PRODUCT_NAME VARCHAR(50) FALSE PRODUCT_CD VARCHAR(10) TRUE CATEGORY VARCHAR(10) TRUE PRICE NUMBER TRUE 문제 FOOD_PRODUCT 테이블에서 가격이 제일 비싼 식품의 식품 ID, 식품 이름, 식품 코드, 식품분류, 식품 가격을 조회하는 SQL문을 작성해주세요. 예시 FOOD_PRODUCT 테이블이 다음과 같을 때 PRODUCT_ID PRODUCT_NAME PRODUCT_CD CATEGORY PRICE P0018 맛있는고추기름 CD_OL00008 식용유 6100 P0019 맛있는카놀라유 CD_OL00009 식용유 5100 P0020 맛있는산초유 CD_OL00010 식용유 6500 P0021 맛있는케첩 CD_OL00001 소스 4500 P0022 맛있는마요네즈 CD_OL00002 소스 4700 SQL을 실행하면 다음과 같이 출력되어야 합니다. PRODUCT_ID PRODUCT_NAME PRODUCT_CD CATEGORY PRICE P0020 맛있는산초유 CD_OL00010 식용유 6500",normal,database
261,"다음은 식품창고의 정보를 담은 FOOD_WAREHOUSE 테이블입니다. FOOD_WAREHOUSE 테이블은 다음과 같으며 WAREHOUSE_ID, WAREHOUSE_NAME, ADDRESS, TLNO, FREEZER_YN는 창고 ID, 창고 이름, 창고 주소, 전화번호, 냉동시설 여부를 의미합니다. Column name Type Nullable WAREHOUSE_ID VARCHAR(10) FALSE WAREHOUSE_NAME VARCHAR(20) FALSE ADDRESS VARCHAR(100) TRUE TLNO VARCHAR(20) TRUE FREEZER_YN VARCHAR(1) TRUE 문제 FOOD_WAREHOUSE 테이블에서 경기도에 위치한 창고의 ID, 이름, 주소, 냉동시설 여부를 조회하는 SQL문을 작성해주세요. 이때 냉동시설 여부가 NULL인 경우, 'N'으로 출력시켜 주시고 결과는 창고 ID를 기준으로 오름차순 정렬해주세요. 예시 FOOD_WAREHOUSE 테이블이 다음과 같을 때 WAREHOUSE_ID WAREHOUSE_NAME ADDRESS TLNO FREEZER_YN WH0001 창고_경기1 경기도 안산시 상록구 용담로 141 031-152-1332 Y WH0002 창고_충북1 충청북도 진천군 진천읍 씨제이로 110 043-623-9900 Y WH0003 창고_경기2 경기도 이천시 마장면 덕평로 811 031-221-7241 NULL WH0004 창고_경기3 경기도 김포시 대곶면 율생중앙로205번길 031-671-1900 N WH0005 창고_충남1 충청남도 천안시 동남구 광덕면 신덕리1길 9 041-876-5421 Y SQL을 실행하면 다음과 같이 출력되어야 합니다. WAREHOUSE_ID WAREHOUSE_NAME ADDRESS FREEZER_YN WH0001 창고_경기1 경기도 안산시 상록구 용담로 141 Y WH0003 창고_경기2 경기도 이천시 마장면 덕평로 811 N WH0004 창고_경기3 경기도 김포시 대곶면 율생중앙로205번길 N",easy,database
262,"다음은 식품공장의 주문정보를 담은 FOOD_ORDER 테이블입니다. FOOD_ORDER 테이블은 다음과 같으며 ORDER_ID, PRODUCT_ID, AMOUNT, PRODUCE_DATE, IN_DATE,OUT_DATE,FACTORY_ID, WAREHOUSE_ID는 각각 주문 ID, 제품 ID, 주문양, 생산일자, 입고일자, 출고일자, 공장 ID, 창고 ID를 의미합니다. Column name Type Nullable ORDER_ID VARCHAR(10) FALSE PRODUCT_ID VARCHAR(5) FALSE AMOUNT NUMBER FALSE PRODUCE_DATE DATE TRUE IN_DATE DATE TRUE OUT_DATE DATE TRUE FACTORY_ID VARCHAR(10) FALSE WAREHOUSE_ID VARCHAR(10) FALSE 문제 FOOD_ORDER 테이블에서 2022년 5월 1일을 기준으로 주문 ID, 제품 ID, 출고일자, 출고여부를 조회하는 SQL문을 작성해주세요. 출고여부는 2022년 5월 1일까지 출고완료로 이 후 날짜는 출고 대기로 미정이면 출고미정으로 출력해주시고, 결과는 주문 ID를 기준으로 오름차순 정렬해주세요. 예시 FOOD_ORDER 테이블이 다음과 같을 때 ORDER_ID PRODUCT_ID AMOUNT PRODUCE_DATE IN_DATE OUT_DATE FACTORY_ID WAREHOUSE_ID OD00000051 P0002 4000 2022-04-01 2022-04-21 2022-04-21 FT19970003 WH0005 OD00000052 P0003 2500 2022-04-10 2022-04-27 2022-04-27 FT19970003 WH0006 OD00000053 P0005 6200 2022-04-15 2022-04-30 2022-05-01 FT19940003 WH0003 OD00000054 P0006 1000 2022-04-21 2022-04-30 NULL FT19940003 WH0009 OD00000055 P0008 1500 2022-04-25 2022-05-11 2022-05-11 FT19980003 WH0009 SQL을 실행하면 다음과 같이 출력되어야 합니다. ORDER_ID PRODUCT_ID OUT_DATE 출고여부 OD00000051 P0002 2022-04-21 출고완료 OD00000052 P0003 2022-04-27 출고완료 OD00000053 P0005 2022-05-01 출고완료 OD00000054 P0006 출고미정 OD00000055 P0008 2022-05-11 출고대기",normal,database
263,"다음은 식품공장의 정보를 담은 FOOD_FACTORY 테이블입니다. FOOD_FACTORY 테이블은 다음과 같으며 FACTORY_ID, FACTORY_NAME, ADDRESS, TLNO는 각각 공장 ID, 공장 이름, 주소, 전화번호를 의미합니다. Column name Type Nullable FACTORY_ID VARCHAR(10) FALSE FACTORY_NAME VARCHAR(50) FALSE ADDRESS VARCHAR(100) FALSE TLNO VARCHAR(20) TRUE 문제 FOOD_FACTORY 테이블에서 강원도에 위치한 식품공장의 공장 ID, 공장 이름, 주소를 조회하는 SQL문을 작성해주세요. 이때 결과는 공장 ID를 기준으로 오름차순 정렬해주세요. 예시 FOOD_FACTORY 테이블이 다음과 같을 때 FACTORY_ID FACTORY_NAME ADDRESS TLNO FT19980003 (주)맛있는라면 강원도 정선군 남면 칠현로 679 033-431-3122 FT19980004 (주)맛있는기름 경기도 평택시 포승읍 포승공단순환로 245 031-651-2410 FT20010001 (주)맛있는소스 경상북도 구미시 1공단로7길 58-11 054-231-2121 FT20010002 (주)맛있는통조림 전라남도 영암군 미암면 곤미현로 1336 061-341-5210 FT20100001 (주)맛있는차 전라남도 장성군 서삼면 장산리 233-1번지 061-661-1420 FT20100002 (주)맛있는김치 충청남도 아산시 탕정면 탕정면로 485 041-241-5421 FT20100003 (주)맛있는음료 강원도 원주시 문막읍 문막공단길 154 033-232-7630 FT20100004 (주)맛있는국 강원도 평창군 봉평면 진조길 227-35 033-323-6640 FT20110001 (주)맛있는밥 경기도 화성시 팔탄면 가재리 34번지 031-661-1532 FT20110002 (주)맛있는과자 광주광역시 북구 하서로 222 062-211-7759 SQL을 실행하면 다음과 같이 출력되어야 합니다. FACTORY_ID FACTORY_NAME ADDRESS FT19980003 (주)맛있는라면 강원도 정선군 남면 칠현로 679 FT20100003 (주)맛있는음료 강원도 원주시 문막읍 문막공단길 154 FT20100004 (주)맛있는국 강원도 평창군 봉평면 진조길 227-35",easy,database
264,"머쓱이는 태어난 지 6개월 된 조카를 돌보고 있습니다. 조카는 아직 ""aya"", ""ye"", ""woo"", ""ma"" 네 가지 발음을 최대 한 번씩 사용해 조합한(이어 붙인) 발음밖에 하지 못합니다. 문자열 배열 babbling이 매개변수로 주어질 때, 머쓱이의 조카가 발음할 수 있는 단어의 개수를 return하도록 solution 함수를 완성해주세요. 제한사항 1 ≤ babbling의 길이 ≤ 100 1 ≤ babbling[i]의 길이 ≤ 15 babbling의 각 문자열에서 ""aya"", ""ye"", ""woo"", ""ma""는 각각 최대 한 번씩만 등장합니다. 즉, 각 문자열의 가능한 모든 부분 문자열 중에서 ""aya"", ""ye"", ""woo"", ""ma""가 한 번씩만 등장합니다. 문자열은 알파벳 소문자로만 이루어져 있습니다. 입출력 예 babbling result [""aya"", ""yee"", ""u"", ""maa"", ""wyeoo""] 1 [""ayaye"", ""uuuma"", ""ye"", ""yemawoo"", ""ayaa""] 3 입출력 예 설명 입출력 예 #1 [""aya"", ""yee"", ""u"", ""maa"", ""wyeoo""]에서 발음할 수 있는 것은 ""aya""뿐입니다. 따라서 1을 return합니다. 입출력 예 #2 [""ayaye"", ""uuuma"", ""ye"", ""yemawoo"", ""ayaa""]에서 발음할 수 있는 것은 ""aya"" + ""ye"" = ""ayaye"", ""ye"", ""ye"" + ""ma"" + ""woo"" = ""yemawoo""로 3개입니다. 따라서 3을 return합니다. 유의사항 네 가지를 붙여 만들 수 있는 발음 이외에는 어떤 발음도 할 수 없는 것으로 규정합니다. 예를 들어 ""woowo""는 ""woo""는 발음할 수 있지만 ""wo""를 발음할 수 없기 때문에 할 수 없는 발음입니다. ※ 공지 - 2022년 10월 27일 문제 지문이 리뉴얼되었습니다. 기존에 제출한 코드가 통과하지 못할 수도 있습니다.",easy,Array
265,"등차수열 혹은 등비수열 common이 매개변수로 주어질 때, 마지막 원소 다음으로 올 숫자를 return 하도록 solution 함수를 완성해보세요. 제한사항 2 < common의 길이 < 1,000 -1,000 < common의 원소 < 2,000 common의 원소는 모두 정수입니다. 등차수열 혹은 등비수열이 아닌 경우는 없습니다. 등비수열인 경우 공비는 0이 아닌 정수입니다. 입출력 예 common result [1, 2, 3, 4] 5 [2, 4, 8] 16 입출력 예 설명 입출력 예 #1 [1, 2, 3, 4]는 공차가 1인 등차수열이므로 다음에 올 수는 5이다. 입출력 예 #2 [2, 4, 8]은 공비가 2인 등비수열이므로 다음에 올 수는 16이다.",easy,Design
266,"연속된 세 개의 정수를 더해 12가 되는 경우는 3, 4, 5입니다. 두 정수 num과 total이 주어집니다. 연속된 수 num개를 더한 값이 total이 될 때, 정수 배열을 오름차순으로 담아 return하도록 solution함수를 완성해보세요. 제한사항 1 ≤ num ≤ 100 0 ≤ total ≤ 1000 num개의 연속된 수를 더하여 total이 될 수 없는 테스트 케이스는 없습니다. 입출력 예 num total result 3 12 [3, 4, 5] 5 15 [1, 2, 3, 4, 5] 4 14 [2, 3, 4, 5] 5 5 [-1, 0, 1, 2, 3] 입출력 예 설명 입출력 예 #1 num = 3, total = 12인 경우 [3, 4, 5]를 return합니다. 입출력 예 #2 num = 5, total = 15인 경우 [1, 2, 3, 4, 5]를 return합니다. 입출력 예 #3 4개의 연속된 수를 더해 14가 되는 경우는 2, 3, 4, 5입니다. 입출력 예 #4 설명 생략",easy,Array
267,"머쓱이는 큰 종이를 1 x 1 크기로 자르려고 합니다. 예를 들어 2 x 2 크기의 종이를 1 x 1 크기로 자르려면 최소 가위질 세 번이 필요합니다. 정수 M, N이 매개변수로 주어질 때, M x N 크기의 종이를 최소로 가위질 해야하는 횟수를 return 하도록 solution 함수를 완성해보세요. 제한사항 0 < M, N < 100 종이를 겹쳐서 자를 수 없습니다. 입출력 예 M N result 2 2 3 2 5 9 1 1 0 입출력 예 설명 입출력 예 #1 본문과 동일합니다. 입출력 예 #2 가로 2 세로 5인 종이는 가로로 1번 세로로 8번 총 가위질 9번이 필요합니다. 입출력 예 #3 이미 1 * 1 크기이므로 0을 return 합니다.",easy,Math
268,"문자열 ""hello""에서 각 문자를 오른쪽으로 한 칸씩 밀고 마지막 문자는 맨 앞으로 이동시키면 ""ohell""이 됩니다. 이것을 문자열을 민다고 정의한다면 문자열 A와 B가 매개변수로 주어질 때, A를 밀어서 B가 될 수 있다면 밀어야 하는 최소 횟수를 return하고 밀어서 B가 될 수 없으면 -1을 return 하도록 solution 함수를 완성해보세요. 제한사항 0 < A의 길이 = B의 길이 < 100 A, B는 알파벳 소문자로 이루어져 있습니다. 입출력 예 A B result ""hello"" ""ohell"" 1 ""apple"" ""elppa"" -1 ""atat"" ""tata"" 1 ""abc"" ""abc"" 0 입출력 예 설명 입출력 예 #1 ""hello""를 오른쪽으로 한 칸 밀면 ""ohell""가 됩니다. 입출력 예 #2 ""apple""은 몇 번을 밀어도 ""elppa""가 될 수 없습니다. 입출력 예 #3 ""atat""는 오른쪽으로 한 칸, 세 칸을 밀면 ""tata""가 되므로 최소 횟수인 1을 반환합니다. 입출력 예 #4 ""abc""는 밀지 않아도 ""abc""이므로 0을 반환합니다. ※ 공지 - 2023년 4월 24일 테스트케이스가 추가되었습니다. 기존에 제출한 코드가 통과하지 못할 수도 있습니다.",easy,String
269,"문자열 my_str과 n이 매개변수로 주어질 때, my_str을 길이 n씩 잘라서 저장한 배열을 return하도록 solution 함수를 완성해주세요. 제한사항 1 ≤ my_str의 길이 ≤ 100 1 ≤ n ≤ my_str의 길이 my_str은 알파벳 소문자, 대문자, 숫자로 이루어져 있습니다. 입출력 예 my_str n result ""abc1Addfggg4556b"" 6 [""abc1Ad"", ""dfggg4"", ""556b""] ""abcdef123"" 3 [""abc"", ""def"", ""123""] 입출력 예 설명 입출력 예 #1 ""abc1Addfggg4556b"" 를 길이 6씩 잘라 배열에 저장한 [""abc1Ad"", ""dfggg4"", ""556b""]를 return해야 합니다. 입출력 예 #2 ""abcdef123"" 를 길이 3씩 잘라 배열에 저장한 [""abc"", ""def"", ""123""]를 return해야 합니다. 유의사항 입출력 예 #1의 경우 ""abc1Addfggg4556b""를 길이 6씩 자르면 ""abc1Ad"", ""dfggg4"" 두개와 마지막 ""556b""가 남습니다. 이런 경우 남은 문자열을 그대로 배열에 저장합니다.",easy,Array
270,"머쓱이는 행운의 숫자 7을 가장 좋아합니다. 정수 배열 array가 매개변수로 주어질 때, 7이 총 몇 개 있는지 return 하도록 solution 함수를 완성해보세요. 제한사항 1 ≤ array의 길이 ≤ 100 0 ≤ array의 원소 ≤ 100,000 입출력 예 array result [7, 77, 17] 4 [10, 29] 0 입출력 예 설명 입출력 예 #1 [7, 77, 17]에는 7이 4개 있으므로 4를 return 합니다. 입출력 예 #2 [10, 29]에는 7이 없으므로 0을 return 합니다.",easy,Array
271,"영어 대소문자로 이루어진 문자열 my_string이 매개변수로 주어질 때, my_string을 모두 소문자로 바꾸고 알파벳 순서대로 정렬한 문자열을 return 하도록 solution 함수를 완성해보세요. 제한사항 0 < my_string 길이 < 100 입출력 예 my_string result ""Bcad"" ""abcd"" ""heLLo"" ""ehllo"" ""Python"" ""hnopty"" 입출력 예 설명 입출력 예 #1 ""Bcad""를 모두 소문자로 바꾸면 ""bcad""이고 이를 알파벳 순으로 정렬하면 ""abcd""입니다. 입출력 예 #2 ""heLLo""를 모두 소문자로 바꾸면 ""hello""이고 이를 알파벳 순으로 정렬하면 ""ehllo""입니다. 입출력 예 #3 ""Python""를 모두 소문자로 바꾸면 ""python""이고 이를 알파벳 순으로 정렬하면 ""hnopty""입니다.",easy,String
272,"어떤 세균은 1시간에 두배만큼 증식한다고 합니다. 처음 세균의 마리수 n과 경과한 시간 t가 매개변수로 주어질 때 t시간 후 세균의 수를 return하도록 solution 함수를 완성해주세요. 제한사항 1 ≤ n ≤ 10 1 ≤ t ≤ 15 입출력 예 n t result 2 10 2048 7 15 229,376 입출력 예 설명 입출력 예 #1 처음엔 2마리, 1시간 후엔 4마리, 2시간 후엔 8마리, ..., 10시간 후엔 2048마리가 됩니다. 따라서 2048을 return합니다. 입출력 예 #2 처음엔 7마리, 1시간 후엔 14마리, 2시간 후엔 28마리, ..., 15시간 후엔 229376마리가 됩니다. 따라서 229,376을 return합니다.",easy,Math
273,"어떤 자연수를 제곱했을 때 나오는 정수를 제곱수라고 합니다. 정수 n이 매개변수로 주어질 때, n이 제곱수라면 1을 아니라면 2를 return하도록 solution 함수를 완성해주세요. 제한사항 1 ≤ n ≤ 1,000,000 입출력 예 n result 144 1 976 2 입출력 예 설명 입출력 예 #1 144는 12의 제곱이므로 제곱수입니다. 따라서 1을 return합니다. 입출력 예 #2 976은 제곱수가 아닙니다. 따라서 2를 return합니다.",easy,Math
274,"문자열 str1, str2가 매개변수로 주어집니다. str1 안에 str2가 있다면 1을 없다면 2를 return하도록 solution 함수를 완성해주세요. 제한사항 1 ≤ str1의 길이 ≤ 100 1 ≤ str2의 길이 ≤ 100 문자열은 알파벳 대문자, 소문자, 숫자로 구성되어 있습니다. 입출력 예 str1 str2 result ""ab6CDE443fgh22iJKlmn1o"" ""6CD"" 1 ""ppprrrogrammers"" ""pppp"" 2 ""AbcAbcA"" ""AAA"" 2 입출력 예 설명 입출력 예 #1 ""ab6CDE443fgh22iJKlmn1o"" str1에 str2가 존재하므로 1을 return합니다. 입출력 예 #2 ""ppprrrogrammers"" str1에 str2가 없으므로 2를 return합니다. 입출력 예 #3 ""AbcAbcA"" str1에 str2가 없으므로 2를 return합니다.",easy,String
275,"덧셈, 뺄셈 수식들이 'X [연산자] Y = Z' 형태로 들어있는 문자열 배열 quiz가 매개변수로 주어집니다. 수식이 옳다면 ""O""를 틀리다면 ""X""를 순서대로 담은 배열을 return하도록 solution 함수를 완성해주세요. 제한사항 연산 기호와 숫자 사이는 항상 하나의 공백이 존재합니다. 단 음수를 표시하는 마이너스 기호와 숫자 사이에는 공백이 존재하지 않습니다. 1 ≤ quiz의 길이 ≤ 10 X, Y, Z는 각각 0부터 9까지 숫자로 이루어진 정수를 의미하며, 각 숫자의 맨 앞에 마이너스 기호가 하나 있을 수 있고 이는 음수를 의미합니다. X, Y, Z는 0을 제외하고는 0으로 시작하지 않습니다. -10,000 ≤ X, Y ≤ 10,000 -20,000 ≤ Z ≤ 20,000 [연산자]는 + 와 - 중 하나입니다. 입출력 예 quiz result [""3 - 4 = -3"", ""5 + 6 = 11""] [""X"", ""O""] [""19 - 6 = 13"", ""5 + 66 = 71"", ""5 - 15 = 63"", ""3 - 1 = 2""] [""O"", ""O"", ""X"", ""O""] 입출력 예 설명 입출력 예 #1 3 - 4 = -3 은 틀린 수식이므로 ""X"", 5 + 6 = 11 은 옳은 수식이므로 ""O"" 입니다. 따라서 [""X"", ""O""]를 return합니다. 입출력 예 #2 19 - 6 = 13 은 옳은 수식이므로 ""O"", 5 + 66 = 71 은 옳은 수식이므로 ""O"", 5 - 15 = 63 은 틀린 수식이므로 ""X"", 3 - 1 = 2는 옳은 수식이므로 ""O"" 따라서 [""O"", ""O"", ""X"", ""O""]를 return합니다.",easy,Array
276,"정수 n이 매개변수로 주어질 때 n의 각 자리 숫자의 합을 return하도록 solution 함수를 완성해주세요 제한사항 0 ≤ n ≤ 1,000,000 입출력 예 n result 1234 10 930211 16 입출력 예 설명 입출력 예 #1 1 + 2 + 3 + 4 = 10을 return합니다. 입출력 예 #2 9 + 3 + 0 + 2 + 1 + 1 = 16을 return합니다.",easy,Math
277,"정수 n과 정수 배열 numlist가 매개변수로 주어질 때, numlist에서 n의 배수가 아닌 수들을 제거한 배열을 return하도록 solution 함수를 완성해주세요. 제한사항 1 ≤ n ≤ 10,000 1 ≤ numlist의 크기 ≤ 100 1 ≤ numlist의 원소 ≤ 100,000 입출력 예 n numlist result 3 [4, 5, 6, 7, 8, 9, 10, 11, 12] [6, 9, 12] 5 [1, 9, 3, 10, 13, 5] [10, 5] 12 [2, 100, 120, 600, 12, 12] [120, 600, 12, 12] 입출력 예 설명 입출력 예 #1 numlist에서 3의 배수만을 남긴 [6, 9, 12]를 return합니다. 입출력 예 #2 numlist에서 5의 배수만을 남긴 [10, 5]를 return합니다. 입출력 예 #3 numlist에서 12의 배수만을 남긴 [120, 600, 12, 12]를 return합니다.",easy,Array
278,"정수 num과 k가 매개변수로 주어질 때, num을 이루는 숫자 중에 k가 있으면 num의 그 숫자가 있는 자리 수를 return하고 없으면 -1을 return 하도록 solution 함수를 완성해보세요. 제한사항 0 < num < 1,000,000 0 ≤ k < 10 num에 k가 여러 개 있으면 가장 처음 나타나는 자리를 return 합니다. 입출력 예 num k result 29183 1 3 232443 4 4 123456 7 -1 입출력 예 설명 입출력 예 #1 29183에서 1은 3번째에 있습니다. 입출력 예 #2 232443에서 4는 4번째에 처음 등장합니다. 입출력 예 #3 123456에 7은 없으므로 -1을 return 합니다.",easy,Math
279,"두 배열이 얼마나 유사한지 확인해보려고 합니다. 문자열 배열 s1과 s2가 주어질 때 같은 원소의 개수를 return하도록 solution 함수를 완성해주세요. 제한사항 1 ≤ s1, s2의 길이 ≤ 100 1 ≤ s1, s2의 원소의 길이 ≤ 10 s1과 s2의 원소는 알파벳 소문자로만 이루어져 있습니다 s1과 s2는 각각 중복된 원소를 갖지 않습니다. 입출력 예 s1 s2 result [""a"", ""b"", ""c""] [""com"", ""b"", ""d"", ""p"", ""c""] 2 [""n"", ""omg""] [""m"", ""dot""] 0 입출력 예 설명 입출력 예 #1 ""b""와 ""c""가 같으므로 2를 return합니다. 입출력 예 #2 같은 원소가 없으므로 0을 return합니다.",easy,Array
280,"my_string은 ""3 + 5""처럼 문자열로 된 수식입니다. 문자열 my_string이 매개변수로 주어질 때, 수식을 계산한 값을 return 하는 solution 함수를 완성해주세요. 제한사항 연산자는 +, -만 존재합니다. 문자열의 시작과 끝에는 공백이 없습니다. 0으로 시작하는 숫자는 주어지지 않습니다. 잘못된 수식은 주어지지 않습니다. 5 ≤ my_string의 길이 ≤ 100 my_string을 계산한 결과값은 1 이상 100,000 이하입니다. my_string의 중간 계산 값은 -100,000 이상 100,000 이하입니다. 계산에 사용하는 숫자는 1 이상 20,000 이하인 자연수입니다. my_string에는 연산자가 적어도 하나 포함되어 있습니다. return type 은 정수형입니다. my_string의 숫자와 연산자는 공백 하나로 구분되어 있습니다. 입출력 예 my_string result ""3 + 4"" 7 입출력 예 설명 입출력 예 #1 3 + 4 = 7을 return 합니다.",easy,String
281,"정수 배열 array가 매개변수로 주어질 때, 가장 큰 수와 그 수의 인덱스를 담은 배열을 return 하도록 solution 함수를 완성해보세요. 제한사항 1 ≤ array의 길이 ≤ 100 0 ≤ array 원소 ≤ 1,000 array에 중복된 숫자는 없습니다. 입출력 예 array result [1, 8, 3] [8, 1] [9, 10, 11, 8] [11, 2] 입출력 예 설명 입출력 예 #1 1, 8, 3 중 가장 큰 수는 8이고 인덱스 1에 있습니다. 입출력 예 #2 9, 10, 11, 8 중 가장 큰 수는 11이고 인덱스 2에 있습니다.",easy,Array
282,"머쓱이는 할머니께 생신 축하 편지를 쓰려고 합니다. 할머니가 보시기 편하도록 글자 한 자 한 자를 가로 2cm 크기로 적으려고 하며, 편지를 가로로만 적을 때, 축하 문구 message를 적기 위해 필요한 편지지의 최소 가로길이를 return 하도록 solution 함수를 완성해주세요. 제한사항 공백도 하나의 문자로 취급합니다. 1 ≤ message의 길이 ≤ 50 편지지의 여백은 생각하지 않습니다. message는 영문 알파벳 대소문자, ‘!’, ‘~’ 또는 공백으로만 이루어져 있습니다. 입출력 예 message result ""happy birthday!"" 30 ""I love you~"" 22 입출력 예 설명 입출력 예 #1 message의 글자 수가 15개로 최소 가로 30cm의 편지지가 필요합니다. 입출력 예 #2 message의 글자 수가 11개로 최소 가로 22cm의 편지지가 필요합니다.",easy,Math
283,"정수 n이 매개변수로 주어질 때, n의 약수를 오름차순으로 담은 배열을 return하도록 solution 함수를 완성해주세요. 제한사항 1 ≤ n ≤ 10,000 입출력 예 n result 24 [1, 2, 3, 4, 6, 8, 12, 24] 29 [1, 29] 입출력 예 설명 입출력 예 #1 24의 약수를 오름차순으로 담은 배열 [1, 2, 3, 4, 6, 8, 12, 24]를 return합니다. 입출력 예 #2 29의 약수를 오름차순으로 담은 배열 [1, 29]를 return합니다.",easy,Array
284,"문자열 s가 매개변수로 주어집니다. s에서 한 번만 등장하는 문자를 사전 순으로 정렬한 문자열을 return 하도록 solution 함수를 완성해보세요. 한 번만 등장하는 문자가 없을 경우 빈 문자열을 return 합니다. 제한사항 0 < s의 길이 < 1,000 s는 소문자로만 이루어져 있습니다. 입출력 예 s result ""abcabcadc"" ""d"" ""abdc"" ""abcd"" ""hello"" ""eho"" 입출력 예 설명 입출력 예 #1 ""abcabcadc""에서 하나만 등장하는 문자는 ""d""입니다. 입출력 예 #2 ""abdc""에서 모든 문자가 한 번씩 등장하므로 사전 순으로 정렬한 ""abcd""를 return 합니다. 입출력 예 #3 ""hello""에서 한 번씩 등장한 문자는 ""heo""이고 이를 사전 순으로 정렬한 ""eho""를 return 합니다.",easy,String
285,"문자열 my_string과 정수 num1, num2가 매개변수로 주어질 때, my_string에서 인덱스 num1과 인덱스 num2에 해당하는 문자를 바꾼 문자열을 return 하도록 solution 함수를 완성해보세요. 제한사항 1 < my_string의 길이 < 100 0 ≤ num1, num2 < my_string의 길이 my_string은 소문자로 이루어져 있습니다. num1 ≠ num2 입출력 예 my_string num1 num2 result ""hello"" 1 2 ""hlelo"" ""I love you"" 3 6 ""I l veoyou"" 입출력 예 설명 입출력 예 #1 ""hello""의 1번째 인덱스인 ""e""와 2번째 인덱스인 ""l""을 바꾸면 ""hlelo""입니다. 입출력 예 #2 ""I love you""의 3번째 인덱스 ""o""와 "" ""(공백)을 바꾸면 ""I l veoyou""입니다.",easy,Array
286,"영어가 싫은 머쓱이는 영어로 표기되어있는 숫자를 수로 바꾸려고 합니다. 문자열 numbers가 매개변수로 주어질 때, numbers를 정수로 바꿔 return 하도록 solution 함수를 완성해 주세요. 제한사항 numbers는 소문자로만 구성되어 있습니다. numbers는 ""zero"", ""one"", ""two"", ""three"", ""four"", ""five"", ""six"", ""seven"", ""eight"", ""nine"" 들이 공백 없이 조합되어 있습니다. 1 ≤ numbers의 길이 ≤ 50 ""zero""는 numbers의 맨 앞에 올 수 없습니다. 입출력 예 numbers result ""onetwothreefourfivesixseveneightnine"" 123456789 ""onefourzerosixseven"" 14067 입출력 예 설명 입출력 예 #1 ""onetwothreefourfivesixseveneightnine""를 숫자로 바꾼 123456789를 return합니다. 입출력 예 #1 ""onefourzerosixseven""를 숫자로 바꾼 14067를 return합니다.",easy,String
287,"문자열 my_string이 매개변수로 주어질 때, 대문자는 소문자로 소문자는 대문자로 변환한 문자열을 return하도록 solution 함수를 완성해주세요. 제한사항 1 ≤ my_string의 길이 ≤ 1,000 my_string은 영어 대문자와 소문자로만 구성되어 있습니다. 입출력 예 my_string result ""cccCCC"" ""CCCccc"" ""abCdEfghIJ"" ""ABcDeFGHij"" 입출력 예 설명 입출력 예 #1 소문자는 대문자로 대문자는 소문자로 바꾼 ""CCCccc""를 return합니다. 입출력 예 #2 소문자는 대문자로 대문자는 소문자로 바꾼 ""ABcDeFGHij""를 return합니다.",easy,String
288,"군 전략가 머쓱이는 전쟁 중 적군이 다음과 같은 암호 체계를 사용한다는 것을 알아냈습니다. 암호화된 문자열 cipher를 주고받습니다. 그 문자열에서 code의 배수 번째 글자만 진짜 암호입니다. 문자열 cipher와 정수 code가 매개변수로 주어질 때 해독된 암호 문자열을 return하도록 solution 함수를 완성해주세요. 제한사항 1 ≤ cipher의 길이 ≤ 1,000 1 ≤ code ≤ cipher의 길이 cipher는 소문자와 공백으로만 구성되어 있습니다. 공백도 하나의 문자로 취급합니다. 입출력 예 cipher code result ""dfjardstddetckdaccccdegk"" 4 ""attack"" ""pfqallllabwaoclk"" 2 ""fallback"" 입출력 예 설명 입출력 예 #1 ""dfjardstddetckdaccccdegk"" 의 4번째, 8번째, 12번째, 16번째, 20번째, 24번째 글자를 합친 ""attack""을 return합니다. 입출력 예 #2 ""pfqallllabwaoclk"" 의 2번째, 4번째, 6번째, 8번째, 10번째, 12번째, 14번째, 16번째 글자를 합친 ""fallback""을 return합니다.",easy,String
289,"머쓱이는 친구들과 369게임을 하고 있습니다. 369게임은 1부터 숫자를 하나씩 대며 3, 6, 9가 들어가는 숫자는 숫자 대신 3, 6, 9의 개수만큼 박수를 치는 게임입니다. 머쓱이가 말해야하는 숫자 order가 매개변수로 주어질 때, 머쓱이가 쳐야할 박수 횟수를 return 하도록 solution 함수를 완성해보세요. 제한사항 1 ≤ order ≤ 1,000,000 입출력 예 order result 3 1 29423 2 입출력 예 설명 입출력 예 #1 3은 3이 1개 있으므로 1을 출력합니다. 입출력 예 #2 29423은 3이 1개, 9가 1개 있으므로 2를 출력합니다. ※ 공지 - 2023년 03월 24일 테스트 케이스가 추가되었습니다. 기존에 제출한 코드가 통과하지 못할 수도 있습니다.",easy,Math
290,"정수 배열 array와 정수 n이 매개변수로 주어질 때, array에 들어있는 정수 중 n과 가장 가까운 수를 return 하도록 solution 함수를 완성해주세요. 제한사항 1 ≤ array의 길이 ≤ 100 1 ≤ array의 원소 ≤ 100 1 ≤ n ≤ 100 가장 가까운 수가 여러 개일 경우 더 작은 수를 return 합니다. 입출력 예 array n result [3, 10, 28] 20 28 [10, 11, 12] 13 12 입출력 예 설명 입출력 예 #1 3, 10, 28 중 20과 가장 가까운 수는 28입니다. 입출력 예 #2 10, 11, 12 중 13과 가장 가까운 수는 12입니다. ※ 공지 - 2023년 3월 29일 테스트 케이스가 추가되었습니다. 기존에 제출한 코드가 통과하지 못할 수도 있습니다.",easy,Array
291,"선분 세 개로 삼각형을 만들기 위해서는 다음과 같은 조건을 만족해야 합니다. 가장 긴 변의 길이는 다른 두 변의 길이의 합보다 작아야 합니다. 삼각형의 세 변의 길이가 담긴 배열 sides이 매개변수로 주어집니다. 세 변으로 삼각형을 만들 수 있다면 1, 만들 수 없다면 2를 return하도록 solution 함수를 완성해주세요. 제한사항 sides의 원소는 자연수입니다. sides의 길이는 3입니다. 1 ≤ sides의 원소 ≤ 1,000 입출력 예 sides result [1, 2, 3] 2 [3, 6, 2] 2 [199, 72, 222] 1 입출력 예 설명 입출력 예 #1 가장 큰 변인 3이 나머지 두 변의 합 3과 같으므로 삼각형을 완성할 수 없습니다. 따라서 2를 return합니다. 입출력 예 #2 가장 큰 변인 6이 나머지 두 변의 합 5보다 크므로 삼각형을 완성할 수 없습니다. 따라서 2를 return합니다. 입출력 예 #3 가장 큰 변인 222가 나머지 두 변의 합 271보다 작으므로 삼각형을 완성할 수 있습니다. 따라서 1을 return합니다.",easy,Array
292,"문자열 my_string이 매개변수로 주어집니다. my_string에서 중복된 문자를 제거하고 하나의 문자만 남긴 문자열을 return하도록 solution 함수를 완성해주세요. 제한사항 1 ≤ my_string ≤ 110 my_string은 대문자, 소문자, 공백으로 구성되어 있습니다. 대문자와 소문자를 구분합니다. 공백("" "")도 하나의 문자로 구분합니다. 중복된 문자 중 가장 앞에 있는 문자를 남깁니다. 입출력 예 my_string result ""people"" ""peol"" ""We are the world"" ""We arthwold"" 입출력 예 설명 입출력 예 #1 ""people""에서 중복된 문자 ""p""와 ""e""을 제거한 ""peol""을 return합니다. 입출력 예 #2 ""We are the world""에서 중복된 문자 ""e"", "" "", ""r"" 들을 제거한 ""We arthwold""을 return합니다.",easy,String
293,"1부터 13까지의 수에서, 1은 1, 10, 11, 12, 13 이렇게 총 6번 등장합니다. 정수 i, j, k가 매개변수로 주어질 때, i부터 j까지 k가 몇 번 등장하는지 return 하도록 solution 함수를 완성해주세요. 제한사항 1 ≤ i < j ≤ 100,000 0 ≤ k ≤ 9 입출력 예 i j k result 1 13 1 6 10 50 5 5 3 10 2 0 입출력 예 설명 입출력 예 #1 본문과 동일합니다. 입출력 예 #2 10부터 50까지 5는 15, 25, 35, 45, 50 총 5번 등장합니다. 따라서 5를 return 합니다. 입출력 예 #3 3부터 10까지 2는 한 번도 등장하지 않으므로 0을 return 합니다.",easy,Math
294,"문자열 before와 after가 매개변수로 주어질 때, before의 순서를 바꾸어 after를 만들 수 있으면 1을, 만들 수 없으면 0을 return 하도록 solution 함수를 완성해보세요. 제한사항 0 < before의 길이 == after의 길이 < 1,000 before와 after는 모두 소문자로 이루어져 있습니다. 입출력 예 before after result ""olleh"" ""hello"" 1 ""allpe"" ""apple"" 0 입출력 예 설명 입출력 예 #1 ""olleh""의 순서를 바꾸면 ""hello""를 만들 수 있습니다. 입출력 예 #2 ""allpe""의 순서를 바꿔도 ""apple""을 만들 수 없습니다.",easy,String
295,"이진수를 의미하는 두 개의 문자열 bin1과 bin2가 매개변수로 주어질 때, 두 이진수의 합을 return하도록 solution 함수를 완성해주세요. 제한사항 return 값은 이진수를 의미하는 문자열입니다. 1 ≤ bin1, bin2의 길이 ≤ 10 bin1과 bin2는 0과 1로만 이루어져 있습니다. bin1과 bin2는 ""0""을 제외하고 0으로 시작하지 않습니다. 입출력 예 bin1 bin2 result ""10"" ""11"" ""101"" ""1001"" ""1111"" ""11000"" 입출력 예 설명 입출력 예 #1 10 + 11 = 101 이므로 ""101"" 을 return합니다. 입출력 예 #2 1001 + 1111 = 11000 이므로 ""11000""을 return합니다.",easy,String
296,"프로그래머스 치킨은 치킨을 시켜먹으면 한 마리당 쿠폰을 한 장 발급합니다. 쿠폰을 열 장 모으면 치킨을 한 마리 서비스로 받을 수 있고, 서비스 치킨에도 쿠폰이 발급됩니다. 시켜먹은 치킨의 수 chicken이 매개변수로 주어질 때 받을 수 있는 최대 서비스 치킨의 수를 return하도록 solution 함수를 완성해주세요. 제한사항 chicken은 정수입니다. 0 ≤ chicken ≤ 1,000,000 입출력 예 chicken result 100 11 1,081 120 입출력 예 설명 입출력 예 #1 100마리를 주문하면 쿠폰이 100장 발급되므로 서비스 치킨 10마리를 주문할 수 있습니다. 10마리를 주문하면 쿠폰이 10장 발급되므로 서비스 치킨 1마리를 주문할 수 있습니다. 따라서 10 + 1 = 11 을 return합니다. 입출력 예 #2 1081마리를 주문하면 쿠폰이 1081장 발급되므로 서비스 치킨 108마리를 주문할 수 있습니다. 그리고 쿠폰이 1장 남습니다. 108마리를 주문하면 쿠폰이 108장 발급되므로 서비스 치킨 10마리를 주문할 수 있습니다. 그리고 쿠폰이 8장 남습니다. 10마리를 주문하면 쿠폰이 10장 발급되므로 서비스 치킨 1마리를 주문할 수 있습니다. 1마리를 주문하면 쿠폰이 1장 발급됩니다. 가지고 있는 쿠폰이 총 10장이므로 서비스 치킨 1마리를 추가로 주문할 수 있습니다. 따라서 108 + 10 + 1 + 1 = 120 을 return합니다.",easy,Math
297,"머쓱이는 프로그래머스에 로그인하려고 합니다. 머쓱이가 입력한 아이디와 패스워드가 담긴 배열 id_pw와 회원들의 정보가 담긴 2차원 배열 db가 주어질 때, 다음과 같이 로그인 성공, 실패에 따른 메시지를 return하도록 solution 함수를 완성해주세요. 아이디와 비밀번호가 모두 일치하는 회원정보가 있으면 ""login""을 return합니다. 로그인이 실패했을 때 아이디가 일치하는 회원이 없다면 “fail”를, 아이디는 일치하지만 비밀번호가 일치하는 회원이 없다면 “wrong pw”를 return 합니다. 제한사항 회원들의 아이디는 문자열입니다. 회원들의 아이디는 알파벳 소문자와 숫자로만 이루어져 있습니다. 회원들의 패스워드는 숫자로 구성된 문자열입니다. 회원들의 비밀번호는 같을 수 있지만 아이디는 같을 수 없습니다. id_pw의 길이는 2입니다. id_pw와 db의 원소는 [아이디, 패스워드] 형태입니다. 1 ≤ 아이디의 길이 ≤ 15 1 ≤ 비밀번호의 길이 ≤ 6 1 ≤ db의 길이 ≤ 10 db의 원소의 길이는 2입니다. 입출력 예 id_pw db result [""meosseugi"", ""1234""] [[""rardss"", ""123""], [""yyoom"", ""1234""], [""meosseugi"", ""1234""]] ""login"" [""programmer01"", ""15789""] [[""programmer02"", ""111111""], [""programmer00"", ""134""], [""programmer01"", ""1145""]] ""wrong pw"" [""rabbit04"", ""98761""] [[""jaja11"", ""98761""], [""krong0313"", ""29440""], [""rabbit00"", ""111333""]] ""fail"" 입출력 예 설명 입출력 예 #1 db에 같은 정보의 계정이 있으므로 ""login""을 return합니다. 입출력 예 #2 db에 아이디는 같지만 패스워드가 다른 계정이 있으므로 ""wrong pw""를 return합니다. 입출력 예 #3 db에 아이디가 맞는 계정이 없으므로 ""fail""을 return합니다.",easy,Array
298,"영어 점수와 수학 점수의 평균 점수를 기준으로 학생들의 등수를 매기려고 합니다. 영어 점수와 수학 점수를 담은 2차원 정수 배열 score가 주어질 때, 영어 점수와 수학 점수의 평균을 기준으로 매긴 등수를 담은 배열을 return하도록 solution 함수를 완성해주세요. 제한사항 0 ≤ score[0], score[1] ≤ 100 1 ≤ score의 길이 ≤ 10 score의 원소 길이는 2입니다. score는 중복된 원소를 갖지 않습니다. 입출력 예 score result [[80, 70], [90, 50], [40, 70], [50, 80]] [1, 2, 4, 3] [[80, 70], [70, 80], [30, 50], [90, 100], [100, 90], [100, 100], [10, 30]] [4, 4, 6, 2, 2, 1, 7] 입출력 예 설명 입출력 예 #1 평균은 각각 75, 70, 55, 65 이므로 등수를 매겨 [1, 2, 4, 3]을 return합니다. 입출력 예 #2 평균은 각각 75, 75, 40, 95, 95, 100, 20 이므로 [4, 4, 6, 2, 2, 1, 7] 을 return합니다. 공동 2등이 두 명, 공동 4등이 2명 이므로 3등과 5등은 없습니다.",easy,Array
299,"정수 n을 기준으로 n과 가까운 수부터 정렬하려고 합니다. 이때 n으로부터의 거리가 같다면 더 큰 수를 앞에 오도록 배치합니다. 정수가 담긴 배열 numlist와 정수 n이 주어질 때 numlist의 원소를 n으로부터 가까운 순서대로 정렬한 배열을 return하도록 solution 함수를 완성해주세요. 제한사항 1 ≤ n ≤ 10,000 1 ≤ numlist의 원소 ≤ 10,000 1 ≤ numlist의 길이 ≤ 100 numlist는 중복된 원소를 갖지 않습니다. 입출력 예 numlist n result [1, 2, 3, 4, 5, 6] 4 [4, 5, 3, 6, 2, 1] [10000,20,36,47,40,6,10,7000] 30 [36, 40, 20, 47, 10, 6, 7000, 10000] 입출력 예 설명 입출력 예 #1 4에서 가까운 순으로 [4, 5, 3, 6, 2, 1]을 return합니다. 3과 5는 거리가 같으므로 더 큰 5가 앞에 와야 합니다. 2와 6은 거리가 같으므로 더 큰 6이 앞에 와야 합니다. 입출력 예 #2 30에서 가까운 순으로 [36, 40, 20, 47, 10, 6, 7000, 10000]을 return합니다. 20과 40은 거리가 같으므로 더 큰 40이 앞에 와야 합니다.",easy,Array
300,"소수점 아래 숫자가 계속되지 않고 유한개인 소수를 유한소수라고 합니다. 분수를 소수로 고칠 때 유한소수로 나타낼 수 있는 분수인지 판별하려고 합니다. 유한소수가 되기 위한 분수의 조건은 다음과 같습니다. 기약분수로 나타내었을 때, 분모의 소인수가 2와 5만 존재해야 합니다. 두 정수 a와 b가 매개변수로 주어질 때, a/b가 유한소수이면 1을, 무한소수라면 2를 return하도록 solution 함수를 완성해주세요. 제한사항 a, b는 정수 0 < a ≤ 1,000 0 < b ≤ 1,000 입출력 예 a b result 7 20 1 11 22 1 12 21 2 입출력 예 설명 입출력 예 #1 분수 7/20은 기약분수 입니다. 분모 20의 소인수가 2, 5 이기 때문에 유한소수입니다. 따라서 1을 return합니다. 입출력 예 #2 분수 11/22는 기약분수로 나타내면 1/2 입니다. 분모 2는 소인수가 2 뿐이기 때문에 유한소수 입니다. 따라서 1을 return합니다. 입출력 예 #3 분수 12/21는 기약분수로 나타내면 4/7 입니다. 분모 7은 소인수가 7 이므로 무한소수입니다. 따라서 2를 return합니다. Hint 분자와 분모의 최대공약수로 약분하면 기약분수를 만들 수 있습니다. 정수도 유한소수로 분류합니다. ※ 공지 - 2022년 11월 10일 테스트 케이스가 추가되었습니다. 기존에 제출한 코드가 통과하지 못할 수도 있습니다.",easy,Math
301,"선분 3개가 평행하게 놓여 있습니다. 세 선분의 시작과 끝 좌표가 [[start, end], [start, end], [start, end]] 형태로 들어있는 2차원 배열 lines가 매개변수로 주어질 때, 두 개 이상의 선분이 겹치는 부분의 길이를 return 하도록 solution 함수를 완성해보세요. lines가 [[0, 2], [-3, -1], [-2, 1]]일 때 그림으로 나타내면 다음과 같습니다. 선분이 두 개 이상 겹친 곳은 [-2, -1], [0, 1]로 길이 2만큼 겹쳐있습니다. 제한사항 lines의 길이 = 3 lines의 원소의 길이 = 2 모든 선분은 길이가 1 이상입니다. lines의 원소는 [a, b] 형태이며, a, b는 각각 선분의 양 끝점 입니다. -100 ≤ a < b ≤ 100 입출력 예 lines result [[0, 1], [2, 5], [3, 9]] 2 [[-1, 1], [1, 3], [3, 9]] 0 [[0, 5], [3, 9], [1, 10]] 8 입출력 예 설명 입출력 예 #1 두 번째, 세 번째 선분 [2, 5], [3, 9]가 [3, 5] 구간에 겹쳐있으므로 2를 return 합니다. 입출력 예 #2 겹친 선분이 없으므로 0을 return 합니다. 입출력 예 #3 첫 번째와 두 번째 선분이 [3, 5] 구간에서 겹칩니다. 첫 번째와 세 번째 선분 [1, 5] 구간에서 겹칩니다. 두 번째와 세 번째 선분 [3, 9] 구간에서 겹칩니다. 따라서 [1, 9] 구간에 두 개 이상의 선분이 겹쳐있으므로, 8을 return 합니다.",easy,Array
302,"점 네 개의 좌표를 담은 이차원 배열 dots가 다음과 같이 매개변수로 주어집니다. [[x1, y1], [x2, y2], [x3, y3], [x4, y4]] 주어진 네 개의 점을 두 개씩 이었을 때, 두 직선이 평행이 되는 경우가 있으면 1을 없으면 0을 return 하도록 solution 함수를 완성해보세요. 제한사항 dots의 길이 = 4 dots의 원소는 [x, y] 형태이며 x, y는 정수입니다. 0 ≤ x, y ≤ 100 서로 다른 두개 이상의 점이 겹치는 경우는 없습니다. 두 직선이 겹치는 경우(일치하는 경우)에도 1을 return 해주세요. 임의의 두 점을 이은 직선이 x축 또는 y축과 평행한 경우는 주어지지 않습니다. 입출력 예 dots result [[1, 4], [9, 2], [3, 8], [11, 6]] 1 [[3, 5], [4, 1], [2, 4], [5, 10]] 0 입출력 예 설명 입출력 예 #1 점 [1, 4], [3, 8]을 잇고 [9, 2], [11, 6]를 이으면 두 선분은 평행합니다. 입출력 예 #2 점을 어떻게 연결해도 평행하지 않습니다. ※ 공지 - 2022년 9월 30일 제한 사항 및 테스트 케이스가 수정되었습니다. ※ 공지 - 2022년 10월 27일 제한 사항 및 테스트 케이스가 수정되었습니다. ※ 공지 - 2023년 2월 14일 테스트 케이스가 수정되었습니다.",easy,Array
303,"3x 마을 사람들은 3을 저주의 숫자라고 생각하기 때문에 3의 배수와 숫자 3을 사용하지 않습니다. 3x 마을 사람들의 숫자는 다음과 같습니다. 10진법 3x 마을에서 쓰는 숫자 10진법 3x 마을에서 쓰는 숫자 1 1 6 8 2 2 7 10 3 4 8 11 4 5 9 14 5 7 10 16 정수 n이 매개변수로 주어질 때, n을 3x 마을에서 사용하는 숫자로 바꿔 return하도록 solution 함수를 완성해주세요. 제한사항 1 ≤ n ≤ 100 입출력 예 n result 15 25 40 76 입출력 예 설명 입출력 예 #1 15를 3x 마을의 숫자로 변환하면 25입니다. 입출력 예 #2 40을 3x 마을의 숫자로 변환하면 76입니다.",easy,Design
304,"PROGRAMMERS-962 행성에 불시착한 우주비행사 머쓱이는 외계행성의 언어를 공부하려고 합니다. 알파벳이 담긴 배열 spell과 외계어 사전 dic이 매개변수로 주어집니다. spell에 담긴 알파벳을 한번씩만 모두 사용한 단어가 dic에 존재한다면 1, 존재하지 않는다면 2를 return하도록 solution 함수를 완성해주세요. 제한사항 spell과 dic의 원소는 알파벳 소문자로만 이루어져있습니다. 2 ≤ spell의 크기 ≤ 10 spell의 원소의 길이는 1입니다. 1 ≤ dic의 크기 ≤ 10 1 ≤ dic의 원소의 길이 ≤ 10 spell의 원소를 모두 사용해 단어를 만들어야 합니다. spell의 원소를 모두 사용해 만들 수 있는 단어는 dic에 두 개 이상 존재하지 않습니다. dic과 spell 모두 중복된 원소를 갖지 않습니다. 입출력 예 spell dic result [""p"", ""o"", ""s""] [""sod"", ""eocd"", ""qixm"", ""adio"", ""soo""] 2 [""z"", ""d"", ""x""] [""def"", ""dww"", ""dzx"", ""loveaw""] 1 [""s"", ""o"", ""m"", ""d""] [""moos"", ""dzx"", ""smm"", ""sunmmo"", ""som""] 2 입출력 예 설명 입출력 예 #1 ""p"", ""o"", ""s"" 를 조합해 만들 수 있는 단어가 dic에 존재하지 않습니다. 따라서 2를 return합니다. 입출력 예 #2 ""z"", ""d"", ""x"" 를 조합해 만들 수 있는 단어 ""dzx""가 dic에 존재합니다. 따라서 1을 return합니다. 입출력 예 #3 ""s"", ""o"", ""m"", ""d"" 를 조합해 만들 수 있는 단어가 dic에 존재하지 않습니다. 따라서 2을 return합니다. 유의사항 입출력 예 #3 에서 ""moos"", ""smm"", ""som""도 ""s"", ""o"", ""m"", ""d"" 를 조합해 만들 수 있지만 spell의 원소를 모두 사용해야 하기 때문에 정답이 아닙니다.",easy,Array
305,"선분 세 개로 삼각형을 만들기 위해서는 다음과 같은 조건을 만족해야 합니다. 가장 긴 변의 길이는 다른 두 변의 길이의 합보다 작아야 합니다. 삼각형의 두 변의 길이가 담긴 배열 sides이 매개변수로 주어집니다. 나머지 한 변이 될 수 있는 정수의 개수를 return하도록 solution 함수를 완성해주세요. 제한사항 sides의 원소는 자연수입니다. sides의 길이는 2입니다. 1 ≤ sides의 원소 ≤ 1,000 입출력 예 sides result [1, 2] 1 [3, 6] 5 [11, 7] 13 입출력 예 설명 입출력 예 #1 두 변이 1, 2 인 경우 삼각형을 완성시키려면 나머지 한 변이 2여야 합니다. 따라서 1을 return합니다. 입출력 예 #2 가장 긴 변이 6인 경우 될 수 있는 나머지 한 변은 4, 5, 6 로 3개입니다. 나머지 한 변이 가장 긴 변인 경우 될 수 있는 한 변은 7, 8 로 2개입니다. 따라서 3 + 2 = 5를 return합니다. 입출력 예 #3 가장 긴 변이 11인 경우 될 수 있는 나머지 한 변은 5, 6, 7, 8, 9, 10, 11 로 7개입니다. 나머지 한 변이 가장 긴 변인 경우 될 수 있는 한 변은 12, 13, 14, 15, 16, 17 로 6개입니다. 따라서 7 + 6 = 13을 return합니다.",easy,Array
306,"다음 그림과 같이 지뢰가 있는 지역과 지뢰에 인접한 위, 아래, 좌, 우 대각선 칸을 모두 위험지역으로 분류합니다. 지뢰는 2차원 배열 board에 1로 표시되어 있고 board에는 지뢰가 매설 된 지역 1과, 지뢰가 없는 지역 0만 존재합니다. 지뢰가 매설된 지역의 지도 board가 매개변수로 주어질 때, 안전한 지역의 칸 수를 return하도록 solution 함수를 완성해주세요. 제한사항 board는 n * n 배열입니다. 1 ≤ n ≤ 100 지뢰는 1로 표시되어 있습니다. board에는 지뢰가 있는 지역 1과 지뢰가 없는 지역 0만 존재합니다. 입출력 예 board result [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 1, 0, 0], [0, 0, 0, 0, 0]] 16 [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 1, 1, 0], [0, 0, 0, 0, 0]] 13 [[1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1]] 0 입출력 예 설명 입출력 예 #1 (3, 2)에 지뢰가 있으므로 지뢰가 있는 지역과 지뢰와 인접한 위, 아래, 좌, 우, 대각선 총 8칸은 위험지역입니다. 따라서 16을 return합니다. 입출력 예 #2 (3, 2), (3, 3)에 지뢰가 있으므로 지뢰가 있는 지역과 지뢰와 인접한 위, 아래, 좌, 우, 대각선은 위험지역입니다. 따라서 위험지역을 제외한 칸 수 13을 return합니다. 입출력 예 #3 모든 지역에 지뢰가 있으므로 안전지역은 없습니다. 따라서 0을 return합니다.",easy,Array
307,"문자열 my_string이 매개변수로 주어집니다. my_string은 소문자, 대문자, 자연수로만 구성되어있습니다. my_string안의 자연수들의 합을 return하도록 solution 함수를 완성해주세요. 제한사항 1 ≤ my_string의 길이 ≤ 1,000 1 ≤ my_string 안의 자연수 ≤ 1000 연속된 수는 하나의 숫자로 간주합니다. 000123과 같이 0이 선행하는 경우는 없습니다. 문자열에 자연수가 없는 경우 0을 return 해주세요. 입출력 예 my_string result ""aAb1B2cC34oOp"" 37 ""1a2b3c4d123Z"" 133 입출력 예 설명 입출력 예 #1 ""aAb1B2cC34oOp""안의 자연수는 1, 2, 34 입니다. 따라서 1 + 2 + 34 = 37 을 return합니다. 입출력 예 #2 ""1a2b3c4d123Z""안의 자연수는 1, 2, 3, 4, 123 입니다. 따라서 1 + 2 + 3 + 4 + 123 = 133 을 return합니다.",easy,String
308,"한 개 이상의 항의 합으로 이루어진 식을 다항식이라고 합니다. 다항식을 계산할 때는 동류항끼리 계산해 정리합니다. 덧셈으로 이루어진 다항식 polynomial이 매개변수로 주어질 때, 동류항끼리 더한 결괏값을 문자열로 return 하도록 solution 함수를 완성해보세요. 같은 식이라면 가장 짧은 수식을 return 합니다. 제한사항 0 < polynomial에 있는 수 < 100 polynomial에 변수는 'x'만 존재합니다. polynomial은 양의 정수, 공백, ‘x’, ‘+'로 이루어져 있습니다. 항과 연산기호 사이에는 항상 공백이 존재합니다. 공백은 연속되지 않으며 시작이나 끝에는 공백이 없습니다. 하나의 항에서 변수가 숫자 앞에 오는 경우는 없습니다. "" + 3xx + + x7 + ""와 같은 잘못된 입력은 주어지지 않습니다. 0으로 시작하는 수는 없습니다. 문자와 숫자 사이의 곱하기는 생략합니다. polynomial에는 일차 항과 상수항만 존재합니다. 계수 1은 생략합니다. 결괏값에 상수항은 마지막에 둡니다. 0 < polynomial의 길이 < 50 입출력 예 polynomial result ""3x + 7 + x"" ""4x + 7"" ""x + x + x"" ""3x"" 입출력 예 설명 입출력 예 #1 ""3x + 7 + x""에서 동류항끼리 더하면 ""4x + 7""입니다. 입출력 예 #2 ""x + x + x""에서 동류항끼리 더하면 ""3x""입니다.",easy,String
309,"정수 배열 numbers가 매개변수로 주어집니다. numbers의 원소 중 두 개를 곱해 만들 수 있는 최댓값을 return하도록 solution 함수를 완성해주세요. 제한사항 -10,000 ≤ numbers의 원소 ≤ 10,000 2 ≤ numbers 의 길이 ≤ 100 입출력 예 numbers result [1, 2, -3, 4, -5] 15 [0, -31, 24, 10, 1, 9] 240 [10, 20, 30, 5, 5, 20, 5] 600 입출력 예 설명 입출력 예 #1 두 수의 곱중 최댓값은 -3 * -5 = 15 입니다. 입출력 예 #2 두 수의 곱중 최댓값은 10 * 24 = 240 입니다. 입출력 예 #3 두 수의 곱중 최댓값은 20 * 30 = 600 입니다.",easy,Array
310,"머쓱이는 RPG게임을 하고 있습니다. 게임에는 up, down, left, right 방향키가 있으며 각 키를 누르면 위, 아래, 왼쪽, 오른쪽으로 한 칸씩 이동합니다. 예를 들어 [0,0]에서 up을 누른다면 캐릭터의 좌표는 [0, 1], down을 누른다면 [0, -1], left를 누른다면 [-1, 0], right를 누른다면 [1, 0]입니다. 머쓱이가 입력한 방향키의 배열 keyinput와 맵의 크기 board이 매개변수로 주어집니다. 캐릭터는 항상 [0,0]에서 시작할 때 키 입력이 모두 끝난 뒤에 캐릭터의 좌표 [x, y]를 return하도록 solution 함수를 완성해주세요. [0, 0]은 board의 정 중앙에 위치합니다. 예를 들어 board의 가로 크기가 9라면 캐릭터는 왼쪽으로 최대 [-4, 0]까지 오른쪽으로 최대 [4, 0]까지 이동할 수 있습니다. 제한사항 board은 [가로 크기, 세로 크기] 형태로 주어집니다. board의 가로 크기와 세로 크기는 홀수입니다. board의 크기를 벗어난 방향키 입력은 무시합니다. 0 ≤ keyinput의 길이 ≤ 50 1 ≤ board[0] ≤ 99 1 ≤ board[1] ≤ 99 keyinput은 항상 up, down, left, right만 주어집니다. 입출력 예 keyinput board result [""left"", ""right"", ""up"", ""right"", ""right""] [11, 11] [2, 1] [""down"", ""down"", ""down"", ""down"", ""down""] [7, 9] [0, -4] 입출력 예 설명 입출력 예 설명 #1 [0, 0]에서 왼쪽으로 한 칸 오른쪽으로 한 칸 위로 한 칸 오른쪽으로 두 칸 이동한 좌표는 [2, 1]입니다. 입출력 예 설명 #2 [0, 0]에서 아래로 다섯 칸 이동한 좌표는 [0, -5]이지만 맵의 세로 크기가 9이므로 아래로는 네 칸을 넘어서 이동할 수 없습니다. 따라서 [0, -4]를 return합니다.",easy,Array
311,"2차원 좌표 평면에 변이 축과 평행한 직사각형이 있습니다. 직사각형 네 꼭짓점의 좌표 [[x1, y1], [x2, y2], [x3, y3], [x4, y4]]가 담겨있는 배열 dots가 매개변수로 주어질 때, 직사각형의 넓이를 return 하도록 solution 함수를 완성해보세요. 제한사항 dots의 길이 = 4 dots의 원소의 길이 = 2 -256 < dots[i]의 원소 < 256 잘못된 입력은 주어지지 않습니다. 입출력 예 dots result [[1, 1], [2, 1], [2, 2], [1, 2]] 1 [[-1, -1], [1, 1], [1, -1], [-1, 1]] 4 입출력 예 설명 입출력 예 #1 좌표 [[1, 1], [2, 1], [2, 2], [1, 2]] 를 꼭짓점으로 갖는 직사각형의 가로, 세로 길이는 각각 1, 1이므로 직사각형의 넓이는 1 x 1 = 1입니다. 입출력 예 #2 좌표 [[-1, -1], [1, 1], [1, -1], [-1, 1]]를 꼭짓점으로 갖는 직사각형의 가로, 세로 길이는 각각 2, 2이므로 직사각형의 넓이는 2 x 2 = 4입니다.",easy,Array
312,"문자열 배열 strlist가 매개변수로 주어집니다. strlist 각 원소의 길이를 담은 배열을 return하도록 solution 함수를 완성해주세요. 제한사항 1 ≤ strlist 원소의 길이 ≤ 100 strlist는 알파벳 소문자, 대문자, 특수문자로 구성되어 있습니다. 입출력 예 strlist result [""We"", ""are"", ""the"", ""world!""] [2, 3, 3, 6] [""I"", ""Love"", ""Programmers.""] [1, 4, 12] 입출력 예 설명 입출력 예 #1 [""We"", ""are"", ""the"", ""world!""]의 각 원소의 길이인 [2, 3, 3, 6]을 return합니다. 입출력 예 #2 [""I"", ""Love"", ""Programmers.""]의 각 원소의 길이인 [1, 4, 12]을 return합니다.",easy,Array
313,"숫자와 ""Z""가 공백으로 구분되어 담긴 문자열이 주어집니다. 문자열에 있는 숫자를 차례대로 더하려고 합니다. 이 때 ""Z""가 나오면 바로 전에 더했던 숫자를 뺀다는 뜻입니다. 숫자와 ""Z""로 이루어진 문자열 s가 주어질 때, 머쓱이가 구한 값을 return 하도록 solution 함수를 완성해보세요. 제한사항 1 ≤ s의 길이 ≤ 200 -1,000 < s의 원소 중 숫자 < 1,000 s는 숫자, ""Z"", 공백으로 이루어져 있습니다. s에 있는 숫자와 ""Z""는 서로 공백으로 구분됩니다. 연속된 공백은 주어지지 않습니다. 0을 제외하고는 0으로 시작하는 숫자는 없습니다. s는 ""Z""로 시작하지 않습니다. s의 시작과 끝에는 공백이 없습니다. ""Z""가 연속해서 나오는 경우는 없습니다. 입출력 예 s result ""1 2 Z 3"" 4 ""10 20 30 40"" 100 ""10 Z 20 Z 1"" 1 ""10 Z 20 Z"" 0 ""-1 -2 -3 Z"" -3 입출력 예 설명 입출력 예 #1 본문과 동일합니다. 입출력 예 #2 10 + 20 + 30 + 40 = 100을 return 합니다. 입출력 예 #3 ""10 Z 20 Z 1""에서 10 다음 Z, 20 다음 Z로 10, 20이 지워지고 1만 더하여 1을 return 합니다. 입출력 예 #4, #5 설명 생략 ※ 공지 - 2022년 11월 30일 제한사항 및 테스트 케이스가 수정되었습니다.",easy,String
314,"소인수분해란 어떤 수를 소수들의 곱으로 표현하는 것입니다. 예를 들어 12를 소인수 분해하면 2 * 2 * 3 으로 나타낼 수 있습니다. 따라서 12의 소인수는 2와 3입니다. 자연수 n이 매개변수로 주어질 때 n의 소인수를 오름차순으로 담은 배열을 return하도록 solution 함수를 완성해주세요. 제한사항 2 ≤ n ≤ 10,000 입출력 예 n result 12 [2, 3] 17 [17] 420 [2, 3, 5, 7] 입출력 예 설명 입출력 예 #1 12를 소인수분해하면 2 * 2 * 3 입니다. 따라서 [2, 3]을 return합니다. 입출력 예 #2 17은 소수입니다. 따라서 [17]을 return 해야 합니다. 입출력 예 #3 420을 소인수분해하면 2 * 2 * 3 * 5 * 7 입니다. 따라서 [2, 3, 5, 7]을 return합니다.",easy,Array
315,"문자열 my_string이 매개변수로 주어집니다. my_string안의 모든 자연수들의 합을 return하도록 solution 함수를 완성해주세요. 제한사항 1 ≤ my_string의 길이 ≤ 1,000 my_string은 소문자, 대문자 그리고 한자리 자연수로만 구성되어있습니다. 입출력 예 my_string result ""aAb1B2cC34oOp"" 10 ""1a2b3c4d123"" 16 입출력 예 설명 입출력 예 #1 ""aAb1B2cC34oOp""안의 한자리 자연수는 1, 2, 3, 4 입니다. 따라서 1 + 2 + 3 + 4 = 10 을 return합니다. 입출력 예 #2 ""1a2b3c4d123Z""안의 한자리 자연수는 1, 2, 3, 4, 1, 2, 3 입니다. 따라서 1 + 2 + 3 + 4 + 1 + 2 + 3 = 16 을 return합니다. 유의사항 연속된 숫자도 각각 한 자리 숫자로 취급합니다.",easy,String
316,"문자열 my_string이 매개변수로 주어질 때, my_string 안에 있는 숫자만 골라 오름차순 정렬한 리스트를 return 하도록 solution 함수를 작성해보세요. 제한사항 1 ≤ my_string의 길이 ≤ 100 my_string에는 숫자가 한 개 이상 포함되어 있습니다. my_string은 영어 소문자 또는 0부터 9까지의 숫자로 이루어져 있습니다. - - - 입출력 예 my_string result ""hi12392"" [1, 2, 2, 3, 9] ""p2o4i8gj2"" [2, 2, 4, 8] ""abcde0"" [0] 입출력 예 설명 입출력 예 #1 ""hi12392""에 있는 숫자 1, 2, 3, 9, 2를 오름차순 정렬한 [1, 2, 2, 3, 9]를 return 합니다. 입출력 예 #2 ""p2o4i8gj2""에 있는 숫자 2, 4, 8, 2를 오름차순 정렬한 [2, 2, 4, 8]을 return 합니다. 입출력 예 #3 ""abcde0""에 있는 숫자 0을 오름차순 정렬한 [0]을 return 합니다.",easy,Array
317,"영어에선 a, e, i, o, u 다섯 가지 알파벳을 모음으로 분류합니다. 문자열 my_string이 매개변수로 주어질 때 모음을 제거한 문자열을 return하도록 solution 함수를 완성해주세요. 제한사항 my_string은 소문자와 공백으로 이루어져 있습니다. 1 ≤ my_string의 길이 ≤ 1,000 입출력 예 my_string result ""bus"" ""bs"" ""nice to meet you"" ""nc t mt y"" 입출력 예 설명 입출력 예 #1 ""bus""에서 모음 u를 제거한 ""bs""를 return합니다. 입출력 예 #1 ""nice to meet you""에서 모음 i, o, e, u를 모두 제거한 ""nc t mt y""를 return합니다.",easy,String
318,"i팩토리얼 (i!)은 1부터 i까지 정수의 곱을 의미합니다. 예를들어 5! = 5 * 4 * 3 * 2 * 1 = 120 입니다. 정수 n이 주어질 때 다음 조건을 만족하는 가장 큰 정수 i를 return 하도록 solution 함수를 완성해주세요. i! ≤ n 제한사항 0 < n ≤ 3,628,800 입출력 예 n result 3628800 10 7 3 입출력 예 설명 입출력 예 #1 10! = 3,628,800입니다. n이 3628800이므로 최대 팩토리얼인 10을 return 합니다. 입출력 예 #2 3! = 6, 4! = 24입니다. n이 7이므로, 7 이하의 최대 팩토리얼인 3을 return 합니다.",easy,Math
319,"정수 배열 numbers가 매개변수로 주어집니다. numbers의 원소 중 두 개를 곱해 만들 수 있는 최댓값을 return하도록 solution 함수를 완성해주세요. 제한사항 0 ≤ numbers의 원소 ≤ 10,000 2 ≤ numbers의 길이 ≤ 100 입출력 예 numbers result [1, 2, 3, 4, 5] 20 [0, 31, 24, 10, 1, 9] 744 입출력 예 설명 입출력 예 #1 두 수의 곱중 최댓값은 4 * 5 = 20 입니다. 입출력 예 #1 두 수의 곱중 최댓값은 31 * 24 = 744 입니다.",easy,Array
320,"약수의 개수가 세 개 이상인 수를 합성수라고 합니다. 자연수 n이 매개변수로 주어질 때 n이하의 합성수의 개수를 return하도록 solution 함수를 완성해주세요. 제한사항 1 ≤ n ≤ 100 입출력 예 n result 10 5 15 8 입출력 예 설명 입출력 예 #1 10 이하 합성수는 4, 6, 8, 9, 10 로 5개입니다. 따라서 5를 return합니다. 입출력 예 #1 15 이하 합성수는 4, 6, 8, 9, 10, 12, 14, 15 로 8개입니다. 따라서 8을 return합니다.",easy,Math
321,"머쓱이는 직육면체 모양의 상자를 하나 가지고 있는데 이 상자에 정육면체 모양의 주사위를 최대한 많이 채우고 싶습니다. 상자의 가로, 세로, 높이가 저장되어있는 배열 box와 주사위 모서리의 길이 정수 n이 매개변수로 주어졌을 때, 상자에 들어갈 수 있는 주사위의 최대 개수를 return 하도록 solution 함수를 완성해주세요. 제한사항 box의 길이는 3입니다. box[0] = 상자의 가로 길이 box[1] = 상자의 세로 길이 box[2] = 상자의 높이 길이 1 ≤ box의 원소 ≤ 100 1 ≤ n ≤ 50 n ≤ box의 원소 주사위는 상자와 평행하게 넣습니다. 입출력 예 box n result [1, 1, 1] 1 1 [10, 8, 6] 3 12 입출력 예 설명 입출력 예 #1 상자의 크기가 가로 1, 세로 1, 높이 1이므로 모서리의 길이가 1인 주사위는 1개 들어갈 수 있습니다. 입출력 예 #2 상자의 크기가 가로 10, 세로 8, 높이 6이므로 모서리의 길이가 3인 주사위는 12개 들어갈 수 있습니다.",easy,Array
322,"정수가 담긴 배열 numbers와 문자열 direction가 매개변수로 주어집니다. 배열 numbers의 원소를 direction방향으로 한 칸씩 회전시킨 배열을 return하도록 solution 함수를 완성해주세요. 제한사항 3 ≤ numbers의 길이 ≤ 20 direction은 ""left"" 와 ""right"" 둘 중 하나입니다. 입출력 예 numbers direction result [1, 2, 3] ""right"" [3, 1, 2] [4, 455, 6, 4, -1, 45, 6] ""left"" [455, 6, 4, -1, 45, 6, 4] 입출력 예 설명 입출력 예 #1 numbers 가 [1, 2, 3]이고 direction이 ""right"" 이므로 오른쪽으로 한 칸씩 회전시킨 [3, 1, 2]를 return합니다. 입출력 예 #2 numbers 가 [4, 455, 6, 4, -1, 45, 6]이고 direction이 ""left"" 이므로 왼쪽으로 한 칸씩 회전시킨 [455, 6, 4, -1, 45, 6, 4]를 return합니다.",easy,Array
323,"머쓱이는 친구들과 동그랗게 서서 공 던지기 게임을 하고 있습니다. 공은 1번부터 던지며 오른쪽으로 한 명을 건너뛰고 그다음 사람에게만 던질 수 있습니다. 친구들의 번호가 들어있는 정수 배열 numbers와 정수 K가 주어질 때, k번째로 공을 던지는 사람의 번호는 무엇인지 return 하도록 solution 함수를 완성해보세요. 제한사항 2 < numbers의 길이 < 100 0 < k < 1,000 numbers의 첫 번째와 마지막 번호는 실제로 바로 옆에 있습니다. numbers는 1부터 시작하며 번호는 순서대로 올라갑니다. 입출력 예 numbers k result [1, 2, 3, 4] 2 3 [1, 2, 3, 4, 5, 6] 5 3 [1, 2, 3] 3 2 입출력 예 설명 입출력 예 #1 1번은 첫 번째로 3번에게 공을 던집니다. 3번은 두 번째로 1번에게 공을 던집니다. 입출력 예 #2 1번은 첫 번째로 3번에게 공을 던집니다. 3번은 두 번째로 5번에게 공을 던집니다. 5번은 세 번째로 1번에게 공을 던집니다. 1번은 네 번째로 3번에게 공을 던집니다. 3번은 다섯 번째로 5번에게 공을 던집니다. 입출력 예 #3 1번은 첫 번째로 3번에게 공을 던집니다. 3번은 두 번째로 2번에게 공을 던집니다. 2번은 세 번째로 1번에게 공을 던집니다. ※ 공지 - 2023년 1월 25일 테스트 케이스가 추가되었습니다. 기존에 제출한 코드가 통과하지 못할 수도 있습니다.",easy,Array
324,"정수 배열 num_list와 정수 n이 매개변수로 주어집니다. num_list를 다음 설명과 같이 2차원 배열로 바꿔 return하도록 solution 함수를 완성해주세요. num_list가 [1, 2, 3, 4, 5, 6, 7, 8] 로 길이가 8이고 n이 2이므로 num_list를 2 * 4 배열로 다음과 같이 변경합니다. 2차원으로 바꿀 때에는 num_list의 원소들을 앞에서부터 n개씩 나눠 2차원 배열로 변경합니다. num_list n result [1, 2, 3, 4, 5, 6, 7, 8] 2 [[1, 2], [3, 4], [5, 6], [7, 8]] 제한사항 num_list의 길이는 n의 배 수개입니다. 0 ≤ num_list의 길이 ≤ 150 2 ≤ n < num_list의 길이 입출력 예 num_list n result [1, 2, 3, 4, 5, 6, 7, 8] 2 [[1, 2], [3, 4], [5, 6], [7, 8]] [100, 95, 2, 4, 5, 6, 18, 33, 948] 3 [[100, 95, 2], [4, 5, 6], [18, 33, 948]] 입출력 예 설명 입출력 예 #1 num_list가 [1, 2, 3, 4, 5, 6, 7, 8] 로 길이가 8이고 n이 2이므로 2 * 4 배열로 변경한 [[1, 2], [3, 4], [5, 6], [7, 8]] 을 return합니다. 입출력 예 #2 num_list가 [100, 95, 2, 4, 5, 6, 18, 33, 948] 로 길이가 9이고 n이 3이므로 3 * 3 배열로 변경한 [[100, 95, 2], [4, 5, 6], [18, 33, 948]] 을 return합니다.",easy,Array
325,"사분면은 한 평면을 x축과 y축을 기준으로 나눈 네 부분입니다. 사분면은 아래와 같이 1부터 4까지 번호를매깁니다. x 좌표와 y 좌표가 모두 양수이면 제1사분면에 속합니다. x 좌표가 음수, y 좌표가 양수이면 제2사분면에 속합니다. x 좌표와 y 좌표가 모두 음수이면 제3사분면에 속합니다. x 좌표가 양수, y 좌표가 음수이면 제4사분면에 속합니다. x 좌표 (x, y)를 차례대로 담은 정수 배열 dot이 매개변수로 주어집니다. 좌표 dot이 사분면 중 어디에 속하는지 1, 2, 3, 4 중 하나를 return 하도록 solution 함수를 완성해주세요. 제한사항 dot의 길이 = 2 dot[0]은 x좌표를, dot[1]은 y좌표를 나타냅니다 -500 ≤ dot의 원소 ≤ 500 dot의 원소는 0이 아닙니다. 입출력 예 dot result [2, 4] 1 [-7, 9] 2 입출력 예 설명 입출력 예 #1 dot이 [2, 4]로 x 좌표와 y 좌표 모두 양수이므로 제 1 사분면에 속합니다. 따라서 1을 return 합니다. 입출력 예 #2 dot이 [-7, 9]로 x 좌표가 음수, y 좌표가 양수이므로 제 2 사분면에 속합니다. 따라서 2를 return 합니다.",easy,Array
326,"머쓱이는 구슬을 친구들에게 나누어주려고 합니다. 구슬은 모두 다르게 생겼습니다. 머쓱이가 갖고 있는 구슬의 개수 balls와 친구들에게 나누어 줄 구슬 개수 share이 매개변수로 주어질 때, balls개의 구슬 중 share개의 구슬을 고르는 가능한 모든 경우의 수를 return 하는 solution 함수를 완성해주세요. 제한사항 1 ≤ balls ≤ 30 1 ≤ share ≤ 30 구슬을 고르는 순서는 고려하지 않습니다. share ≤ balls 입출력 예 balls share result 3 2 3 5 3 10 입출력 예 설명 입출력 예 #1 서로 다른 구슬 3개 중 2개를 고르는 경우의 수는 3입니다. 입출력 예 #2 서로 다른 구슬 5개 중 3개를 고르는 경우의 수는 10입니다. Hint 서로 다른 n개 중 m개를 뽑는 경우의 수 공식은 다음과 같습니다. ※ 공지 - 2022년 10월 11일 제한 사항 및 테스트케이스가 수정되었습니다.",easy,Math
327,"가위는 2 바위는 0 보는 5로 표현합니다. 가위 바위 보를 내는 순서대로 나타낸 문자열 rsp가 매개변수로 주어질 때, rsp에 저장된 가위 바위 보를 모두 이기는 경우를 순서대로 나타낸 문자열을 return하도록 solution 함수를 완성해보세요. 제한사항 0 < rsp의 길이 ≤ 100 rsp와 길이가 같은 문자열을 return 합니다. rsp는 숫자 0, 2, 5로 이루어져 있습니다. 입출력 예 rsp result ""2"" ""0"" ""205"" ""052"" 입출력 예 설명 입출력 예 #1 ""2""는 가위이므로 바위를 나타내는 ""0""을 return 합니다. 입출력 예 #2 ""205""는 순서대로 가위, 바위, 보이고 이를 모두 이기려면 바위, 보, 가위를 순서대로 내야하므로 “052”를 return합니다.",easy,String
328,"머쓱이는 친구에게 모스부호를 이용한 편지를 받았습니다. 그냥은 읽을 수 없어 이를 해독하는 프로그램을 만들려고 합니다. 문자열 letter가 매개변수로 주어질 때, letter를 영어 소문자로 바꾼 문자열을 return 하도록 solution 함수를 완성해보세요. 모스부호는 다음과 같습니다. morse = { '.-':'a','-...':'b','-.-.':'c','-..':'d','.':'e','..-.':'f', '--.':'g','....':'h','..':'i','.---':'j','-.-':'k','.-..':'l', '--':'m','-.':'n','---':'o','.--.':'p','--.-':'q','.-.':'r', '...':'s','-':'t','..-':'u','...-':'v','.--':'w','-..-':'x', '-.--':'y','--..':'z' } 제한사항 1 ≤ letter의 길이 ≤ 1,000 return값은 소문자입니다. letter의 모스부호는 공백으로 나누어져 있습니다. letter에 공백은 연속으로 두 개 이상 존재하지 않습니다. 해독할 수 없는 편지는 주어지지 않습니다. 편지의 시작과 끝에는 공백이 없습니다. 입출력 예 letter result "".... . .-.. .-.. ---"" ""hello"" "".--. -.-- - .... --- -."" ""python"" 입출력 예 설명 입출력 예 #1 .... = h . = e .-.. = l .-.. = l --- = o 따라서 ""hello""를 return 합니다. 입출력 예 #2 .--. = p -.-- = y - = t .... = h --- = o -. = n 따라서 ""python""을 return 합니다. a ~ z에 해당하는 모스부호가 순서대로 담긴 배열입니다. {"".-"",""-..."",""-.-."",""-.."",""."",""..-."",""--."",""...."","".."","".---"",""-.-"","".-.."",""--"",""-."",""---"","".--."",""--.-"","".-."",""..."",""-"",""..-"",""...-"","".--"",""-..-"",""-.--"",""--..""}",easy,Array
329,"개미 군단이 사냥을 나가려고 합니다. 개미군단은 사냥감의 체력에 딱 맞는 병력을 데리고 나가려고 합니다. 장군개미는 5의 공격력을, 병정개미는 3의 공격력을 일개미는 1의 공격력을 가지고 있습니다. 예를 들어 체력 23의 여치를 사냥하려고 할 때, 일개미 23마리를 데리고 가도 되지만, 장군개미 네 마리와 병정개미 한 마리를 데리고 간다면 더 적은 병력으로 사냥할 수 있습니다. 사냥감의 체력 hp가 매개변수로 주어질 때, 사냥감의 체력에 딱 맞게 최소한의 병력을 구성하려면 몇 마리의 개미가 필요한지를 return하도록 solution 함수를 완성해주세요. 제한사항 hp는 자연수입니다. 0 ≤ hp ≤ 1000 입출력 예 hp result 23 5 24 6 999 201 입출력 예 설명 입출력 예 #1 hp가 23이므로, 장군개미 네마리와 병정개미 한마리로 사냥할 수 있습니다. 따라서 5를 return합니다. 입출력 예 #2 hp가 24이므로, 장군개미 네마리 병정개미 한마리 일개미 한마리로 사냥할 수 있습니다. 따라서 6을 return합니다. 입출력 예 #3 hp가 999이므로, 장군개미 199 마리 병정개미 한마리 일개미 한마리로 사냥할 수 있습니다. 따라서 201을 return합니다.",easy,Math
330,"순서쌍이란 두 개의 숫자를 순서를 정하여 짝지어 나타낸 쌍으로 (a, b)로 표기합니다. 자연수 n이 매개변수로 주어질 때 두 숫자의 곱이 n인 자연수 순서쌍의 개수를 return하도록 solution 함수를 완성해주세요. 제한사항 1 ≤ n ≤ 1,000,000 입출력 예 n result 20 6 100 9 입출력 예 설명 입출력 예 #1 n이 20 이므로 곱이 20인 순서쌍은 (1, 20), (2, 10), (4, 5), (5, 4), (10, 2), (20, 1) 이므로 6을 return합니다. 입출력 예 #2 n이 100 이므로 곱이 100인 순서쌍은 (1, 100), (2, 50), (4, 25), (5, 20), (10, 10), (20, 5), (25, 4), (50, 2), (100, 1) 이므로 9를 return합니다.",easy,Math
331,"외과의사 머쓱이는 응급실에 온 환자의 응급도를 기준으로 진료 순서를 정하려고 합니다. 정수 배열 emergency가 매개변수로 주어질 때 응급도가 높은 순서대로 진료 순서를 정한 배열을 return하도록 solution 함수를 완성해주세요. 제한사항 중복된 원소는 없습니다. 1 ≤ emergency의 길이 ≤ 10 1 ≤ emergency의 원소 ≤ 100 입출력 예 emergency result [3, 76, 24] [3, 1, 2] [1, 2, 3, 4, 5, 6, 7] [7, 6, 5, 4, 3, 2, 1] [30, 10, 23, 6, 100] [2, 4, 3, 5, 1] 입출력 예 설명 입출력 예 #1 emergency가 [3, 76, 24]이므로 응급도의 크기 순서대로 번호를 매긴 [3, 1, 2]를 return합니다. 입출력 예 #2 emergency가 [1, 2, 3, 4, 5, 6, 7]이므로 응급도의 크기 순서대로 번호를 매긴 [7, 6, 5, 4, 3, 2, 1]를 return합니다. 입출력 예 #3 emergency가 [30, 10, 23, 6, 100]이므로 응급도의 크기 순서대로 번호를 매긴 [2, 4, 3, 5, 1]를 return합니다.",easy,Array
332,"우주여행을 하던 머쓱이는 엔진 고장으로 PROGRAMMERS-962 행성에 불시착하게 됐습니다. 입국심사에서 나이를 말해야 하는데, PROGRAMMERS-962 행성에서는 나이를 알파벳으로 말하고 있습니다. a는 0, b는 1, c는 2, ..., j는 9입니다. 예를 들어 23살은 cd, 51살은 fb로 표현합니다. 나이 age가 매개변수로 주어질 때 PROGRAMMER-962식 나이를 return하도록 solution 함수를 완성해주세요. 제한사항 age는 자연수입니다. age ≤ 1,000 PROGRAMMERS-962 행성은 알파벳 소문자만 사용합니다. 입출력 예 age result 23 ""cd"" 51 ""fb"" 100 ""baa"" 입출력 예 설명 입출력 예 #1 age가 23이므로 ""cd""를 return합니다. 입출력 예 #2 age가 51이므로 ""fb""를 return합니다. 입출력 예 #3 age가 100이므로 ""baa""를 return합니다.",easy,Math
333,"정수 배열 numbers와 정수 num1, num2가 매개변수로 주어질 때, numbers의 num1번 째 인덱스부터 num2번째 인덱스까지 자른 정수 배열을 return 하도록 solution 함수를 완성해보세요. 제한사항 2 ≤ numbers의 길이 ≤ 30 0 ≤ numbers의 원소 ≤ 1,000 0 ≤num1 < num2 < numbers의 길이 입출력 예 numbers num1 num2 result [1, 2, 3, 4, 5] 1 3 [2, 3, 4] [1, 3, 5] 1 2 [3, 5] 입출력 예 설명 입출력 예 #1 [1, 2, 3, 4, 5]의 1번째 인덱스 2부터 3번째 인덱스 4 까지 자른 [2, 3, 4]를 return 합니다. 입출력 예 #2 [1, 3, 5]의 1번째 인덱스 3부터 2번째 인덱스 5까지 자른 [3, 5]를 return 합니다.",easy,Array
334,"정수 n이 주어질 때, n이하의 짝수를 모두 더한 값을 return 하도록 solution 함수를 작성해주세요. 제한사항 0 < n ≤ 1000 입출력 예 n result 10 30 4 6 입출력 예 설명 입출력 예 #1 n이 10이므로 2 + 4 + 6 + 8 + 10 = 30을 return 합니다. 입출력 예 #2 n이 4이므로 2 + 4 = 6을 return 합니다.",easy,Math
335,"머쓱이네 양꼬치 가게는 10인분을 먹으면 음료수 하나를 서비스로 줍니다. 양꼬치는 1인분에 12,000원, 음료수는 2,000원입니다. 정수 n과 k가 매개변수로 주어졌을 때, 양꼬치 n인분과 음료수 k개를 먹었다면 총얼마를 지불해야 하는지 return 하도록 solution 함수를 완성해보세요. 제한사항 0 < n < 1,000 n / 10 ≤ k < 1,000 서비스로 받은 음료수는 모두 마십니다. 입출력 예 n k result 10 3 124,000 64 6 768,000 입출력 예 설명 입출력 예 #1 10인분을 시켜 서비스로 음료수를 하나 받아 총 10 * 12000 + 3 * 2000 - 1 * 2000 = 124,000원입니다. 입출력 예 #2 64인분을 시켜 서비스로 음료수를 6개 받아 총 64 * 12000 + 6 * 2000 - 6 * 2000 =768,000원입니다.",easy,Design
336,"각에서 0도 초과 90도 미만은 예각, 90도는 직각, 90도 초과 180도 미만은 둔각 180도는 평각으로 분류합니다. 각 angle이 매개변수로 주어질 때 예각일 때 1, 직각일 때 2, 둔각일 때 3, 평각일 때 4를 return하도록 solution 함수를 완성해주세요. 예각 : 0 < angle < 90 직각 : angle = 90 둔각 : 90 < angle < 180 평각 : angle = 180 제한사항 0 < angle ≤ 180 angle은 정수입니다. 입출력 예 angle result 70 1 91 3 180 4 입출력 예 설명 입출력 예 #1 angle이 70이므로 예각입니다. 따라서 1을 return합니다. 입출력 예 #2 angle이 91이므로 둔각입니다. 따라서 3을 return합니다. 입출력 예 #2 angle이 180이므로 평각입니다. 따라서 4를 return합니다.",easy,Math
337,"문자열 my_string과 문자 letter이 매개변수로 주어집니다. my_string에서 letter를 제거한 문자열을 return하도록 solution 함수를 완성해주세요. 제한사항 1 ≤ my_string의 길이 ≤ 100 letter은 길이가 1인 영문자입니다. my_string과 letter은 알파벳 대소문자로 이루어져 있습니다. 대문자와 소문자를 구분합니다. 입출력 예 my_string letter result ""abcdef"" ""f"" ""abcde"" ""BCBdbe"" ""B"" ""Cdbe"" 입출력 예 설명 입출력 예 #1 ""abcdef"" 에서 ""f""를 제거한 ""abcde""를 return합니다. 입출력 예 #2 ""BCBdbe"" 에서 ""B""를 모두 제거한 ""Cdbe""를 return합니다.",easy,String
338,"문자열 my_string과 정수 n이 매개변수로 주어질 때, my_string에 들어있는 각 문자를 n만큼 반복한 문자열을 return 하도록 solution 함수를 완성해보세요. 제한사항 2 ≤ my_string 길이 ≤ 5 2 ≤ n ≤ 10 ""my_string""은 영어 대소문자로 이루어져 있습니다. 입출력 예 my_string n result ""hello"" 3 ""hhheeellllllooo"" 입출력 예 설명 입출력 예 #1 ""hello""의 각 문자를 세 번씩 반복한 ""hhheeellllllooo""를 return 합니다.",easy,String
339,"정수가 담긴 리스트 num_list가 주어질 때, num_list의 원소 중 짝수와 홀수의 개수를 담은 배열을 return 하도록 solution 함수를 완성해보세요. 제한사항 1 ≤ num_list의 길이 ≤ 100 0 ≤ num_list의 원소 ≤ 1,000 입출력 예 num_list result [1, 2, 3, 4, 5] [2, 3] [1, 3, 5, 7] [0, 4] 입출력 예 설명 입출력 예 #1 [1, 2, 3, 4, 5]에는 짝수가 2, 4로 두 개, 홀수가 1, 3, 5로 세 개 있습니다. 입출력 예 #2 [1, 3, 5, 7]에는 짝수가 없고 홀수가 네 개 있습니다.",easy,Array
340,"""*""의 높이와 너비를 1이라고 했을 때, ""*""을 이용해 직각 이등변 삼각형을 그리려고합니다. 정수 n 이 주어지면 높이와 너비가 n 인 직각 이등변 삼각형을 출력하도록 코드를 작성해보세요. 제한사항 1 ≤ n ≤ 10 입출력 예 입력 #1 3 출력 #1 * ** *** 입출력 예 설명 입출력 예 #1 n이 3이므로 첫째 줄에 * 1개, 둘째 줄에 * 2개, 셋째 줄에 * 3개를 출력합니다.",easy,Math
341,"문자열 my_string이 매개변수로 주어집니다. my_string을 거꾸로 뒤집은 문자열을 return하도록 solution 함수를 완성해주세요. 제한사항 1 ≤ my_string의 길이 ≤ 1,000 입출력 예 my_string return ""jaron"" ""noraj"" ""bread"" ""daerb"" 입출력 예 설명 입출력 예 #1 my_string이 ""jaron""이므로 거꾸로 뒤집은 ""noraj""를 return합니다. 입출력 예 #2 my_string이 ""bread""이므로 거꾸로 뒤집은 ""daerb""를 return합니다.",easy,String
342,"정수가 들어 있는 배열 num_list가 매개변수로 주어집니다. num_list의 원소의 순서를 거꾸로 뒤집은 배열을 return하도록 solution 함수를 완성해주세요. 제한사항 1 ≤ num_list의 길이 ≤ 1,000 0 ≤ num_list의 원소 ≤ 1,000 입출력 예 num_list result [1, 2, 3, 4, 5] [5, 4, 3, 2, 1] [1, 1, 1, 1, 1, 2] [2, 1, 1, 1, 1, 1] [1, 0, 1, 1, 1, 3, 5] [5, 3, 1, 1, 1, 0, 1] 입출력 예 설명 입출력 예 #1 num_list가 [1, 2, 3, 4, 5]이므로 순서를 거꾸로 뒤집은 배열 [5, 4, 3, 2, 1]을 return합니다. 입출력 예 #2 num_list가 [1, 1, 1, 1, 1, 2]이므로 순서를 거꾸로 뒤집은 배열 [2, 1, 1, 1, 1, 1]을 return합니다. 입출력 예 #3 num_list가 [1, 0, 1, 1, 1, 3, 5]이므로 순서를 거꾸로 뒤집은 배열 [5, 3, 1, 1, 1, 0, 1]을 return합니다.",easy,Array
343,"머쓱이는 선생님이 몇 년도에 태어났는지 궁금해졌습니다. 2022년 기준 선생님의 나이 age가 주어질 때, 선생님의 출생 연도를 return 하는 solution 함수를 완성해주세요 제한사항 0 < age ≤ 120 나이는 태어난 연도에 1살이며 매년 1월 1일마다 1살씩 증가합니다. 입출력 예 age result 40 1983 23 2000 입출력 예 설명 입출력 예 #1 2022년 기준 40살이므로 1983년생입니다. 입출력 예 #2 2022년 기준 23살이므로 2000년생입니다. ※ 공지 - 2024년 3월 14일 문제 지문이 보다 명확하게 수정되었습니다.",easy,Math
344,"머쓱이는 추운 날에도 아이스 아메리카노만 마십니다. 아이스 아메리카노는 한잔에 5,500원입니다. 머쓱이가 가지고 있는 돈 money가 매개변수로 주어질 때, 머쓱이가 최대로 마실 수 있는 아메리카노의 잔 수와 남는 돈을 순서대로 담은 배열을 return 하도록 solution 함수를 완성해보세요. 제한사항 0 < money ≤ 1,000,000 입출력 예 money result 5,500 [1, 0] 15,000 [2, 4000] 입출력 예 설명 입출력 예 #1 5,500원은 아이스 아메리카노 한 잔을 살 수 있고 잔돈은 0원입니다. 입출력 예 #2 15,000원은 아이스 아메리카노 두 잔을 살 수 있고 잔돈은 4,000원입니다.",easy,Array
345,"머쓱이네 옷가게는 10만 원 이상 사면 5%, 30만 원 이상 사면 10%, 50만 원 이상 사면 20%를 할인해줍니다. 구매한 옷의 가격 price가 주어질 때, 지불해야 할 금액을 return 하도록 solution 함수를 완성해보세요. 제한사항 10 ≤ price ≤ 1,000,000 price는 10원 단위로(1의 자리가 0) 주어집니다. 소수점 이하를 버린 정수를 return합니다. 입출력 예 price result 150,000 142,500 580,000 464,000 입출력 예 설명 입출력 예 #1 150,000원에서 5%를 할인한 142,500원을 return 합니다. 입출력 예 #2 580,000원에서 20%를 할인한 464,000원을 return 합니다.",easy,Math
346,"정수 배열 numbers가 매개변수로 주어집니다. numbers의 원소의 평균값을 return하도록 solution 함수를 완성해주세요. 제한사항 0 ≤ numbers의 원소 ≤ 1,000 1 ≤ numbers의 길이 ≤ 100 정답의 소수 부분이 .0 또는 .5인 경우만 입력으로 주어집니다. 입출력 예 numbers result [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 5.5 [89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99] 94.0 입출력 예 설명 입출력 예 #1 numbers의 원소들의 평균 값은 5.5입니다. 입출력 예 #2 numbers의 원소들의 평균 값은 94.0입니다.",easy,Array
347,"머쓱이네 피자가게는 피자를 두 조각에서 열 조각까지 원하는 조각 수로 잘라줍니다. 피자 조각 수 slice와 피자를 먹는 사람의 수 n이 매개변수로 주어질 때, n명의 사람이 최소 한 조각 이상 피자를 먹으려면 최소 몇 판의 피자를 시켜야 하는지를 return 하도록 solution 함수를 완성해보세요. 제한사항 2 ≤ slice ≤ 10 1 ≤ n ≤ 100 입출력 예 slice n result 7 10 2 4 12 3 입출력 예 설명 입출력 예 #1 10명이 7조각으로 자른 피자를 한 조각 이상씩 먹으려면 최소 2판을 시켜야 합니다. 입출력 예 #2 12명이 4조각으로 자른 피자를 한 조각 이상씩 먹으려면 최소 3판을 시켜야 합니다.",easy,Math
348,"머쓱이네 피자가게는 피자를 여섯 조각으로 잘라 줍니다. 피자를 나눠먹을 사람의 수 n이 매개변수로 주어질 때, n명이 주문한 피자를 남기지 않고 모두 같은 수의 피자 조각을 먹어야 한다면 최소 몇 판을 시켜야 하는지를 return 하도록 solution 함수를 완성해보세요. 제한사항 1 ≤ n ≤ 100 입출력 예 n result 6 1 10 5 4 2 입출력 예 설명 입출력 예 #1 6명이 모두 같은 양을 먹기 위해 한 판을 시켜야 피자가 6조각으로 모두 한 조각씩 먹을 수 있습니다. 입출력 예 #2 10명이 모두 같은 양을 먹기 위해 최소 5판을 시켜야 피자가 30조각으로 모두 세 조각씩 먹을 수 있습니다. 입출력 예 #3 4명이 모두 같은 양을 먹기 위해 최소 2판을 시키면 피자가 12조각으로 모두 세 조각씩 먹을 수 있습니다.",easy,Design
349,"머쓱이네 피자가게는 피자를 일곱 조각으로 잘라 줍니다. 피자를 나눠먹을 사람의 수 n이 주어질 때, 모든 사람이 피자를 한 조각 이상 먹기 위해 필요한 피자의 수를 return 하는 solution 함수를 완성해보세요. 제한사항 1 ≤ n ≤ 100 입출력 예 n result 7 1 1 1 15 3 입출력 예 설명 입출력 예 #1 7명이 최소 한 조각씩 먹기 위해서 최소 1판이 필요합니다. 입출력 예 #2 1명은 최소 한 조각을 먹기 위해 1판이 필요합니다. 입출력 예 #3 15명이 최소 한 조각씩 먹기 위해서 최소 3판이 필요합니다.",easy,Math
350,"정수 n이 매개변수로 주어질 때, n 이하의 홀수가 오름차순으로 담긴 배열을 return하도록 solution 함수를 완성해주세요. 제한사항 1 ≤ n ≤ 100 입출력 예 n result 10 [1, 3, 5, 7, 9] 15 [1, 3, 5, 7, 9, 11, 13, 15] 입출력 예 설명 입출력 #1 10 이하의 홀수가 담긴 배열 [1, 3, 5, 7, 9]를 return합니다. 입출력 #1 15 이하의 홀수가 담긴 배열 [1, 3, 5, 7, 9, 11, 13, 15]를 return합니다.",easy,Array
351,"최빈값은 주어진 값 중에서 가장 자주 나오는 값을 의미합니다. 정수 배열 array가 매개변수로 주어질 때, 최빈값을 return 하도록 solution 함수를 완성해보세요. 최빈값이 여러 개면 -1을 return 합니다. 제한사항 0 < array의 길이 < 100 0 ≤ array의 원소 < 1000 입출력 예 array result [1, 2, 3, 3, 3, 4] 3 [1, 1, 2, 2] -1 [1] 1 입출력 예 설명 입출력 예 #1 [1, 2, 3, 3, 3, 4]에서 1은 1개 2는 1개 3은 3개 4는 1개로 최빈값은 3입니다. 입출력 예 #2 [1, 1, 2, 2]에서 1은 2개 2는 2개로 최빈값이 1, 2입니다. 최빈값이 여러 개이므로 -1을 return 합니다. 입출력 예 #3 [1]에는 1만 있으므로 최빈값은 1입니다. ※ 공지 - 2022년 10월 17일 제한 사항 및 테스트케이스가 수정되었습니다.",easy,Array
352,"중앙값은 어떤 주어진 값들을 크기의 순서대로 정렬했을 때 가장 중앙에 위치하는 값을 의미합니다. 예를 들어 1, 2, 7, 10, 11의 중앙값은 7입니다. 정수 배열 array가 매개변수로 주어질 때, 중앙값을 return 하도록 solution 함수를 완성해보세요. 제한사항 array의 길이는 홀수입니다. 0 < array의 길이 < 100 -1,000 < array의 원소 < 1,000 입출력 예 array result [1, 2, 7, 10, 11] 7 [9, -1, 0] 0 입출력 예 설명 입출력 예 #1 본문과 동일합니다. 입출력 예 #2 9, -1, 0을 오름차순 정렬하면 -1, 0, 9이고 가장 중앙에 위치하는 값은 0입니다.",easy,Array
353,"정수 num1, num2가 매개변수로 주어질 때, num1를 num2로 나눈 나머지를 return 하도록 solution 함수를 완성해주세요. 제한사항 0 < num1 ≤ 100 0 < num2 ≤ 100 입출력 예 num1 num2 result 3 2 1 10 5 0 입출력 예 설명 입출력 예 #1 num1이 3, num2가 2이므로 3을 2로 나눈 나머지 1을 return 합니다. 입출력 예 #2 num1이 10, num2가 5이므로 10을 5로 나눈 나머지 0을 return 합니다.",easy,Math
354,"정수 배열 numbers가 매개변수로 주어집니다. numbers의 각 원소에 두배한 원소를 가진 배열을 return하도록 solution 함수를 완성해주세요. 제한사항 -10,000 ≤ numbers의 원소 ≤ 10,000 1 ≤ numbers의 길이 ≤ 1,000 입출력 예 numbers result [1, 2, 3, 4, 5] [2, 4, 6, 8, 10] [1, 2, 100, -99, 1, 2, 3] [2, 4, 200, -198, 2, 4, 6] 입출력 예 설명 입출력 예 #1 [1, 2, 3, 4, 5]의 각 원소에 두배를 한 배열 [2, 4, 6, 8, 10]을 return합니다. 입출력 예 #2 [1, 2, 100, -99, 1, 2, 3]의 각 원소에 두배를 한 배열 [2, 4, 200, -198, 2, 4, 6]을 return합니다.",easy,Array
355,"첫 번째 분수의 분자와 분모를 뜻하는 numer1, denom1, 두 번째 분수의 분자와 분모를 뜻하는 numer2, denom2가 매개변수로 주어집니다. 두 분수를 더한 값을 기약 분수로 나타냈을 때 분자와 분모를 순서대로 담은 배열을 return 하도록 solution 함수를 완성해보세요. 제한사항 0 <numer1, denom1, numer2, denom2 < 1,000 입출력 예 numer1 denom1 numer2 denom2 result 1 2 3 4 [5, 4] 9 2 1 3 [29, 6] 입출력 예 설명 입출력 예 #1 1 / 2 + 3 / 4 = 5 / 4입니다. 따라서 [5, 4]를 return 합니다. 입출력 예 #2 9 / 2 + 1 / 3 = 29 / 6입니다. 따라서 [29, 6]을 return 합니다.",easy,Array
356,"정수 num1과 num2가 매개변수로 주어집니다. 두 수가 같으면 1 다르면 -1을 retrun하도록 solution 함수를 완성해주세요. 제한사항 0 ≤ num1 ≤ 10,000 0 ≤ num2 ≤ 10,000 입출력 예 num1 num2 result 2 3 -1 11 11 1 7 99 -1 입출력 예 설명 입출력 예 설명 #1 num1이 2이고 num2가 3이므로 다릅니다. 따라서 -1을 return합니다. 입출력 예 설명 #2 num1이 11이고 num2가 11이므로 같습니다. 따라서 1을 return합니다. 입출력 예 설명 #3 num1이 7이고 num2가 99이므로 다릅니다. 따라서 -1을 return합니다.",easy,Math
357,"정수 num1과 num2가 매개변수로 주어질 때, num1을 num2로 나눈 값에 1,000을 곱한 후 정수 부분을 return 하도록 solution 함수를 완성해주세요. 제한사항 0 < num1 ≤ 100 0 < num2 ≤ 100 입출력 예 num1 num2 result 3 2 1500 7 3 2333 1 16 62 입출력 예 설명 입출력 예 #1 num1이 3, num2가 2이므로 3 / 2 = 1.5에 1,000을 곱하면 1500이 됩니다. 입출력 예 #2 num1이 7, num2가 3이므로 7 / 3 = 2.33333...에 1,000을 곱하면 2333.3333.... 이 되며, 정수 부분은 2333입니다. 입출력 예 #3 num1이 1, num2가 16이므로 1 / 16 = 0.0625에 1,000을 곱하면 62.5가 되며, 정수 부분은 62입니다.",easy,Math
358,"정수 num1, num2가 매개변수로 주어질 때, num1을 num2로 나눈 몫을 return 하도록 solution 함수를 완성해주세요. 제한사항 0 < num1 ≤ 100 0 < num2 ≤ 100 입출력 예 num1 num2 result 10 5 2 7 2 3 입출력 예 설명 입출력 예 #1 num1이 10, num2가 5이므로 10을 5로 나눈 몫 2를 return 합니다. 입출력 예 #2 num1이 7, num2가 2이므로 7을 2로 나눈 몫 3을 return 합니다.",easy,Math
359,"정수 num1, num2가 매개변수 주어집니다. num1과 num2를 곱한 값을 return 하도록 solution 함수를 완성해주세요. 제한사항 0 ≤ num1 ≤ 100 0 ≤ num2 ≤ 100 입출력 예 num1 num2 result 3 4 12 27 19 513 입출력 예 설명 입출력 예 #1 num1이 3, num2가 4이므로 3 * 4 = 12를 return합니다. 입출력 예 #2 num1이 27, num2가 19이므로 27 * 19 = 513을 return합니다.",easy,Math
360,"정수 num1과 num2가 주어질 때, num1에서 num2를 뺀 값을 return하도록 soltuion 함수를 완성해주세요. 제한사항 -50000 ≤ num1 ≤ 50000 -50000 ≤ num2 ≤ 50000 입출력 예 num1 num2 result 2 3 -1 100 2 98 입출력 예 설명 입출력 예 #1 num1이 2이고 num2가 3이므로 2 - 3 = -1을 return합니다. 입출력 예 #2 num1이 100이고 num2가 2이므로 100 - 2 = 98을 return합니다.",easy,Math
361,"정수 num1과 num2가 주어질 때, num1과 num2의 합을 return하도록 soltuion 함수를 완성해주세요. 제한사항 -50,000 ≤ num1 ≤ 50,000 -50,000 ≤ num2 ≤ 50,000 입출력 예 num1 num2 result 2 3 5 100 2 102 입출력 예 설명 입출력 예 #1 num1이 2이고 num2가 3이므로 2 + 3 = 5를 return합니다. 입출력 예 #2 num1이 100이고 num2가 2이므로 100 + 2 = 102를 return합니다.",easy,Math
362,"머쓱이는 학교에서 키 순으로 줄을 설 때 몇 번째로 서야 하는지 궁금해졌습니다. 머쓱이네 반 친구들의 키가 담긴 정수 배열 array와 머쓱이의 키 height가 매개변수로 주어질 때, 머쓱이보다 키 큰 사람 수를 return 하도록 solution 함수를 완성해보세요. 제한사항 1 ≤ array의 길이 ≤ 100 1 ≤ height ≤ 200 1 ≤ array의 원소 ≤ 200 입출력 예 array height result [149, 180, 192, 170] 167 3 [180, 120, 140] 190 0 입출력 예 설명 입출력 예 #1 149, 180, 192, 170 중 머쓱이보다 키가 큰 사람은 180, 192, 170으로 세 명입니다. 입출력 예 #2 180, 120, 140 중 190보다 큰 수는 없으므로 0명입니다.",easy,Array
363,"정수가 담긴 배열 array와 정수 n이 매개변수로 주어질 때, array에 n이 몇 개 있는 지를 return 하도록 solution 함수를 완성해보세요. 제한사항 1 ≤ array의 길이 ≤ 100 0 ≤ array의 원소 ≤ 1,000 0 ≤ n ≤ 1,000 입출력 예 array n result [1, 1, 2, 3, 4, 5] 1 2 [0, 2, 3, 4] 1 0 입출력 예 설명 입출력 예 #1 [1, 1, 2, 3, 4, 5] 에는 1이 2개 있습니다. 입출력 예 #2 [0, 2, 3, 4] 에는 1이 0개 있습니다.",easy,Array
364,"[본 문제는 정확성과 효율성 테스트 각각 점수가 있는 문제입니다.] 당신은 행렬에 적용할 수 있는 두 가지 연산을 만들었습니다. ShiftRow 모든 행이 아래쪽으로 한 칸씩 밀려납니다. 즉, 모든 행에 대해서 i번째 행은 i+1번째 행이 됩니다. (마지막 행은 1번째 행이 됩니다.) ShiftRow의 예 왼쪽 행렬이 초기 상태이고 오른쪽 행렬이 ShiftRow를 한 번 시행한 뒤의 행렬입니다. 1번째 행에 있던 [1,2,3]이 2번째 행으로, 2번째 행에 있던 [4,5,6]이 3번째 행으로, 3번째 행에 있던 [7,8,9]가 1번째 행이 된 것을 확인할 수 있습니다. Rotate 행렬의 바깥쪽에 있는 원소들을 시계 방향으로 한 칸 회전시킵니다. 행렬의 바깥쪽에 있는 원소들은 첫 행, 첫 열, 끝 행, 끝 열에 포함되는 원소들입니다. 한 칸 회전시킨다는 것은 이 원소들이 시계 방향으로 한 칸씩 밀려난다는 것을 의미합니다. 즉, 다음 4개의 연산이 동시에 시행됩니다. 첫 행에서 끝 열에 있는 원소를 제외한 첫 행의 모든 원소는 오른쪽으로 한 칸 이동합니다. 끝 열에서 끝 행에 있는 원소를 제외한 끝 열의 모든 원소는 아래쪽으로 한 칸 이동합니다. 끝 행에서 첫 열에 있는 원소를 제외한 끝 행의 모든 원소는 왼쪽으로 한 칸 이동합니다. 첫 열에서 첫 행에 있는 원소를 제외한 첫 열의 모든 원소는 위쪽으로 한 칸 이동합니다. Rotate의 예 왼쪽 행렬이 초기 상태이고 오른쪽 행렬이 Rotate를 한 번 시행한 뒤의 행렬입니다. 바깥쪽에 있는 값들이 시계 방향으로 한 칸씩 이동한 것을 확인할 수 있습니다. 당신은 행렬에 연산을 여러 번 시행하려고 합니다. 행렬의 초기 상태를 담고 있는 2차원 정수 배열 rc, 시행할 연산을 순서대로 담고 있는 문자열 배열 operations가 매개변수로 주어졌을 때, 연산을 차례대로 시행한 후의 행렬 상태를 return 하도록 solution 함수를 완성해주세요. 제한사항 2 ≤ rc의 행 길이(=행렬의 가로 길이) ≤ 50,000 rc의 모든 행의 길이는 동일합니다. 2 ≤ rc의 열 길이(=행렬의 세로 길이) ≤ 50,000 rc의 모든 열의 길이는 동일합니다. 4 ≤ rc의 행 길이 x rc의 열 길이 ≤ 100,000 rc[i][j] 는 i+1번째 행 j+1번째 열에 있는 원소를 나타냅니다. 1 ≤ rc[i][j] ≤ 1,000,000 1 ≤ operations의 길이 ≤ 100,000 operations의 원소는 ""ShiftRow"" 혹은 ""Rotate""입니다. 정확성 테스트 케이스 제한 사항 2 ≤ rc의 행 길이(=행렬의 가로 길이) ≤ 1,000 rc의 모든 행의 길이는 동일합니다. 2 ≤ rc의 열 길이(=행렬의 세로 길이) ≤ 1,000 rc의 모든 열의 길이는 동일합니다. 4 ≤ rc의 행 길이 x rc의 열 길이 ≤ 10,000 1 ≤ operations의 길이 ≤ 100 효율성 테스트 케이스 제한 사항 주어진 조건 외 추가 제한사항 없습니다. 입출력 예 rc operations result [[1, 2, 3], [4, 5, 6], [7, 8, 9]] [""Rotate"", ""ShiftRow""] [[8, 9, 6], [4, 1, 2], [7, 5, 3]] [[8, 6, 3], [3, 3, 7], [8, 4, 9]] [""Rotate"", ""ShiftRow"", ""ShiftRow""] [[8, 3, 3], [4, 9, 7], [3, 8, 6]] [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]] [""ShiftRow"", ""Rotate"", ""ShiftRow"", ""Rotate""] [[1, 6, 7 ,8], [5, 9, 10, 4], [2, 3, 12, 11]] 입출력 예 설명 입출력 예#1 위 그림은 ”Rotate”와 ”ShiftRow”를 차례대로 실행한 결과입니다. 따라서 [[8, 9, 6], [4, 1, 2], [7, 5, 3]]을 return 해야 합니다. 입출력 예#2 위 그림은 ”Rotate”, ”ShiftRow”, ""ShiftRow""를 차례대로 실행한 결과입니다. 따라서 [[8, 3, 3], [4, 9, 7], [3, 8, 6]]을 return 해야 합니다. 입출력 예#3 위 그림은 ”ShiftRow”, ”Rotate”, ”ShiftRow”, ”Rotate”를 차례대로 실행한 결과입니다. 따라서 [[1, 6, 7 ,8], [5, 9, 10, 4], [2, 3, 12, 11]]을 return 해야 합니다. 제한시간 안내 정확성 테스트 : 10초 효율성 테스트 : 언어별로 작성된 정답 코드의 실행 시간의 적정 배수",hard,Array
365,"XX산은 n개의 지점으로 이루어져 있습니다. 각 지점은 1부터 n까지 번호가 붙어있으며, 출입구, 쉼터, 혹은 산봉우리입니다. 각 지점은 양방향 통행이 가능한 등산로로 연결되어 있으며, 서로 다른 지점을 이동할 때 이 등산로를 이용해야 합니다. 이때, 등산로별로 이동하는데 일정 시간이 소요됩니다. 등산코스는 방문할 지점 번호들을 순서대로 나열하여 표현할 수 있습니다. 예를 들어 1-2-3-2-1 으로 표현하는 등산코스는 1번지점에서 출발하여 2번, 3번, 2번, 1번 지점을 순서대로 방문한다는 뜻입니다. 등산코스를 따라 이동하는 중 쉼터 혹은 산봉우리를 방문할 때마다 휴식을 취할 수 있으며, 휴식 없이 이동해야 하는 시간 중 가장 긴 시간을 해당 등산코스의 intensity라고 부르기로 합니다. 당신은 XX산의 출입구 중 한 곳에서 출발하여 산봉우리 중 한 곳만 방문한 뒤 다시 원래의 출입구로 돌아오는 등산코스를 정하려고 합니다. 다시 말해, 등산코스에서 출입구는 처음과 끝에 한 번씩, 산봉우리는 한 번만 포함되어야 합니다. 당신은 이러한 규칙을 지키면서 intensity가 최소가 되도록 등산코스를 정하려고 합니다. 다음은 XX산의 지점과 등산로를 그림으로 표현한 예시입니다. 위 그림에서 원에 적힌 숫자는 지점의 번호를 나타내며, 1, 3번 지점에 출입구, 5번 지점에 산봉우리가 있습니다. 각 선분은 등산로를 나타내며, 각 선분에 적힌 수는 이동 시간을 나타냅니다. 예를 들어 1번 지점에서 2번 지점으로 이동할 때는 3시간이 소요됩니다. 위의 예시에서 1-2-5-4-3 과 같은 등산코스는 처음 출발한 원래의 출입구로 돌아오지 않기 때문에 잘못된 등산코스입니다. 또한 1-2-5-6-4-3-2-1 과 같은 등산코스는 코스의 처음과 끝 외에 3번 출입구를 방문하기 때문에 잘못된 등산코스입니다. 등산코스를 3-2-5-4-3 과 같이 정했을 때의 이동경로를 그림으로 나타내면 아래와 같습니다. 이때, 휴식 없이 이동해야 하는 시간 중 가장 긴 시간은 5시간입니다. 따라서 이 등산코스의 intensity는 5입니다. 등산코스를 1-2-4-5-6-4-2-1 과 같이 정했을 때의 이동경로를 그림으로 나타내면 아래와 같습니다. 이때, 휴식 없이 이동해야 하는 시간 중 가장 긴 시간은 3시간입니다. 따라서 이 등산코스의 intensity는 3이며, 이 보다 intensity가 낮은 등산코스는 없습니다. XX산의 지점 수 n, 각 등산로의 정보를 담은 2차원 정수 배열 paths, 출입구들의 번호가 담긴 정수 배열 gates, 산봉우리들의 번호가 담긴 정수 배열 summits가 매개변수로 주어집니다. 이때, intensity가 최소가 되는 등산코스에 포함된 산봉우리 번호와 intensity의 최솟값을 차례대로 정수 배열에 담아 return 하도록 solution 함수를 완성해주세요. intensity가 최소가 되는 등산코스가 여러 개라면 그중 산봉우리의 번호가 가장 낮은 등산코스를 선택합니다. 제한사항 2 ≤ n ≤ 50,000 n - 1 ≤ paths의 길이 ≤ 200,000 paths의 원소는 [i, j, w] 형태입니다. i번 지점과 j번 지점을 연결하는 등산로가 있다는 뜻입니다. w는 두 지점 사이를 이동하는 데 걸리는 시간입니다. 1 ≤ i < j ≤ n 1 ≤ w ≤ 10,000,000 서로 다른 두 지점을 직접 연결하는 등산로는 최대 1개입니다. 1 ≤ gates의 길이 ≤ n 1 ≤ gates의 원소 ≤ n gates의 원소는 해당 지점이 출입구임을 나타냅니다. 1 ≤ summits의 길이 ≤ n 1 ≤ summits의 원소 ≤ n summits의 원소는 해당 지점이 산봉우리임을 나타냅니다. 출입구이면서 동시에 산봉우리인 지점은 없습니다. gates와 summits에 등장하지 않은 지점은 모두 쉼터입니다. 임의의 두 지점 사이에 이동 가능한 경로가 항상 존재합니다. return 하는 배열은 [산봉우리의 번호, intensity의 최솟값] 순서여야 합니다. 입출력 예 n paths gates summits result 6 [[1, 2, 3], [2, 3, 5], [2, 4, 2], [2, 5, 4], [3, 4, 4], [4, 5, 3], [4, 6, 1], [5, 6, 1]] [1, 3] [5] [5, 3] 7 [[1, 4, 4], [1, 6, 1], [1, 7, 3], [2, 5, 2], [3, 7, 4], [5, 6, 6]] [1] [2, 3, 4] [3, 4] 7 [[1, 2, 5], [1, 4, 1], [2, 3, 1], [2, 6, 7], [4, 5, 1], [5, 6, 1], [6, 7, 1]] [3, 7] [1, 5] [5, 1] 5 [[1, 3, 10], [1, 4, 20], [2, 3, 4], [2, 4, 6], [3, 5, 20], [4, 5, 6]] [1, 2] [5] [5, 6] 입출력 예 설명 입출력 예 #1 문제 예시와 같습니다. 등산코스의 intensity가 최소가 되는 산봉우리 번호는 5, intensity의 최솟값은 3이므로 [5, 3]을 return 해야 합니다. 입출력 예 #2 XX산의 지점과 등산로를 그림으로 표현하면 아래와 같습니다. 가능한 intensity의 최솟값은 4이며, intensity가 4가 되는 등산코스는 1-4-1 과 1-7-3-7-1 이 있습니다. intensity가 최소가 되는 등산코스가 여러 개이므로 둘 중 산봉우리의 번호가 낮은 1-7-3-7-1 을 선택합니다. 따라서 [3, 4]를 return 해야 합니다. 입출력 예 #3 XX산의 지점과 등산로를 그림으로 표현하면 아래와 같습니다. 가능한 intensity의 최솟값은 1이며, 그때의 등산코스는 7-6-5-6-7 입니다. 따라서 [5, 1]를 return 해야 합니다. 7-6-5-4-1-4-5-6-7 과 같은 등산코스는 산봉우리를 여러 번 방문하기 때문에 잘못된 등산코스입니다. 입출력 예 #4 XX산의 지점과 등산로를 그림으로 표현하면 아래와 같습니다. 가능한 intensity의 최솟값은 6, 그때의 등산코스는 2-4-5-4-2 입니다. 따라서 [5, 6]을 return 해야 합니다.",normal,Array
366,"[본 문제는 정확성과 효율성 테스트 각각 점수가 있는 문제입니다.] 당신은 코딩 테스트를 준비하기 위해 공부하려고 합니다. 코딩 테스트 문제를 풀기 위해서는 알고리즘에 대한 지식과 코드를 구현하는 능력이 필요합니다. 알고리즘에 대한 지식은 알고력, 코드를 구현하는 능력은 코딩력이라고 표현합니다. 알고력과 코딩력은 0 이상의 정수로 표현됩니다. 문제를 풀기 위해서는 문제가 요구하는 일정 이상의 알고력과 코딩력이 필요합니다. 예를 들어, 당신의 현재 알고력이 15, 코딩력이 10이라고 가정해보겠습니다. A라는 문제가 알고력 10, 코딩력 10을 요구한다면 A 문제를 풀 수 있습니다. B라는 문제가 알고력 10, 코딩력 20을 요구한다면 코딩력이 부족하기 때문에 B 문제를 풀 수 없습니다. 풀 수 없는 문제를 해결하기 위해서는 알고력과 코딩력을 높여야 합니다. 알고력과 코딩력을 높이기 위한 다음과 같은 방법들이 있습니다. 알고력을 높이기 위해 알고리즘 공부를 합니다. 알고력 1을 높이기 위해서 1의 시간이 필요합니다. 코딩력을 높이기 위해 코딩 공부를 합니다. 코딩력 1을 높이기 위해서 1의 시간이 필요합니다. 현재 풀 수 있는 문제 중 하나를 풀어 알고력과 코딩력을 높입니다. 각 문제마다 문제를 풀면 올라가는 알고력과 코딩력이 정해져 있습니다. 문제를 하나 푸는 데는 문제가 요구하는 시간이 필요하며 같은 문제를 여러 번 푸는 것이 가능합니다. 당신은 주어진 모든 문제들을 풀 수 있는 알고력과 코딩력을 얻는 최단시간을 구하려 합니다. 초기의 알고력과 코딩력을 담은 정수 alp와 cop, 문제의 정보를 담은 2차원 정수 배열 problems가 매개변수로 주어졌을 때, 모든 문제들을 풀 수 있는 알고력과 코딩력을 얻는 최단시간을 return 하도록 solution 함수를 작성해주세요. 모든 문제들을 1번 이상씩 풀 필요는 없습니다. 입출력 예 설명을 참고해주세요. 제한사항 초기의 알고력을 나타내는 alp와 초기의 코딩력을 나타내는 cop가 입력으로 주어집니다. 0 ≤ alp,cop ≤ 150 1 ≤ problems의 길이 ≤ 100 problems의 원소는 [alp_req, cop_req, alp_rwd, cop_rwd, cost]의 형태로 이루어져 있습니다. alp_req는 문제를 푸는데 필요한 알고력입니다. 0 ≤ alp_req ≤ 150 cop_req는 문제를 푸는데 필요한 코딩력입니다. 0 ≤ cop_req ≤ 150 alp_rwd는 문제를 풀었을 때 증가하는 알고력입니다. 0 ≤ alp_rwd ≤ 30 cop_rwd는 문제를 풀었을 때 증가하는 코딩력입니다. 0 ≤ cop_rwd ≤ 30 cost는 문제를 푸는데 드는 시간입니다. 1 ≤ cost ≤ 100 정확성 테스트 케이스 제한사항 0 ≤ alp,cop ≤ 20 1 ≤ problems의 길이 ≤ 6 0 ≤ alp_req,cop_req ≤ 20 0 ≤ alp_rwd,cop_rwd ≤ 5 1 ≤ cost ≤ 10 효율성 테스트 케이스 제한사항 주어진 조건 외 추가 제한사항 없습니다. 입출력 예 alp cop problems result 10 10 [[10,15,2,1,2],[20,20,3,3,4]] 15 0 0 [[0,0,2,1,2],[4,5,3,1,2],[4,11,4,0,2],[10,4,0,4,2]] 13 입출력 예 설명 입출력 예 #1 코딩력 5를 늘립니다. 알고력 10, 코딩력 15가 되며 시간이 5만큼 소요됩니다. 1번 문제를 5번 풉니다. 알고력 20, 코딩력 20이 되며 시간이 10만큼 소요됩니다. 15의 시간을 소요하여 모든 문제를 풀 수 있는 알고력과 코딩력을 가질 수 있습니다. 입출력 예 #2 1번 문제를 2번 풉니다. 알고력 4, 코딩력 2가 되며 시간이 4만큼 소요됩니다. 코딩력 3을 늘립니다. 알고력 4, 코딩력 5가 되며 시간이 3만큼 소요됩니다. 2번 문제를 2번 풉니다. 알고력 10, 코딩력 7이 되며 시간이 4만큼 소요됩니다. 4번 문제를 1번 풉니다. 알고력 10, 코딩력 11이 되며 시간이 2만큼 소요됩니다. 13의 시간을 소요하여 모든 문제를 풀 수 있는 알고력과 코딩력을 가질 수 있습니다. 제한시간 안내 정확성 테스트 : 10초 효율성 테스트 : 언어별로 작성된 정답 코드의 실행 시간의 적정 배수",normal,Array
367,"길이가 같은 두 개의 큐가 주어집니다. 하나의 큐를 골라 원소를 추출(pop)하고, 추출된 원소를 다른 큐에 집어넣는(insert) 작업을 통해 각 큐의 원소 합이 같도록 만들려고 합니다. 이때 필요한 작업의 최소 횟수를 구하고자 합니다. 한 번의 pop과 한 번의 insert를 합쳐서 작업을 1회 수행한 것으로 간주합니다. 큐는 먼저 집어넣은 원소가 먼저 나오는 구조입니다. 이 문제에서는 큐를 배열로 표현하며, 원소가 배열 앞쪽에 있을수록 먼저 집어넣은 원소임을 의미합니다. 즉, pop을 하면 배열의 첫 번째 원소가 추출되며, insert를 하면 배열의 끝에 원소가 추가됩니다. 예를 들어 큐 [1, 2, 3, 4]가 주어졌을 때, pop을 하면 맨 앞에 있는 원소 1이 추출되어 [2, 3, 4]가 되며, 이어서 5를 insert하면 [2, 3, 4, 5]가 됩니다. 다음은 두 큐를 나타내는 예시입니다. queue1 = [3, 2, 7, 2] queue2 = [4, 6, 5, 1] 두 큐에 담긴 모든 원소의 합은 30입니다. 따라서, 각 큐의 합을 15로 만들어야 합니다. 예를 들어, 다음과 같이 2가지 방법이 있습니다. queue2의 4, 6, 5를 순서대로 추출하여 queue1에 추가한 뒤, queue1의 3, 2, 7, 2를 순서대로 추출하여 queue2에 추가합니다. 그 결과 queue1은 [4, 6, 5], queue2는 [1, 3, 2, 7, 2]가 되며, 각 큐의 원소 합은 15로 같습니다. 이 방법은 작업을 7번 수행합니다. queue1에서 3을 추출하여 queue2에 추가합니다. 그리고 queue2에서 4를 추출하여 queue1에 추가합니다. 그 결과 queue1은 [2, 7, 2, 4], queue2는 [6, 5, 1, 3]가 되며, 각 큐의 원소 합은 15로 같습니다. 이 방법은 작업을 2번만 수행하며, 이보다 적은 횟수로 목표를 달성할 수 없습니다. 따라서 각 큐의 원소 합을 같게 만들기 위해 필요한 작업의 최소 횟수는 2입니다. 길이가 같은 두 개의 큐를 나타내는 정수 배열 queue1, queue2가 매개변수로 주어집니다. 각 큐의 원소 합을 같게 만들기 위해 필요한 작업의 최소 횟수를 return 하도록 solution 함수를 완성해주세요. 단, 어떤 방법으로도 각 큐의 원소 합을 같게 만들 수 없는 경우, -1을 return 해주세요. 제한사항 1 ≤ queue1의 길이 = queue2의 길이 ≤ 300,000 1 ≤ queue1의 원소, queue2의 원소 ≤ 109 주의: 언어에 따라 합 계산 과정 중 산술 오버플로우 발생 가능성이 있으므로 long type 고려가 필요합니다. 입출력 예 queue1 queue2 result [3, 2, 7, 2] [4, 6, 5, 1] 2 [1, 2, 1, 2] [1, 10, 1, 2] 7 [1, 1] [1, 5] -1 입출력 예 설명 입출력 예 #1 문제 예시와 같습니다. 입출력 예 #2 두 큐에 담긴 모든 원소의 합은 20입니다. 따라서, 각 큐의 합을 10으로 만들어야 합니다. queue2에서 1, 10을 순서대로 추출하여 queue1에 추가하고, queue1에서 1, 2, 1, 2와 1(queue2으로부터 받은 원소)을 순서대로 추출하여 queue2에 추가합니다. 그 결과 queue1은 [10], queue2는 [1, 2, 1, 2, 1, 2, 1]가 되며, 각 큐의 원소 합은 10으로 같습니다. 이때 작업 횟수는 7회이며, 이보다 적은 횟수로 목표를 달성하는 방법은 없습니다. 따라서 7를 return 합니다. 입출력 예 #3 어떤 방법을 쓰더라도 각 큐의 원소 합을 같게 만들 수 없습니다. 따라서 -1을 return 합니다.",normal,Array
368,"나만의 카카오 성격 유형 검사지를 만들려고 합니다. 성격 유형 검사는 다음과 같은 4개 지표로 성격 유형을 구분합니다. 성격은 각 지표에서 두 유형 중 하나로 결정됩니다. 지표 번호 성격 유형 1번 지표 라이언형(R), 튜브형(T) 2번 지표 콘형(C), 프로도형(F) 3번 지표 제이지형(J), 무지형(M) 4번 지표 어피치형(A), 네오형(N) 4개의 지표가 있으므로 성격 유형은 총 16(=2 x 2 x 2 x 2)가지가 나올 수 있습니다. 예를 들어, ""RFMN""이나 ""TCMA""와 같은 성격 유형이 있습니다. 검사지에는 총 n개의 질문이 있고, 각 질문에는 아래와 같은 7개의 선택지가 있습니다. 매우 비동의 비동의 약간 비동의 모르겠음 약간 동의 동의 매우 동의 각 질문은 1가지 지표로 성격 유형 점수를 판단합니다. 예를 들어, 어떤 한 질문에서 4번 지표로 아래 표처럼 점수를 매길 수 있습니다. 선택지 성격 유형 점수 매우 비동의 네오형 3점 비동의 네오형 2점 약간 비동의 네오형 1점 모르겠음 어떤 성격 유형도 점수를 얻지 않습니다 약간 동의 어피치형 1점 동의 어피치형 2점 매우 동의 어피치형 3점 이때 검사자가 질문에서 약간 동의 선택지를 선택할 경우 어피치형(A) 성격 유형 1점을 받게 됩니다. 만약 검사자가 매우 비동의 선택지를 선택할 경우 네오형(N) 성격 유형 3점을 받게 됩니다. 위 예시처럼 네오형이 비동의, 어피치형이 동의인 경우만 주어지지 않고, 질문에 따라 네오형이 동의, 어피치형이 비동의인 경우도 주어질 수 있습니다. 하지만 각 선택지는 고정적인 크기의 점수를 가지고 있습니다. 매우 동의나 매우 비동의 선택지를 선택하면 3점을 얻습니다. 동의나 비동의 선택지를 선택하면 2점을 얻습니다. 약간 동의나 약간 비동의 선택지를 선택하면 1점을 얻습니다. 모르겠음 선택지를 선택하면 점수를 얻지 않습니다. 검사 결과는 모든 질문의 성격 유형 점수를 더하여 각 지표에서 더 높은 점수를 받은 성격 유형이 검사자의 성격 유형이라고 판단합니다. 단, 하나의 지표에서 각 성격 유형 점수가 같으면, 두 성격 유형 중 사전 순으로 빠른 성격 유형을 검사자의 성격 유형이라고 판단합니다. 질문마다 판단하는 지표를 담은 1차원 문자열 배열 survey와 검사자가 각 질문마다 선택한 선택지를 담은 1차원 정수 배열 choices가 매개변수로 주어집니다. 이때, 검사자의 성격 유형 검사 결과를 지표 번호 순서대로 return 하도록 solution 함수를 완성해주세요. 제한사항 1 ≤ survey의 길이 ( = n) ≤ 1,000 survey의 원소는 ""RT"", ""TR"", ""FC"", ""CF"", ""MJ"", ""JM"", ""AN"", ""NA"" 중 하나입니다. survey[i]의 첫 번째 캐릭터는 i+1번 질문의 비동의 관련 선택지를 선택하면 받는 성격 유형을 의미합니다. survey[i]의 두 번째 캐릭터는 i+1번 질문의 동의 관련 선택지를 선택하면 받는 성격 유형을 의미합니다. choices의 길이 = survey의 길이 choices[i]는 검사자가 선택한 i+1번째 질문의 선택지를 의미합니다. 1 ≤ choices의 원소 ≤ 7 choices 뜻 1 매우 비동의 2 비동의 3 약간 비동의 4 모르겠음 5 약간 동의 6 동의 7 매우 동의 입출력 예 survey choices result [""AN"", ""CF"", ""MJ"", ""RT"", ""NA""] [5, 3, 2, 7, 5] ""TCMA"" [""TR"", ""RT"", ""TR""] [7, 1, 3] ""RCJA"" 입출력 예 설명 입출력 예 #1 1번 질문의 점수 배치는 아래 표와 같습니다. 선택지 성격 유형 점수 매우 비동의 어피치형 3점 비동의 어피치형 2점 약간 비동의 어피치형 1점 모르겠음 어떤 성격 유형도 점수를 얻지 않습니다 약간 동의 네오형 1점 동의 네오형 2점 매우 동의 네오형 3점 1번 질문에서는 지문의 예시와 다르게 비동의 관련 선택지를 선택하면 어피치형(A) 성격 유형의 점수를 얻고, 동의 관련 선택지를 선택하면 네오형(N) 성격 유형의 점수를 얻습니다. 1번 질문에서 검사자는 약간 동의 선택지를 선택했으므로 네오형(N) 성격 유형 점수 1점을 얻게 됩니다. 2번 질문의 점수 배치는 아래 표와 같습니다. 선택지 성격 유형 점수 매우 비동의 콘형 3점 비동의 콘형 2점 약간 비동의 콘형 1점 모르겠음 어떤 성격 유형도 점수를 얻지 않습니다 약간 동의 프로도형 1점 동의 프로도형 2점 매우 동의 프로도형 3점 2번 질문에서 검사자는 약간 비동의 선택지를 선택했으므로 콘형(C) 성격 유형 점수 1점을 얻게 됩니다. 3번 질문의 점수 배치는 아래 표와 같습니다. 선택지 성격 유형 점수 매우 비동의 무지형 3점 비동의 무지형 2점 약간 비동의 무지형 1점 모르겠음 어떤 성격 유형도 점수를 얻지 않습니다 약간 동의 제이지형 1점 동의 제이지형 2점 매우 동의 제이지형 3점 3번 질문에서 검사자는 비동의 선택지를 선택했으므로 무지형(M) 성격 유형 점수 2점을 얻게 됩니다. 4번 질문의 점수 배치는 아래 표와 같습니다. 선택지 성격 유형 점수 매우 비동의 라이언형 3점 비동의 라이언형 2점 약간 비동의 라이언형 1점 모르겠음 어떤 성격 유형도 점수를 얻지 않습니다 약간 동의 튜브형 1점 동의 튜브형 2점 매우 동의 튜브형 3점 4번 질문에서 검사자는 매우 동의 선택지를 선택했으므로 튜브형(T) 성격 유형 점수 3점을 얻게 됩니다. 5번 질문의 점수 배치는 아래 표와 같습니다. 선택지 성격 유형 점수 매우 비동의 네오형 3점 비동의 네오형 2점 약간 비동의 네오형 1점 모르겠음 어떤 성격 유형도 점수를 얻지 않습니다 약간 동의 어피치형 1점 동의 어피치형 2점 매우 동의 어피치형 3점 5번 질문에서 검사자는 약간 동의 선택지를 선택했으므로 어피치형(A) 성격 유형 점수 1점을 얻게 됩니다. 1번부터 5번까지 질문의 성격 유형 점수를 합치면 아래 표와 같습니다. 지표 번호 성격 유형 점수 성격 유형 점수 1번 지표 라이언형(R) 0 튜브형(T) 3 2번 지표 콘형(C) 1 프로도형(F) 0 3번 지표 제이지형(J) 0 무지형(M) 2 4번 지표 어피치형(A) 1 네오형(N) 1 각 지표에서 더 점수가 높은 T,C,M이 성격 유형입니다. 하지만, 4번 지표는 1점으로 동일한 점수입니다. 따라서, 4번 지표의 성격 유형은 사전순으로 빠른 A입니다. 따라서 ""TCMA""를 return 해야 합니다. 입출력 예 #2 1번부터 3번까지 질문의 성격 유형 점수를 합치면 아래 표와 같습니다. 지표 번호 성격 유형 점수 성격 유형 점수 1번 지표 라이언형(R) 6 튜브형(T) 1 2번 지표 콘형(C) 0 프로도형(F) 0 3번 지표 제이지형(J) 0 무지형(M) 0 4번 지표 어피치형(A) 0 네오형(N) 0 1번 지표는 튜브형(T)보다 라이언형(R)의 점수가 더 높습니다. 따라서 첫 번째 지표의 성격 유형은 R입니다. 하지만, 2, 3, 4번 지표는 모두 0점으로 동일한 점수입니다. 따라서 2, 3, 4번 지표의 성격 유형은 사전순으로 빠른 C, J, A입니다. 따라서 ""RCJA""를 return 해야 합니다.",easy,Array
369,"문제 설명 플레이어 A와 플레이어 B가 서로 게임을 합니다. 당신은 이 게임이 끝날 때까지 양 플레이어가 캐릭터를 몇 번 움직이게 될지 예측하려고 합니다. 각 플레이어는 자신의 캐릭터 하나를 보드 위에 올려놓고 게임을 시작합니다. 게임 보드는 1x1 크기 정사각 격자로 이루어져 있으며, 보드 안에는 발판이 있는 부분과 없는 부분이 있습니다. 발판이 있는 곳에만 캐릭터가 서있을 수 있으며, 처음 캐릭터를 올려놓는 곳은 항상 발판이 있는 곳입니다. 캐릭터는 발판이 있는 곳으로만 이동할 수 있으며, 보드 밖으로 이동할 수 없습니다. 밟고 있던 발판은 그 위에 있던 캐릭터가 다른 곳으로 이동하여 다른 발판을 밞음과 동시에 사라집니다. 양 플레이어는 번갈아가며 자기 차례에 자신의 캐릭터를 상하좌우로 인접한 4개의 칸 중에서 발판이 있는 칸으로 옮겨야 합니다. 다음과 같은 2가지 상황에서 패자와 승자가 정해지며, 게임이 종료됩니다. 움직일 차례인데 캐릭터의 상하좌우 주변 4칸이 모두 발판이 없거나 보드 밖이라서 이동할 수 없는 경우, 해당 차례 플레이어는 패배합니다. 두 캐릭터가 같은 발판 위에 있을 때, 상대 플레이어의 캐릭터가 다른 발판으로 이동하여 자신의 캐릭터가 서있던 발판이 사라지게 되면 패배합니다. 게임은 항상 플레이어 A가 먼저 시작합니다. 양 플레이어는 최적의 플레이를 합니다. 즉, 이길 수 있는 플레이어는 최대한 빨리 승리하도록 플레이하고, 질 수밖에 없는 플레이어는 최대한 오래 버티도록 플레이합니다. '이길 수 있는 플레이어'는 실수만 하지 않는다면 항상 이기는 플레이어를 의미하며, '질 수밖에 없는 플레이어'는 최선을 다해도 상대가 실수하지 않으면 항상 질 수밖에 없는 플레이어를 의미합니다. 최대한 오래 버틴다는 것은 양 플레이어가 캐릭터를 움직이는 횟수를 최대화한다는 것을 의미합니다. 아래 그림은 초기 보드의 상태와 각 플레이어의 위치를 나타내는 예시입니다. 위와 같은 경우, 플레이어 A는 실수만 하지 않는다면 항상 이길 수 있습니다. 따라서 플레이어 A는 이길 수 있는 플레이어이며, B는 질 수밖에 없는 플레이어입니다. 다음은 A와 B가 최적의 플레이를 하는 과정을 나타냅니다. 플레이어 A가 초기 위치 (1, 0)에서 (1, 1)로 이동합니다. 플레이어 A가 (0, 0)이나 (2, 0)으로 이동할 경우 승리를 보장할 수 없습니다. 따라서 무조건 이길 방법이 있는 (1, 1)로 이동합니다. 플레이어 B는 (1, 1)로 이동할 경우, 바로 다음 차례에 A가 위 또는 아래 방향으로 이동하면 발판이 없어져 패배하게 됩니다. 질 수밖에 없는 플레이어는 최대한 오래 버티도록 플레이하기 때문에 (1, 1)로 이동하지 않습니다. (1, 2)에서 위쪽 칸인 (0, 2)로 이동합니다. A가 (1, 1)에서 (0, 1)로 이동합니다. B에게는 남은 선택지가 (0, 1)밖에 없습니다. 따라서 (0, 2)에서 (0, 1)로 이동합니다. A가 (0, 1)에서 (0, 0)으로 이동합니다. 이동을 완료함과 동시에 B가 서있던 (0, 1)의 발판이 사라집니다. B가 패배합니다. 만약 과정 2에서 B가 아래쪽 칸인 (2, 2)로 이동하더라도 A는 (2, 1)로 이동하면 됩니다. 이후 B가 (2, 1)로 이동, 다음 차례에 A가 (2, 0)으로 이동하면 B가 패배합니다. 위 예시에서 양 플레이어가 최적의 플레이를 했을 경우, 캐릭터의 이동 횟수 합은 5입니다. 최적의 플레이를 하는 방법은 여러 가지일 수 있으나, 이동한 횟수는 모두 5로 같습니다. 게임 보드의 초기 상태를 나타내는 2차원 정수 배열 board와 플레이어 A의 캐릭터 초기 위치를 나타내는 정수 배열 aloc, 플레이어 B의 캐릭터 초기 위치를 나타내는 정수 배열 bloc이 매개변수로 주어집니다. 양 플레이어가 최적의 플레이를 했을 때, 두 캐릭터가 움직인 횟수의 합을 return 하도록 solution 함수를 완성해주세요. 제한사항 1 ≤ board의 세로 길이 ≤ 5 1 ≤ board의 가로 길이 ≤ 5 board의 원소는 0 또는 1입니다. 0은 발판이 없음을, 1은 발판이 있음을 나타냅니다. 게임 보드의 좌측 상단 좌표는 (0, 0), 우측 하단 좌표는 (board의 세로 길이 - 1, board의 가로 길이 - 1)입니다. aloc과 bloc은 각각 플레이어 A의 캐릭터와 플레이어 B의 캐릭터 초기 위치를 나타내는 좌표값이며 [r, c] 형태입니다. r은 몇 번째 행인지를 나타냅니다. 0 ≤ r < board의 세로 길이 c는 몇 번째 열인지를 나타냅니다. 0 ≤ c < board의 가로 길이 초기 보드의 aloc과 bloc 위치는 항상 발판이 있는 곳입니다. aloc과 bloc이 같을 수 있습니다. 상대 플레이어의 캐릭터가 있는 칸으로 이동할 수 있습니다. 입출력 예 board aloc bloc result [[1, 1, 1], [1, 1, 1], [1, 1, 1]] [1, 0] [1, 2] 5 [[1, 1, 1], [1, 0, 1], [1, 1, 1]] [1, 0] [1, 2] 4 [[1, 1, 1, 1, 1]] [0, 0] [0, 4] 4 [[1]] [0, 0] [0, 0] 0 입출력 예 설명 입출력 예 #1 문제 예시와 같습니다. 입출력 예 #2 주어진 조건을 그림으로 나타내면 아래와 같습니다. 항상 이기는 플레이어는 B, 항상 지는 플레이어는 A입니다. 다음은 B가 이기는 방법 중 하나입니다. A가 (1, 0)에서 (0, 0)으로 이동 B가 (1, 2)에서 (2, 2)로 이동 A가 (0, 0)에서 (0, 1)로 이동 B가 (2, 2)에서 (2, 1)로 이동 A가 (0, 1)에서 (0, 2)로 이동 B가 (2, 1)에서 (2, 0)으로 이동 A는 더 이상 이동할 수 없어 패배합니다. 위와 같이 플레이할 경우 이동 횟수 6번 만에 게임을 B의 승리로 끝낼 수 있습니다. B가 다음과 같이 플레이할 경우 게임을 더 빨리 끝낼 수 있습니다. 이길 수 있는 플레이어는 최대한 빨리 게임을 끝내려 하기 때문에 위 방법 대신 아래 방법을 선택합니다. A가 (1, 0)에서 (0, 0)으로 이동 B가 (1, 2)에서 (0, 2)로 이동 A가 (0, 0)에서 (0, 1)로 이동 B가 (0, 2)에서 (0, 1)로 이동 A는 더 이상 이동할 수 없어 패배합니다. 위와 같이 플레이할 경우 이동 횟수 4번 만에 게임을 B의 승리로 끝낼 수 있습니다. 따라서 4를 return 합니다. 입출력 예 #3 양 플레이어는 매 차례마다 한 가지 선택지밖에 고를 수 없습니다. 그 결과, (0, 2)에서 어디로도 이동할 수 없는 A가 패배합니다. 양 플레이어가 캐릭터를 움직인 횟수의 합은 4입니다. 입출력 예 #4 게임을 시작하는 플레이어 A가 처음부터 어디로도 이동할 수 없는 상태입니다. 따라서 A의 패배이며, 이동 횟수의 합은 0입니다. 제한시간 안내 정확성 테스트 : 10초",normal,Array
370,"문제 설명 [본 문제는 정확성과 효율성 테스트 각각 점수가 있는 문제입니다.] N x M 크기의 행렬 모양의 게임 맵이 있습니다. 이 맵에는 내구도를 가진 건물이 각 칸마다 하나씩 있습니다. 적은 이 건물들을 공격하여 파괴하려고 합니다. 건물은 적의 공격을 받으면 내구도가 감소하고 내구도가 0이하가 되면 파괴됩니다. 반대로, 아군은 회복 스킬을 사용하여 건물들의 내구도를 높이려고 합니다. 적의 공격과 아군의 회복 스킬은 항상 직사각형 모양입니다. 예를 들어, 아래 사진은 크기가 4 x 5인 맵에 내구도가 5인 건물들이 있는 상태입니다. 첫 번째로 적이 맵의 (0,0)부터 (3,4)까지 공격하여 4만큼 건물의 내구도를 낮추면 아래와 같은 상태가 됩니다. 두 번째로 적이 맵의 (2,0)부터 (2,3)까지 공격하여 2만큼 건물의 내구도를 낮추면 아래와 같이 4개의 건물이 파괴되는 상태가 됩니다. 세 번째로 아군이 맵의 (1,0)부터 (3,1)까지 회복하여 2만큼 건물의 내구도를 높이면 아래와 같이 2개의 건물이 파괴되었다가 복구되고 2개의 건물만 파괴되어있는 상태가 됩니다. 마지막으로 적이 맵의 (0,1)부터 (3,3)까지 공격하여 1만큼 건물의 내구도를 낮추면 아래와 같이 8개의 건물이 더 파괴되어 총 10개의 건물이 파괴된 상태가 됩니다. (내구도가 0 이하가 된 이미 파괴된 건물도, 공격을 받으면 계속해서 내구도가 하락하는 것에 유의해주세요.) 최종적으로 총 10개의 건물이 파괴되지 않았습니다. 건물의 내구도를 나타내는 2차원 정수 배열 board와 적의 공격 혹은 아군의 회복 스킬을 나타내는 2차원 정수 배열 skill이 매개변수로 주어집니다. 적의 공격 혹은 아군의 회복 스킬이 모두 끝난 뒤 파괴되지 않은 건물의 개수를 return하는 solution함수를 완성해 주세요. 제한사항 1 ≤ board의 행의 길이 (= N) ≤ 1,000 1 ≤ board의 열의 길이 (= M) ≤ 1,000 1 ≤ board의 원소 (각 건물의 내구도) ≤ 1,000 1 ≤ skill의 행의 길이 ≤ 250,000 skill의 열의 길이 = 6 skill의 각 행은 [type, r1, c1, r2, c2, degree]형태를 가지고 있습니다. type은 1 혹은 2입니다. type이 1일 경우는 적의 공격을 의미합니다. 건물의 내구도를 낮춥니다. type이 2일 경우는 아군의 회복 스킬을 의미합니다. 건물의 내구도를 높입니다. (r1, c1)부터 (r2, c2)까지 직사각형 모양의 범위 안에 있는 건물의 내구도를 degree 만큼 낮추거나 높인다는 뜻입니다. 0 ≤ r1 ≤ r2 < board의 행의 길이 0 ≤ c1 ≤ c2 < board의 열의 길이 1 ≤ degree ≤ 500 type이 1이면 degree만큼 건물의 내구도를 낮춥니다. type이 2이면 degree만큼 건물의 내구도를 높입니다. 건물은 파괴되었다가 회복 스킬을 받아 내구도가 1이상이 되면 파괴되지 않은 상태가 됩니다. 즉, 최종적으로 건물의 내구도가 1이상이면 파괴되지 않은 건물입니다. 정확성 테스트 케이스 제한 사항 1 ≤ board의 행의 길이 (= N) ≤ 100 1 ≤ board의 열의 길이 (= M) ≤ 100 1 ≤ board의 원소 (각 건물의 내구도) ≤ 100 1 ≤ skill의 행의 길이 ≤ 100 1 ≤ degree ≤ 100 효율성 테스트 케이스 제한 사항 주어진 조건 외 추가 제한사항 없습니다. 입출력 예 board skill result [[5,5,5,5,5],[5,5,5,5,5],[5,5,5,5,5],[5,5,5,5,5]] [[1,0,0,3,4,4],[1,2,0,2,3,2],[2,1,0,3,1,2],[1,0,1,3,3,1]] 10 [[1,2,3],[4,5,6],[7,8,9]] [[1,1,1,2,2,4],[1,0,0,1,1,2],[2,2,0,2,0,100]] 6 입출력 예 설명 입출력 예 #1 문제 예시와 같습니다. 입출력 예 #2 <초기 맵 상태> 첫 번째로 적이 맵의 (1,1)부터 (2,2)까지 공격하여 4만큼 건물의 내구도를 낮추면 아래와 같은 상태가 됩니다. 두 번째로 적이 맵의 (0,0)부터 (1,1)까지 공격하여 2만큼 건물의 내구도를 낮추면 아래와 같은 상태가 됩니다. 마지막으로 아군이 맵의 (2,0)부터 (2,0)까지 회복하여 100만큼 건물의 내구도를 높이면 아래와 같은 상황이 됩니다. 총, 6개의 건물이 파괴되지 않았습니다. 따라서 6을 return 해야 합니다. 제한시간 안내 정확성 테스트 : 10초 효율성 테스트 : 언어별로 작성된 정답 코드의 실행 시간의 적정 배수",normal,Array
371,"문제 설명 2진 트리 모양 초원의 각 노드에 늑대와 양이 한 마리씩 놓여 있습니다. 이 초원의 루트 노드에서 출발하여 각 노드를 돌아다니며 양을 모으려 합니다. 각 노드를 방문할 때 마다 해당 노드에 있던 양과 늑대가 당신을 따라오게 됩니다. 이때, 늑대는 양을 잡아먹을 기회를 노리고 있으며, 당신이 모은 양의 수보다 늑대의 수가 같거나 더 많아지면 바로 모든 양을 잡아먹어 버립니다. 당신은 중간에 양이 늑대에게 잡아먹히지 않도록 하면서 최대한 많은 수의 양을 모아서 다시 루트 노드로 돌아오려 합니다. 예를 들어, 위 그림의 경우(루트 노드에는 항상 양이 있습니다) 0번 노드(루트 노드)에서 출발하면 양을 한마리 모을 수 있습니다. 다음으로 1번 노드로 이동하면 당신이 모은 양은 두 마리가 됩니다. 이때, 바로 4번 노드로 이동하면 늑대 한 마리가 당신을 따라오게 됩니다. 아직은 양 2마리, 늑대 1마리로 양이 잡아먹히지 않지만, 이후에 갈 수 있는 아직 방문하지 않은 모든 노드(2, 3, 6, 8번)에는 늑대가 있습니다. 이어서 늑대가 있는 노드로 이동한다면(예를 들어 바로 6번 노드로 이동한다면) 양 2마리, 늑대 2마리가 되어 양이 모두 잡아먹힙니다. 여기서는 0번, 1번 노드를 방문하여 양을 2마리 모은 후, 8번 노드로 이동한 후(양 2마리 늑대 1마리) 이어서 7번, 9번 노드를 방문하면 양 4마리 늑대 1마리가 됩니다. 이제 4번, 6번 노드로 이동하면 양 4마리, 늑대 3마리가 되며, 이제 5번 노드로 이동할 수 있게 됩니다. 따라서 양을 최대 5마리 모을 수 있습니다. 각 노드에 있는 양 또는 늑대에 대한 정보가 담긴 배열 info, 2진 트리의 각 노드들의 연결 관계를 담은 2차원 배열 edges가 매개변수로 주어질 때, 문제에 제시된 조건에 따라 각 노드를 방문하면서 모을 수 있는 양은 최대 몇 마리인지 return 하도록 solution 함수를 완성해주세요. 제한사항 2 ≤ info의 길이 ≤ 17 info의 원소는 0 또는 1 입니다. info[i]는 i번 노드에 있는 양 또는 늑대를 나타냅니다. 0은 양, 1은 늑대를 의미합니다. info[0]의 값은 항상 0입니다. 즉, 0번 노드(루트 노드)에는 항상 양이 있습니다. edges의 세로(행) 길이 = info의 길이 - 1 edges의 가로(열) 길이 = 2 edges의 각 행은 [부모 노드 번호, 자식 노드 번호] 형태로, 서로 연결된 두 노드를 나타냅니다. 동일한 간선에 대한 정보가 중복해서 주어지지 않습니다. 항상 하나의 이진 트리 형태로 입력이 주어지며, 잘못된 데이터가 주어지는 경우는 없습니다. 0번 노드는 항상 루트 노드입니다. 입출력 예 info edges result [0,0,1,1,1,0,1,0,1,0,1,1] [[0,1],[1,2],[1,4],[0,8],[8,7],[9,10],[9,11],[4,3],[6,5],[4,6],[8,9]] 5 [0,1,0,1,1,0,1,0,0,1,0] [[0,1],[0,2],[1,3],[1,4],[2,5],[2,6],[3,7],[4,8],[6,9],[9,10]] 5 입출력 예 설명 입출력 예 #1 문제의 예시와 같습니다. 입출력 예 #2 주어진 입력은 다음 그림과 같습니다. 0번 - 2번 - 5번 - 1번 - 4번 - 8번 - 3번 - 7번 노드 순으로 이동하면 양 5마리 늑대 3마리가 됩니다. 여기서 6번, 9번 노드로 이동하면 양 5마리, 늑대 5마리가 되어 양이 모두 잡아먹히게 됩니다. 따라서 늑대에게 잡아먹히지 않도록 하면서 최대로 모을 수 있는 양은 5마리입니다. 제한시간 안내 정확성 테스트 : 10초",normal,Array
372,"문제 설명 카카오배 양궁대회가 열렸습니다. 라이언은 저번 카카오배 양궁대회 우승자이고 이번 대회에도 결승전까지 올라왔습니다. 결승전 상대는 어피치입니다. 카카오배 양궁대회 운영위원회는 한 선수의 연속 우승보다는 다양한 선수들이 양궁대회에서 우승하기를 원합니다. 따라서, 양궁대회 운영위원회는 결승전 규칙을 전 대회 우승자인 라이언에게 불리하게 다음과 같이 정했습니다. 어피치가 화살 n발을 다 쏜 후에 라이언이 화살 n발을 쏩니다. 점수를 계산합니다. 과녁판은 아래 사진처럼 생겼으며 가장 작은 원의 과녁 점수는 10점이고 가장 큰 원의 바깥쪽은 과녁 점수가 0점입니다. 만약, k(k는 1~10사이의 자연수)점을 어피치가 a발을 맞혔고 라이언이 b발을 맞혔을 경우 더 많은 화살을 k점에 맞힌 선수가 k 점을 가져갑니다. 단, a = b일 경우는 어피치가 k점을 가져갑니다. k점을 여러 발 맞혀도 k점 보다 많은 점수를 가져가는 게 아니고 k점만 가져가는 것을 유의하세요. 또한 a = b = 0 인 경우, 즉, 라이언과 어피치 모두 k점에 단 하나의 화살도 맞히지 못한 경우는 어느 누구도 k점을 가져가지 않습니다. 예를 들어, 어피치가 10점을 2발 맞혔고 라이언도 10점을 2발 맞혔을 경우 어피치가 10점을 가져갑니다. 다른 예로, 어피치가 10점을 0발 맞혔고 라이언이 10점을 2발 맞혔을 경우 라이언이 10점을 가져갑니다. 모든 과녁 점수에 대하여 각 선수의 최종 점수를 계산합니다. 최종 점수가 더 높은 선수를 우승자로 결정합니다. 단, 최종 점수가 같을 경우 어피치를 우승자로 결정합니다. 현재 상황은 어피치가 화살 n발을 다 쏜 후이고 라이언이 화살을 쏠 차례입니다. 라이언은 어피치를 가장 큰 점수 차이로 이기기 위해서 n발의 화살을 어떤 과녁 점수에 맞혀야 하는지를 구하려고 합니다. 화살의 개수를 담은 자연수 n, 어피치가 맞힌 과녁 점수의 개수를 10점부터 0점까지 순서대로 담은 정수 배열 info가 매개변수로 주어집니다. 이때, 라이언이 가장 큰 점수 차이로 우승하기 위해 n발의 화살을 어떤 과녁 점수에 맞혀야 하는지를 10점부터 0점까지 순서대로 정수 배열에 담아 return 하도록 solution 함수를 완성해 주세요. 만약, 라이언이 우승할 수 없는 경우(무조건 지거나 비기는 경우)는 [-1]을 return 해주세요. 제한사항 1 ≤ n ≤ 10 info의 길이 = 11 0 ≤ info의 원소 ≤ n info의 원소 총합 = n info의 i번째 원소는 과녁의 10 - i 점을 맞힌 화살 개수입니다. ( i는 0~10 사이의 정수입니다.) 라이언이 우승할 방법이 있는 경우, return 할 정수 배열의 길이는 11입니다. 0 ≤ return할 정수 배열의 원소 ≤ n return할 정수 배열의 원소 총합 = n (꼭 n발을 다 쏴야 합니다.) return할 정수 배열의 i번째 원소는 과녁의 10 - i 점을 맞힌 화살 개수입니다. ( i는 0~10 사이의 정수입니다.) 라이언이 가장 큰 점수 차이로 우승할 수 있는 방법이 여러 가지 일 경우, 가장 낮은 점수를 더 많이 맞힌 경우를 return 해주세요. 가장 낮은 점수를 맞힌 개수가 같을 경우 계속해서 그다음으로 낮은 점수를 더 많이 맞힌 경우를 return 해주세요. 예를 들어, [2,3,1,0,0,0,0,1,3,0,0]과 [2,1,0,2,0,0,0,2,3,0,0]를 비교하면 [2,1,0,2,0,0,0,2,3,0,0]를 return 해야 합니다. 다른 예로, [0,0,2,3,4,1,0,0,0,0,0]과 [9,0,0,0,0,0,0,0,1,0,0]를 비교하면[9,0,0,0,0,0,0,0,1,0,0]를 return 해야 합니다. 라이언이 우승할 방법이 없는 경우, return 할 정수 배열의 길이는 1입니다. 라이언이 어떻게 화살을 쏘든 라이언의 점수가 어피치의 점수보다 낮거나 같으면 [-1]을 return 해야 합니다. 입출력 예 n info result 5 [2,1,1,1,0,0,0,0,0,0,0] [0,2,2,0,1,0,0,0,0,0,0] 1 [1,0,0,0,0,0,0,0,0,0,0] [-1] 9 [0,0,1,2,0,1,1,1,1,1,1] [1,1,2,0,1,2,2,0,0,0,0] 10 [0,0,0,0,0,0,0,0,3,4,3] [1,1,1,1,1,1,1,1,0,0,2] 입출력 예 설명 입출력 예 #1 어피치와 라이언이 아래와 같이 화살을 맞힐 경우, 과녁 점수 어피치가 맞힌 화살 개수 라이언이 맞힌 화살 개수 결과 10 2 3 라이언이 10점 획득 9 1 2 라이언이 9점 획득 8 1 0 어피치가 8점 획득 7 1 0 어피치가 7점 획득 6 0 0 5 0 0 4 0 0 3 0 0 2 0 0 1 0 0 0 0 0 어피치의 최종 점수는 15점, 라이언의 최종 점수는 19점입니다. 4점 차이로 라이언이 우승합니다. 하지만, 라이언이 아래와 같이 화살을 맞힐 경우 더 큰 점수 차로 우승할 수 있습니다. 과녁 점수 어피치가 맞힌 화살 개수 라이언이 맞힌 화살 개수 결과 10 2 0 어피치가 10점 획득 9 1 2 라이언이 9점 획득 8 1 2 라이언이 8점 획득 7 1 0 어피치가 7점 획득 6 0 1 라이언이 6점 획득 5 0 0 4 0 0 3 0 0 2 0 0 1 0 0 0 0 0 어피치의 최종 점수는 17점, 라이언의 최종 점수는 23점입니다. 6점 차이로 라이언이 우승합니다. 따라서 [0,2,2,0,1,0,0,0,0,0,0]을 return 해야 합니다. 입출력 예 #2 라이언이 10점을 맞혀도 어피치가 10점을 가져가게 됩니다. 따라서, 라이언은 우승할 수 없기 때문에 [-1]을 return 해야 합니다. 입출력 예 #3 어피치와 라이언이 아래와 같이 화살을 맞힐 경우, 과녁 점수 어피치가 맞힌 화살 개수 라이언이 맞힌 화살 개수 결과 10 0 1 라이언이 10점 획득 9 0 1 라이언이 9점 획득 8 1 2 라이언이 8점 획득 7 2 3 라이언이 7점 획득 6 0 0 5 1 2 라이언이 5점 획득 4 1 0 어피치가 4점 획득 3 1 0 어피치가 3점 획득 2 1 0 어피치가 2점 획득 1 1 0 어피치가 1점 획득 0 1 0 어피치가 0점 획득 어피치의 최종 점수는 10점, 라이언의 최종 점수는 39점입니다. 29점 차이로 라이언이 우승합니다. 하지만 라이언이 아래와 같이 화살을 맞힐 경우, 과녁 점수 어피치가 맞힌 화살 개수 라이언이 맞힌 화살 개수 결과 10 0 1 라이언이 10점 획득 9 0 1 라이언이 9점 획득 8 1 2 라이언이 8점 획득 7 2 0 어피치가 7점 획득 6 0 1 라이언이 6점 획득 5 1 2 라이언이 5점 획득 4 1 2 라이언이 4점 획득 3 1 0 어피치가 3점 획득 2 1 0 어피치가 2점 획득 1 1 0 어피치가 1점 획득 0 1 0 어피치가 0점 획득 어피치의 최종 점수는 13점, 라이언의 최종 점수는 42점입니다. 이 경우도 29점 차이로 라이언이 우승합니다. 하지만, 첫 번째 경우와 두 번째 경우를 비교했을 때, 두 번째 경우가 두 경우 중 가장 낮은 점수인 4점을 더 많이 맞혔기 때문에 [1,1,2,3,0,2,0,0,0,0,0]이 아닌 [1,1,2,0,1,2,2,0,0,0,0]을 return 해야 합니다. 입출력 예 #4 가장 큰 점수 차이로 이기는 경우 중에서 가장 낮은 점수를 가장 많이 맞힌, 10~3점을 한 발씩 맞히고 나머지 두 발을 0점에 맞히는 경우인 [1,1,1,1,1,1,1,1,0,0,2]를 return 해야 합니다. 제한시간 안내 정확성 테스트 : 10초",normal,Array
373,"문제 설명 주차장의 요금표와 차량이 들어오고(입차) 나간(출차) 기록이 주어졌을 때, 차량별로 주차 요금을 계산하려고 합니다. 아래는 하나의 예시를 나타냅니다. 요금표 기본 시간(분) 기본 요금(원) 단위 시간(분) 단위 요금(원) 180 5000 10 600 입/출차 기록 시각(시:분) 차량 번호 내역 05:34 5961 입차 06:00 0000 입차 06:34 0000 출차 07:59 5961 출차 07:59 0148 입차 18:59 0000 입차 19:09 0148 출차 22:59 5961 입차 23:00 5961 출차 자동차별 주차 요금 차량 번호 누적 주차 시간(분) 주차 요금(원) 0000 34 + 300 = 334 5000 + ⌈(334 - 180) / 10⌉ x 600 = 14600 0148 670 5000 +⌈(670 - 180) / 10⌉x 600 = 34400 5961 145 + 1 = 146 5000 어떤 차량이 입차된 후에 출차된 내역이 없다면, 23:59에 출차된 것으로 간주합니다. 0000번 차량은 18:59에 입차된 이후, 출차된 내역이 없습니다. 따라서, 23:59에 출차된 것으로 간주합니다. 00:00부터 23:59까지의 입/출차 내역을 바탕으로 차량별 누적 주차 시간을 계산하여 요금을 일괄로 정산합니다. 누적 주차 시간이 기본 시간이하라면, 기본 요금을 청구합니다. 누적 주차 시간이 기본 시간을 초과하면, 기본 요금에 더해서, 초과한 시간에 대해서 단위 시간 마다 단위 요금을 청구합니다. 초과한 시간이 단위 시간으로 나누어 떨어지지 않으면, 올림합니다. ⌈a⌉ : a보다 작지 않은 최소의 정수를 의미합니다. 즉, 올림을 의미합니다. 주차 요금을 나타내는 정수 배열 fees, 자동차의 입/출차 내역을 나타내는 문자열 배열 records가 매개변수로 주어집니다. 차량 번호가 작은 자동차부터 청구할 주차 요금을 차례대로 정수 배열에 담아서 return 하도록 solution 함수를 완성해주세요. 제한사항 fees의 길이 = 4 fees[0] = 기본 시간(분) 1 ≤ fees[0] ≤ 1,439 fees[1] = 기본 요금(원) 0 ≤ fees[1] ≤ 100,000 fees[2] = 단위 시간(분) 1 ≤ fees[2] ≤ 1,439 fees[3] = 단위 요금(원) 1 ≤ fees[3] ≤ 10,000 1 ≤ records의 길이 ≤ 1,000 records의 각 원소는 ""시각 차량번호 내역"" 형식의 문자열입니다. 시각, 차량번호, 내역은 하나의 공백으로 구분되어 있습니다. 시각은 차량이 입차되거나 출차된 시각을 나타내며, HH:MM 형식의 길이 5인 문자열입니다. HH:MM은 00:00부터 23:59까지 주어집니다. 잘못된 시각(""25:22"", ""09:65"" 등)은 입력으로 주어지지 않습니다. 차량번호는 자동차를 구분하기 위한, `0'~'9'로 구성된 길이 4인 문자열입니다. 내역은 길이 2 또는 3인 문자열로, IN 또는 OUT입니다. IN은 입차를, OUT은 출차를 의미합니다. records의 원소들은 시각을 기준으로 오름차순으로 정렬되어 주어집니다. records는 하루 동안의 입/출차된 기록만 담고 있으며, 입차된 차량이 다음날 출차되는 경우는 입력으로 주어지지 않습니다. 같은 시각에, 같은 차량번호의 내역이 2번 이상 나타내지 않습니다. 마지막 시각(23:59)에 입차되는 경우는 입력으로 주어지지 않습니다. 아래의 예를 포함하여, 잘못된 입력은 주어지지 않습니다. 주차장에 없는 차량이 출차되는 경우 주차장에 이미 있는 차량(차량번호가 같은 차량)이 다시 입차되는 경우 입출력 예 fees records result [180, 5000, 10, 600] [""05:34 5961 IN"", ""06:00 0000 IN"", ""06:34 0000 OUT"", ""07:59 5961 OUT"", ""07:59 0148 IN"", ""18:59 0000 IN"", ""19:09 0148 OUT"", ""22:59 5961 IN"", ""23:00 5961 OUT""] [14600, 34400, 5000] [120, 0, 60, 591] [""16:00 3961 IN"",""16:00 0202 IN"",""18:00 3961 OUT"",""18:00 0202 OUT"",""23:58 3961 IN""] [0, 591] [1, 461, 1, 10] [""00:00 1234 IN""] [14841] 입출력 예 설명 입출력 예 #1 문제 예시와 같습니다. 입출력 예 #2 요금표 기본 시간(분) 기본 요금(원) 단위 시간(분) 단위 요금(원) 120 0 60 591 입/출차 기록 시각(시:분) 차량 번호 내역 16:00 3961 입차 16:00 0202 입차 18:00 3961 출차 18:00 0202 출차 23:58 3961 입차 자동차별 주차 요금 차량 번호 누적 주차 시간(분) 주차 요금(원) 0202 120 0 3961 120 + 1 = 121 0 +⌈(121 - 120) / 60⌉x 591 = 591 3961번 차량은 2번째 입차된 후에는 출차된 내역이 없으므로, 23:59에 출차되었다고 간주합니다. 입출력 예 #3 요금표 기본 시간(분) 기본 요금(원) 단위 시간(분) 단위 요금(원) 1 461 1 10 입/출차 기록 시각(시:분) 차량 번호 내역 00:00 1234 입차 자동차별 주차 요금 차량 번호 누적 주차 시간(분) 주차 요금(원) 1234 1439 461 +⌈(1439 - 1) / 1⌉x 10 = 14841 1234번 차량은 출차 내역이 없으므로, 23:59에 출차되었다고 간주합니다. ​ 제한시간 안내 정확성 테스트 : 10초",normal,Array
374,"문제 설명 양의 정수 n이 주어집니다. 이 숫자를 k진수로 바꿨을 때, 변환된 수 안에 아래 조건에 맞는 소수(Prime number)가 몇 개인지 알아보려 합니다. 0P0처럼 소수 양쪽에 0이 있는 경우 P0처럼 소수 오른쪽에만 0이 있고 왼쪽에는 아무것도 없는 경우 0P처럼 소수 왼쪽에만 0이 있고 오른쪽에는 아무것도 없는 경우 P처럼 소수 양쪽에 아무것도 없는 경우 단, P는 각 자릿수에 0을 포함하지 않는 소수입니다. 예를 들어, 101은 P가 될 수 없습니다. 예를 들어, 437674을 3진수로 바꾸면 211020101011입니다. 여기서 찾을 수 있는 조건에 맞는 소수는 왼쪽부터 순서대로 211, 2, 11이 있으며, 총 3개입니다. (211, 2, 11을 k진법으로 보았을 때가 아닌, 10진법으로 보았을 때 소수여야 한다는 점에 주의합니다.) 211은 P0 형태에서 찾을 수 있으며, 2는 0P0에서, 11은 0P에서 찾을 수 있습니다. 정수 n과 k가 매개변수로 주어집니다. n을 k진수로 바꿨을 때, 변환된 수 안에서 찾을 수 있는 위 조건에 맞는 소수의 개수를 return 하도록 solution 함수를 완성해 주세요. 제한사항 1 ≤ n ≤ 1,000,000 3 ≤ k ≤ 10 입출력 예 n k result 437674 3 3 110011 10 2 입출력 예 설명 입출력 예 #1 문제 예시와 같습니다. 입출력 예 #2 110011을 10진수로 바꾸면 110011입니다. 여기서 찾을 수 있는 조건에 맞는 소수는 11, 11 2개입니다. 이와 같이, 중복되는 소수를 발견하더라도 모두 따로 세어야 합니다. 문제가 잘 안풀린다면😢 힌트가 필요한가요? [코딩테스트 연습 힌트 모음집]으로 오세요! → 클릭",normal,Math
375,"문제 설명 신입사원 무지는 게시판 불량 이용자를 신고하고 처리 결과를 메일로 발송하는 시스템을 개발하려 합니다. 무지가 개발하려는 시스템은 다음과 같습니다. 각 유저는 한 번에 한 명의 유저를 신고할 수 있습니다. 신고 횟수에 제한은 없습니다. 서로 다른 유저를 계속해서 신고할 수 있습니다. 한 유저를 여러 번 신고할 수도 있지만, 동일한 유저에 대한 신고 횟수는 1회로 처리됩니다. k번 이상 신고된 유저는 게시판 이용이 정지되며, 해당 유저를 신고한 모든 유저에게 정지 사실을 메일로 발송합니다. 유저가 신고한 모든 내용을 취합하여 마지막에 한꺼번에 게시판 이용 정지를 시키면서 정지 메일을 발송합니다. 다음은 전체 유저 목록이 [""muzi"", ""frodo"", ""apeach"", ""neo""]이고, k = 2(즉, 2번 이상 신고당하면 이용 정지)인 경우의 예시입니다. 유저 ID 유저가 신고한 ID 설명 ""muzi"" ""frodo"" ""muzi""가 ""frodo""를 신고했습니다. ""apeach"" ""frodo"" ""apeach""가 ""frodo""를 신고했습니다. ""frodo"" ""neo"" ""frodo""가 ""neo""를 신고했습니다. ""muzi"" ""neo"" ""muzi""가 ""neo""를 신고했습니다. ""apeach"" ""muzi"" ""apeach""가 ""muzi""를 신고했습니다. 각 유저별로 신고당한 횟수는 다음과 같습니다. 유저 ID 신고당한 횟수 ""muzi"" 1 ""frodo"" 2 ""apeach"" 0 ""neo"" 2 위 예시에서는 2번 이상 신고당한 ""frodo""와 ""neo""의 게시판 이용이 정지됩니다. 이때, 각 유저별로 신고한 아이디와 정지된 아이디를 정리하면 다음과 같습니다. 유저 ID 유저가 신고한 ID 정지된 ID ""muzi"" [""frodo"", ""neo""] [""frodo"", ""neo""] ""frodo"" [""neo""] [""neo""] ""apeach"" [""muzi"", ""frodo""] [""frodo""] ""neo"" 없음 없음 따라서 ""muzi""는 처리 결과 메일을 2회, ""frodo""와 ""apeach""는 각각 처리 결과 메일을 1회 받게 됩니다. 이용자의 ID가 담긴 문자열 배열 id_list, 각 이용자가 신고한 이용자의 ID 정보가 담긴 문자열 배열 report, 정지 기준이 되는 신고 횟수 k가 매개변수로 주어질 때, 각 유저별로 처리 결과 메일을 받은 횟수를 배열에 담아 return 하도록 solution 함수를 완성해주세요. 제한사항 2 ≤ id_list의 길이 ≤ 1,000 1 ≤ id_list의 원소 길이 ≤ 10 id_list의 원소는 이용자의 id를 나타내는 문자열이며 알파벳 소문자로만 이루어져 있습니다. id_list에는 같은 아이디가 중복해서 들어있지 않습니다. 1 ≤ report의 길이 ≤ 200,000 3 ≤ report의 원소 길이 ≤ 21 report의 원소는 ""이용자id 신고한id""형태의 문자열입니다. 예를 들어 ""muzi frodo""의 경우 ""muzi""가 ""frodo""를 신고했다는 의미입니다. id는 알파벳 소문자로만 이루어져 있습니다. 이용자id와 신고한id는 공백(스페이스)하나로 구분되어 있습니다. 자기 자신을 신고하는 경우는 없습니다. 1 ≤ k ≤ 200, k는 자연수입니다. return 하는 배열은 id_list에 담긴 id 순서대로 각 유저가 받은 결과 메일 수를 담으면 됩니다. 입출력 예 id_list report k result [""muzi"", ""frodo"", ""apeach"", ""neo""] [""muzi frodo"",""apeach frodo"",""frodo neo"",""muzi neo"",""apeach muzi""] 2 [2,1,1,0] [""con"", ""ryan""] [""ryan con"", ""ryan con"", ""ryan con"", ""ryan con""] 3 [0,0] 입출력 예 설명 입출력 예 #1 문제의 예시와 같습니다. 입출력 예 #2 ""ryan""이 ""con""을 4번 신고했으나, 주어진 조건에 따라 한 유저가 같은 유저를 여러 번 신고한 경우는 신고 횟수 1회로 처리합니다. 따라서 ""con""은 1회 신고당했습니다. 3번 이상 신고당한 이용자는 없으며, ""con""과 ""ryan""은 결과 메일을 받지 않습니다. 따라서 [0, 0]을 return 합니다. 제한시간 안내 정확성 테스트 : 10초",easy,Array
376,"XX게임에는 피로도 시스템(0 이상의 정수로 표현합니다)이 있으며, 일정 피로도를 사용해서 던전을 탐험할 수 있습니다. 이때, 각 던전마다 탐험을 시작하기 위해 필요한 ""최소 필요 피로도""와 던전 탐험을 마쳤을 때 소모되는 ""소모 피로도""가 있습니다. ""최소 필요 피로도""는 해당 던전을 탐험하기 위해 가지고 있어야 하는 최소한의 피로도를 나타내며, ""소모 피로도""는 던전을 탐험한 후 소모되는 피로도를 나타냅니다. 예를 들어 ""최소 필요 피로도""가 80, ""소모 피로도""가 20인 던전을 탐험하기 위해서는 유저의 현재 남은 피로도는 80 이상 이어야 하며, 던전을 탐험한 후에는 피로도 20이 소모됩니다. 이 게임에는 하루에 한 번씩 탐험할 수 있는 던전이 여러개 있는데, 한 유저가 오늘 이 던전들을 최대한 많이 탐험하려 합니다. 유저의 현재 피로도 k와 각 던전별 ""최소 필요 피로도"", ""소모 피로도""가 담긴 2차원 배열 dungeons 가 매개변수로 주어질 때, 유저가 탐험할수 있는 최대 던전 수를 return 하도록 solution 함수를 완성해주세요. 제한사항 k는 1 이상 5,000 이하인 자연수입니다. dungeons의 세로(행) 길이(즉, 던전의 개수)는 1 이상 8 이하입니다. dungeons의 가로(열) 길이는 2 입니다. dungeons의 각 행은 각 던전의 [""최소 필요 피로도"", ""소모 피로도""] 입니다. ""최소 필요 피로도""는 항상 ""소모 피로도""보다 크거나 같습니다. ""최소 필요 피로도""와 ""소모 피로도""는 1 이상 1,000 이하인 자연수입니다. 서로 다른 던전의 [""최소 필요 피로도"", ""소모 피로도""]가 서로 같을 수 있습니다. 입출력 예 k dungeons result 80 [[80,20],[50,40],[30,10]] 3 입출력 예 설명 현재 피로도는 80입니다. 만약, 첫 번째 → 두 번째 → 세 번째 던전 순서로 탐험한다면 현재 피로도는 80이며, 첫 번째 던전을 돌기위해 필요한 ""최소 필요 피로도"" 또한 80이므로, 첫 번째 던전을 탐험할 수 있습니다. 첫 번째 던전의 ""소모 피로도""는 20이므로, 던전을 탐험한 후 남은 피로도는 60입니다. 남은 피로도는 60이며, 두 번째 던전을 돌기위해 필요한 ""최소 필요 피로도""는 50이므로, 두 번째 던전을 탐험할 수 있습니다. 두 번째 던전의 ""소모 피로도""는 40이므로, 던전을 탐험한 후 남은 피로도는 20입니다. 남은 피로도는 20이며, 세 번째 던전을 돌기위해 필요한 ""최소 필요 피로도""는 30입니다. 따라서 세 번째 던전은 탐험할 수 없습니다. 만약, 첫 번째 → 세 번째 → 두 번째 던전 순서로 탐험한다면 현재 피로도는 80이며, 첫 번째 던전을 돌기위해 필요한 ""최소 필요 피로도"" 또한 80이므로, 첫 번째 던전을 탐험할 수 있습니다. 첫 번째 던전의 ""소모 피로도""는 20이므로, 던전을 탐험한 후 남은 피로도는 60입니다. 남은 피로도는 60이며, 세 번째 던전을 돌기위해 필요한 ""최소 필요 피로도""는 30이므로, 세 번째 던전을 탐험할 수 있습니다. 세 번째 던전의 ""소모 피로도""는 10이므로, 던전을 탐험한 후 남은 피로도는 50입니다. 남은 피로도는 50이며, 두 번째 던전을 돌기위해 필요한 ""최소 필요 피로도""는 50이므로, 두 번째 던전을 탐험할 수 있습니다. 두 번째 던전의 ""소모 피로도""는 40이므로, 던전을 탐험한 후 남은 피로도는 10입니다. 따라서 이 경우 세 던전을 모두 탐험할 수 있으며, 유저가 탐험할 수 있는 최대 던전 수는 3입니다. ※ 공지 - 2022년 2월 25일 테스트케이스가 추가되었습니다.",normal,Array
377,"다음과 같은 다각형 모양 지형에서 캐릭터가 아이템을 줍기 위해 이동하려 합니다. 지형은 각 변이 x축, y축과 평행한 직사각형이 겹쳐진 형태로 표현하며, 캐릭터는 이 다각형의 둘레(굵은 선)를 따라서 이동합니다. 만약 직사각형을 겹친 후 다음과 같이 중앙에 빈 공간이 생기는 경우, 다각형의 가장 바깥쪽 테두리가 캐릭터의 이동 경로가 됩니다. 단, 서로 다른 두 직사각형의 x축 좌표 또는 y축 좌표가 같은 경우는 없습니다. 즉, 위 그림처럼 서로 다른 두 직사각형이 꼭짓점에서 만나거나, 변이 겹치는 경우 등은 없습니다. 다음 그림과 같이 지형이 2개 이상으로 분리된 경우도 없습니다. 한 직사각형이 다른 직사각형 안에 완전히 포함되는 경우 또한 없습니다. 지형을 나타내는 직사각형이 담긴 2차원 배열 rectangle, 초기 캐릭터의 위치 characterX, characterY, 아이템의 위치 itemX, itemY가 solution 함수의 매개변수로 주어질 때, 캐릭터가 아이템을 줍기 위해 이동해야 하는 가장 짧은 거리를 return 하도록 solution 함수를 완성해주세요. 제한사항 rectangle의 세로(행) 길이는 1 이상 4 이하입니다. rectangle의 원소는 각 직사각형의 [좌측 하단 x, 좌측 하단 y, 우측 상단 x, 우측 상단 y] 좌표 형태입니다. 직사각형을 나타내는 모든 좌표값은 1 이상 50 이하인 자연수입니다. 서로 다른 두 직사각형의 x축 좌표, 혹은 y축 좌표가 같은 경우는 없습니다. 문제에 주어진 조건에 맞는 직사각형만 입력으로 주어집니다. charcterX, charcterY는 1 이상 50 이하인 자연수입니다. 지형을 나타내는 다각형 테두리 위의 한 점이 주어집니다. itemX, itemY는 1 이상 50 이하인 자연수입니다. 지형을 나타내는 다각형 테두리 위의 한 점이 주어집니다. 캐릭터와 아이템의 처음 위치가 같은 경우는 없습니다. 전체 배점의 50%는 직사각형이 1개인 경우입니다. 전체 배점의 25%는 직사각형이 2개인 경우입니다. 전체 배점의 25%는 직사각형이 3개 또는 4개인 경우입니다. 입출력 예 rectangle characterX characterY itemX itemY result [[1,1,7,4],[3,2,5,5],[4,3,6,9],[2,6,8,8]] 1 3 7 8 17 [[1,1,8,4],[2,2,4,9],[3,6,9,8],[6,3,7,7]] 9 7 6 1 11 [[1,1,5,7]] 1 1 4 7 9 [[2,1,7,5],[6,4,10,10]] 3 1 7 10 15 [[2,2,5,5],[1,3,6,4],[3,1,4,6]] 1 4 6 3 10 입출력 예 설명 입출력 예 #1 캐릭터 위치는 (1, 3)이며, 아이템 위치는 (7, 8)입니다. 위 그림과 같이 굵은 선을 따라 이동하는 경로가 가장 짧습니다. 입출력 예 #2 캐릭터 위치는 (9, 7)이며, 아이템 위치는 (6, 1)입니다. 위 그림과 같이 굵은 선을 따라 이동하는 경로가 가장 짧습니다. 입출력 예 #3 캐릭터 위치는 (1, 1)이며, 아이템 위치는 (4, 7)입니다. 위 그림과 같이 굵은 선을 따라 이동하는 경로가 가장 짧습니다. 입출력 예 #4, #5 설명 생략",normal,Array
378,"길이가 n인 배열 a가 주어집니다. 당신은 여기에 q개의 쿼리를 순차적으로 날려 n개의 0으로 이루어진 배열을 a로 만들고자 합니다. query(l, r, x)는 다음 수도코드와 같은 역할을 합니다. (0 ≤ l ≤ r < n, 1 ≤ x ≤ 105 ) for i = l, l+1, ..., r: a[i] := max(a[i], x) q개의 쿼리를 통해 a를 만드는 방법은 여러 가지가 있을 수 있습니다. 예를 들어 a = [1,2], q = 2라면 다음 4가지 방법으로 a를 만들 수 있습니다. query(0, 0, 1), query(1, 1, 2) query(1, 1, 2), query(0, 0, 1) query(0, 1, 1), query(1, 1, 2) query(1, 1, 2), query(0, 1, 1) 정수 q와 정수 배열 a가 매개변수로 주어집니다. q개의 쿼리를 통해 a를 만드는 방법의 가짓수를 998,244,353으로 나눈 나머지를 return 하도록 solution 함수를 완성해주세요. 제한사항 1 ≤ q ≤ 50 1 ≤ a의 길이 ≤ 50 1 ≤ a의 모든 원소 ≤ 105 입출력 예 q a result 2 [1,2] 4 3 [3] 19 5 [1,4,4] 157740 50 [1,6,5,2,4] 61953538 입출력 예 설명 입출력 예 #1 문제 예시와 같습니다. 입출력 예 #2 a를 만들기 위해 날릴 수 있는 쿼리는 오직 query(0, 0, 1), query(0, 0, 2), query(0, 0, 3) 뿐입니다. 33 = 27가지 경우의 수 중에서 query(0, 0, 3)을 사용하지 않는 8가지 경우를 걸러내면 답은 27 - 8 = 19가 됩니다. 따라서, 19를 return 해야 합니다. 입출력 예 #3 a를 만들 수 있는 경우의 수가 157,740가지 이므로, 157,740을 return 해야 합니다. 입출력 예 #4 설명 생략",hard,Array
379,"n행 m열의 격자가 있습니다. 격자의 각 행은 0, 1, ..., n-1번의 번호, 그리고 각 열은 0, 1, ..., m-1번의 번호가 순서대로 매겨져 있습니다. 당신은 이 격자에 공을 하나 두고, 그 공에 다음과 같은 쿼리들을 날리고자 합니다. 열 번호가 감소하는 방향으로 dx칸 이동하는 쿼리 (query(0, dx)) 열 번호가 증가하는 방향으로 dx칸 이동하는 쿼리 (query(1, dx)) 행 번호가 감소하는 방향으로 dx칸 이동하는 쿼리 (query(2, dx)) 행 번호가 증가하는 방향으로 dx칸 이동하는 쿼리 (query(3, dx)) 단, 공은 격자 바깥으로 이동할 수 없으며, 목적지가 격자 바깥인 경우 공은 이동하다가 더 이상 이동할 수 없을 때 멈추게 됩니다. 예를 들어, 5행 × 4열 크기의 격자 내의 공이 3행 2열에 있을 때 query(3, 10) 쿼리를 받은 경우 공은 4행 2열에서 멈추게 됩니다. (격자의 크기가 5행 × 4열이므로, 0~4번 행과 0~3번 열로 격자가 구성되기 때문입니다.) 격자의 행의 개수 n, 열의 개수 m, 정수 x와 y, 그리고 쿼리들의 목록을 나타내는 2차원 정수 배열 queries가 매개변수로 주어집니다. n × m개의 가능한 시작점에 대해서 해당 시작점에 공을 두고 queries 내의 쿼리들을 순서대로 시뮬레이션했을 때, x행 y열에 도착하는 시작점의 개수를 return 하도록 solution 함수를 완성해주세요. 제한사항 1 ≤ n ≤ 109 1 ≤ m ≤ 109 0 ≤ x < n 0 ≤ y < m 1 ≤ queries의 행의 개수 ≤ 200,000 queries의 각 행은 [command,dx] 두 정수로 이루어져 있습니다. 0 ≤ command ≤ 3 1 ≤ dx ≤ 109 이는 query(command, dx)를 의미합니다. 입출력 예 n m x y queries result 2 2 0 0 [[2,1],[0,1],[1,1],[0,1],[2,1]] 4 2 5 0 1 [[3,1],[2,2],[1,1],[2,3],[0,1],[2,1]] 2 입출력 예 설명 입출력 예 #1 다음 애니메이션은 4개의 가능한 시작점에 대한 모든 시뮬레이션을 나타낸 것입니다. 어떤 곳에서 출발하더라도 항상 0행 0열에 도착하기 때문에, 4를 return 해야 합니다. 입출력 예 #2 다음 애니메이션은 10개의 가능한 시작점에 대한 모든 시뮬레이션을 나타낸 것입니다. 0행 1열, 1행 1열에서 출발했을 때만 0행 1열에 도착하므로, 2를 return 해야 합니다.",normal,Array
380,"정수 n, left, right가 주어집니다. 다음 과정을 거쳐서 1차원 배열을 만들고자 합니다. n행 n열 크기의 비어있는 2차원 배열을 만듭니다. i = 1, 2, 3, ..., n에 대해서, 다음 과정을 반복합니다. 1행 1열부터 i행 i열까지의 영역 내의 모든 빈 칸을 숫자 i로 채웁니다. 1행, 2행, ..., n행을 잘라내어 모두 이어붙인 새로운 1차원 배열을 만듭니다. 새로운 1차원 배열을 arr이라 할 때, arr[left], arr[left+1], ..., arr[right]만 남기고 나머지는 지웁니다. 정수 n, left, right가 매개변수로 주어집니다. 주어진 과정대로 만들어진 1차원 배열을 return 하도록 solution 함수를 완성해주세요. 제한사항 1 ≤ n ≤ 107 0 ≤ left ≤ right < n2 right - left < 105 입출력 예 n left right result 3 2 5 [3,2,2,3] 4 7 14 [4,3,3,3,4,4,4,4] 입출력 예 설명 입출력 예 #1 다음 애니메이션은 주어진 과정대로 1차원 배열을 만드는 과정을 나타낸 것입니다. 입출력 예 #2 다음 애니메이션은 주어진 과정대로 1차원 배열을 만드는 과정을 나타낸 것입니다.",normal,Array
381,"자연수 n이 매개변수로 주어집니다. n을 x로 나눈 나머지가 1이 되도록 하는 가장 작은 자연수 x를 return 하도록 solution 함수를 완성해주세요. 답이 항상 존재함은 증명될 수 있습니다. 제한사항 3 ≤ n ≤ 1,000,000 입출력 예 n result 10 3 12 11 입출력 예 설명 입출력 예 #1 10을 3으로 나눈 나머지가 1이고, 3보다 작은 자연수 중에서 문제의 조건을 만족하는 수가 없으므로, 3을 return 해야 합니다. 입출력 예 #2 12를 11로 나눈 나머지가 1이고, 11보다 작은 자연수 중에서 문제의 조건을 만족하는 수가 없으므로, 11을 return 해야 합니다.",easy,Math
382,"Ax + By + C = 0으로 표현할 수 있는 n개의 직선이 주어질 때, 이 직선의 교점 중 정수 좌표에 별을 그리려 합니다. 예를 들어, 다음과 같은 직선 5개를 2x - y + 4 = 0 -2x - y + 4 = 0 -y + 1 = 0 5x - 8y - 12 = 0 5x + 8y + 12 = 0 좌표 평면 위에 그리면 아래 그림과 같습니다. 이때, 모든 교점의 좌표는 (4, 1), (4, -4), (-4, -4), (-4, 1), (0, 4), (1.5, 1.0), (2.1, -0.19), (0, -1.5), (-2.1, -0.19), (-1.5, 1.0)입니다. 이 중 정수로만 표현되는 좌표는 (4, 1), (4, -4), (-4, -4), (-4, 1), (0, 4)입니다. 만약 정수로 표현되는 교점에 별을 그리면 다음과 같습니다. 위의 그림을 문자열로 나타낼 때, 별이 그려진 부분은 *, 빈 공간(격자선이 교차하는 지점)은 .으로 표현하면 다음과 같습니다. ""..........."" "".....*....."" ""..........."" ""..........."" "".*.......*."" ""..........."" ""..........."" ""..........."" ""..........."" "".*.......*."" ""..........."" 이때 격자판은 무한히 넓으니 모든 별을 포함하는 최소한의 크기만 나타내면 됩니다. 따라서 정답은 ""....*...."" ""........."" ""........."" ""*.......*"" ""........."" ""........."" ""........."" ""........."" ""*.......*"" 입니다. 직선 A, B, C에 대한 정보가 담긴 배열 line이 매개변수로 주어집니다. 이때 모든 별을 포함하는 최소 사각형을 return 하도록 solution 함수를 완성해주세요. 제한사항 line의 세로(행) 길이는 2 이상 1,000 이하인 자연수입니다. line의 가로(열) 길이는 3입니다. line의 각 원소는 [A, B, C] 형태입니다. A, B, C는 -100,000 이상 100,000 이하인 정수입니다. 무수히 많은 교점이 생기는 직선 쌍은 주어지지 않습니다. A = 0이면서 B = 0인 경우는 주어지지 않습니다. 정답은 1,000 * 1,000 크기 이내에서 표현됩니다. 별이 한 개 이상 그려지는 입력만 주어집니다. 입출력 예 line result [[2, -1, 4], [-2, -1, 4], [0, -1, 1], [5, -8, -12], [5, 8, 12]] [""....*...."", ""........."", ""........."", ""*.......*"", ""........."", ""........."", ""........."", ""........."", ""*.......*""] [[0, 1, -1], [1, 0, -1], [1, 0, 1]] [""*.*""] [[1, -1, 0], [2, -1, 0]] [""*""] [[1, -1, 0], [2, -1, 0], [4, -1, 0]] [""*""] 입출력 예 설명 입출력 예 #1 문제 예시와 같습니다. 입출력 예 #2 직선 y = 1, x = 1, x = -1는 다음과 같습니다. (-1, 1), (1, 1) 에서 교점이 발생합니다. 따라서 정답은 ""*.*"" 입니다. 입출력 예 #3 직선 y = x, y = 2x는 다음과 같습니다. (0, 0) 에서 교점이 발생합니다. 따라서 정답은 ""*"" 입니다. 입출력 예 #4 직선 y = x, y = 2x, y = 4x는 다음과 같습니다. (0, 0) 에서 교점이 발생합니다. 따라서 정답은 ""*"" 입니다. 참고 사항 Ax + By + E = 0 Cx + Dy + F = 0 두 직선의 교점이 유일하게 존재할 경우, 그 교점은 다음과 같습니다. 또, AD - BC = 0인 경우 두 직선은 평행 또는 일치합니다.",normal,Array
383,"n개의 송전탑이 전선을 통해 하나의 트리 형태로 연결되어 있습니다. 당신은 이 전선들 중 하나를 끊어서 현재의 전력망 네트워크를 2개로 분할하려고 합니다. 이때, 두 전력망이 갖게 되는 송전탑의 개수를 최대한 비슷하게 맞추고자 합니다. 송전탑의 개수 n, 그리고 전선 정보 wires가 매개변수로 주어집니다. 전선들 중 하나를 끊어서 송전탑 개수가 가능한 비슷하도록 두 전력망으로 나누었을 때, 두 전력망이 가지고 있는 송전탑 개수의 차이(절대값)를 return 하도록 solution 함수를 완성해주세요. 제한사항 n은 2 이상 100 이하인 자연수입니다. wires는 길이가 n-1인 정수형 2차원 배열입니다. wires의 각 원소는 [v1, v2] 2개의 자연수로 이루어져 있으며, 이는 전력망의 v1번 송전탑과 v2번 송전탑이 전선으로 연결되어 있다는 것을 의미합니다. 1 ≤ v1 < v2 ≤ n 입니다. 전력망 네트워크가 하나의 트리 형태가 아닌 경우는 입력으로 주어지지 않습니다. 입출력 예 n wires result 9 [[1,3],[2,3],[3,4],[4,5],[4,6],[4,7],[7,8],[7,9]] 3 4 [[1,2],[2,3],[3,4]] 0 7 [[1,2],[2,7],[3,7],[3,4],[4,5],[6,7]] 1 입출력 예 설명 입출력 예 #1 다음 그림은 주어진 입력을 해결하는 방법 중 하나를 나타낸 것입니다. 4번과 7번을 연결하는 전선을 끊으면 두 전력망은 각 6개와 3개의 송전탑을 가지며, 이보다 더 비슷한 개수로 전력망을 나눌 수 없습니다. 또 다른 방법으로는 3번과 4번을 연결하는 전선을 끊어도 최선의 정답을 도출할 수 있습니다. 입출력 예 #2 다음 그림은 주어진 입력을 해결하는 방법을 나타낸 것입니다. 2번과 3번을 연결하는 전선을 끊으면 두 전력망이 모두 2개의 송전탑을 가지게 되며, 이 방법이 최선입니다. 입출력 예 #3 다음 그림은 주어진 입력을 해결하는 방법을 나타낸 것입니다. 3번과 7번을 연결하는 전선을 끊으면 두 전력망이 각각 4개와 3개의 송전탑을 가지게 되며, 이 방법이 최선입니다.",normal,Array
384,"명함 지갑을 만드는 회사에서 지갑의 크기를 정하려고 합니다. 다양한 모양과 크기의 명함들을 모두 수납할 수 있으면서, 작아서 들고 다니기 편한 지갑을 만들어야 합니다. 이러한 요건을 만족하는 지갑을 만들기 위해 디자인팀은 모든 명함의 가로 길이와 세로 길이를 조사했습니다. 아래 표는 4가지 명함의 가로 길이와 세로 길이를 나타냅니다. 명함 번호 가로 길이 세로 길이 1 60 50 2 30 70 3 60 30 4 80 40 가장 긴 가로 길이와 세로 길이가 각각 80, 70이기 때문에 80(가로) x 70(세로) 크기의 지갑을 만들면 모든 명함들을 수납할 수 있습니다. 하지만 2번 명함을 가로로 눕혀 수납한다면 80(가로) x 50(세로) 크기의 지갑으로 모든 명함들을 수납할 수 있습니다. 이때의 지갑 크기는 4000(=80 x 50)입니다. 모든 명함의 가로 길이와 세로 길이를 나타내는 2차원 배열 sizes가 매개변수로 주어집니다. 모든 명함을 수납할 수 있는 가장 작은 지갑을 만들 때, 지갑의 크기를 return 하도록 solution 함수를 완성해주세요. 제한사항 sizes의 길이는 1 이상 10,000 이하입니다. sizes의 원소는 [w, h] 형식입니다. w는 명함의 가로 길이를 나타냅니다. h는 명함의 세로 길이를 나타냅니다. w와 h는 1 이상 1,000 이하인 자연수입니다. 입출력 예 sizes result [[60, 50], [30, 70], [60, 30], [80, 40]] 4000 [[10, 7], [12, 3], [8, 15], [14, 7], [5, 15]] 120 [[14, 4], [19, 6], [6, 16], [18, 7], [7, 11]] 133 입출력 예 설명 입출력 예 #1 문제 예시와 같습니다. 입출력 예 #2 명함들을 적절히 회전시켜 겹쳤을 때, 3번째 명함(가로: 8, 세로: 15)이 다른 모든 명함보다 크기가 큽니다. 따라서 지갑의 크기는 3번째 명함의 크기와 같으며, 120(=8 x 15)을 return 합니다. 입출력 예 #3 명함들을 적절히 회전시켜 겹쳤을 때, 모든 명함을 포함하는 가장 작은 지갑의 크기는 133(=19 x 7)입니다.",easy,Array
385,"당신에게 자연수로 이루어진 길이가 n인 배열 b가 주어집니다. 초기에는 모든 수들이 ""안티 세포"" 안에 들어있습니다. 일반적인 세포는 분열을 하지만, 이 안티 세포는 반대로 여러 안티 세포가 모여 합성을 합니다. 당신은 다음과 같은 과정을 통해 인접한 두 안티 세포를 합치거나 또는 그대로 두려고 합니다. i=0로 설정하고, 빈 배열 c를 하나 만듭니다. i가 n이라면 과정을 종료합니다. b[i]를 포함하는 안티 세포를 X, 그리고 X 바로 왼쪽에 있는 안티 세포를 Y라고 정의합니다. 만약 Y가 존재하고 X의 모든 숫자의 합과 Y의 모든 숫자의 합이 같다면, 당신은 이 두 안티 세포를 합치거나 합치지 않는 행동 중에서 하나를 선택할 수 있습니다. 만약 X와 Y를 합친다면, 둘을 합치고, c의 맨 뒤에 i를 추가한 뒤 다시 3번 과정으로 돌아갑니다. 만약 X와 Y를 합치지 않는다면(또는 Y가 존재하지 않는다면), i를 1 증가시키고 2번 과정으로 돌아갑니다. 예를 들어, 다음은 b = [1,1,1,1]일 때 위와 같은 과정을 거치는 것을 나타낸 것입니다. i 안티 세포 c 비고 0 (1)(1)(1)(1) [] 초기 상태입니다. 1 (1)(1)(1)(1) [] i=0 일 때는 Y가 존재하지 않으므로 i를 1 증가시켰습니다. 1 (1,1)(1)(1) [1] b[1]을 포함하는 안티 세포(X)와 그 왼쪽의 안티 세포(Y)를 합쳤습니다. 따라서 c에 i=1이 추가됩니다. 2 (1,1)(1)(1) [1] b[1]을 포함하는 안티 세포(X) 왼쪽의 안티 세포 Y가 존재하지 않으므로 i를 1 증가시켰습니다. 3 (1,1)(1)(1) [1] X의 모든 수의 합은 1이고, Y의 모든 수의 합은 2이므로, 둘은 합칠 수 없습니다. 따라서 i을 1 증가시켰습니다. 3 (1,1)(1,1) [1,3] b[3]을 포함하는 안티 세포(X)와 그 왼쪽의 안티 세포(Y)를 합쳤습니다. 따라서 c에 i=3이 추가됩니다. 4 (1,1)(1,1) [1,3] b[3]을 포함하는 안티 세포(X)와 그 왼쪽의 안티 세포(Y)를 합칠 수 있었지만 그러지 않았습니다. 따라서 i를 1 증가시켰습니다. 이 경우 c = [1,3]이 됩니다. 물론 이는 c를 만들 수 있는 하나의 경우일 뿐이며, 당신의 선택에 따라 [], [1], [3], [1,3], [2], [1,3,3]으로 c배열을 다양하게 만들 수 있습니다. 당신이 어떤 선택을 하더라도 유한한 횟수 안에 c 배열을 만들 수 있음은 증명될 수 있습니다. 당신은 b가 주어졌을 때 만들 수 있는 서로 다른 배열 c의 개수가 몇 개인지 알고 싶습니다. 정수로 이루어진 배열 a와 s가 매개변수로 주어집니다. a는 여러 개의 b 배열을 순서대로 이어 붙인 배열이며, s는 각 b 배열의 길이가 순서대로 담긴 배열입니다. 각 b 배열에 대해 문제의 답을 109 + 7로 나눈 나머지를 구하여 배열에 차례대로 담아 return 하도록 solution 함수를 완성해주세요. 예를 들어, a = [1,2,3,4,5,6,7,8,9], s = [2,3,4] 라면, 다음 3가지 b 배열에 대해서 답을 구해야 합니다. b = [1,2] (s[0] = 2 이므로, a의 첫 2개 원소가 b 배열을 이룹니다.) b = [3,4,5] (s[1] = 3 이므로, a의 그다음 3개 원소가 b 배열을 이룹니다.) b = [6,7,8,9] (s[2] = 4 이므로, a의 그다음 4개 원소가 b 배열을 이룹니다.) 제한사항 1 ≤ a의 길이 ≤ 200,000 1 ≤ a의 모든 수 ≤ 109 1 ≤ s의 길이 ≤ a의 길이 1 ≤ s의 모든 수 ≤ a의 길이 s의 모든 수의 합 = a의 길이 입출력 예 a s result [1,1,1,1,1,1,2,5,8,2,1,1,4,8,8,8,12,6,6] [4,3,1,5,6] [6,3,1,5,9] 입출력 예 설명 입출력 예 #1 다음 5개의 b 배열에 대한 답을 구해야 합니다. b 답 [1,1,1,1] 6 [1,1,2] 3 [5] 1 [8,2,1,1,4] 5 [8,8,8,12,6,6] 9 따라서, [6,3,1,5,9]를 return 해야 합니다.",hard,Array
386,"어느 왕국에 하나 이상의 도시들이 있습니다. 왕국의 왕은 새 도시를 짓기로 결정하였습니다. 해당 도시를 짓기 위해서는 도시를 짓는 장소에 금 a kg과 은 b kg이 전달되어야 합니다. 각 도시에는 번호가 매겨져 있는데, i번 도시에는 금 g[i] kg, 은 s[i] kg, 그리고 트럭 한 대가 있습니다. i번 도시의 트럭은 오직 새 도시를 짓는 건설 장소와 i번 도시만을 왕복할 수 있으며, 편도로 이동하는 데 t[i] 시간이 걸리고, 최대 w[i] kg 광물을 운반할 수 있습니다. (광물은 금과 은입니다. 즉, 금과 은을 동시에 운반할 수 있습니다.) 모든 트럭은 같은 도로를 여러 번 왕복할 수 있으며 연료는 무한대라고 가정합니다. 정수 a, b와 정수 배열 g, s, w, t가 매개변수로 주어집니다. 주어진 정보를 바탕으로 각 도시의 트럭을 최적으로 운행했을 때, 새로운 도시를 건설하기 위해 금 a kg과 은 b kg을 전달할 수 있는 가장 빠른 시간을 구해 return 하도록 solution 함수를 완성해주세요. 제한사항 0 ≤ a, b ≤ 109 1 ≤ g의 길이 = s의 길이 = w의 길이 = t의 길이 = 도시 개수 ≤ 105 0 ≤ g[i], s[i] ≤ 109 1 ≤ w[i] ≤ 102 1 ≤ t[i] ≤ 105 a ≤ g의 모든 수의 합 b ≤ s의 모든 수의 합 입출력 예 a b g s w t result 10 10 [100] [100] [7] [10] 50 90 500 [70,70,0] [0,0,500] [100,100,2] [4,8,1] 499 입출력 예 설명 입출력 예 #1 도시가 오직 하나뿐이므로, 0번 도시의 유일한 트럭이 모든 운반을 해결해야 합니다. 이 트럭은 최대 7kg만큼의 광물을 운반할 수 있으며 편도 완주에는 10시간이 걸립니다. 맨 처음에 10시간을 써서 7kg만큼의 금을 운반하고, 10시간을 써서 다시 도시로 돌아오고, 10시간을 써서 7kg만큼의 은을 운반하고, 10시간을 써서 다시 도시로 돌아오고, 마지막으로 10시간을 써서 3kg만큼의 금과 3kg만큼의 은을 운반하면, 총 50시간 만에 필요한 모든 금과 은을 조달할 수 있습니다. 따라서, 50을 return 해야 합니다. 입출력 예 #2 도시가 3개이고, 0번과 1번 도시는 금만 70kg씩 가지고 있고 2번 도시는 은을 500kg 가지고 있습니다. 0번 도시의 트럭은 용량은 100kg, 편도 완주 시간은 4시간입니다. 1번 도시의 트럭은 용량은 100kg, 편도 완주 시간은 8시간입니다. 2번 도시의 트럭은 용량은 2kg, 편도 완주 시간은 1시간입니다. 금은 0번 도시의 트럭과 1번 도시의 트럭이 각각 45kg씩 나누어서 운반하면 8시간 안에 필요한 모든 금을 조달할 수 있습니다. 은은 2번 도시의 트럭이 한 번에 2kg씩 250번 운반하면(249번 왕복 + 1번 편도) 총 499시간 만에 필요한 모든 은을 조달할 수 있습니다. 따라서, 499를 return 해야 합니다.",normal,Array
387,"각 칸마다 S, L, 또는 R가 써져 있는 격자가 있습니다. 당신은 이 격자에서 빛을 쏘고자 합니다. 이 격자의 각 칸에는 다음과 같은 특이한 성질이 있습니다. 빛이 ""S""가 써진 칸에 도달한 경우, 직진합니다. 빛이 ""L""이 써진 칸에 도달한 경우, 좌회전을 합니다. 빛이 ""R""이 써진 칸에 도달한 경우, 우회전을 합니다. 빛이 격자의 끝을 넘어갈 경우, 반대쪽 끝으로 다시 돌아옵니다. 예를 들어, 빛이 1행에서 행이 줄어드는 방향으로 이동할 경우, 같은 열의 반대쪽 끝 행으로 다시 돌아옵니다. 당신은 이 격자 내에서 빛이 이동할 수 있는 경로 사이클이 몇 개 있고, 각 사이클의 길이가 얼마인지 알고 싶습니다. 경로 사이클이란, 빛이 이동하는 순환 경로를 의미합니다. 예를 들어, 다음 그림은 격자 [""SL"",""LR""]에서 1행 1열에서 2행 1열 방향으로 빛을 쏠 경우, 해당 빛이 이동하는 경로 사이클을 표현한 것입니다. 이 격자에는 길이가 16인 사이클 1개가 있으며, 다른 사이클은 존재하지 않습니다. 격자의 정보를 나타내는 1차원 문자열 배열 grid가 매개변수로 주어집니다. 주어진 격자를 통해 만들어지는 빛의 경로 사이클의 모든 길이들을 배열에 담아 오름차순으로 정렬하여 return 하도록 solution 함수를 완성해주세요. 제한사항 1 ≤ grid의 길이 ≤ 500 1 ≤ grid의 각 문자열의 길이 ≤ 500 grid의 모든 문자열의 길이는 서로 같습니다. grid의 모든 문자열은 'L', 'R', 'S'로 이루어져 있습니다. 입출력 예 grid result [""SL"",""LR""] [16] [""S""] [1,1,1,1] [""R"",""R""] [4,4] 입출력 예 설명 입출력 예 #1 문제 예시와 같습니다. 길이가 16인 사이클이 하나 존재하므로(다른 사이클은 없습니다.), [16]을 return 해야 합니다. 입출력 예 #2 주어진 격자를 통해 만들 수 있는 사이클들은 다음 그림과 같습니다. 4개의 사이클의 길이가 모두 1이므로, [1,1,1,1]을 return 해야 합니다. 입출력 예 #3 주어진 격자를 통해 만들 수 있는 사이클들은 다음 그림과 같습니다. 2개의 사이클의 길이가 모두 4이므로, [4,4]를 return 해야 합니다.",normal,Array
388,"0부터 9까지의 숫자 중 일부가 들어있는 정수 배열 numbers가 매개변수로 주어집니다. numbers에서 찾을 수 없는 0부터 9까지의 숫자를 모두 찾아 더한 수를 return 하도록 solution 함수를 완성해주세요. 제한사항 1 ≤ numbers의 길이 ≤ 9 0 ≤ numbers의 모든 원소 ≤ 9 numbers의 모든 원소는 서로 다릅니다. 입출력 예 numbers result [1,2,3,4,6,7,8,0] 14 [5,8,4,0,6,7,9] 6 입출력 예 설명 입출력 예 #1 5, 9가 numbers에 없으므로, 5 + 9 = 14를 return 해야 합니다. 입출력 예 #2 1, 2, 3이 numbers에 없으므로, 1 + 2 + 3 = 6을 return 해야 합니다.",easy,Array
389,"사전에 알파벳 모음 'A', 'E', 'I', 'O', 'U'만을 사용하여 만들 수 있는, 길이 5 이하의 모든 단어가 수록되어 있습니다. 사전에서 첫 번째 단어는 ""A""이고, 그다음은 ""AA""이며, 마지막 단어는 ""UUUUU""입니다. 단어 하나 word가 매개변수로 주어질 때, 이 단어가 사전에서 몇 번째 단어인지 return 하도록 solution 함수를 완성해주세요. 제한사항 word의 길이는 1 이상 5 이하입니다. word는 알파벳 대문자 'A', 'E', 'I', 'O', 'U'로만 이루어져 있습니다. 입출력 예 word result ""AAAAE"" 6 ""AAAE"" 10 ""I"" 1563 ""EIO"" 1189 입출력 예 설명 입출력 예 #1 사전에서 첫 번째 단어는 ""A""이고, 그다음은 ""AA"", ""AAA"", ""AAAA"", ""AAAAA"", ""AAAAE"", ... 와 같습니다. ""AAAAE""는 사전에서 6번째 단어입니다. 입출력 예 #2 ""AAAE""는 ""A"", ""AA"", ""AAA"", ""AAAA"", ""AAAAA"", ""AAAAE"", ""AAAAI"", ""AAAAO"", ""AAAAU""의 다음인 10번째 단어입니다. 입출력 예 #3 ""I""는 1563번째 단어입니다. 입출력 예 #4 ""EIO""는 1189번째 단어입니다.",normal,Bit Manipulation
390,"테이블 위에 놓인 퍼즐 조각을 게임 보드의 빈 공간에 적절히 올려놓으려 합니다. 게임 보드와 테이블은 모두 각 칸이 1x1 크기인 정사각 격자 모양입니다. 이때, 다음 규칙에 따라 테이블 위에 놓인 퍼즐 조각을 게임 보드의 빈칸에 채우면 됩니다. 조각은 한 번에 하나씩 채워 넣습니다. 조각을 회전시킬 수 있습니다. 조각을 뒤집을 수는 없습니다. 게임 보드에 새로 채워 넣은 퍼즐 조각과 인접한 칸이 비어있으면 안 됩니다. 다음은 퍼즐 조각을 채우는 예시입니다. 위 그림에서 왼쪽은 현재 게임 보드의 상태를, 오른쪽은 테이블 위에 놓인 퍼즐 조각들을 나타냅니다. 테이블 위에 놓인 퍼즐 조각들 또한 마찬가지로 [상,하,좌,우]로 인접해 붙어있는 경우는 없으며, 흰 칸은 퍼즐이 놓이지 않은 빈 공간을 나타냅니다. 모든 퍼즐 조각은 격자 칸에 딱 맞게 놓여있으며, 격자 칸을 벗어나거나, 걸쳐 있는 등 잘못 놓인 경우는 없습니다. 이때, 아래 그림과 같이 3,4,5번 조각을 격자 칸에 놓으면 규칙에 어긋나므로 불가능한 경우입니다. 3번 조각을 놓고 4번 조각을 놓기 전에 위쪽으로 인접한 칸에 빈칸이 생깁니다. 5번 조각의 양 옆으로 인접한 칸에 빈칸이 생깁니다. 다음은 규칙에 맞게 최대한 많은 조각을 게임 보드에 채워 넣은 모습입니다. 최대한 많은 조각을 채워 넣으면 총 14칸을 채울 수 있습니다. 현재 게임 보드의 상태 game_board, 테이블 위에 놓인 퍼즐 조각의 상태 table이 매개변수로 주어집니다. 규칙에 맞게 최대한 많은 퍼즐 조각을 채워 넣을 경우, 총 몇 칸을 채울 수 있는지 return 하도록 solution 함수를 완성해주세요. 제한사항 3 ≤ game_board의 행 길이 ≤ 50 game_board의 각 열 길이 = game_board의 행 길이 즉, 게임 보드는 정사각 격자 모양입니다. game_board의 모든 원소는 0 또는 1입니다. 0은 빈칸, 1은 이미 채워진 칸을 나타냅니다. 퍼즐 조각이 놓일 빈칸은 1 x 1 크기 정사각형이 최소 1개에서 최대 6개까지 연결된 형태로만 주어집니다. table의 행 길이 = game_board의 행 길이 table의 각 열 길이 = table의 행 길이 즉, 테이블은 game_board와 같은 크기의 정사각 격자 모양입니다. table의 모든 원소는 0 또는 1입니다. 0은 빈칸, 1은 조각이 놓인 칸을 나타냅니다. 퍼즐 조각은 1 x 1 크기 정사각형이 최소 1개에서 최대 6개까지 연결된 형태로만 주어집니다. game_board에는 반드시 하나 이상의 빈칸이 있습니다. table에는 반드시 하나 이상의 블록이 놓여 있습니다. 입출력 예 game_board table result [[1,1,0,0,1,0],[0,0,1,0,1,0],[0,1,1,0,0,1],[1,1,0,1,1,1],[1,0,0,0,1,0],[0,1,1,1,0,0]] [[1,0,0,1,1,0],[1,0,1,0,1,0],[0,1,1,0,1,1],[0,0,1,0,0,0],[1,1,0,1,1,0],[0,1,0,0,0,0]] 14 [[0,0,0],[1,1,0],[1,1,1]] [[1,1,1],[1,0,0],[0,0,0]] 0 입출력 예 설명 입출력 예 #1 입력은 다음과 같은 형태이며, 문제의 예시와 같습니다. 입출력 예 #2 블록의 회전은 가능하지만, 뒤집을 수는 없습니다.",normal,Math
391,"새로 생긴 놀이기구는 인기가 매우 많아 줄이 끊이질 않습니다. 이 놀이기구의 원래 이용료는 price원 인데, 놀이기구를 N 번 째 이용한다면 원래 이용료의 N배를 받기로 하였습니다. 즉, 처음 이용료가 100이었다면 2번째에는 200, 3번째에는 300으로 요금이 인상됩니다. 놀이기구를 count번 타게 되면 현재 자신이 가지고 있는 금액에서 얼마가 모자라는지를 return 하도록 solution 함수를 완성하세요. 단, 금액이 부족하지 않으면 0을 return 하세요. 제한사항 놀이기구의 이용료 price : 1 ≤ price ≤ 2,500, price는 자연수 처음 가지고 있던 금액 money : 1 ≤ money ≤ 1,000,000,000, money는 자연수 놀이기구의 이용 횟수 count : 1 ≤ count ≤ 2,500, count는 자연수 입출력 예 price money count result 3 20 4 10 입출력 예 설명 입출력 예 #1 이용금액이 3인 놀이기구를 4번 타고 싶은 고객이 현재 가진 금액이 20이라면, 총 필요한 놀이기구의 이용 금액은 30 (= 3+6+9+12) 이 되어 10만큼 부족하므로 10을 return 합니다. 참고 사항 미션 언어는 Java, JavaScript, Python3, C++ 만 해당 됩니다. 같은 코드를 제출한 사람이 여럿이라면 코드를 가장 먼저 제출한 분께 상품을 드립니다. 좋아요 수가 동일할 경우 코드를 가장 먼저 제출한 분께 상품을 드립니다.",easy,Math
392,"[본 문제는 정확성과 효율성 테스트 각각 점수가 있는 문제입니다.] 카카오 인턴을 선발하는 코딩 테스트 시험장이 하나의 이진 트리1 형태로 연결되어 있습니다. 아래 그림은 12개의 시험장이 연결된 예시입니다. 하나의 노드는 하나의 시험장을 나타냅니다. 검은 바탕의 흰 숫자는 해당 시험장의 고유 번호(ID)를 나타냅니다. 2-1. 시험장이 n개 있다면, 시험장의 고유 번호는 0부터 n-1까지 부여됩니다. 노드 안의 빨간 숫자는, 해당 시험장의 응시자 수를 나타냅니다. 3-1. 위의 그림에서, 9번 시험장에는 10명, 4번 시험장에는 8명, 6번 시험장에는 20명의 응시자가 시험을 볼 예정입니다. 노드 사이의 간선은 해당 시험장이 연결되어 있음을 의미합니다. 4-1. 위의 그림에서, 9번 시험장은 7번 시험장과, 7번 시험장은 6번 시험장과 연결되어 있습니다. 코딩 테스트를 총괄하는 무지는 안정적인 시험을 위해, 시험장에서 오는 트래픽을 k개의 그룹으로 나누어 각 그룹별 서버로 분산시키기로 하였습니다. 시험장 사이를 연결한 간선들 중 k-1개를 끊어서 시험장을 k 개의 그룹으로 나눌 계획입니다. 이때, 그룹별 최대 트래픽을 최소화하기 위하여 가장 큰 그룹의 인원을 최소화시켜야 합니다. 위의 그림에서 7번과 6번 시험장을 잇는 간선을 끊고, 9번과 7번 시험장을 잇는 간선을 끊는다면, 전체 시험장은 3개의 그룹으로 나누어집니다. 주황색 노드로 표시된 A그룹의 인원은 35명(10+8+5+6+1+1+4) 보라색 노드로 표시된 B그룹의 인원은 37명(7+30) 녹색 노드로 표시된 C그룹의 인원은 40명(20+8+12) 즉, 인원이 가장 많은 그룹은 40명입니다. 다른 어떤 방법으로 시험장을 3개의 그룹으로 나눈다고 해도, 인원이 가장 많은 그룹의 인원이 40명 미만이 되도록 나눌 수는 없습니다. 나눌 그룹의 수를 나타내는 정수 k, 각 시험장의 응시자 수를 나타내는 1차원 정수 배열 num, 시험장의 연결 상태를 나타내는 2차원 정수 배열 links가 매개변수로 주어집니다. 인원이 가장 많은 그룹의 인원이 최소화되도록 k개의 그룹으로 나누었을 때, 최소화된 최대 그룹의 인원을 return 하도록 solution 함수를 완성해주세요. 제한사항 1 ≤ k ≤ 10,000 k ≤ num의 길이 ≤ 10,000 num[i]에는 i번 시험장의 응시자 수가 담겨있습니다. 1 ≤ num의 원소 ≤ 10,000 links의 길이 = num의 길이 links의 i번째 행은 i번 노드(시험장)의 [왼쪽 자식 노드 번호, 오른쪽 자식 노드 번호]입니다. 해당 위치에 자식 노드가 없는 경우 -1이 담겨있습니다. 잘못된 노드 번호나, 하나의 이진 트리 구조가 아닌 입력은 주어지지 않습니다. 정확성 테스트 케이스 제한 사항 1 ≤ k ≤ 20 k ≤ num의 길이 ≤ 20 효율성 테스트 케이스 제한 사항 주어진 조건 외 추가 제한사항 없습니다. 입출력 예 k num links result 3 [12, 30, 1, 8, 8, 6, 20, 7, 5, 10, 4, 1] [[-1, -1], [-1, -1], [-1, -1], [-1, -1], [8, 5], [2, 10], [3, 0], [6, 1], [11, -1], [7, 4], [-1, -1], [-1, -1]] 40 1 [6, 9, 7, 5] [[-1, -1], [-1, -1], [-1, 0], [2, 1]] 27 2 [6, 9, 7, 5] [[-1, -1], [-1, -1], [-1, 0], [2, 1]] 14 4 [6, 9, 7, 5] [[-1, -1], [-1, -1], [-1, 0], [2, 1]] 9 입출력 예 설명 입출력 예 #1 문제 예시와 같습니다. 입출력 예 #2 나눌 그룹의 수가 1개 이므로, 주어진 트리를 나눌 수 없습니다. 보라색 노드로 표시된 유일한 그룹의 인원은 27명입니다. 입출력 예 #3 나눌 그룹의 수가 2개 이므로, 그림과 같이 1개의 간선을 끊어서 2개의 그룹으로 나눌 수 있습니다. 보라색 노드로 표시된 그룹은 13명, 주황색 노드로 표시된 그룹은 14명입니다. 따라서, 최대 그룹의 인원은 14명입니다. 입출력 예 #4 나늘 그룹의 수가 4개 이므로, 그림과 같이 3개의 모든 간선을 끊어서 4개의 그룹으로 나눌 수 있습니다. 최대 그룹의 인원은 9명입니다. 제한시간 안내 정확성 테스트 : 10초 효율성 테스트 : 언어별로 작성된 정답 코드의 실행 시간의 적정 배수 이진 트리 : 모든 노드들의 자식 노드가 두 개 이하인 트리 ↩",hard,Array
393,"신규 게임 ‘카카오 미로 탈출’이 출시되어, 라이언이 베타테스터로 참가했습니다. 위 예시 그림은 카카오 미로 탈출의 초기 상태를 나타냅니다. 1번부터 3번까지 번호가 붙어있는 3개의 방이 있고, 방과 방 사이를 연결하는 길에는 이동하는데 걸리는 시간이 표시되어 있습니다. 길은 화살표가 가리키는 방향으로만 이동할 수 있습니다. 미로에는 함정이 존재하며, 함정으로 이동하면, 이동한 함정과 연결된 모든 화살표의 방향이 바뀝니다. 출발지점인 1번 방에서 탈출이 가능한 3번 방까지 이동해야 합니다. 탈출하는데 걸리는 최소 시간을 구하려고 합니다. 그림의 원은 방을 나타내며 원 안의 숫자는 방 번호를 나타냅니다. 방이 n개일 때, 방 번호는 1부터 n까지 사용됩니다. 화살표에 표시된 숫자는 방과 방 사이를 이동할 때 걸리는 시간을 나타냅니다. 화살표가 가리키고 있는 방향으로만 이동이 가능합니다. 즉, 위 그림에서 2번 방에서 1번 방으로는 이동할 수 없습니다. 그림에 표시된 빨간색 방인 2번 방은 함정입니다. 함정 방으로 이동하는 순간, 이동한 함정 방과 연결되어있는 모든 길의 방향이 반대가 됩니다. 위 그림 1번 방에서 2번 방으로 이동하는 순간 1에서 2로 이동할 수 있던 길은 2에서 1로 이동할 수 있는 길로 바뀌고, 3에서 2로 이동할 수 있던 길은 2에서 3으로 이동할 수 있는 길로 바뀝니다. 똑같은 함정 방을 두 번째 방문하게 되면 원래 방향의 길로 돌아옵니다. 즉, 여러 번 방문하여 계속 길의 방향을 반대로 뒤집을 수 있습니다. 미로를 탈출하는데 필요한 최단 시간은 다음과 같습니다. 1→2: 2번 방으로 이동합니다. 이동 시간은 2입니다. 함정 발동: 2번 방과 연결된 모든 길의 방향이 반대가 됩니다. 2→3: 3번 방으로 이동합니다. 이동 시간은 3입니다. 탈출에 성공했습니다. 총 이동시간은 5입니다. 방의 개수를 나타내는 정수 n, 출발 방의 번호 start, 도착 방의 번호 end, 통로와 이동시간을 나타내는 2차원 정수 배열 roads, 함정 방의 번호를 담은 정수 배열 traps이 매개변수로 주어질 때, 미로를 탈출하는데 필요한 최단 시간을 return 하도록 solution 함수를 완성해주세요. 제한사항 2 ≤ n ≤ 1,000 1 ≤ start ≤ n 1 ≤ end ≤ n 1 ≤ roads의 행 길이 ≤ 3,000 roads의 행은 [P, Q, S]로 이루어져 있습니다. P에서 Q로 갈 수 있는 길이 있으며, 길을 따라 이동하는데 S만큼 시간이 걸립니다. 1 ≤ P ≤ n 1 ≤ Q ≤ n P ≠ Q 1 ≤ S ≤ 3,000 서로 다른 두 방 사이에 직접 연결된 길이 여러 개 존재할 수도 있습니다. 0 ≤ traps의 길이 ≤ 10 1 ≤ traps의 원소 ≤ n 시작 방과 도착 방은 함정이 아닙니다. 항상 미로를 탈출할 수 있는 경우만 주어집니다. 입출력 예 n start end roads traps result 3 1 3 [[1, 2, 2], [3, 2, 3]] [2] 5 4 1 4 [[1, 2, 1], [3, 2, 1], [2, 4, 1]] [2, 3] 4 입출력 예 설명 입출력 예 #1 문제 예시와 같습니다. 입출력 예 #2 1 → 2 → 3 → 2 → 4 순서로 이동하면 됩니다. 총 이동시간은 4입니다. 제한시간 안내 정확성 테스트 : 10초",hard,Array
394,"[본 문제는 정확성과 효율성 테스트 각각 점수가 있는 문제입니다.] 업무용 소프트웨어를 개발하는 니니즈웍스의 인턴인 앙몬드는 명령어 기반으로 표의 행을 선택, 삭제, 복구하는 프로그램을 작성하는 과제를 맡았습니다. 세부 요구 사항은 다음과 같습니다 위 그림에서 파란색으로 칠해진 칸은 현재 선택된 행을 나타냅니다. 단, 한 번에 한 행만 선택할 수 있으며, 표의 범위(0행 ~ 마지막 행)를 벗어날 수 없습니다. 이때, 다음과 같은 명령어를 이용하여 표를 편집합니다. ""U X"": 현재 선택된 행에서 X칸 위에 있는 행을 선택합니다. ""D X"": 현재 선택된 행에서 X칸 아래에 있는 행을 선택합니다. ""C"" : 현재 선택된 행을 삭제한 후, 바로 아래 행을 선택합니다. 단, 삭제된 행이 가장 마지막 행인 경우 바로 윗 행을 선택합니다. ""Z"" : 가장 최근에 삭제된 행을 원래대로 복구합니다. 단, 현재 선택된 행은 바뀌지 않습니다. 예를 들어 위 표에서 ""D 2""를 수행할 경우 아래 그림의 왼쪽처럼 4행이 선택되며, ""C""를 수행하면 선택된 행을 삭제하고, 바로 아래 행이었던 ""네오""가 적힌 행을 선택합니다(4행이 삭제되면서 아래 있던 행들이 하나씩 밀려 올라오고, 수정된 표에서 다시 4행을 선택하는 것과 동일합니다). 다음으로 ""U 3""을 수행한 다음 ""C""를 수행한 후의 표 상태는 아래 그림과 같습니다. 다음으로 ""D 4""를 수행한 다음 ""C""를 수행한 후의 표 상태는 아래 그림과 같습니다. 5행이 표의 마지막 행 이므로, 이 경우 바로 윗 행을 선택하는 점에 주의합니다. 다음으로 ""U 2""를 수행하면 현재 선택된 행은 2행이 됩니다. 위 상태에서 ""Z""를 수행할 경우 가장 최근에 제거된 ""라이언""이 적힌 행이 원래대로 복구됩니다. 다시한번 ""Z""를 수행하면 그 다음으로 최근에 제거된 ""콘""이 적힌 행이 원래대로 복구됩니다. 이때, 현재 선택된 행은 바뀌지 않는 점에 주의하세요. 이때, 최종 표의 상태와 처음 주어진 표의 상태를 비교하여 삭제되지 않은 행은 ""O"", 삭제된 행은 ""X""로 표시하면 다음과 같습니다. 처음 표의 행 개수를 나타내는 정수 n, 처음에 선택된 행의 위치를 나타내는 정수 k, 수행한 명령어들이 담긴 문자열 배열 cmd가 매개변수로 주어질 때, 모든 명령어를 수행한 후 표의 상태와 처음 주어진 표의 상태를 비교하여 삭제되지 않은 행은 O, 삭제된 행은 X로 표시하여 문자열 형태로 return 하도록 solution 함수를 완성해주세요. 제한사항 5 ≤ n ≤ 1,000,000 0 ≤ k < n 1 ≤ cmd의 원소 개수 ≤ 200,000 cmd의 각 원소는 ""U X"", ""D X"", ""C"", ""Z"" 중 하나입니다. X는 1 이상 300,000 이하인 자연수이며 0으로 시작하지 않습니다. X가 나타내는 자연수에 ',' 는 주어지지 않습니다. 예를 들어 123,456의 경우 123456으로 주어집니다. cmd에 등장하는 모든 X들의 값을 합친 결과가 1,000,000 이하인 경우만 입력으로 주어집니다. 표의 모든 행을 제거하여, 행이 하나도 남지 않는 경우는 입력으로 주어지지 않습니다. 본문에서 각 행이 제거되고 복구되는 과정을 보다 자연스럽게 보이기 위해 ""이름"" 열을 사용하였으나, ""이름""열의 내용이 실제 문제를 푸는 과정에 필요하지는 않습니다. ""이름""열에는 서로 다른 이름들이 중복없이 채워져 있다고 가정하고 문제를 해결해 주세요. 표의 범위를 벗어나는 이동은 입력으로 주어지지 않습니다. 원래대로 복구할 행이 없을 때(즉, 삭제된 행이 없을 때) ""Z""가 명령어로 주어지는 경우는 없습니다. 정답은 표의 0행부터 n - 1행까지에 해당되는 O, X를 순서대로 이어붙인 문자열 형태로 return 해주세요. 정확성 테스트 케이스 제한 사항 5 ≤ n ≤ 1,000 1 ≤ cmd의 원소 개수 ≤ 1,000 효율성 테스트 케이스 제한 사항 주어진 조건 외 추가 제한사항 없습니다. 입출력 예 n k cmd result 8 2 [""D 2"",""C"",""U 3"",""C"",""D 4"",""C"",""U 2"",""Z"",""Z""] ""OOOOXOOO"" 8 2 [""D 2"",""C"",""U 3"",""C"",""D 4"",""C"",""U 2"",""Z"",""Z"",""U 1"",""C""] ""OOXOXOOO"" 입출력 예 설명 입출력 예 #1 문제의 예시와 같습니다. 입출력 예 #2 다음은 9번째 명령어까지 수행한 후의 표 상태이며, 이는 입출력 예 #1과 같습니다. 10번째 명령어 ""U 1""을 수행하면 ""어피치""가 적힌 2행이 선택되며, 마지막 명령어 ""C""를 수행하면 선택된 행을 삭제하고, 바로 아래 행이었던 ""제이지""가 적힌 행을 선택합니다. 따라서 처음 주어진 표의 상태와 최종 표의 상태를 비교하면 다음과 같습니다. 제한시간 안내 정확성 테스트 : 10초 효율성 테스트 : 언어별로 작성된 정답 코드의 실행 시간의 적정 배수",normal,Array
395,"개발자를 희망하는 죠르디가 카카오에 면접을 보러 왔습니다. 코로나 바이러스 감염 예방을 위해 응시자들은 거리를 둬서 대기를 해야하는데 개발 직군 면접인 만큼 아래와 같은 규칙으로 대기실에 거리를 두고 앉도록 안내하고 있습니다. 대기실은 5개이며, 각 대기실은 5x5 크기입니다. 거리두기를 위하여 응시자들 끼리는 맨해튼 거리1가 2 이하로 앉지 말아 주세요. 단 응시자가 앉아있는 자리 사이가 파티션으로 막혀 있을 경우에는 허용합니다. 예를 들어, 위 그림처럼 자리 사이에 파티션이 존재한다면 맨해튼 거리가 2여도 거리두기를 지킨 것입니다. 위 그림처럼 파티션을 사이에 두고 앉은 경우도 거리두기를 지킨 것입니다. 위 그림처럼 자리 사이가 맨해튼 거리 2이고 사이에 빈 테이블이 있는 경우는 거리두기를 지키지 않은 것입니다. 응시자가 앉아있는 자리(P)를 의미합니다. 빈 테이블(O)을 의미합니다. 파티션(X)을 의미합니다. 5개의 대기실을 본 죠르디는 각 대기실에서 응시자들이 거리두기를 잘 기키고 있는지 알고 싶어졌습니다. 자리에 앉아있는 응시자들의 정보와 대기실 구조를 대기실별로 담은 2차원 문자열 배열 places가 매개변수로 주어집니다. 각 대기실별로 거리두기를 지키고 있으면 1을, 한 명이라도 지키지 않고 있으면 0을 배열에 담아 return 하도록 solution 함수를 완성해 주세요. 제한사항 places의 행 길이(대기실 개수) = 5 places의 각 행은 하나의 대기실 구조를 나타냅니다. places의 열 길이(대기실 세로 길이) = 5 places의 원소는 P,O,X로 이루어진 문자열입니다. places 원소의 길이(대기실 가로 길이) = 5 P는 응시자가 앉아있는 자리를 의미합니다. O는 빈 테이블을 의미합니다. X는 파티션을 의미합니다. 입력으로 주어지는 5개 대기실의 크기는 모두 5x5 입니다. return 값 형식 1차원 정수 배열에 5개의 원소를 담아서 return 합니다. places에 담겨 있는 5개 대기실의 순서대로, 거리두기 준수 여부를 차례대로 배열에 담습니다. 각 대기실 별로 모든 응시자가 거리두기를 지키고 있으면 1을, 한 명이라도 지키지 않고 있으면 0을 담습니다. 입출력 예 places result [[""POOOP"", ""OXXOX"", ""OPXPX"", ""OOXOX"", ""POXXP""], [""POOPX"", ""OXPXP"", ""PXXXO"", ""OXXXO"", ""OOOPP""], [""PXOPX"", ""OXOXP"", ""OXPOX"", ""OXXOP"", ""PXPOX""], [""OOOXX"", ""XOOOX"", ""OOOXX"", ""OXOOX"", ""OOOOO""], [""PXPXP"", ""XPXPX"", ""PXPXP"", ""XPXPX"", ""PXPXP""]] [1, 0, 1, 1, 1] 입출력 예 설명 입출력 예 #1 첫 번째 대기실 No. 0 1 2 3 4 0 P O O O P 1 O X X O X 2 O P X P X 3 O O X O X 4 P O X X P 모든 응시자가 거리두기를 지키고 있습니다. 두 번째 대기실 No. 0 1 2 3 4 0 P O O P X 1 O X P X P 2 P X X X O 3 O X X X O 4 O O O P P (0, 0) 자리의 응시자와 (2, 0) 자리의 응시자가 거리두기를 지키고 있지 않습니다. (1, 2) 자리의 응시자와 (0, 3) 자리의 응시자가 거리두기를 지키고 있지 않습니다. (4, 3) 자리의 응시자와 (4, 4) 자리의 응시자가 거리두기를 지키고 있지 않습니다. 세 번째 대기실 No. 0 1 2 3 4 0 P X O P X 1 O X O X P 2 O X P O X 3 O X X O P 4 P X P O X 모든 응시자가 거리두기를 지키고 있습니다. 네 번째 대기실 No. 0 1 2 3 4 0 O O O X X 1 X O O O X 2 O O O X X 3 O X O O X 4 O O O O O 대기실에 응시자가 없으므로 거리두기를 지키고 있습니다. 다섯 번째 대기실 No. 0 1 2 3 4 0 P X P X P 1 X P X P X 2 P X P X P 3 X P X P X 4 P X P X P 모든 응시자가 거리두기를 지키고 있습니다. 두 번째 대기실을 제외한 모든 대기실에서 거리두기가 지켜지고 있으므로, 배열 [1, 0, 1, 1, 1]을 return 합니다. 제한시간 안내 정확성 테스트 : 10초 ※ 공지 - 2022년 4월 25일 테스트케이스가 추가되었습니다. 두 테이블 T1, T2가 행렬 (r1, c1), (r2, c2)에 각각 위치하고 있다면, T1, T2 사이의 맨해튼 거리는 |r1 - r2| + |c1 - c2| 입니다. ↩",normal,Array
396,"네오와 프로도가 숫자놀이를 하고 있습니다. 네오가 프로도에게 숫자를 건넬 때 일부 자릿수를 영단어로 바꾼 카드를 건네주면 프로도는 원래 숫자를 찾는 게임입니다. 다음은 숫자의 일부 자릿수를 영단어로 바꾸는 예시입니다. 1478 → ""one4seveneight"" 234567 → ""23four5six7"" 10203 → ""1zerotwozero3"" 이렇게 숫자의 일부 자릿수가 영단어로 바뀌어졌거나, 혹은 바뀌지 않고 그대로인 문자열 s가 매개변수로 주어집니다. s가 의미하는 원래 숫자를 return 하도록 solution 함수를 완성해주세요. 참고로 각 숫자에 대응되는 영단어는 다음 표와 같습니다. 숫자 영단어 0 zero 1 one 2 two 3 three 4 four 5 five 6 six 7 seven 8 eight 9 nine 제한사항 1 ≤ s의 길이 ≤ 50 s가 ""zero"" 또는 ""0""으로 시작하는 경우는 주어지지 않습니다. return 값이 1 이상 2,000,000,000 이하의 정수가 되는 올바른 입력만 s로 주어집니다. 입출력 예 s result ""one4seveneight"" 1478 ""23four5six7"" 234567 ""2three45sixseven"" 234567 ""123"" 123 입출력 예 설명 입출력 예 #1 문제 예시와 같습니다. 입출력 예 #2 문제 예시와 같습니다. 입출력 예 #3 ""three""는 3, ""six""는 6, ""seven""은 7에 대응되기 때문에 정답은 입출력 예 #2와 같은 234567이 됩니다. 입출력 예 #2와 #3과 같이 같은 정답을 가리키는 문자열이 여러 가지가 나올 수 있습니다. 입출력 예 #4 s에는 영단어로 바뀐 부분이 없습니다. 제한시간 안내 정확성 테스트 : 10초",easy,String
397,"1부터 n까지 번호가 하나씩 붙은 n개의 노드를 갖는 트리가 주어집니다. 각 노드에는 값이 하나씩 들어 있으며, 이 트리의 루트 노드는 1번 노드입니다. 당신은 이 트리에 대해 다음과 같은 쿼리 두 종류를 처리하면 됩니다. 1번 쿼리: 정수 u가 주어집니다. u번 노드의 서브 트리의 모든 노드의 값의 합을 구해야 합니다. 2번 쿼리: 정수 u, w가 주어집니다. u번 노드의 값을 삭제한 뒤, u번 노드의 부모 노드의 값을 u번 노드로 복사합니다., u번 노드의 부모 노드에 대해 같은 작업을 반복하며 루트노드까지 거슬러 올라갑니다. 마지막으로 루트 노드의 값을 w로 바꿉니다. 트리의 노드 초기값이 담긴 정수 배열 values, 트리의 연결 상태가 담긴 2차원 정수 배열 edges, 쿼리들이 담긴 2차원 정수 배열 queries가 주어집니다. 쿼리들을 순서대로 처리할 때, 각 1번 쿼리에 대한 답을 수행 순서대로 배열에 담아 return 하도록 solution 함수를 완성해주세요. 제한사항 1 ≤ values의 길이 ≤ 100,000 values의 길이는 트리의 노드 개수를 의미합니다. values[i]는 i+1번 노드의 초기 값을 의미합니다. edges의 길이 = values의 길이 - 1 edges의 각 행은 [v1, v2] 2개의 정수로 이루어져 있으며, 이는 v1번 노드와 v2번 노드가 연결되어 있음을 의미합니다. 주어진 그래프는 항상 1번 노드가 루트인 트리 형태입니다. 1 ≤ queries의 길이 ≤ 100,000 queries의 각 행은 단일 쿼리를 의미하며, [u, w] 2개의 정수로 이루어져 있습니다. 1 ≤ u ≤ values의 길이 -1 ≤ w ≤ 109 w가 -1일 경우, 이 쿼리는 1번 쿼리이며, 그렇지 않을 경우 이 쿼리는 2번 쿼리입니다. 입출력 예 values edges queries result [1,10,100,1000,10000] [[1,2],[1,3],[2,4],[2,5]] [[1,-1],[2,-1],[3,-1],[4,-1],[5,-1],[4,1000],[1,-1],[2,-1],[3,-1],[4,-1],[5,-1],[2,1],[1,-1],[2,-1],[3,-1],[4,-1],[5,-1]] [11111,11010,100,1000,10000,11111,10011,100,10,10000,11111,11010,100,10,10000] 입출력 예 설명 입출력 예 #1 주어진 예시는 1번 쿼리 15개와 2번 쿼리 2개로 이루어져 있습니다. 다음 그림은 두 2번 쿼리에 의해 트리의 노드 값들이 바뀌는 과정을 나타낸 것입니다.",hard,Array
398,"0과 1로 이루어진 어떤 문자열 x에 대해서, 당신은 다음과 같은 행동을 통해 x를 최대한 사전 순으로 앞에 오도록 만들고자 합니다. x에 있는 ""110""을 뽑아서, 임의의 위치에 다시 삽입합니다. 예를 들어, x = ""11100"" 일 때, 여기서 중앙에 있는 ""110""을 뽑으면 x = ""10"" 이 됩니다. 뽑았던 ""110""을 x의 맨 앞에 다시 삽입하면 x = ""11010"" 이 됩니다. 변형시킬 문자열 x가 여러 개 들어있는 문자열 배열 s가 주어졌을 때, 각 문자열에 대해서 위의 행동으로 변형해서 만들 수 있는 문자열 중 사전 순으로 가장 앞에 오는 문자열을 배열에 담아 return 하도록 solution 함수를 완성해주세요. 제한사항 1 ≤ s의 길이 ≤ 1,000,000 1 ≤ s의 각 원소 길이 ≤ 1,000,000 1 ≤ s의 모든 원소의 길이의 합 ≤ 1,000,000 입출력 예 s result [""1110"",""100111100"",""0111111010""] [""1101"",""100110110"",""0110110111""] 입출력 예 설명 입출력 예 #1 다음 그림은 ""1110""을 ""1101""로 만드는 과정을 나타낸 것입니다. ""1101""보다 사전 순으로 더 앞에 오는 문자열을 만들 수 없으므로, 배열에 ""1101""을 담아야 합니다. 다음 그림은 ""100111100""을 ""100110110""으로 만드는 과정을 나타낸 것입니다. ""100110110""보다 사전 순으로 더 앞에 오는 문자열을 만들 수 없으므로, 배열에 ""100110110""을 담아야 합니다. 그림에 나온 방식 말고도 다른 방법으로 ""100110110""을 만들 수 있습니다. 다음 그림은 ""0111111010""을 ""0110110111""로 만드는 과정을 나타낸 것입니다. ""0110110111""보다 사전 순으로 더 앞에 오는 문자열을 만들 수 없으므로, 배열에 ""0110110111""을 담아야 합니다. 그림에 나온 방식 말고도 다른 방법으로 ""0110110111""을 만들 수 있습니다.",normal,Array
399,"양의 정수 x에 대한 함수 f(x)를 다음과 같이 정의합니다. x보다 크고 x와 비트가 1~2개 다른 수들 중에서 제일 작은 수 예를 들어, f(2) = 3 입니다. 다음 표와 같이 2보다 큰 수들 중에서 비트가 다른 지점이 2개 이하이면서 제일 작은 수가 3이기 때문입니다. 수 비트 다른 비트의 개수 2 000...0010 3 000...0011 1 f(7) = 11 입니다. 다음 표와 같이 7보다 큰 수들 중에서 비트가 다른 지점이 2개 이하이면서 제일 작은 수가 11이기 때문입니다. 수 비트 다른 비트의 개수 7 000...0111 8 000...1000 4 9 000...1001 3 10 000...1010 3 11 000...1011 2 정수들이 담긴 배열 numbers가 매개변수로 주어집니다. numbers의 모든 수들에 대하여 각 수의 f 값을 배열에 차례대로 담아 return 하도록 solution 함수를 완성해주세요. 제한사항 1 ≤ numbers의 길이 ≤ 100,000 0 ≤ numbers의 모든 수 ≤ 1015 입출력 예 numbers result [2,7] [3,11] 입출력 예 설명 입출력 예 #1 문제 예시와 같습니다.",normal,Array
400,"두 정수 left와 right가 매개변수로 주어집니다. left부터 right까지의 모든 수들 중에서, 약수의 개수가 짝수인 수는 더하고, 약수의 개수가 홀수인 수는 뺀 수를 return 하도록 solution 함수를 완성해주세요. 제한사항 1 ≤ left ≤ right ≤ 1,000 입출력 예 left right result 13 17 43 24 27 52 입출력 예 설명 입출력 예 #1 다음 표는 13부터 17까지의 수들의 약수를 모두 나타낸 것입니다. 수 약수 약수의 개수 13 1, 13 2 14 1, 2, 7, 14 4 15 1, 3, 5, 15 4 16 1, 2, 4, 8, 16 5 17 1, 17 2 따라서, 13 + 14 + 15 - 16 + 17 = 43을 return 해야 합니다. 입출력 예 #2 다음 표는 24부터 27까지의 수들의 약수를 모두 나타낸 것입니다. 수 약수 약수의 개수 24 1, 2, 3, 4, 6, 8, 12, 24 8 25 1, 5, 25 3 26 1, 2, 13, 26 4 27 1, 3, 9, 27 4 따라서, 24 - 25 + 26 + 27 = 52를 return 해야 합니다.",easy,Math
401,"PLACES 테이블은 공간 임대 서비스에 등록된 공간의 정보를 담은 테이블입니다. PLACES 테이블의 구조는 다음과 같으며 ID, NAME, HOST_ID는 각각 공간의 아이디, 이름, 공간을 소유한 유저의 아이디를 나타냅니다. ID는 기본키입니다. NAME TYPE ID INT NAME VARCHAR HOST_ID INT 문제 이 서비스에서는 공간을 둘 이상 등록한 사람을 ""헤비 유저""라고 부릅니다. 헤비 유저가 등록한 공간의 정보를 아이디 순으로 조회하는 SQL문을 작성해주세요. 예시 예를 들어, PLACES 테이블이 다음과 같다면 ID NAME HOST_ID 4431977 BOUTIQUE STAYS - Somerset Terrace, Pet Friendly 760849 5194998 BOUTIQUE STAYS - Elwood Beaches 3, Pet Friendly 760849 16045624 Urban Jungle in the Heart of Melbourne 30900122 17810814 Stylish Bayside Retreat with a Luscious Garden 760849 22740286 FREE PARKING - The Velvet Lux in Melbourne CBD 30900122 22868779 ★ Fresh Fitzroy Pad with City Views! ★ 21058208 760849번 유저는 공간을 3개 등록했으므로 이 유저는 헤비유저입니다. 30900122번 유저는 공간을 2개 등록했으므로 이 유저는 헤비유저입니다. 21058208번 유저는 공간을 1개 등록했으므로 이 유저는 헤비유저가 아닙니다. 따라서 SQL 문을 실행하면 다음과 같이 나와야 합니다. ID NAME HOST_ID 4431977 BOUTIQUE STAYS - Somerset Terrace, Pet Friendly 760849 5194998 BOUTIQUE STAYS - Elwood Beaches 3, Pet Friendly 760849 16045624 Urban Jungle in the Heart of Melbourne 30900122 17810814 Stylish Bayside Retreat with a Luscious Garden 760849 22740286 FREE PARKING - The Velvet Lux in Melbourne CBD 30900122",normal,database
402,"민호는 다단계 조직을 이용하여 칫솔을 판매하고 있습니다. 판매원이 칫솔을 판매하면 그 이익이 피라미드 조직을 타고 조금씩 분배되는 형태의 판매망입니다. 어느정도 판매가 이루어진 후, 조직을 운영하던 민호는 조직 내 누가 얼마만큼의 이득을 가져갔는지가 궁금해졌습니다. 예를 들어, 민호가 운영하고 있는 다단계 칫솔 판매 조직이 아래 그림과 같다고 합시다. 민호는 center이며, 파란색 네모는 여덟 명의 판매원을 표시한 것입니다. 각각은 자신을 조직에 참여시킨 추천인에 연결되어 피라미드 식의 구조를 이루고 있습니다. 조직의 이익 분배 규칙은 간단합니다. 모든 판매원은 칫솔의 판매에 의하여 발생하는 이익에서 10% 를 계산하여 자신을 조직에 참여시킨 추천인에게 배분하고 나머지는 자신이 가집니다. 모든 판매원은 자신이 칫솔 판매에서 발생한 이익 뿐만 아니라, 자신이 조직에 추천하여 가입시킨 판매원에게서 발생하는 이익의 10% 까지 자신에 이익이 됩니다. 자신에게 발생하는 이익 또한 마찬가지의 규칙으로 자신의 추천인에게 분배됩니다. 단, 10% 를 계산할 때에는 원 단위에서 절사하며, 10%를 계산한 금액이 1 원 미만인 경우에는 이득을 분배하지 않고 자신이 모두 가집니다. 예를 들어, 아래와 같은 판매 기록이 있다고 가정하겠습니다. 칫솔의 판매에서 발생하는 이익은 개당 100 원으로 정해져 있습니다. 판매원 판매 수량 이익금 young 12 1,200 원 john 4 400 원 tod 2 200 원 emily 5 500 원 mary 10 1,000 원 판매원 young 에 의하여 1,200 원의 이익이 발생했습니다. young 은 이 중 10% 에 해당하는 120 원을, 자신을 조직에 참여시킨 추천인인 edward 에게 배분하고 자신은 나머지인 1,080 원을 가집니다. edward 는 young 에게서 받은 120 원 중 10% 인 12 원을 mary 에게 배분하고 자신은 나머지인 108 원을 가집니다. 12 원을 edward 로부터 받은 mary 는 10% 인 1 원을 센터에 (즉, 민호에게) 배분하고 자신은 나머지인 11 원을 가집니다. 이 상태를 그림으로 나타내면 아래와 같습니다. 그 후, 판매원 john 에 의하여 400 원의 이익이 발생합니다. john 은 10% 인 40 원을 센터에 배분하고 자신이 나머지인 360 원을 가집니다. 이 상태를 그림으로 나타내면 아래와 같습니다. 또 그 후에는 판매원 tod 에 의하여 200 원 이익이 발생하는데, tod 자신이 180 원을, 추천인인 jaimie 가 그 중 10% 인 20 원을 받아서 18 원을 가지고, jaimie 의 추천인인 mary 는 2 원을 받지만 이것의 10% 는 원 단위에서 절사하면 배분할 금액이 없기 때문에 mary 는 2 원을 모두 가집니다. 이 상태를 그림으로 나타내면 아래와 같습니다. 그 다음으로 emily 가 칫솔 판매를 통하여 얻은 이익 500 원은 마찬가지의 규칙에 따라 emily 에게 450 원, mary 에게 45 원, 그리고 센터에 5 원으로 분배됩니다. 이 상태를 그림으로 나타내면 아래와 같습니다. 마지막으로, 판매원 mary 는 1,000 원의 이익을 달성하고, 이 중 10% 인 100 원을 센터에 배분한 후 그 나머지인 900 원을 자신이 가집니다. 이 상태를 그림으로 나타내면 아래와 같습니다. 위와 같이 하여 모든 조직 구성원들의 이익 달성 현황 집계가 끝났습니다. 지금까지 얻은 이익을 모두 합한 결과를 그림으로 나타내면 아래와 같습니다. 이 결과가 민호가 파악하고자 하는 이익 배분 현황입니다. 각 판매원의 이름을 담은 배열 enroll, 각 판매원을 다단계 조직에 참여시킨 다른 판매원의 이름을 담은 배열 referral, 판매량 집계 데이터의 판매원 이름을 나열한 배열 seller, 판매량 집계 데이터의 판매 수량을 나열한 배열 amount가 매개변수로 주어질 때, 각 판매원이 득한 이익금을 나열한 배열을 return 하도록 solution 함수를 완성해주세요. 판매원에게 배분된 이익금의 총합을 계산하여(정수형으로), 입력으로 주어진 enroll에 이름이 포함된 순서에 따라 나열하면 됩니다. 제한사항 enroll의 길이는 1 이상 10,000 이하입니다. enroll에 민호의 이름은 없습니다. 따라서 enroll의 길이는 민호를 제외한 조직 구성원의 총 수입니다. referral의 길이는 enroll의 길이와 같습니다. referral 내에서 i 번째에 있는 이름은 배열 enroll 내에서 i 번째에 있는 판매원을 조직에 참여시킨 사람의 이름입니다. 어느 누구의 추천도 없이 조직에 참여한 사람에 대해서는 referral 배열 내에 추천인의 이름이 기입되지 않고 “-“ 가 기입됩니다. 위 예제에서는 john 과 mary 가 이러한 예에 해당합니다. enroll 에 등장하는 이름은 조직에 참여한 순서에 따릅니다. 즉, 어느 판매원의 이름이 enroll 의 i 번째에 등장한다면, 이 판매원을 조직에 참여시킨 사람의 이름, 즉 referral 의 i 번째 원소는 이미 배열 enroll 의 j 번째 (j < i) 에 등장했음이 보장됩니다. seller의 길이는 1 이상 100,000 이하입니다. seller 내의 i 번째에 있는 이름은 i 번째 판매 집계 데이터가 어느 판매원에 의한 것인지를 나타냅니다. seller 에는 같은 이름이 중복해서 들어있을 수 있습니다. amount의 길이는 seller의 길이와 같습니다. amount 내의 i 번째에 있는 수는 i 번째 판매 집계 데이터의 판매량을 나타냅니다. 판매량의 범위, 즉 amount 의 원소들의 범위는 1 이상 100 이하인 자연수입니다. 칫솔 한 개를 판매하여 얻어지는 이익은 100 원으로 정해져 있습니다. 모든 조직 구성원들의 이름은 10 글자 이내의 영문 알파벳 소문자들로만 이루어져 있습니다. 입출력 예 enroll referral seller amount result [""john"", ""mary"", ""edward"", ""sam"", ""emily"", ""jaimie"", ""tod"", ""young""] [""-"", ""-"", ""mary"", ""edward"", ""mary"", ""mary"", ""jaimie"", ""edward""] [""young"", ""john"", ""tod"", ""emily"", ""mary""] [12, 4, 2, 5, 10] [360, 958, 108, 0, 450, 18, 180, 1080] [""john"", ""mary"", ""edward"", ""sam"", ""emily"", ""jaimie"", ""tod"", ""young""] [""-"", ""-"", ""mary"", ""edward"", ""mary"", ""mary"", ""jaimie"", ""edward""] [""sam"", ""emily"", ""jaimie"", ""edward""] [2, 3, 5, 4] [0, 110, 378, 180, 270, 450, 0, 0] 입출력 예 설명 입출력 예 #1 문제의 예시와 같습니다. 입출력 예 #2 문제에 주어진 예시와 동일한 조직 구성에 조금 다른 판매량 집계를 적용한 것입니다. 이익을 분배하는 규칙이 동일하므로, 간단한 계산에 의하여 표에 보인 결과를 얻을 수 있습니다. ※ 공지 - 2021년 5월 21일 테스트케이스가 추가되었습니다.",normal,Array
403,"rows x columns 크기인 행렬이 있습니다. 행렬에는 1부터 rows x columns까지의 숫자가 한 줄씩 순서대로 적혀있습니다. 이 행렬에서 직사각형 모양의 범위를 여러 번 선택해, 테두리 부분에 있는 숫자들을 시계방향으로 회전시키려 합니다. 각 회전은 (x1, y1, x2, y2)인 정수 4개로 표현하며, 그 의미는 다음과 같습니다. x1 행 y1 열부터 x2 행 y2 열까지의 영역에 해당하는 직사각형에서 테두리에 있는 숫자들을 한 칸씩 시계방향으로 회전합니다. 다음은 6 x 6 크기 행렬의 예시입니다. 이 행렬에 (2, 2, 5, 4) 회전을 적용하면, 아래 그림과 같이 2행 2열부터 5행 4열까지 영역의 테두리가 시계방향으로 회전합니다. 이때, 중앙의 15와 21이 있는 영역은 회전하지 않는 것을 주의하세요. 행렬의 세로 길이(행 개수) rows, 가로 길이(열 개수) columns, 그리고 회전들의 목록 queries가 주어질 때, 각 회전들을 배열에 적용한 뒤, 그 회전에 의해 위치가 바뀐 숫자들 중 가장 작은 숫자들을 순서대로 배열에 담아 return 하도록 solution 함수를 완성해주세요. 제한사항 rows는 2 이상 100 이하인 자연수입니다. columns는 2 이상 100 이하인 자연수입니다. 처음에 행렬에는 가로 방향으로 숫자가 1부터 하나씩 증가하면서 적혀있습니다. 즉, 아무 회전도 하지 않았을 때, i 행 j 열에 있는 숫자는 ((i-1) x columns + j)입니다. queries의 행의 개수(회전의 개수)는 1 이상 10,000 이하입니다. queries의 각 행은 4개의 정수 [x1, y1, x2, y2]입니다. x1 행 y1 열부터 x2 행 y2 열까지 영역의 테두리를 시계방향으로 회전한다는 뜻입니다. 1 ≤ x1 < x2 ≤ rows, 1 ≤ y1 < y2 ≤ columns입니다. 모든 회전은 순서대로 이루어집니다. 예를 들어, 두 번째 회전에 대한 답은 첫 번째 회전을 실행한 다음, 그 상태에서 두 번째 회전을 실행했을 때 이동한 숫자 중 최솟값을 구하면 됩니다. 입출력 예시 rows columns queries result 6 6 [[2,2,5,4],[3,3,6,6],[5,1,6,3]] [8, 10, 25] 3 3 [[1,1,2,2],[1,2,2,3],[2,1,3,2],[2,2,3,3]] [1, 1, 5, 3] 100 97 [[1,1,100,97]] [1] 입출력 예 설명 입출력 예 #1 회전을 수행하는 과정을 그림으로 표현하면 다음과 같습니다. 입출력 예 #2 회전을 수행하는 과정을 그림으로 표현하면 다음과 같습니다. 입출력 예 #3 이 예시에서는 행렬의 테두리에 위치한 모든 칸들이 움직입니다. 따라서, 행렬의 테두리에 있는 수 중 가장 작은 숫자인 1이 바로 답이 됩니다.",normal,Array
404,"로또 6/45(이하 '로또'로 표기)는 1부터 45까지의 숫자 중 6개를 찍어서 맞히는 대표적인 복권입니다. 아래는 로또의 순위를 정하는 방식입니다. 1 순위 당첨 내용 1 6개 번호가 모두 일치 2 5개 번호가 일치 3 4개 번호가 일치 4 3개 번호가 일치 5 2개 번호가 일치 6(낙첨) 그 외 로또를 구매한 민우는 당첨 번호 발표일을 학수고대하고 있었습니다. 하지만, 민우의 동생이 로또에 낙서를 하여, 일부 번호를 알아볼 수 없게 되었습니다. 당첨 번호 발표 후, 민우는 자신이 구매했던 로또로 당첨이 가능했던 최고 순위와 최저 순위를 알아보고 싶어 졌습니다. 알아볼 수 없는 번호를 0으로 표기하기로 하고, 민우가 구매한 로또 번호 6개가 44, 1, 0, 0, 31 25라고 가정해보겠습니다. 당첨 번호 6개가 31, 10, 45, 1, 6, 19라면, 당첨 가능한 최고 순위와 최저 순위의 한 예는 아래와 같습니다. 당첨 번호 31 10 45 1 6 19 결과 최고 순위 번호 31 0→10 44 1 0→6 25 4개 번호 일치, 3등 최저 순위 번호 31 0→11 44 1 0→7 25 2개 번호 일치, 5등 순서와 상관없이, 구매한 로또에 당첨 번호와 일치하는 번호가 있으면 맞힌 걸로 인정됩니다. 알아볼 수 없는 두 개의 번호를 각각 10, 6이라고 가정하면 3등에 당첨될 수 있습니다. 3등을 만드는 다른 방법들도 존재합니다. 하지만, 2등 이상으로 만드는 것은 불가능합니다. 알아볼 수 없는 두 개의 번호를 각각 11, 7이라고 가정하면 5등에 당첨될 수 있습니다. 5등을 만드는 다른 방법들도 존재합니다. 하지만, 6등(낙첨)으로 만드는 것은 불가능합니다. 민우가 구매한 로또 번호를 담은 배열 lottos, 당첨 번호를 담은 배열 win_nums가 매개변수로 주어집니다. 이때, 당첨 가능한 최고 순위와 최저 순위를 차례대로 배열에 담아서 return 하도록 solution 함수를 완성해주세요. 제한사항 lottos는 길이 6인 정수 배열입니다. lottos의 모든 원소는 0 이상 45 이하인 정수입니다. 0은 알아볼 수 없는 숫자를 의미합니다. 0을 제외한 다른 숫자들은 lottos에 2개 이상 담겨있지 않습니다. lottos의 원소들은 정렬되어 있지 않을 수도 있습니다. win_nums은 길이 6인 정수 배열입니다. win_nums의 모든 원소는 1 이상 45 이하인 정수입니다. win_nums에는 같은 숫자가 2개 이상 담겨있지 않습니다. win_nums의 원소들은 정렬되어 있지 않을 수도 있습니다. 입출력 예 lottos win_nums result [44, 1, 0, 0, 31, 25] [31, 10, 45, 1, 6, 19] [3, 5] [0, 0, 0, 0, 0, 0] [38, 19, 20, 40, 15, 25] [1, 6] [45, 4, 35, 20, 3, 9] [20, 9, 3, 45, 4, 35] [1, 1] 입출력 예 설명 입출력 예 #1 문제 예시와 같습니다. 입출력 예 #2 알아볼 수 없는 번호들이 아래와 같았다면, 1등과 6등에 당첨될 수 있습니다. 당첨 번호 38 19 20 40 15 25 결과 최고 순위 번호 0→38 0→19 0→20 0→40 0→15 0→25 6개 번호 일치, 1등 최저 순위 번호 0→21 0→22 0→23 0→24 0→26 0→27 0개 번호 일치, 6등 입출력 예 #3 민우가 구매한 로또의 번호와 당첨 번호가 모두 일치하므로, 최고 순위와 최저 순위는 모두 1등입니다. 실제로 사용되는 로또 순위의 결정 방식과는 약간 다르지만, 이 문제에서는 지문에 명시된 대로 로또 순위를 결정하도록 합니다. ↩",easy,Array
405,"당신은 어떤 RPG 게임의 주인공입니다. 게임에는 n개의 도시(0번, 1번, ..., n-1번)와 m개의 도시 간 도로, 그리고 상수값 z가 있습니다. 각 도로는 일방통행이며, 도로마다 다른 가중치값 w (이 w는 z보다 항상 작습니다)를 가지고 있습니다. 당신은 게임 도중 매 턴당 다음 행동 중 하나를 취할 수 있습니다. 현재 있는 도시에서 연결된 도로를 따라 다른 도시로 이동합니다. 해당 도로의 가중치값을 w라고 할 때, w원을 얻습니다. 현재 있는 도시에서 움직이지 않고 z원을 얻습니다. 원하는 아무 도시로 순간 이동합니다. 이때 얻는 돈은 없습니다. 여기서 주의해야 할 점은, 같은 도로를 몇 번을 사용하든 그 도로를 사용할 때마다 얻는 금액은 동일하다는 것입니다. 이때, 당신에게 q개의 쿼리가 주어집니다. 각 쿼리는 단일 숫자 c로 이루어져 있으며, 당신은 이 게임을 0번 도시에서 0원을 가진 상태에서 시작했을 때, 정확히 c원을 얻는 것이 가능한지, 가능하다면 최소 몇 턴만에 c원을 얻을 수 있는지를 판별해야 합니다. 도시의 숫자 n, 게임의 상수값 z, 도시 간 도로의 정보 roads, 그리고 쿼리들로 이루어진 배열 queries가 매개변수로 주어집니다. 주어진 정보들을 활용하여 각 쿼리의 답(불가능한 경우 -1)을 배열에 담아 return 하도록 solution 함수를 완성해주세요. 제한사항 n은 2 이상 3,000 이하입니다. z는 2 이상 50 이하입니다. roads의 길이는 1 이상 3,000 이하입니다. roads의 각 행은 [u, v, w] 3개의 정수로 이루어져 있으며, 이는 u번 도시부터 v번 도시까지 도로가 연결되어 있고, 해당 도로를 따라 이동했을 때 w원을 얻을 수 있음을 의미합니다. 0 ≤ u, v < n 입니다. 1 ≤ w < z 입니다. u와 v는 서로 다른 수입니다. u번 도시에서 v번 도시로 가는 도로는 최대 하나뿐입니다. queries의 길이는 1 이상 100,000 이하입니다. queries의 모든 숫자는 0 이상 1018 이하입니다. 입출력 예 n z roads queries result 5 5 [[1,2,3],[0,3,2]] [0,1,2,3,4,5,6] [0,-1,1,2,3,1,4] 입출력 예 설명 입출력 예 #1 게임에 도시가 5개, z = 5, 그리고 도로가 2개 있습니다. 다음 그림은 각 쿼리 별로 가장 빠르게 해당 금액을 정확히 획득하는 법을 도식화한 것입니다. 0원은 시작할 때부터 가지고 있으므로, 답은 0입니다. 1원을 가지는 것은 불가능하므로, 답은 -1입니다. 2원을 가지기 위해서는 0번 도시에서 3번 도시로 도로를 타고 이동하면 가장 빠르므로, 답은 1입니다. 3원을 가지기 위해서는 0번 도시에서 1번 도시로 순간 이동한 뒤, 2번 도시로 도로를 타고 이동하면 가장 빠르므로, 답은 2입니다. 4원을 가지기 위해서는 0번 도시에서 3번 도시로 도로를 타고 이동하고, 다시 0번 도시로 순간 이동해서 똑같은 도로를 다시 사용하면 가장 빠르므로, 답은 3입니다. 5원을 가지기 위해서는 0번 도시에서 가만히 있으면(2번째 행동) 가장 빠르므로, 답은 1입니다. 6원을 가지기 위해서는 1번 도시로 순간이동하고, 2번 도시로 도로를 타고 이동하고, 다시 1번 도시로 순간 이동해서 똑같은 도로를 다시 사용하면 가장 빠르므로, 답은 4입니다. 따라서, [0,-1,1,2,3,1,4] 를 return 해야 합니다.",hard,Array
406,"각 점에 가중치가 부여된 트리가 주어집니다. 당신은 다음 연산을 통하여, 이 트리의 모든 점들의 가중치를 0으로 만들고자 합니다. 임의의 연결된 두 점을 골라서 한쪽은 1 증가시키고, 다른 한쪽은 1 감소시킵니다. 하지만, 모든 트리가 위의 행동을 통하여 모든 점들의 가중치를 0으로 만들 수 있는 것은 아닙니다. 당신은 주어진 트리에 대해서 해당 사항이 가능한지 판별하고, 만약 가능하다면 최소한의 행동을 통하여 모든 점들의 가중치를 0으로 만들고자 합니다. 트리의 각 점의 가중치를 의미하는 1차원 정수 배열 a와 트리의 간선 정보를 의미하는 edges가 매개변수로 주어집니다. 주어진 행동을 통해 트리의 모든 점들의 가중치를 0으로 만드는 것이 불가능하다면 -1을, 가능하다면 최소 몇 번만에 가능한지를 찾아 return 하도록 solution 함수를 완성해주세요. (만약 처음부터 트리의 모든 정점의 가중치가 0이라면, 0을 return 해야 합니다.) 제한사항 a의 길이는 2 이상 300,000 이하입니다. a의 모든 수는 각각 -1,000,000 이상 1,000,000 이하입니다. a[i]는 i번 정점의 가중치를 의미합니다. edges의 행의 개수는 (a의 길이 - 1)입니다. edges의 각 행은 [u, v] 2개의 정수로 이루어져 있으며, 이는 u번 정점과 v번 정점이 간선으로 연결되어 있음을 의미합니다. edges가 나타내는 그래프는 항상 트리로 주어집니다. 입출력 예 a edges result [-5,0,2,1,2] [[0,1],[3,4],[2,3],[0,3]] 9 [0,1,0] [[0,1],[1,2]] -1 입출력 예 설명 입출력 예 #1 다음 그림은 주어진 트리의 모든 정점의 가중치를 0으로 만드는 과정을 나타낸 것입니다. 2번 정점과 3번 정점을 선택하여 2번 정점은 1 감소시키고, 3번 정점은 1 증가시킵니다. (2번 반복) 3번 정점과 4번 정점을 선택하여 4번 정점은 1 감소시키고, 3번 정점은 1 증가시킵니다. (2번 반복) 0번 정점과 3번 정점을 선택하여 3번 정점은 1 감소시키고, 0번 정점은 1 증가시킵니다. (5번 반복) 모든 정점의 가중치를 0으로 만드는 데 필요한 최소 행동 횟수는 9번이므로, 9를 return 해야 합니다. 입출력 예 #2 주어진 트리는 모든 정점의 가중치를 0으로 만드는 것이 불가능하므로, -1을 return 해야 합니다.",normal,Array
407,"다음 규칙을 지키는 문자열을 올바른 괄호 문자열이라고 정의합니다. (), [], {} 는 모두 올바른 괄호 문자열입니다. 만약 A가 올바른 괄호 문자열이라면, (A), [A], {A} 도 올바른 괄호 문자열입니다. 예를 들어, [] 가 올바른 괄호 문자열이므로, ([]) 도 올바른 괄호 문자열입니다. 만약 A, B가 올바른 괄호 문자열이라면, AB 도 올바른 괄호 문자열입니다. 예를 들어, {} 와 ([]) 가 올바른 괄호 문자열이므로, {}([]) 도 올바른 괄호 문자열입니다. 대괄호, 중괄호, 그리고 소괄호로 이루어진 문자열 s가 매개변수로 주어집니다. 이 s를 왼쪽으로 x (0 ≤ x < (s의 길이)) 칸만큼 회전시켰을 때 s가 올바른 괄호 문자열이 되게 하는 x의 개수를 return 하도록 solution 함수를 완성해주세요. 제한사항 s의 길이는 1 이상 1,000 이하입니다. 입출력 예 s result ""[](){}"" 3 ""}]()[{"" 2 ""[)(]"" 0 ""}}}"" 0 입출력 예 설명 입출력 예 #1 다음 표는 ""[](){}"" 를 회전시킨 모습을 나타낸 것입니다. x s를 왼쪽으로 x칸만큼 회전 올바른 괄호 문자열? 0 ""[](){}"" O 1 ""](){}["" X 2 ""(){}[]"" O 3 ""){}[]("" X 4 ""{}[]()"" O 5 ""}[](){"" X 올바른 괄호 문자열이 되는 x가 3개이므로, 3을 return 해야 합니다. 입출력 예 #2 다음 표는 ""}]()[{"" 를 회전시킨 모습을 나타낸 것입니다. x s를 왼쪽으로 x칸만큼 회전 올바른 괄호 문자열? 0 ""}]()[{"" X 1 ""]()[{}"" X 2 ""()[{}]"" O 3 "")[{}]("" X 4 ""[{}]()"" O 5 ""{}]()["" X 올바른 괄호 문자열이 되는 x가 2개이므로, 2를 return 해야 합니다. 입출력 예 #3 s를 어떻게 회전하더라도 올바른 괄호 문자열을 만들 수 없으므로, 0을 return 해야 합니다. 입출력 예 #4 s를 어떻게 회전하더라도 올바른 괄호 문자열을 만들 수 없으므로, 0을 return 해야 합니다. ※ 공지 - 2021년 4월 16일 테스트케이스가 추가되었습니다.",normal,String
408,"어떤 정수들이 있습니다. 이 정수들의 절댓값을 차례대로 담은 정수 배열 absolutes와 이 정수들의 부호를 차례대로 담은 불리언 배열 signs가 매개변수로 주어집니다. 실제 정수들의 합을 구하여 return 하도록 solution 함수를 완성해주세요. 제한사항 absolutes의 길이는 1 이상 1,000 이하입니다. absolutes의 모든 수는 각각 1 이상 1,000 이하입니다. signs의 길이는 absolutes의 길이와 같습니다. signs[i] 가 참이면 absolutes[i] 의 실제 정수가 양수임을, 그렇지 않으면 음수임을 의미합니다. 입출력 예 absolutes signs result [4,7,12] [true,false,true] 9 [1,2,3] [false,false,true] 0 입출력 예 설명 입출력 예 #1 signs가 [true,false,true] 이므로, 실제 수들의 값은 각각 4, -7, 12입니다. 따라서 세 수의 합인 9를 return 해야 합니다. 입출력 예 #2 signs가 [false,false,true] 이므로, 실제 수들의 값은 각각 -1, -2, 3입니다. 따라서 세 수의 합인 0을 return 해야 합니다.",easy,Array
409,"유통전문회사 카카오상사의 오너인 제이지는 새로운 사업 아이템을 구상하기 위해 전문경영인(CEO)인 프로도에게 회사의 경영을 부탁하였습니다. ""카카오상사""는 직원들을 여러 개의 팀 단위로 조직을 구성하고 있으며 아래 그림은 CEO를 포함하여 10명의 직원과 4개의 팀으로 구성되어 있는 회사 조직도를 보여주고 있습니다. 그림의 조직도는 다음과 같이 설명할 수 있습니다. 그림의 각 원들은 각각의 직원 1명을 표시하고 있으며, CEO를 포함하여 총 10명의 직원을 표시하고 있습니다. 원 안에 적힌 두 개의 숫자는 직원의 정보를 담고 있습니다. 왼쪽 숫자는 직원번호이며 직원을 식별할 수 있도록 1번부터 순서대로 발급되는 일련번호이며, 오른쪽 숫자는 해당 직원의 하루평균 매출액을 나타냅니다. 위 그림에서 1번 직원은 14원을, 9번 직원은 28원의 하루평균 매출액을 기록하고 있습니다. CEO를 포함하여 모든 직원은 팀장 또는 팀원이라는 직위를 가지고 있으며 그림에서는 팀장과 팀원의 관계를 화살표로 표시하고 있습니다. 화살표가 시작되는 쪽의 직원은 팀장, 화살표를 받는 쪽의 직원은 팀원을 의미합니다. 3-1. 직원번호 1번은 회사의 CEO로 고정되어 있으며, CEO는 항상 팀장이고 팀원일 수 없어 화살표를 받는 쪽이 될 수 없습니다. 3-2. 반면에 CEO를 제외한 나머지 모든 직원들은 다른 누군가로부터 정확히 1개의 화살표를 받게 됩니다. 3-3. 한 직원은 최대 2개의 팀에 소속될 수 있습니다. 만약 어떤 직원이 두 개의 팀에 소속되어 있다면, 반드시 하나의 팀에서는 팀장, 나머지 팀에서는 팀원이어야 합니다. 팀장을 겸임하거나, 두 개의 팀에서 팀원이 될 수는 없습니다. 예를들어 10번 직원은 D팀의 팀장이면서 동시에 5번 직원이 팀장으로 있는 C팀에 속한 팀원입니다. 3-4. 5번, 9번, 10번 직원은 받는 쪽의 화살표와 시작하는 화살표가 모두 있으므로 팀장인 동시에 팀원입니다. 3-5. 2번, 3번, 4번, 6번, 7번, 8번 직원은 시작하는 화살표가 없고 받는 쪽의 화살표만 있으므로 팀장이 아니며 오직 팀원입니다. 3-6. 1번 직원인 CEO는 받는 쪽의 화살표가 없고 시작하는 화살표만 있으며 항상 팀원이 아닌 팀장입니다. 3-7. 그림의 조직도에는 A, B, C, D 총 4개의 팀이 존재하며, 각각 1번, 9번, 5번, 10번 직원이 팀장 직위를 담당하게 됩니다. ""제이지""는 자신이 구상한 새로운 사업 아이템에 대해 직원들에게 설명하고자 하루 일정으로 워크숍을 계획하고 있습니다. 단, 모든 직원을 참석시킬 수 없어 아래와 같은 기준으로 워크숍에 참석할 직원들을 선발하려고 합니다. 워크숍에서 교육받은 내용은 전 직원들에게 공유되어야 하므로 모든 팀은 최소 1명 이상의 직원을 워크숍에 참석시켜야 합니다. 워크숍 기간 동안, 회사의 매출 손실을 최소화하는 것이 중요하므로 워크숍에 참석하는 직원들의 하루평균 매출액의 합이 최소가 되어야 합니다. 위 그림의 조직도에서 회색으로 색칠된 1번, 7번, 10번 직원을 워크숍에 참석시키면 모든 팀에서 최소 한 명 이상의 직원을 참석시킨 것이 되며, 해당 직원들의 하루평균 매출액의 합은 44(14+13+17)원 입니다. 10번 직원은 C팀과 D팀 모두에 속해 있으므로, 두 팀에서 모두 참석한 것으로 인정됩니다. [문제] 직원들의 하루평균 매출액 값을 담은 배열 sales, 직원들의 팀장-팀원의 관계를 나타내는 2차원 배열 links가 매개변수로 주어집니다. 이때, 모든 팀에서 최소 한 명 이상 워크숍에 참석하면서, 참석하는 직원들의 하루평균 매출액의 합을 최소로 하려고 합니다. 그렇게 최소화된 매출액의 합을 구해서 return 하도록 solution 함수를 완성해 주세요. [제한사항] sales 배열의 크기는 2 이상 300,000 이하입니다. sales 배열의 크기는 CEO를 포함한 전체 직원 수와 같습니다. sales 배열은 각 직원들의 하루평균 매출액을 담고 있으며, 1번 직원부터 직원번호 순서대로 주어집니다. sales 배열의 각 원소의 값은 0 이상 10,000 이하인 정수입니다. links 배열의 크기는 sales 배열의 크기 - 1 입니다. 즉, 전체 직원 수보다 1이 작습니다. links 배열의 각 원소는 [a, b] 형식입니다. a는 팀장의 직원번호, b는 a팀장이 관리하는 팀원의 직원번호이며, a와 b는 서로 다른 자연수입니다. 1 ≤ a ≤ sales 배열의 크기 입니다. 2 ≤ b ≤ sales 배열의 크기 입니다. 직원번호 1은 CEO로 정해져 있고 CEO는 항상 팀장으므로 b ≠ 1 입니다. links 배열로 만들어지는 조직도는 하나의 트리 구조 형태입니다. 정답으로 return 되는 값은 231 - 1 이하인 자연수임이 보장됩니다. [입출력 예] sales links result [14, 17, 15, 18, 19, 14, 13, 16, 28, 17] [[10, 8], [1, 9], [9, 7], [5, 4], [1, 5], [5, 10], [10, 6], [1, 3], [10, 2]] 44 [5, 6, 5, 3, 4] [[2,3], [1,4], [2,5], [1,2]] 6 [5, 6, 5, 1, 4] [[2,3], [1,4], [2,5], [1,2]] 5 [10, 10, 1, 1] [[3,2], [4,3], [1,4]] 2 입출력 예에 대한 설명 입출력 예 #1 문제 예시와 같습니다. 입출력 예 #2 직원번호가 2인 직원 한 명을 워크숍에 참석시키는 것이 최선이며, 2번 직원의 하루평균 매출액은 6원입니다. 따라서 6을 return 해주어야 합니다. 입출력 예 #3 직원번호가 4, 5인 직원 두 명을 워크숍에 참석시키는 것이 최선이며, 4번, 5번 직원의 하루평균 매출액의 합은 5(1+4)원 입니다. 따라서 5를 return 해주어야 합니다. 입출력 예 #4 직원번호가 3, 4인 직원 두 명을 워크숍에 참석시키는 것이 최선이며, 3번, 4번 직원의 하루평균 매출액의 합은 2(1+1)원 입니다. 따라서 2를 return 해주어야 합니다.",hard,Array
410,"게임 개발자인 베로니는 개발 연습을 위해 다음과 같은 간단한 카드 짝맞추기 보드 게임을 개발해 보려고 합니다. 게임이 시작되면 화면에는 카드 16장이 뒷면을 위로하여 4 x 4 크기의 격자 형태로 표시되어 있습니다. 각 카드의 앞면에는 카카오프렌즈 캐릭터 그림이 그려져 있으며, 8가지의 캐릭터 그림이 그려진 카드가 각기 2장씩 화면에 무작위로 배치되어 있습니다. 유저가 카드를 2장 선택하여 앞면으로 뒤집었을 때 같은 그림이 그려진 카드면 해당 카드는 게임 화면에서 사라지며, 같은 그림이 아니라면 원래 상태로 뒷면이 보이도록 뒤집힙니다. 이와 같은 방법으로 모든 카드를 화면에서 사라지게 하면 게임이 종료됩니다. 게임에서 카드를 선택하는 방법은 다음과 같습니다. 카드는 커서를 이용해서 선택할 수 있습니다. 커서는 4 x 4 화면에서 유저가 선택한 현재 위치를 표시하는 ""굵고 빨간 테두리 상자""를 의미합니다. 커서는 [Ctrl] 키와 방향키에 의해 이동되며 키 조작법은 다음과 같습니다. 방향키 ←, ↑, ↓, → 중 하나를 누르면, 커서가 누른 키 방향으로 1칸 이동합니다. [Ctrl] 키를 누른 상태에서 방향키 ←, ↑, ↓, → 중 하나를 누르면, 누른 키 방향에 있는 가장 가까운 카드로 한번에 이동합니다. 만약, 해당 방향에 카드가 하나도 없다면 그 방향의 가장 마지막 칸으로 이동합니다. 만약, 누른 키 방향으로 이동 가능한 카드 또는 빈 공간이 없어 이동할 수 없다면 커서는 움직이지 않습니다. 커서가 위치한 카드를 뒤집기 위해서는 [Enter] 키를 입력합니다. [Enter] 키를 입력해서 카드를 뒤집었을 때 앞면이 보이는 카드가 1장 뿐이라면 그림을 맞출 수 없으므로 두번째 카드를 뒤집을 때 까지 앞면을 유지합니다. 앞면이 보이는 카드가 2장이 된 경우, 두개의 카드에 그려진 그림이 같으면 해당 카드들이 화면에서 사라지며, 그림이 다르다면 두 카드 모두 뒷면이 보이도록 다시 뒤집힙니다. ""베로니""는 게임 진행 중 카드의 짝을 맞춰 몇 장 제거된 상태에서 카드 앞면의 그림을 알고 있다면, 남은 카드를 모두 제거하는데 필요한 키 조작 횟수의 최솟값을 구해 보려고 합니다. 키 조작 횟수는 방향키와 [Enter] 키를 누르는 동작을 각각 조작 횟수 1로 계산하며, [Ctrl] 키와 방향키를 함께 누르는 동작 또한 조작 횟수 1로 계산합니다. 다음은 카드가 몇 장 제거된 상태의 게임 화면에서 커서를 이동하는 예시입니다. 아래 그림에서 빈 칸은 이미 카드가 제거되어 없어진 칸을 의미하며, 그림이 그려진 칸은 카드 앞 면에 그려진 그림을 나타냅니다. 예시에서 커서는 두번째 행, 첫번째 열 위치에서 시작하였습니다. [Enter] 입력, ↓ 이동, [Ctrl]+→ 이동, [Enter] 입력 = 키 조작 4회 [Ctrl]+↑ 이동, [Enter] 입력, [Ctrl]+← 이동, [Ctrl]+↓ 이동, [Enter] 입력 = 키 조작 5회 [Ctrl]+→ 이동, [Enter] 입력, [Ctrl]+↑ 이동, [Ctrl]+← 이동, [Enter] 입력 = 키 조작 5회 위와 같은 방법으로 커서를 이동하여 카드를 선택하고 그림을 맞추어 카드를 모두 제거하기 위해서는 총 14번(방향 이동 8번, [Enter] 키 입력 6번)의 키 조작 횟수가 필요합니다. [문제] 현재 카드가 놓인 상태를 나타내는 2차원 배열 board와 커서의 처음 위치 r, c가 매개변수로 주어질 때, 모든 카드를 제거하기 위한 키 조작 횟수의 최솟값을 return 하도록 solution 함수를 완성해 주세요. [제한사항] board는 4 x 4 크기의 2차원 배열입니다. board 배열의 각 원소는 0 이상 6 이하인 자연수입니다. 0은 카드가 제거된 빈 칸을 나타냅니다. 1 부터 6까지의 자연수는 2개씩 들어있으며 같은 숫자는 같은 그림의 카드를 의미합니다. 뒤집을 카드가 없는 경우(board의 모든 원소가 0인 경우)는 입력으로 주어지지 않습니다. r은 커서의 최초 세로(행) 위치를 의미합니다. c는 커서의 최초 가로(열) 위치를 의미합니다. r과 c는 0 이상 3 이하인 정수입니다. 게임 화면의 좌측 상단이 (0, 0), 우측 하단이 (3, 3) 입니다. [입출력 예] board r c result [[1,0,0,3],[2,0,0,0],[0,0,0,2],[3,0,1,0]] 1 0 14 [[3,0,0,2],[0,0,1,0],[0,1,0,0],[2,0,0,3]] 0 1 16 입출력 예에 대한 설명 입출력 예 #1 문제의 예시와 같습니다. 입출력 예 #2 입력으로 주어진 게임 화면은 아래 그림과 같습니다. 위 게임 화면에서 모든 카드를 제거하기 위한 키 조작 횟수의 최솟값은 16번 입니다.",normal,Array
411,"카카오TV에서 유명한 크리에이터로 활동 중인 죠르디는 환경 단체로부터 자신의 가장 인기있는 동영상에 지구온난화의 심각성을 알리기 위한 공익광고를 넣어 달라는 요청을 받았습니다. 평소에 환경 문제에 관심을 가지고 있던 ""죠르디""는 요청을 받아들였고 광고효과를 높이기 위해 시청자들이 가장 많이 보는 구간에 공익광고를 넣으려고 합니다. ""죠르디""는 시청자들이 해당 동영상의 어떤 구간을 재생했는 지 알 수 있는 재생구간 기록을 구했고, 해당 기록을 바탕으로 공익광고가 삽입될 최적의 위치를 고를 수 있었습니다. 참고로 광고는 재생 중인 동영상의 오른쪽 아래에서 원래 영상과 동시에 재생되는 PIP(Picture in Picture) 형태로 제공됩니다. 다음은 ""죠르디""가 공익광고가 삽입될 최적의 위치를 고르는 과정을 그림으로 설명한 것입니다. 그림의 파란색 선은 광고를 검토 중인 ""죠르디"" 동영상의 전체 재생 구간을 나타냅니다. 위 그림에서, ""죠르디"" 동영상의 총 재생시간은 02시간 03분 55초 입니다. 그림의 검은색 선들은 각 시청자들이 ""죠르디""의 동영상을 재생한 구간의 위치를 표시하고 있습니다. 검은색 선의 가운데 숫자는 각 재생 기록을 구분하는 ID를 나타냅니다. 검은색 선에 표기된 왼쪽 끝 숫자와 오른쪽 끝 숫자는 시청자들이 재생한 동영상 구간의 시작 시각과 종료 시각을 나타냅니다. 위 그림에서, 3번 재생 기록은 00시 25분 50초 부터 00시 48분 29초 까지 총 00시간 22분 39초 동안 죠르디의 동영상을 재생했습니다. 1 위 그림에서, 1번 재생 기록은 01시 20분 15초 부터 01시 45분 14초 까지 총 00시간 24분 59초 동안 죠르디의 동영상을 재생했습니다. 그림의 빨간색 선은 ""죠르디""가 선택한 최적의 공익광고 위치를 나타냅니다. 만약 공익광고의 재생시간이 00시간 14분 15초라면, 위의 그림처럼 01시 30분 59초 부터 01시 45분 14초 까지 공익광고를 삽입하는 것이 가장 좋습니다. 이 구간을 시청한 시청자들의 누적 재생시간이 가장 크기 때문입니다. 01시 30분 59초 부터 01시 45분 14초 까지의 누적 재생시간은 다음과 같이 계산됩니다. 01시 30분 59초 부터 01시 37분 44초 까지 : 4번, 1번 재생 기록이 두차례 있으므로 재생시간의 합은 00시간 06분 45초 X 2 = 00시간 13분 30초 01시 37분 44초 부터 01시 45분 14초 까지 : 4번, 1번, 5번 재생 기록이 세차례 있으므로 재생시간의 합은 00시간 07분 30초 X 3 = 00시간 22분 30초 따라서, 이 구간 시청자들의 누적 재생시간은 00시간 13분 30초 + 00시간 22분 30초 = 00시간 36분 00초입니다. [문제] ""죠르디""의 동영상 재생시간 길이 play_time, 공익광고의 재생시간 길이 adv_time, 시청자들이 해당 동영상을 재생했던 구간 정보 logs가 매개변수로 주어질 때, 시청자들의 누적 재생시간이 가장 많이 나오는 곳에 공익광고를 삽입하려고 합니다. 이때, 공익광고가 들어갈 시작 시각을 구해서 return 하도록 solution 함수를 완성해주세요. 만약, 시청자들의 누적 재생시간이 가장 많은 곳이 여러 곳이라면, 그 중에서 가장 빠른 시작 시각을 return 하도록 합니다. [제한사항] play_time, adv_time은 길이 8로 고정된 문자열입니다. play_time, adv_time은 HH:MM:SS 형식이며, 00:00:01 이상 99:59:59 이하입니다. 즉, 동영상 재생시간과 공익광고 재생시간은 00시간 00분 01초 이상 99시간 59분 59초 이하입니다. 공익광고 재생시간은 동영상 재생시간보다 짧거나 같게 주어집니다. logs는 크기가 1 이상 300,000 이하인 문자열 배열입니다. logs 배열의 각 원소는 시청자의 재생 구간을 나타냅니다. logs 배열의 각 원소는 길이가 17로 고정된 문자열입니다. logs 배열의 각 원소는 H1:M1:S1-H2:M2:S2 형식입니다. H1:M1:S1은 동영상이 시작된 시각, H2:M2:S2는 동영상이 종료된 시각을 나타냅니다. H1:M1:S1는 H2:M2:S2보다 1초 이상 이전 시각으로 주어집니다. H1:M1:S1와 H2:M2:S2는 play_time 이내의 시각입니다. 시간을 나타내는 HH, H1, H2의 범위는 00~99, 분을 나타내는 MM, M1, M2의 범위는 00~59, 초를 나타내는 SS, S1, S2의 범위는 00~59까지 사용됩니다. 잘못된 시각은 입력으로 주어지지 않습니다. (예: 04:60:24, 11:12:78, 123:12:45 등) return 값의 형식 공익광고를 삽입할 시각을 HH:MM:SS 형식의 8자리 문자열로 반환합니다. [입출력 예] play_time adv_time logs result ""02:03:55"" ""00:14:15"" [""01:20:15-01:45:14"", ""00:40:31-01:00:00"", ""00:25:50-00:48:29"", ""01:30:59-01:53:29"", ""01:37:44-02:02:30""] ""01:30:59"" ""99:59:59"" ""25:00:00"" [""69:59:59-89:59:59"", ""01:00:00-21:00:00"", ""79:59:59-99:59:59"", ""11:00:00-31:00:00""] ""01:00:00"" ""50:00:00"" ""50:00:00"" [""15:36:51-38:21:49"", ""10:14:18-15:36:51"", ""38:21:49-42:51:45""] ""00:00:00"" 입출력 예에 대한 설명 입출력 예 #1 문제 예시와 같습니다. 입출력 예 #2 01:00:00에 공익광고를 삽입하면 26:00:00까지 재생되며, 이곳이 가장 좋은 위치입니다. 이 구간의 시청자 누적 재생시간은 다음과 같습니다. 01:00:00-11:00:00 : 해당 구간이 1회(2번 기록) 재생되었으므로 누적 재생시간은 10시간 00분 00초 입니다. 11:00:00-21:00:00 : 해당 구간이 2회(2번, 4번 기록) 재생되었으므로 누적 재생시간은 20시간 00분 00초 입니다. 21:00:00-26:00:00 : 해당 구간이 1회(4번 기록) 재생되었으므로 누적 재생시간은 05시간 00분 00초 입니다. 따라서, 이 구간의 시청자 누적 재생시간은 10시간 00분 00초 + 20시간 00분 00초 + 05시간 00분 00초 = 35시간 00분 00초 입니다. 초록색으로 표시된 구간(69:59:59-94:59:59)에 광고를 삽입해도 동일한 결과를 얻을 수 있으나, 01:00:00이 69:59:59 보다 빠른 시각이므로, ""01:00:00""을 return 합니다. 입출력 예 #3 동영상 재생시간과 공익광고 재생시간이 같으므로, 삽입할 수 있는 위치는 맨 처음(00:00:00)이 유일합니다. 동영상 재생시간 = 재생이 종료된 시각 - 재생이 시작된 시각(예를 들어, 00시 00분 01초부터 00시 00분 10초까지 동영상이 재생되었다면, 동영상 재생시간은 9초 입니다.) ↩",normal,Array
412,"[본 문제는 정확성과 효율성 테스트 각각 점수가 있는 문제입니다.] 밤늦게 귀가할 때 안전을 위해 항상 택시를 이용하던 무지는 최근 야근이 잦아져 택시를 더 많이 이용하게 되어 택시비를 아낄 수 있는 방법을 고민하고 있습니다. ""무지""는 자신이 택시를 이용할 때 동료인 어피치 역시 자신과 비슷한 방향으로 가는 택시를 종종 이용하는 것을 알게 되었습니다. ""무지""는 ""어피치""와 귀가 방향이 비슷하여 택시 합승을 적절히 이용하면 택시요금을 얼마나 아낄 수 있을 지 계산해 보고 ""어피치""에게 합승을 제안해 보려고 합니다. 위 예시 그림은 택시가 이동 가능한 반경에 있는 6개 지점 사이의 이동 가능한 택시노선과 예상요금을 보여주고 있습니다. 그림에서 A와 B 두 사람은 출발지점인 4번 지점에서 출발해서 택시를 타고 귀가하려고 합니다. A의 집은 6번 지점에 있으며 B의 집은 2번 지점에 있고 두 사람이 모두 귀가하는 데 소요되는 예상 최저 택시요금이 얼마인 지 계산하려고 합니다. 그림의 원은 지점을 나타내며 원 안의 숫자는 지점 번호를 나타냅니다. 지점이 n개일 때, 지점 번호는 1부터 n까지 사용됩니다. 지점 간에 택시가 이동할 수 있는 경로를 간선이라 하며, 간선에 표시된 숫자는 두 지점 사이의 예상 택시요금을 나타냅니다. 간선은 편의 상 직선으로 표시되어 있습니다. 위 그림 예시에서, 4번 지점에서 1번 지점으로(4→1) 가거나, 1번 지점에서 4번 지점으로(1→4) 갈 때 예상 택시요금은 10원으로 동일하며 이동 방향에 따라 달라지지 않습니다. 예상되는 최저 택시요금은 다음과 같이 계산됩니다. 4→1→5 : A, B가 합승하여 택시를 이용합니다. 예상 택시요금은 10 + 24 = 34원 입니다. 5→6 : A가 혼자 택시를 이용합니다. 예상 택시요금은 2원 입니다. 5→3→2 : B가 혼자 택시를 이용합니다. 예상 택시요금은 24 + 22 = 46원 입니다. A, B 모두 귀가 완료까지 예상되는 최저 택시요금은 34 + 2 + 46 = 82원 입니다. [문제] 지점의 개수 n, 출발지점을 나타내는 s, A의 도착지점을 나타내는 a, B의 도착지점을 나타내는 b, 지점 사이의 예상 택시요금을 나타내는 fares가 매개변수로 주어집니다. 이때, A, B 두 사람이 s에서 출발해서 각각의 도착 지점까지 택시를 타고 간다고 가정할 때, 최저 예상 택시요금을 계산해서 return 하도록 solution 함수를 완성해 주세요. 만약, 아예 합승을 하지 않고 각자 이동하는 경우의 예상 택시요금이 더 낮다면, 합승을 하지 않아도 됩니다. [제한사항] 지점갯수 n은 3 이상 200 이하인 자연수입니다. 지점 s, a, b는 1 이상 n 이하인 자연수이며, 각기 서로 다른 값입니다. 즉, 출발지점, A의 도착지점, B의 도착지점은 서로 겹치지 않습니다. fares는 2차원 정수 배열입니다. fares 배열의 크기는 2 이상 n x (n-1) / 2 이하입니다. 예를들어, n = 6이라면 fares 배열의 크기는 2 이상 15 이하입니다. (6 x 5 / 2 = 15) fares 배열의 각 행은 [c, d, f] 형태입니다. c지점과 d지점 사이의 예상 택시요금이 f원이라는 뜻입니다. 지점 c, d는 1 이상 n 이하인 자연수이며, 각기 서로 다른 값입니다. 요금 f는 1 이상 100,000 이하인 자연수입니다. fares 배열에 두 지점 간 예상 택시요금은 1개만 주어집니다. 즉, [c, d, f]가 있다면 [d, c, f]는 주어지지 않습니다. 출발지점 s에서 도착지점 a와 b로 가는 경로가 존재하는 경우만 입력으로 주어집니다. [입출력 예] n s a b fares result 6 4 6 2 [[4, 1, 10], [3, 5, 24], [5, 6, 2], [3, 1, 41], [5, 1, 24], [4, 6, 50], [2, 4, 66], [2, 3, 22], [1, 6, 25]] 82 7 3 4 1 [[5, 7, 9], [4, 6, 4], [3, 6, 1], [3, 2, 3], [2, 1, 6]] 14 6 4 5 6 [[2,6,6], [6,3,7], [4,6,7], [6,5,11], [2,5,12], [5,3,20], [2,4,8], [4,3,9]] 18 입출력 예에 대한 설명 입출력 예 #1 문제 예시와 같습니다. 입출력 예 #2 합승을 하지 않고, B는 3→2→1, A는 3→6→4 경로로 각자 택시를 타고 가는 것이 최저 예상 택시요금입니다. 따라서 최저 예상 택시요금은 (3 + 6) + (1 + 4) = 14원 입니다. 입출력 예 #3 A와 B가 4→6 구간을 합승하고 B가 6번 지점에서 내린 후, A가6→5` 구간을 혼자 타고 가는 것이 최저 예상 택시요금입니다. 따라서 최저 예상 택시요금은 7 + 11 = 18원 입니다.",normal,Array
413,"[본 문제는 정확성과 효율성 테스트 각각 점수가 있는 문제입니다.] 카카오는 하반기 경력 개발자 공개채용을 진행 중에 있으며 현재 지원서 접수와 코딩테스트가 종료되었습니다. 이번 채용에서 지원자는 지원서 작성 시 아래와 같이 4가지 항목을 반드시 선택하도록 하였습니다. 코딩테스트 참여 개발언어 항목에 cpp, java, python 중 하나를 선택해야 합니다. 지원 직군 항목에 backend와 frontend 중 하나를 선택해야 합니다. 지원 경력구분 항목에 junior와 senior 중 하나를 선택해야 합니다. 선호하는 소울푸드로 chicken과 pizza 중 하나를 선택해야 합니다. 인재영입팀에 근무하고 있는 니니즈는 코딩테스트 결과를 분석하여 채용에 참여한 개발팀들에 제공하기 위해 지원자들의 지원 조건을 선택하면 해당 조건에 맞는 지원자가 몇 명인 지 쉽게 알 수 있는 도구를 만들고 있습니다. 예를 들어, 개발팀에서 궁금해하는 문의사항은 다음과 같은 형태가 될 수 있습니다. 코딩테스트에 java로 참여했으며, backend 직군을 선택했고, junior 경력이면서, 소울푸드로 pizza를 선택한 사람 중 코딩테스트 점수를 50점 이상 받은 지원자는 몇 명인가? 물론 이 외에도 각 개발팀의 상황에 따라 아래와 같이 다양한 형태의 문의가 있을 수 있습니다. 코딩테스트에 python으로 참여했으며, frontend 직군을 선택했고, senior 경력이면서, 소울푸드로 chicken을 선택한 사람 중 코딩테스트 점수를 100점 이상 받은 사람은 모두 몇 명인가? 코딩테스트에 cpp로 참여했으며, senior 경력이면서, 소울푸드로 pizza를 선택한 사람 중 코딩테스트 점수를 100점 이상 받은 사람은 모두 몇 명인가? backend 직군을 선택했고, senior 경력이면서 코딩테스트 점수를 200점 이상 받은 사람은 모두 몇 명인가? 소울푸드로 chicken을 선택한 사람 중 코딩테스트 점수를 250점 이상 받은 사람은 모두 몇 명인가? 코딩테스트 점수를 150점 이상 받은 사람은 모두 몇 명인가? 즉, 개발팀에서 궁금해하는 내용은 다음과 같은 형태를 갖습니다. * [조건]을 만족하는 사람 중 코딩테스트 점수를 X점 이상 받은 사람은 모두 몇 명인가? [문제] 지원자가 지원서에 입력한 4가지의 정보와 획득한 코딩테스트 점수를 하나의 문자열로 구성한 값의 배열 info, 개발팀이 궁금해하는 문의조건이 문자열 형태로 담긴 배열 query가 매개변수로 주어질 때, 각 문의조건에 해당하는 사람들의 숫자를 순서대로 배열에 담아 return 하도록 solution 함수를 완성해 주세요. [제한사항] info 배열의 크기는 1 이상 50,000 이하입니다. info 배열 각 원소의 값은 지원자가 지원서에 입력한 4가지 값과 코딩테스트 점수를 합친 ""개발언어 직군 경력 소울푸드 점수"" 형식입니다. 개발언어는 cpp, java, python 중 하나입니다. 직군은 backend, frontend 중 하나입니다. 경력은 junior, senior 중 하나입니다. 소울푸드는 chicken, pizza 중 하나입니다. 점수는 코딩테스트 점수를 의미하며, 1 이상 100,000 이하인 자연수입니다. 각 단어는 공백문자(스페이스 바) 하나로 구분되어 있습니다. query 배열의 크기는 1 이상 100,000 이하입니다. query의 각 문자열은 ""[조건] X"" 형식입니다. [조건]은 ""개발언어 and 직군 and 경력 and 소울푸드"" 형식의 문자열입니다. 언어는 cpp, java, python, - 중 하나입니다. 직군은 backend, frontend, - 중 하나입니다. 경력은 junior, senior, - 중 하나입니다. 소울푸드는 chicken, pizza, - 중 하나입니다. '-' 표시는 해당 조건을 고려하지 않겠다는 의미입니다. X는 코딩테스트 점수를 의미하며 조건을 만족하는 사람 중 X점 이상 받은 사람은 모두 몇 명인 지를 의미합니다. 각 단어는 공백문자(스페이스 바) 하나로 구분되어 있습니다. 예를 들면, ""cpp and - and senior and pizza 500""은 ""cpp로 코딩테스트를 봤으며, 경력은 senior 이면서 소울푸드로 pizza를 선택한 지원자 중 코딩테스트 점수를 500점 이상 받은 사람은 모두 몇 명인가?""를 의미합니다. [입출력 예] info query result [""java backend junior pizza 150"",""python frontend senior chicken 210"",""python frontend senior chicken 150"",""cpp backend senior pizza 260"",""java backend junior chicken 80"",""python backend senior chicken 50""] [""java and backend and junior and pizza 100"",""python and frontend and senior and chicken 200"",""cpp and - and senior and pizza 250"",""- and backend and senior and - 150"",""- and - and - and chicken 100"",""- and - and - and - 150""] [1,1,1,1,2,4] 입출력 예에 대한 설명 지원자 정보를 표로 나타내면 다음과 같습니다. 언어 직군 경력 소울 푸드 점수 java backend junior pizza 150 python frontend senior chicken 210 python frontend senior chicken 150 cpp backend senior pizza 260 java backend junior chicken 80 python backend senior chicken 50 ""java and backend and junior and pizza 100"" : java로 코딩테스트를 봤으며, backend 직군을 선택했고 junior 경력이면서 소울푸드로 pizza를 선택한 지원자 중 코딩테스트 점수를 100점 이상 받은 지원자는 1명 입니다. ""python and frontend and senior and chicken 200"" : python으로 코딩테스트를 봤으며, frontend 직군을 선택했고, senior 경력이면서 소울 푸드로 chicken을 선택한 지원자 중 코딩테스트 점수를 200점 이상 받은 지원자는 1명 입니다. ""cpp and - and senior and pizza 250"" : cpp로 코딩테스트를 봤으며, senior 경력이면서 소울푸드로 pizza를 선택한 지원자 중 코딩테스트 점수를 250점 이상 받은 지원자는 1명 입니다. ""- and backend and senior and - 150"" : backend 직군을 선택했고, senior 경력인 지원자 중 코딩테스트 점수를 150점 이상 받은 지원자는 1명 입니다. ""- and - and - and chicken 100"" : 소울푸드로 chicken을 선택한 지원자 중 코딩테스트 점수를 100점 이상을 받은 지원자는 2명 입니다. ""- and - and - and - 150"" : 코딩테스트 점수를 150점 이상 받은 지원자는 4명 입니다.",normal,Array
414,"레스토랑을 운영하던 스카피는 코로나19로 인한 불경기를 극복하고자 메뉴를 새로 구성하려고 고민하고 있습니다. 기존에는 단품으로만 제공하던 메뉴를 조합해서 코스요리 형태로 재구성해서 새로운 메뉴를 제공하기로 결정했습니다. 어떤 단품메뉴들을 조합해서 코스요리 메뉴로 구성하면 좋을 지 고민하던 ""스카피""는 이전에 각 손님들이 주문할 때 가장 많이 함께 주문한 단품메뉴들을 코스요리 메뉴로 구성하기로 했습니다. 단, 코스요리 메뉴는 최소 2가지 이상의 단품메뉴로 구성하려고 합니다. 또한, 최소 2명 이상의 손님으로부터 주문된 단품메뉴 조합에 대해서만 코스요리 메뉴 후보에 포함하기로 했습니다. 예를 들어, 손님 6명이 주문한 단품메뉴들의 조합이 다음과 같다면, (각 손님은 단품메뉴를 2개 이상 주문해야 하며, 각 단품메뉴는 A ~ Z의 알파벳 대문자로 표기합니다.) 손님 번호 주문한 단품메뉴 조합 1번 손님 A, B, C, F, G 2번 손님 A, C 3번 손님 C, D, E 4번 손님 A, C, D, E 5번 손님 B, C, F, G 6번 손님 A, C, D, E, H 가장 많이 함께 주문된 단품메뉴 조합에 따라 ""스카피""가 만들게 될 코스요리 메뉴 구성 후보는 다음과 같습니다. 코스 종류 메뉴 구성 설명 요리 2개 코스 A, C 1번, 2번, 4번, 6번 손님으로부터 총 4번 주문됐습니다. 요리 3개 코스 C, D, E 3번, 4번, 6번 손님으로부터 총 3번 주문됐습니다. 요리 4개 코스 B, C, F, G 1번, 5번 손님으로부터 총 2번 주문됐습니다. 요리 4개 코스 A, C, D, E 4번, 6번 손님으로부터 총 2번 주문됐습니다. [문제] 각 손님들이 주문한 단품메뉴들이 문자열 형식으로 담긴 배열 orders, ""스카피""가 추가하고 싶어하는 코스요리를 구성하는 단품메뉴들의 갯수가 담긴 배열 course가 매개변수로 주어질 때, ""스카피""가 새로 추가하게 될 코스요리의 메뉴 구성을 문자열 형태로 배열에 담아 return 하도록 solution 함수를 완성해 주세요. [제한사항] orders 배열의 크기는 2 이상 20 이하입니다. orders 배열의 각 원소는 크기가 2 이상 10 이하인 문자열입니다. 각 문자열은 알파벳 대문자로만 이루어져 있습니다. 각 문자열에는 같은 알파벳이 중복해서 들어있지 않습니다. course 배열의 크기는 1 이상 10 이하입니다. course 배열의 각 원소는 2 이상 10 이하인 자연수가 오름차순으로 정렬되어 있습니다. course 배열에는 같은 값이 중복해서 들어있지 않습니다. 정답은 각 코스요리 메뉴의 구성을 문자열 형식으로 배열에 담아 사전 순으로 오름차순 정렬해서 return 해주세요. 배열의 각 원소에 저장된 문자열 또한 알파벳 오름차순으로 정렬되어야 합니다. 만약 가장 많이 함께 주문된 메뉴 구성이 여러 개라면, 모두 배열에 담아 return 하면 됩니다. orders와 course 매개변수는 return 하는 배열의 길이가 1 이상이 되도록 주어집니다. [입출력 예] orders course result [""ABCFG"", ""AC"", ""CDE"", ""ACDE"", ""BCFG"", ""ACDEH""] [2,3,4] [""AC"", ""ACDE"", ""BCFG"", ""CDE""] [""ABCDE"", ""AB"", ""CD"", ""ADE"", ""XYZ"", ""XYZ"", ""ACD""] [2,3,5] [""ACD"", ""AD"", ""ADE"", ""CD"", ""XYZ""] [""XYZ"", ""XWY"", ""WXA""] [2,3,4] [""WX"", ""XY""] 입출력 예에 대한 설명 입출력 예 #1 문제의 예시와 같습니다. 입출력 예 #2 AD가 세 번, CD가 세 번, ACD가 두 번, ADE가 두 번, XYZ 가 두 번 주문됐습니다. 요리 5개를 주문한 손님이 1명 있지만, 최소 2명 이상의 손님에게서 주문된 구성만 코스요리 후보에 들어가므로, 요리 5개로 구성된 코스요리는 새로 추가하지 않습니다. 입출력 예 #3 WX가 두 번, XY가 두 번 주문됐습니다. 3명의 손님 모두 단품메뉴를 3개씩 주문했지만, 최소 2명 이상의 손님에게서 주문된 구성만 코스요리 후보에 들어가므로, 요리 3개로 구성된 코스요리는 새로 추가하지 않습니다. 또, 단품메뉴를 4개 이상 주문한 손님은 없으므로, 요리 4개로 구성된 코스요리 또한 새로 추가하지 않습니다.",normal,Array
415,"카카오에 입사한 신입 개발자 네오는 ""카카오계정개발팀""에 배치되어, 카카오 서비스에 가입하는 유저들의 아이디를 생성하는 업무를 담당하게 되었습니다. ""네오""에게 주어진 첫 업무는 새로 가입하는 유저들이 카카오 아이디 규칙에 맞지 않는 아이디를 입력했을 때, 입력된 아이디와 유사하면서 규칙에 맞는 아이디를 추천해주는 프로그램을 개발하는 것입니다. 다음은 카카오 아이디의 규칙입니다. 아이디의 길이는 3자 이상 15자 이하여야 합니다. 아이디는 알파벳 소문자, 숫자, 빼기(-), 밑줄(_), 마침표(.) 문자만 사용할 수 있습니다. 단, 마침표(.)는 처음과 끝에 사용할 수 없으며 또한 연속으로 사용할 수 없습니다. ""네오""는 다음과 같이 7단계의 순차적인 처리 과정을 통해 신규 유저가 입력한 아이디가 카카오 아이디 규칙에 맞는 지 검사하고 규칙에 맞지 않은 경우 규칙에 맞는 새로운 아이디를 추천해 주려고 합니다. 신규 유저가 입력한 아이디가 new_id 라고 한다면, 1단계 new_id의 모든 대문자를 대응되는 소문자로 치환합니다. 2단계 new_id에서 알파벳 소문자, 숫자, 빼기(-), 밑줄(_), 마침표(.)를 제외한 모든 문자를 제거합니다. 3단계 new_id에서 마침표(.)가 2번 이상 연속된 부분을 하나의 마침표(.)로 치환합니다. 4단계 new_id에서 마침표(.)가 처음이나 끝에 위치한다면 제거합니다. 5단계 new_id가 빈 문자열이라면, new_id에 ""a""를 대입합니다. 6단계 new_id의 길이가 16자 이상이면, new_id의 첫 15개의 문자를 제외한 나머지 문자들을 모두 제거합니다. 만약 제거 후 마침표(.)가 new_id의 끝에 위치한다면 끝에 위치한 마침표(.) 문자를 제거합니다. 7단계 new_id의 길이가 2자 이하라면, new_id의 마지막 문자를 new_id의 길이가 3이 될 때까지 반복해서 끝에 붙입니다. 예를 들어, new_id 값이 ""...!@BaT#*..y.abcdefghijklm"" 라면, 위 7단계를 거치고 나면 new_id는 아래와 같이 변경됩니다. 1단계 대문자 'B'와 'T'가 소문자 'b'와 't'로 바뀌었습니다. ""...!@BaT#*..y.abcdefghijklm"" → ""...!@bat#*..y.abcdefghijklm"" 2단계 '!', '@', '#', '*' 문자가 제거되었습니다. ""...!@bat#*..y.abcdefghijklm"" → ""...bat..y.abcdefghijklm"" 3단계 '...'와 '..' 가 '.'로 바뀌었습니다. ""...bat..y.abcdefghijklm"" → "".bat.y.abcdefghijklm"" 4단계 아이디의 처음에 위치한 '.'가 제거되었습니다. "".bat.y.abcdefghijklm"" → ""bat.y.abcdefghijklm"" 5단계 아이디가 빈 문자열이 아니므로 변화가 없습니다. ""bat.y.abcdefghijklm"" → ""bat.y.abcdefghijklm"" 6단계 아이디의 길이가 16자 이상이므로, 처음 15자를 제외한 나머지 문자들이 제거되었습니다. ""bat.y.abcdefghijklm"" → ""bat.y.abcdefghi"" 7단계 아이디의 길이가 2자 이하가 아니므로 변화가 없습니다. ""bat.y.abcdefghi"" → ""bat.y.abcdefghi"" 따라서 신규 유저가 입력한 new_id가 ""...!@BaT#*..y.abcdefghijklm""일 때, 네오의 프로그램이 추천하는 새로운 아이디는 ""bat.y.abcdefghi"" 입니다. [문제] 신규 유저가 입력한 아이디를 나타내는 new_id가 매개변수로 주어질 때, ""네오""가 설계한 7단계의 처리 과정을 거친 후의 추천 아이디를 return 하도록 solution 함수를 완성해 주세요. [제한사항] new_id는 길이 1 이상 1,000 이하인 문자열입니다. new_id는 알파벳 대문자, 알파벳 소문자, 숫자, 특수문자로 구성되어 있습니다. new_id에 나타날 수 있는 특수문자는 -_.~!@#$%^&*()=+[{]}:?,<>/ 로 한정됩니다. [입출력 예] no new_id result 예1 ""...!@BaT#*..y.abcdefghijklm"" ""bat.y.abcdefghi"" 예2 ""z-+.^."" ""z--"" 예3 ""=.="" ""aaa"" 예4 ""123_.def"" ""123_.def"" 예5 ""abcdefghijklmn.p"" ""abcdefghijklmn"" 입출력 예에 대한 설명 입출력 예 #1 문제의 예시와 같습니다. 입출력 예 #2 7단계를 거치는 동안 new_id가 변화하는 과정은 아래와 같습니다. 1단계 변화 없습니다. 2단계 ""z-+.^."" → ""z-.."" 3단계 ""z-.."" → ""z-."" 4단계 ""z-."" → ""z-"" 5단계 변화 없습니다. 6단계 변화 없습니다. 7단계 ""z-"" → ""z--"" 입출력 예 #3 7단계를 거치는 동안 new_id가 변화하는 과정은 아래와 같습니다. 1단계 변화 없습니다. 2단계 ""=.="" → ""."" 3단계 변화 없습니다. 4단계 ""."" → """" (new_id가 빈 문자열이 되었습니다.) 5단계 """" → ""a"" 6단계 변화 없습니다. 7단계 ""a"" → ""aaa"" 입출력 예 #4 1단계에서 7단계까지 거치는 동안 new_id(""123_.def"")는 변하지 않습니다. 즉, new_id가 처음부터 카카오의 아이디 규칙에 맞습니다. 입출력 예 #5 1단계 변화 없습니다. 2단계 변화 없습니다. 3단계 변화 없습니다. 4단계 변화 없습니다. 5단계 변화 없습니다. 6단계 ""abcdefghijklmn.p"" → ""abcdefghijklmn."" → ""abcdefghijklmn"" 7단계 변화 없습니다.",easy,String
416,"다음 조건을 만족하는 그래프 상의 경로(Path)를 가짜 해밀토니안 경로라고 정의합니다. 경로가 그래프 상의 모든 점을 최소 1번, 최대 2번 방문해야 합니다. 그래프의 형태에 따라, 해당 그래프가 가짜 해밀토니안 경로를 가질 수도 있고, 가지지 않을 수도 있습니다. 본 문제에서 주어지는 그래프는 항상 트리 형태이며, 다음은 트리에서 가짜 해밀토니안 경로를 나타내는 예시입니다. 이 트리는 가짜 해밀토니안 경로를 가지는 트리입니다. 그림의 경로가 트리 상의 모든 점을 최소 1번, 최대 2번 방문하는 가짜 해밀토니안 경로 중 하나입니다. 이 트리는 가짜 해밀토니안 경로를 가지지 않는 트리입니다. 트리 정보를 담고 있는 2차원 정수 배열 t가 매개변수로 주어집니다. 이 트리의 모든 부분 트리(Subtree) 중에서, 가짜 해밀토니안 경로를 갖고 있으면서 동시에 점의 개수가 제일 많은 트리의 크기를 찾아 그 트리의 점의 개수를 return 하도록 solution 함수를 완성해주세요. 이때, 점의 개수가 3 이상(제한사항을 참고해주세요)인 임의의 트리는 항상 가짜 해밀토니안 경로를 가지는 부분 트리를 가지므로, 이 문제에서 답은 항상 존재합니다. 제한사항 t의 행의 개수는 2 이상 200,000 미만입니다. 트리의 점(Vertex)의 개수는 (t의 행의 개수 + 1) 입니다. 즉, 트리의 점의 개수는 3 이상 200,000 이하입니다. 각 행은 [v1, v2] 2개의 정수로 이루어져 있습니다. 이는 v1번 점과 v2번 점이 서로 연결되어 있다는 것을 의미합니다. v1, v2는 각각 0 이상 (t의 행의 개수) 이하입니다. v1과 v2는 서로 다른 수입니다. t는 항상 트리 형태로만 주어집니다. 입출력 예 t result [[5,1],[2,5],[3,5],[3,6],[2,4],[4,0]] 7 [[2,5],[2,0],[3,2],[4,2],[2,1]] 4 입출력 예 #1 주어진 트리를 그림으로 나타내면 다음과 같습니다. 이 트리는 그 자체로 가짜 해밀토니안 경로를 가지므로, 트리의 점의 개수인 7을 return 해야 합니다. 입출력 예 #2 주어진 트리에서, 가짜 해밀토니안 경로를 가지면서 점의 개수가 가장 많은 부분 트리 중 하나를 그림으로 나타내면 다음과 같습니다. (0,1,2,3) 외에도 (0,2,4,5), (1,2,3,4) 등 가짜 해밀토니안 경로를 가지면서 점의 개수가 4개인 다른 부분 트리가 존재하지만, 동일한 조건에서 그보다 더 많은 점의 개수를 가지는 트리는 없습니다. 따라서 4를 return 해야 합니다.",hard,Array
417,"다음과 같은 것들을 정의합니다. 어떤 수열 x의 부분 수열(Subsequence)이란, x의 몇몇 원소들을 제거하거나 그러지 않고 남은 원소들이 원래 순서를 유지하여 얻을 수 있는 새로운 수열을 말합니다. 예를 들어, [1,3]은 [1,2,3,4,5]의 부분수열입니다. 원래 수열에서 2, 4, 5를 제거해서 얻을 수 있기 때문입니다. 다음과 같은 조건을 모두 만족하는 수열 x를 스타 수열이라고 정의합니다. x의 길이가 2 이상의 짝수입니다. (빈 수열은 허용되지 않습니다.) x의 길이를 2n이라 할 때, 다음과 같은 n개의 집합 {x[0], x[1]}, {x[2], x[3]}, ..., {x[2n-2], x[2n-1]} 의 교집합의 원소의 개수가 1 이상입니다. x[0] != x[1], x[2] != x[3], ..., x[2n-2] != x[2n-1] 입니다. 예를 들어, [1,2,1,3,4,1,1,3]은 스타 수열입니다. {1,2}, {1,3}, {4,1}, {1,3} 의 교집합은 {1} 이고, 각 집합 내의 숫자들이 서로 다르기 때문입니다. 1차원 정수 배열 a가 매개변수로 주어집니다. a의 모든 부분 수열 중에서 가장 길이가 긴 스타 수열의 길이를 return 하도록 solution 함수를 완성해주세요. 이때, a의 모든 부분 수열 중에서 스타 수열이 없다면, 0을 return 해주세요. 제한사항 a의 길이는 1 이상 500,000 이하입니다. a의 모든 수는 0 이상 (a의 길이) 미만입니다. 입출력 예 a result [0] 0 [5,2,3,3,5,3] 4 [0,3,3,0,7,2,0,2,2,0] 8 입출력 예 설명 입출력 예 #1 a의 부분 수열 중에서 주어진 조건을 모두 만족하는 스타 수열이 없으므로, 0을 return 해야 합니다. 입출력 예 #2 [5,2,5,3], [5,3,3,5] 는 a의 부분 수열인 동시에 스타 수열입니다. a의 부분 수열 중 이보다 더 긴 스타 수열은 없으므로, 4를 return 해야 합니다. 입출력 예 #3 [0,3,3,0,7,0,2,0] 는 a의 부분 수열인 동시에 스타 수열입니다. a의 부분 수열 중 이보다 더 긴 스타 수열은 없으므로, 8을 return 해야 합니다. ※ 공지 - 2020년 11월 27일 테스트케이스가 추가되었습니다.",normal,Array
418,"0과 1로 이루어진 어떤 문자열 x에 대한 이진 변환을 다음과 같이 정의합니다. x의 모든 0을 제거합니다. x의 길이를 c라고 하면, x를 ""c를 2진법으로 표현한 문자열""로 바꿉니다. 예를 들어, x = ""0111010""이라면, x에 이진 변환을 가하면 x = ""0111010"" -> ""1111"" -> ""100"" 이 됩니다. 0과 1로 이루어진 문자열 s가 매개변수로 주어집니다. s가 ""1""이 될 때까지 계속해서 s에 이진 변환을 가했을 때, 이진 변환의 횟수와 변환 과정에서 제거된 모든 0의 개수를 각각 배열에 담아 return 하도록 solution 함수를 완성해주세요. 제한사항 s의 길이는 1 이상 150,000 이하입니다. s에는 '1'이 최소 하나 이상 포함되어 있습니다. 입출력 예 s result ""110010101001"" [3,8] ""01110"" [3,3] ""1111111"" [4,1] 입출력 예 설명 입출력 예 #1 ""110010101001""이 ""1""이 될 때까지 이진 변환을 가하는 과정은 다음과 같습니다. 회차 이진 변환 이전 제거할 0의 개수 0 제거 후 길이 이진 변환 결과 1 ""110010101001"" 6 6 ""110"" 2 ""110"" 1 2 ""10"" 3 ""10"" 1 1 ""1"" 3번의 이진 변환을 하는 동안 8개의 0을 제거했으므로, [3,8]을 return 해야 합니다. 입출력 예 #2 ""01110""이 ""1""이 될 때까지 이진 변환을 가하는 과정은 다음과 같습니다. 회차 이진 변환 이전 제거할 0의 개수 0 제거 후 길이 이진 변환 결과 1 ""01110"" 2 3 ""11"" 2 ""11"" 0 2 ""10"" 3 ""10"" 1 1 ""1"" 3번의 이진 변환을 하는 동안 3개의 0을 제거했으므로, [3,3]을 return 해야 합니다. 입출력 예 #3 ""1111111""이 ""1""이 될 때까지 이진 변환을 가하는 과정은 다음과 같습니다. 회차 이진 변환 이전 제거할 0의 개수 0 제거 후 길이 이진 변환 결과 1 ""1111111"" 0 7 ""111"" 2 ""111"" 0 3 ""11"" 3 ""11"" 0 2 ""10"" 4 ""10"" 1 1 ""1"" 4번의 이진 변환을 하는 동안 1개의 0을 제거했으므로, [4,1]을 return 해야 합니다.",normal,Array
419,"길이가 같은 두 1차원 정수 배열 a, b가 매개변수로 주어집니다. a와 b의 내적을 return 하도록 solution 함수를 완성해주세요. 이때, a와 b의 내적은 a[0]*b[0] + a[1]*b[1] + ... + a[n-1]*b[n-1] 입니다. (n은 a, b의 길이) 제한사항 a, b의 길이는 1 이상 1,000 이하입니다. a, b의 모든 수는 -1,000 이상 1,000 이하입니다. 입출력 예 a b result [1,2,3,4] [-3,-1,0,2] 3 [-1,0,1] [1,0,-1] -2 입출력 예 설명 입출력 예 #1 a와 b의 내적은 1*(-3) + 2*(-1) + 3*0 + 4*2 = 3 입니다. 입출력 예 #2 a와 b의 내적은 (-1)*1 + 0*0 + 1*(-1) = -2 입니다.",easy,Array
420,"어떤 문자열 x의 ""아름다움""을 다음과 같이 정의합니다. 만약 x의 모든 글자가 전부 같다면, 0입니다. 그렇지 않다면, 서로 다른 글자가 위치해 있는 두 인덱스 i, j를 골랐을 때의 j-i 값들 중 최대값입니다. 예를 들어, 문자열 ""abbca""의 아름다움은 3입니다. 인덱스 1(b)과 4(a)를 고르거나, 또는 0(a)과 3(c)를 고를 때 최대값이기 때문입니다. 영어 소문자로 이루어진 문자열 s가 매개변수로 주어집니다. s의 모든 부분문자열의 아름다움의 합을 return 하도록 solution 함수를 완성해주세요. 제한 사항 s의 길이는 1 이상 300,000 이하입니다. 입출력 예 s result ""baby"" 9 ""oo"" 0 입출력 예 설명 입출력 예 #1 다음 표는 ""baby""의 각 부분문자열과 그 아름다움을 나타낸 것입니다. 인덱스 범위 부분문자열 아름다움 0 ~ 0 ""b"" 0 0 ~ 1 ""ba"" 1 (""b"", ""a"" 선택) 0 ~ 2 ""bab"" 1 (앞 ""b"", ""a"" 선택 또는 ""a"", 뒤 ""b"" 선택) 0 ~ 3 ""baby"" 3 (앞 ""b"", ""y"" 선택) 1 ~ 1 ""a"" 0 1 ~ 2 ""ab"" 1 (""a"", ""b"" 선택) 1 ~ 3 ""aby"" 2 (""a"", ""y"" 선택) 2 ~ 2 ""b"" 0 2 ~ 3 ""by"" 1 (""b"", ""y"" 선택) 3 ~ 3 ""y"" 0 따라서, 각 부분문자열의 아름다움을 모두 더한 9를 return 해야 합니다. 입출력 예 #2 ""oo""는 모든 글자가 동일하므로, ""oo""의 임의의 부분문자열도 모두 동일한 글자를 가지고 있습니다. 따라서, ""oo""의 임의의 부분문자열의 아름다움은 전부 0이므로, 0을 return 해야 합니다.",hard,Array
421,"n개의 점으로 이루어진 트리가 있습니다. 이때, 트리 상에서 다음과 같은 것들을 정의합니다. 어떤 두 점 사이의 거리는, 두 점을 잇는 경로 상 간선의 개수로 정의합니다. 임의의 3개의 점 a, b, c에 대한 함수 f(a, b, c)의 값을 a와 b 사이의 거리, b와 c 사이의 거리, c와 a 사이의 거리, 3개 값의 중간값으로 정의합니다. 트리의 정점의 개수 n과 트리의 간선을 나타내는 2차원 정수 배열 edges가 매개변수로 주어집니다. 주어진 트리에서 임의의 3개의 점을 뽑아 만들 수 있는 모든 f값 중에서, 제일 큰 값을 구해 return 하도록 solution 함수를 완성해주세요. 제한 사항 n은 3 이상 250,000 이하입니다. edges의 행의 개수는 n-1 입니다. edges의 각 행은 [v1, v2] 2개의 정수로 이루어져 있으며, 이는 v1번 정점과 v2번 정점 사이에 간선이 있음을 의미합니다. v1, v2는 각각 1 이상 n 이하입니다. v1, v2는 다른 수입니다. 입력으로 주어지는 그래프는 항상 트리입니다. 입출력 예 n edges result 4 [[1,2],[2,3],[3,4]] 2 5 [[1,5],[2,5],[3,5],[4,5]] 2 입출력 예 설명 입출력 예 #1 다음 그림은 입력으로 주어진 트리를 나타낸 것입니다. 다음 표는 주어진 트리에서 나올 수 있는 모든 f값의 경우를 나열한 것입니다. (단, a, b, c의 순서만 다른 경우는 f값이 동일하기 때문에 표에서 제외) a b c a ~ b 거리 b ~ c 거리 c ~ a 거리 f(a, b, c) 1 2 3 1 1 2 1 1 2 4 1 2 3 2 1 3 4 2 1 3 2 2 3 4 1 1 2 1 따라서, 2를 return 해야 합니다. 입출력 예 #2 다음 그림은 입력으로 주어진 트리를 나타낸 것입니다. f값에 사용될 3개의 점으로 (1, 2, 3), (2, 3, 4) 등을 고를 때 가장 큰 값인 2를 얻을 수 있으므로, 2를 return 해야 합니다.",hard,Array
422,"0과 1로 이루어진 2n x 2n 크기의 2차원 정수 배열 arr이 있습니다. 당신은 이 arr을 쿼드 트리와 같은 방식으로 압축하고자 합니다. 구체적인 방식은 다음과 같습니다. 당신이 압축하고자 하는 특정 영역을 S라고 정의합니다. 만약 S 내부에 있는 모든 수가 같은 값이라면, S를 해당 수 하나로 압축시킵니다. 그렇지 않다면, S를 정확히 4개의 균일한 정사각형 영역(입출력 예를 참고해주시기 바랍니다.)으로 쪼갠 뒤, 각 정사각형 영역에 대해 같은 방식의 압축을 시도합니다. arr이 매개변수로 주어집니다. 위와 같은 방식으로 arr을 압축했을 때, 배열에 최종적으로 남는 0의 개수와 1의 개수를 배열에 담아서 return 하도록 solution 함수를 완성해주세요. 제한사항 arr의 행의 개수는 1 이상 1024 이하이며, 2의 거듭 제곱수 형태를 하고 있습니다. 즉, arr의 행의 개수는 1, 2, 4, 8, ..., 1024 중 하나입니다. arr의 각 행의 길이는 arr의 행의 개수와 같습니다. 즉, arr은 정사각형 배열입니다. arr의 각 행에 있는 모든 값은 0 또는 1 입니다. 입출력 예 arr result [[1,1,0,0],[1,0,0,0],[1,0,0,1],[1,1,1,1]] [4,9] [[1,1,1,1,1,1,1,1],[0,1,1,1,1,1,1,1],[0,0,0,0,1,1,1,1],[0,1,0,0,1,1,1,1],[0,0,0,0,0,0,1,1],[0,0,0,0,0,0,0,1],[0,0,0,0,1,0,0,1],[0,0,0,0,1,1,1,1]] [10,15] 입출력 예 설명 입출력 예 #1 다음 그림은 주어진 arr을 압축하는 과정을 나타낸 것입니다. 최종 압축 결과에 0이 4개, 1이 9개 있으므로, [4,9]를 return 해야 합니다. 입출력 예 #2 다음 그림은 주어진 arr을 압축하는 과정을 나타낸 것입니다. 최종 압축 결과에 0이 10개, 1이 15개 있으므로, [10,15]를 return 해야 합니다.",normal,Array
423,"자연수 n이 매개변수로 주어집니다. n을 3진법 상에서 앞뒤로 뒤집은 후, 이를 다시 10진법으로 표현한 수를 return 하도록 solution 함수를 완성해주세요. 제한사항 n은 1 이상 100,000,000 이하인 자연수입니다. 입출력 예 n result 45 7 125 229 입출력 예 설명 입출력 예 #1 답을 도출하는 과정은 다음과 같습니다. n (10진법) n (3진법) 앞뒤 반전(3진법) 10진법으로 표현 45 1200 0021 7 따라서 7을 return 해야 합니다. 입출력 예 #2 답을 도출하는 과정은 다음과 같습니다. n (10진법) n (3진법) 앞뒤 반전(3진법) 10진법으로 표현 125 11122 22111 229 따라서 229를 return 해야 합니다.",easy,Math
424,"모든 수가 0 또는 1로 이루어진 2차원 배열 a가 주어집니다. 다음 조건을 모두 만족하는 2차원 배열 b의 경우의 수를 (107 + 19)로 나눈 나머지를 return 하도록 solution 함수를 완성해주세요. b의 모든 원소는 0 아니면 1입니다. a의 행/열의 개수와 b의 행/열의 개수가 같습니다. (= a와 b의 크기가 같습니다.) i = 1, 2, ..., (a의 열의 개수)에 대해서 a의 i번째 열과 b의 i번째 열에 들어 있는 1의 개수가 같습니다. b의 각 행에 들어 있는 1의 개수가 짝수입니다. (0도 짝수입니다.) 제한 사항 a의 행의 개수는 1 이상 300 이하입니다. a의 각 행의 길이는 1 이상 300 이하로 모두 동일합니다. 입출력 예 a result [[0,1,0],[1,1,1],[1,1,0],[0,1,1]] 6 [[1,0,0],[1,0,0]] 0 [[1,0,0,1,1],[0,0,0,0,0],[1,1,0,0,0],[0,0,0,0,1]] 72 입출력 예 설명 입출력 예 #1 주어진 a는 다음 표와 같은 4행 3열의 배열입니다. a 1열 2열 3열 1행 0 1 0 2행 1 1 1 3행 1 1 0 4행 0 1 1 주어진 조건을 만족하는 2차원 배열 b는 다음과 같이 총 6개입니다. b 1열 2열 3열 1행 1 1 0 2행 1 1 0 3행 0 1 1 4행 0 1 1 b 1열 2열 3열 1행 1 1 0 2행 0 1 1 3행 1 1 0 4행 0 1 1 b 1열 2열 3열 1행 1 1 0 2행 0 1 1 3행 0 1 1 4행 1 1 0 b 1열 2열 3열 1행 0 1 1 2행 1 1 0 3행 1 1 0 4행 0 1 1 b 1열 2열 3열 1행 0 1 1 2행 1 1 0 3행 0 1 1 4행 1 1 0 b 1열 2열 3열 1행 0 1 1 2행 0 1 1 3행 1 1 0 4행 1 1 0 입출력 예 #2 주어진 a는 다음 표와 같은 2행 3열의 배열입니다. a 1열 2열 3열 1행 1 0 0 2행 1 0 0 주어진 조건을 만족하는 2차원 배열 b가 없으므로, 0을 return 해야 합니다. 입출력 예 #3 주어진 a는 다음 표와 같은 4행 5열의 배열입니다. a 1열 2열 3열 4열 5열 1행 1 0 0 1 1 2행 0 0 0 0 0 3행 1 1 0 0 0 4행 0 0 0 0 1 주어진 조건을 만족하는 2차원 배열 b는 72개이므로, 72를 return 해야 합니다.",hard,Array
425,"일렬로 나열된 n개의 풍선이 있습니다. 모든 풍선에는 서로 다른 숫자가 써져 있습니다. 당신은 다음 과정을 반복하면서 풍선들을 단 1개만 남을 때까지 계속 터트리려고 합니다. 임의의 인접한 두 풍선을 고른 뒤, 두 풍선 중 하나를 터트립니다. 터진 풍선으로 인해 풍선들 사이에 빈 공간이 생겼다면, 빈 공간이 없도록 풍선들을 중앙으로 밀착시킵니다. 여기서 조건이 있습니다. 인접한 두 풍선 중에서 번호가 더 작은 풍선을 터트리는 행위는 최대 1번만 할 수 있습니다. 즉, 어떤 시점에서 인접한 두 풍선 중 번호가 더 작은 풍선을 터트렸다면, 그 이후에는 인접한 두 풍선을 고른 뒤 번호가 더 큰 풍선만을 터트릴 수 있습니다. 당신은 어떤 풍선이 최후까지 남을 수 있는지 알아보고 싶습니다. 위에 서술된 조건대로 풍선을 터트리다 보면, 어떤 풍선은 최후까지 남을 수도 있지만, 어떤 풍선은 무슨 수를 쓰더라도 마지막까지 남기는 것이 불가능할 수도 있습니다. 일렬로 나열된 풍선들의 번호가 담긴 배열 a가 주어집니다. 위에 서술된 규칙대로 풍선들을 1개만 남을 때까지 터트렸을 때 최후까지 남기는 것이 가능한 풍선들의 개수를 return 하도록 solution 함수를 완성해주세요. 제한 사항 a의 길이는 1 이상 1,000,000 이하입니다. a[i]는 i+1 번째 풍선에 써진 숫자를 의미합니다. a의 모든 수는 -1,000,000,000 이상 1,000,000,000 이하인 정수입니다. a의 모든 수는 서로 다릅니다. 입출력 예 a result [9,-1,-5] 3 [-16,27,65,-2,58,-92,-71,-68,-61,-33] 6 입출력 예 설명 입출력 예 #1 첫 번째 풍선(9가 써진 풍선)을 최후까지 남기는 방법은 다음과 같습니다. [9, -1, -5] 에서 -1, -5가 써진 풍선을 고른 뒤, -1이 써진 풍선(번호가 더 큰 것)을 터트립니다. [9, -5] 에서 9, -5가 써진 풍선을 고른 뒤, -5가 써진 풍선(번호가 더 작은 것)을 터트립니다. 두 번째 풍선(-1이 써진 풍선)을 최후까지 남기는 방법은 다음과 같습니다. [9, -1, -5] 에서 9, -1이 써진 풍선을 고른 뒤, 9가 써진 풍선(번호가 더 큰 것)을 터트립니다. [-1, -5] 에서 -1, -5가 써진 풍선을 고른 뒤, -5가 써진 풍선(번호가 더 작은 것)을 터트립니다. 세 번째 풍선(-5가 써진 풍선)을 최후까지 남기는 방법은 다음과 같습니다. [9, -1, -5] 에서 9, -1이 써진 풍선을 고른 뒤, 9가 써진 풍선(번호가 더 큰 것)을 터트립니다. [-1, -5] 에서 -1, -5가 써진 풍선을 고른 뒤, -1이 써진 풍선(번호가 더 큰 것)을 터트립니다. 3개의 풍선이 최후까지 남을 수 있으므로, 3을 return 해야 합니다. 입출력 예 #2 최후까지 남을 수 있는 풍선은 -16, -92, -71, -68, -61, -33이 써진 풍선으로 모두 6개입니다.",normal,Array
426,"정수 n이 매개변수로 주어집니다. 다음 그림과 같이 밑변의 길이와 높이가 n인 삼각형에서 맨 위 꼭짓점부터 반시계 방향으로 달팽이 채우기를 진행한 후, 첫 행부터 마지막 행까지 모두 순서대로 합친 새로운 배열을 return 하도록 solution 함수를 완성해주세요. 제한사항 n은 1 이상 1,000 이하입니다. 입출력 예 n result 4 [1,2,9,3,10,8,4,5,6,7] 5 [1,2,12,3,13,11,4,14,15,10,5,6,7,8,9] 6 [1,2,15,3,16,14,4,17,21,13,5,18,19,20,12,6,7,8,9,10,11] 입출력 예 설명 입출력 예 #1 문제 예시와 같습니다. 입출력 예 #2 문제 예시와 같습니다. 입출력 예 #3 문제 예시와 같습니다.",normal,Array
427,"정수 배열 numbers가 주어집니다. numbers에서 서로 다른 인덱스에 있는 두 개의 수를 뽑아 더해서 만들 수 있는 모든 수를 배열에 오름차순으로 담아 return 하도록 solution 함수를 완성해주세요. 제한사항 numbers의 길이는 2 이상 100 이하입니다. numbers의 모든 수는 0 이상 100 이하입니다. 입출력 예 numbers result [2,1,3,4,1] [2,3,4,5,6,7] [5,0,2,7] [2,5,7,9,12] 입출력 예 설명 입출력 예 #1 2 = 1 + 1 입니다. (1이 numbers에 두 개 있습니다.) 3 = 2 + 1 입니다. 4 = 1 + 3 입니다. 5 = 1 + 4 = 2 + 3 입니다. 6 = 2 + 4 입니다. 7 = 3 + 4 입니다. 따라서 [2,3,4,5,6,7] 을 return 해야 합니다. 입출력 예 #2 2 = 0 + 2 입니다. 5 = 5 + 0 입니다. 7 = 0 + 7 = 5 + 2 입니다. 9 = 2 + 7 입니다. 12 = 5 + 7 입니다. 따라서 [2,5,7,9,12] 를 return 해야 합니다.",easy,Array
428,"[본 문제는 정확성과 효율성 테스트 각각 점수가 있는 문제입니다.] 오지 탐험가인 프로도는 탐험 도중 n개의 방으로 이루어진 지하 동굴을 탐험하게 되었습니다. 모든 방에는 0부터 n - 1 까지 번호가 붙어있고, 이 동굴에 들어갈 수 있는 유일한 입구는 0번 방과 연결되어 있습니다. 각 방들은 양방향으로 통행이 가능한 통로로 서로 연결되어 있는데, 서로 다른 두 방을 직접 연결하는 통로는 오직 하나입니다. 임의의 서로 다른 두 방 사이의 최단경로는 딱 한 가지만 있으며, 또한 임의의 두 방 사이에 이동이 불가능한 경우는 없습니다. 탐험에 앞서 이 지하 동굴의 지도를 손에 넣은 프로도는 다음과 같이 탐험 계획을 세웠습니다. 모든 방을 적어도 한 번은 방문해야 합니다. 특정 방은 방문하기 전에 반드시 먼저 방문할 방이 정해져 있습니다. 2-1. 이는 A번 방은 방문하기 전에 반드시 B번 방을 먼저 방문해야 한다는 의미입니다. 2-2. 어떤 방을 방문하기 위해 반드시 먼저 방문해야 하는 방은 없거나 또는 1개 입니다. 2-3. 서로 다른 두 개 이상의 방에 대해 먼저 방문해야 하는 방이 같은 경우는 없습니다. 2-4. 어떤 방이 먼저 방문해야 하는 방이면서 동시에 나중에 방문해야 되는 방인 경우는 없습니다. 위 계획 중 2-2, 2-3, 2-4는 순서를 지켜 방문해야 하는 두 방의 쌍이 A → B(A를 먼저 방문하고 B를 방문함) 형태로 유일함을 의미합니다. 즉, 프로도는 아래와 같은 형태로 방문순서가 잡히지 않도록 방문 계획을 세웠습니다. A → B, A → C (방문순서 배열 order = [...,[A,B],...,[A,C],...]) 형태로 A를 방문 후에 방문해야 할 방이 B와 C로 두 개 또는 그 이상인 경우 X → A, Z → A (방문순서 배열 order = [...,[X,A],...,[Z,A],...]) 형태로 A를 방문하기 전에 방문해야 할 방이 X와 Z로 두 개 또는 그 이상 인 경우 A → B → C (방문순서 배열 order = [...,[A,B],...,[B,C],...) 형태로 B처럼 A 방문 후이면서 동시에 C 방문 전인 경우 그리고 먼저 방문해야 할 방과 나중에 방문할 방을 반드시 연속해서 방문해야 할 필요는 없어 A방을 방문한 후 다른 방을 방문한 후 B방을 방문해도 좋습니다. 방 개수 n, 동굴의 각 통로들이 연결하는 두 방의 번호가 담긴 2차원 배열 path, 프로도가 정한 방문 순서가 담긴 2차원 배열 order가 매개변수로 주어질 때, 프로도가 규칙에 맞게 모든 방을 탐험할 수 있을 지 return 하도록 solution 함수를 완성해주세요. [제한사항] n은 2 이상 200,000 이하입니다. path 배열의 세로(행) 길이는 n - 1 입니다. path 배열의 원소는 [방 번호 A, 방 번호 B] 형태입니다. 두 방 A, B사이를 연결하는 통로를 나타냅니다. 통로가 연결하는 두 방 번호가 순서없이 들어있음에 주의하세요. order 배열의 세로(행) 길이는 1 이상 (n / 2) 이하입니다. order 배열의 원소는 [방 번호 A, 방 번호 B] 형태입니다. A번 방을 먼저 방문한 후 B번 방을 방문해야 함을 나타냅니다. 입출력 예 n path order result 9 [[0,1],[0,3],[0,7],[8,1],[3,6],[1,2],[4,7],[7,5]] [[8,5],[6,7],[4,1]] true 9 [[8,1],[0,1],[1,2],[0,7],[4,7],[0,3],[7,5],[3,6]] [[4,1],[5,2]] true 9 [[0,1],[0,3],[0,7],[8,1],[3,6],[1,2],[4,7],[7,5]] [[4,1],[8,7],[6,5]] false 입출력 예에 대한 설명 입출력 예 #1 동굴 그림은 아래와 같습니다. 방문 순서를 지켜야 하는 방 번호는 다음과 같습니다. 6번 → 7번 4번 → 1번 8번 → 5번 따라서 모든 방을 방문할 수 있는 방법 중 하나는 다음과 같습니다. 0번 → 3번 → 6번 → 3번 → 0번 → 7번 → 4번 → 7번 → 0번 → 1번 → 8번 → 1번 → 2번 → 1번 → 0번 → 7번 → 5번 입출력 예 #2 다음 순서로 각 방을 방문하면 됩니다. 0번 → 7번 → 4번 → 7번 → 5번 → 7번 → 0번 → 3번 → 6번 → 3번 → 0번 → 1번 → 8번 → 1번 → 2번 입출력 예 #3 규칙에 맞게 모든 방을 방문할 수 있는 방법이 없습니다.",hard,Array
429,"건설회사의 설계사인 죠르디는 고객사로부터 자동차 경주로 건설에 필요한 견적을 의뢰받았습니다. 제공된 경주로 설계 도면에 따르면 경주로 부지는 N x N 크기의 정사각형 격자 형태이며 각 격자는 1 x 1 크기입니다. 설계 도면에는 각 격자의 칸은 0 또는 1 로 채워져 있으며, 0은 칸이 비어 있음을 1은 해당 칸이 벽으로 채워져 있음을 나타냅니다. 경주로의 출발점은 (0, 0) 칸(좌측 상단)이며, 도착점은 (N-1, N-1) 칸(우측 하단)입니다. 죠르디는 출발점인 (0, 0) 칸에서 출발한 자동차가 도착점인 (N-1, N-1) 칸까지 무사히 도달할 수 있게 중간에 끊기지 않도록 경주로를 건설해야 합니다. 경주로는 상, 하, 좌, 우로 인접한 두 빈 칸을 연결하여 건설할 수 있으며, 벽이 있는 칸에는 경주로를 건설할 수 없습니다. 이때, 인접한 두 빈 칸을 상하 또는 좌우로 연결한 경주로를 직선 도로 라고 합니다. 또한 두 직선 도로가 서로 직각으로 만나는 지점을 코너 라고 부릅니다. 건설 비용을 계산해 보니 직선 도로 하나를 만들 때는 100원이 소요되며, 코너를 하나 만들 때는 500원이 추가로 듭니다. 죠르디는 견적서 작성을 위해 경주로를 건설하는 데 필요한 최소 비용을 계산해야 합니다. 예를 들어, 아래 그림은 직선 도로 6개와 코너 4개로 구성된 임의의 경주로 예시이며, 건설 비용은 6 x 100 + 4 x 500 = 2600원 입니다. 또 다른 예로, 아래 그림은 직선 도로 4개와 코너 1개로 구성된 경주로이며, 건설 비용은 4 x 100 + 1 x 500 = 900원 입니다. 도면의 상태(0은 비어 있음, 1은 벽)을 나타내는 2차원 배열 board가 매개변수로 주어질 때, 경주로를 건설하는데 필요한 최소 비용을 return 하도록 solution 함수를 완성해주세요. [제한사항] board는 2차원 정사각 배열로 배열의 크기는 3 이상 25 이하입니다. board 배열의 각 원소의 값은 0 또는 1 입니다. 도면의 가장 왼쪽 상단 좌표는 (0, 0)이며, 가장 우측 하단 좌표는 (N-1, N-1) 입니다. 원소의 값 0은 칸이 비어 있어 도로 연결이 가능함을 1은 칸이 벽으로 채워져 있어 도로 연결이 불가능함을 나타냅니다. board는 항상 출발점에서 도착점까지 경주로를 건설할 수 있는 형태로 주어집니다. 출발점과 도착점 칸의 원소의 값은 항상 0으로 주어집니다. 입출력 예 board result [[0,0,0],[0,0,0],[0,0,0]] 900 [[0,0,0,0,0,0,0,1],[0,0,0,0,0,0,0,0],[0,0,0,0,0,1,0,0],[0,0,0,0,1,0,0,0],[0,0,0,1,0,0,0,1],[0,0,1,0,0,0,1,0],[0,1,0,0,0,1,0,0],[1,0,0,0,0,0,0,0]] 3800 [[0,0,1,0],[0,0,0,0],[0,1,0,1],[1,0,0,0]] 2100 [[0,0,0,0,0,0],[0,1,1,1,1,0],[0,0,1,0,0,0],[1,0,0,1,0,1],[0,1,0,0,0,1],[0,0,0,0,0,0]] 3200 입출력 예에 대한 설명 입출력 예 #1 본문의 예시와 같습니다. 입출력 예 #2 위와 같이 경주로를 건설하면 직선 도로 18개, 코너 4개로 총 3800원이 듭니다. 입출력 예 #3 위와 같이 경주로를 건설하면 직선 도로 6개, 코너 3개로 총 2100원이 듭니다. 입출력 예 #4 붉은색 경로와 같이 경주로를 건설하면 직선 도로 12개, 코너 4개로 총 3200원이 듭니다. 만약, 파란색 경로와 같이 경주로를 건설한다면 직선 도로 10개, 코너 5개로 총 3500원이 들며, 더 많은 비용이 듭니다. ※ 공지 - 2021년 8월 30일 테스트케이스가 추가되었습니다.",normal,Array
430,"[본 문제는 정확성과 효율성 테스트 각각 점수가 있는 문제입니다.] 개발자 출신으로 세계 최고의 갑부가 된 어피치는 스트레스를 받을 때면 이를 풀기 위해 오프라인 매장에 쇼핑을 하러 가곤 합니다. 어피치는 쇼핑을 할 때면 매장 진열대의 특정 범위의 물건들을 모두 싹쓸이 구매하는 습관이 있습니다. 어느 날 스트레스를 풀기 위해 보석 매장에 쇼핑을 하러 간 어피치는 이전처럼 진열대의 특정 범위의 보석을 모두 구매하되 특별히 아래 목적을 달성하고 싶었습니다. 진열된 모든 종류의 보석을 적어도 1개 이상 포함하는 가장 짧은 구간을 찾아서 구매 예를 들어 아래 진열대는 4종류의 보석(RUBY, DIA, EMERALD, SAPPHIRE) 8개가 진열된 예시입니다. 진열대 번호 1 2 3 4 5 6 7 8 보석 이름 DIA RUBY RUBY DIA DIA EMERALD SAPPHIRE DIA 진열대의 3번부터 7번까지 5개의 보석을 구매하면 모든 종류의 보석을 적어도 하나 이상씩 포함하게 됩니다. 진열대의 3, 4, 6, 7번의 보석만 구매하는 것은 중간에 특정 구간(5번)이 빠지게 되므로 어피치의 쇼핑 습관에 맞지 않습니다. 진열대 번호 순서대로 보석들의 이름이 저장된 배열 gems가 매개변수로 주어집니다. 이때 모든 보석을 하나 이상 포함하는 가장 짧은 구간을 찾아서 return 하도록 solution 함수를 완성해주세요. 가장 짧은 구간의 시작 진열대 번호와 끝 진열대 번호를 차례대로 배열에 담아서 return 하도록 하며, 만약 가장 짧은 구간이 여러 개라면 시작 진열대 번호가 가장 작은 구간을 return 합니다. [제한사항] gems 배열의 크기는 1 이상 100,000 이하입니다. gems 배열의 각 원소는 진열대에 나열된 보석을 나타냅니다. gems 배열에는 1번 진열대부터 진열대 번호 순서대로 보석이름이 차례대로 저장되어 있습니다. gems 배열의 각 원소는 길이가 1 이상 10 이하인 알파벳 대문자로만 구성된 문자열입니다. 입출력 예 gems result [""DIA"", ""RUBY"", ""RUBY"", ""DIA"", ""DIA"", ""EMERALD"", ""SAPPHIRE"", ""DIA""] [3, 7] [""AA"", ""AB"", ""AC"", ""AA"", ""AC""] [1, 3] [""XYZ"", ""XYZ"", ""XYZ""] [1, 1] [""ZZZ"", ""YYY"", ""NNNN"", ""YYY"", ""BBB""] [1, 5] 입출력 예에 대한 설명 입출력 예 #1 문제 예시와 같습니다. 입출력 예 #2 3종류의 보석(AA, AB, AC)을 모두 포함하는 가장 짧은 구간은 [1, 3], [2, 4]가 있습니다. 시작 진열대 번호가 더 작은 [1, 3]을 return 해주어야 합니다. 입출력 예 #3 1종류의 보석(XYZ)을 포함하는 가장 짧은 구간은 [1, 1], [2, 2], [3, 3]이 있습니다. 시작 진열대 번호가 가장 작은 [1, 1]을 return 해주어야 합니다. 입출력 예 #4 4종류의 보석(ZZZ, YYY, NNNN, BBB)을 모두 포함하는 구간은 [1, 5]가 유일합니다. 그러므로 [1, 5]를 return 해주어야 합니다. ※ 공지 - 2020년 7월 21일 테스트케이스가 추가되었습니다.",normal,Array
431,"IT 벤처 회사를 운영하고 있는 라이언은 매년 사내 해커톤 대회를 개최하여 우승자에게 상금을 지급하고 있습니다. 이번 대회에서는 우승자에게 지급되는 상금을 이전 대회와는 다르게 다음과 같은 방식으로 결정하려고 합니다. 해커톤 대회에 참가하는 모든 참가자들에게는 숫자들과 3가지의 연산문자(+, -, *) 만으로 이루어진 연산 수식이 전달되며, 참가자의 미션은 전달받은 수식에 포함된 연산자의 우선순위를 자유롭게 재정의하여 만들 수 있는 가장 큰 숫자를 제출하는 것입니다. 단, 연산자의 우선순위를 새로 정의할 때, 같은 순위의 연산자는 없어야 합니다. 즉, + > - > * 또는 - > * > + 등과 같이 연산자 우선순위를 정의할 수 있으나 +,* > - 또는 * > +,-처럼 2개 이상의 연산자가 동일한 순위를 가지도록 연산자 우선순위를 정의할 수는 없습니다. 수식에 포함된 연산자가 2개라면 정의할 수 있는 연산자 우선순위 조합은 2! = 2가지이며, 연산자가 3개라면 3! = 6가지 조합이 가능합니다. 만약 계산된 결과가 음수라면 해당 숫자의 절댓값으로 변환하여 제출하며 제출한 숫자가 가장 큰 참가자를 우승자로 선정하며, 우승자가 제출한 숫자를 우승상금으로 지급하게 됩니다. 예를 들어, 참가자 중 네오가 아래와 같은 수식을 전달받았다고 가정합니다. ""100-200*300-500+20"" 일반적으로 수학 및 전산학에서 약속된 연산자 우선순위에 따르면 더하기와 빼기는 서로 동등하며 곱하기는 더하기, 빼기에 비해 우선순위가 높아 * > +,- 로 우선순위가 정의되어 있습니다. 대회 규칙에 따라 + > - > * 또는 - > * > + 등과 같이 연산자 우선순위를 정의할 수 있으나 +,* > - 또는 * > +,- 처럼 2개 이상의 연산자가 동일한 순위를 가지도록 연산자 우선순위를 정의할 수는 없습니다. 수식에 연산자가 3개 주어졌으므로 가능한 연산자 우선순위 조합은 3! = 6가지이며, 그 중 + > - > * 로 연산자 우선순위를 정한다면 결괏값은 22,000원이 됩니다. 반면에 * > + > - 로 연산자 우선순위를 정한다면 수식의 결괏값은 -60,420 이지만, 규칙에 따라 우승 시 상금은 절댓값인 60,420원이 됩니다. 참가자에게 주어진 연산 수식이 담긴 문자열 expression이 매개변수로 주어질 때, 우승 시 받을 수 있는 가장 큰 상금 금액을 return 하도록 solution 함수를 완성해주세요. [제한사항] expression은 길이가 3 이상 100 이하인 문자열입니다. expression은 공백문자, 괄호문자 없이 오로지 숫자와 3가지의 연산자(+, -, *) 만으로 이루어진 올바른 중위표기법(연산의 두 대상 사이에 연산기호를 사용하는 방식)으로 표현된 연산식입니다. 잘못된 연산식은 입력으로 주어지지 않습니다. 즉, ""402+-561*""처럼 잘못된 수식은 올바른 중위표기법이 아니므로 주어지지 않습니다. expression의 피연산자(operand)는 0 이상 999 이하의 숫자입니다. 즉, ""100-2145*458+12""처럼 999를 초과하는 피연산자가 포함된 수식은 입력으로 주어지지 않습니다. ""-56+100""처럼 피연산자가 음수인 수식도 입력으로 주어지지 않습니다. expression은 적어도 1개 이상의 연산자를 포함하고 있습니다. 연산자 우선순위를 어떻게 적용하더라도, expression의 중간 계산값과 최종 결괏값은 절댓값이 263 - 1 이하가 되도록 입력이 주어집니다. 같은 연산자끼리는 앞에 있는 것의 우선순위가 더 높습니다. 입출력 예 expression result ""100-200*300-500+20"" 60420 ""50*6-3*2"" 300 입출력 예에 대한 설명 입출력 예 #1 * > + > - 로 연산자 우선순위를 정했을 때, 가장 큰 절댓값을 얻을 수 있습니다. 연산 순서는 아래와 같습니다. 100-200*300-500+20 = 100-(200*300)-500+20 = 100-60000-(500+20) = (100-60000)-520 = (-59900-520) = -60420 따라서, 우승 시 받을 수 있는 상금은 |-60420| = 60420 입니다. 입출력 예 #2 - > * 로 연산자 우선순위를 정했을 때, 가장 큰 절댓값을 얻을 수 있습니다. 연산 순서는 아래와 같습니다.(expression에서 + 연산자는 나타나지 않았으므로, 고려할 필요가 없습니다.) 50*6-3*2 = 50*(6-3)*2 = (50*3)*2 = 150*2 = 300 따라서, 우승 시 받을 수 있는 상금은 300 입니다.",normal,String
432,"스마트폰 전화 키패드의 각 칸에 다음과 같이 숫자들이 적혀 있습니다. 이 전화 키패드에서 왼손과 오른손의 엄지손가락만을 이용해서 숫자만을 입력하려고 합니다. 맨 처음 왼손 엄지손가락은 * 키패드에 오른손 엄지손가락은 # 키패드 위치에서 시작하며, 엄지손가락을 사용하는 규칙은 다음과 같습니다. 엄지손가락은 상하좌우 4가지 방향으로만 이동할 수 있으며 키패드 이동 한 칸은 거리로 1에 해당합니다. 왼쪽 열의 3개의 숫자 1, 4, 7을 입력할 때는 왼손 엄지손가락을 사용합니다. 오른쪽 열의 3개의 숫자 3, 6, 9를 입력할 때는 오른손 엄지손가락을 사용합니다. 가운데 열의 4개의 숫자 2, 5, 8, 0을 입력할 때는 두 엄지손가락의 현재 키패드의 위치에서 더 가까운 엄지손가락을 사용합니다. 4-1. 만약 두 엄지손가락의 거리가 같다면, 오른손잡이는 오른손 엄지손가락, 왼손잡이는 왼손 엄지손가락을 사용합니다. 순서대로 누를 번호가 담긴 배열 numbers, 왼손잡이인지 오른손잡이인 지를 나타내는 문자열 hand가 매개변수로 주어질 때, 각 번호를 누른 엄지손가락이 왼손인 지 오른손인 지를 나타내는 연속된 문자열 형태로 return 하도록 solution 함수를 완성해주세요. [제한사항] numbers 배열의 크기는 1 이상 1,000 이하입니다. numbers 배열 원소의 값은 0 이상 9 이하인 정수입니다. hand는 ""left"" 또는 ""right"" 입니다. ""left""는 왼손잡이, ""right""는 오른손잡이를 의미합니다. 왼손 엄지손가락을 사용한 경우는 L, 오른손 엄지손가락을 사용한 경우는 R을 순서대로 이어붙여 문자열 형태로 return 해주세요. 입출력 예 numbers hand result [1, 3, 4, 5, 8, 2, 1, 4, 5, 9, 5] ""right"" ""LRLLLRLLRRL"" [7, 0, 8, 2, 8, 3, 1, 5, 7, 6, 2] ""left"" ""LRLLRRLLLRR"" [1, 2, 3, 4, 5, 6, 7, 8, 9, 0] ""right"" ""LLRLLRLLRL"" 입출력 예에 대한 설명 입출력 예 #1 순서대로 눌러야 할 번호가 [1, 3, 4, 5, 8, 2, 1, 4, 5, 9, 5]이고, 오른손잡이입니다. 왼손 위치 오른손 위치 눌러야 할 숫자 사용한 손 설명 * # 1 L 1은 왼손으로 누릅니다. 1 # 3 R 3은 오른손으로 누릅니다. 1 3 4 L 4는 왼손으로 누릅니다. 4 3 5 L 왼손 거리는 1, 오른손 거리는 2이므로 왼손으로 5를 누릅니다. 5 3 8 L 왼손 거리는 1, 오른손 거리는 3이므로 왼손으로 8을 누릅니다. 8 3 2 R 왼손 거리는 2, 오른손 거리는 1이므로 오른손으로 2를 누릅니다. 8 2 1 L 1은 왼손으로 누릅니다. 1 2 4 L 4는 왼손으로 누릅니다. 4 2 5 R 왼손 거리와 오른손 거리가 1로 같으므로, 오른손으로 5를 누릅니다. 4 5 9 R 9는 오른손으로 누릅니다. 4 9 5 L 왼손 거리는 1, 오른손 거리는 2이므로 왼손으로 5를 누릅니다. 5 9 - - 따라서 ""LRLLLRLLRRL""를 return 합니다. 입출력 예 #2 왼손잡이가 [7, 0, 8, 2, 8, 3, 1, 5, 7, 6, 2]를 순서대로 누르면 사용한 손은 ""LRLLRRLLLRR""이 됩니다. 입출력 예 #3 오른손잡이가 [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]를 순서대로 누르면 사용한 손은 ""LLRLLRLLRL""이 됩니다.",easy,Array
433,"셀수있는 수량의 순서있는 열거 또는 어떤 순서를 따르는 요소들의 모음을 튜플(tuple)이라고 합니다. n개의 요소를 가진 튜플을 n-튜플(n-tuple)이라고 하며, 다음과 같이 표현할 수 있습니다. (a1, a2, a3, ..., an) 튜플은 다음과 같은 성질을 가지고 있습니다. 중복된 원소가 있을 수 있습니다. ex : (2, 3, 1, 2) 원소에 정해진 순서가 있으며, 원소의 순서가 다르면 서로 다른 튜플입니다. ex : (1, 2, 3) ≠ (1, 3, 2) 튜플의 원소 개수는 유한합니다. 원소의 개수가 n개이고, 중복되는 원소가 없는 튜플 (a1, a2, a3, ..., an)이 주어질 때(단, a1, a2, ..., an은 자연수), 이는 다음과 같이 집합 기호 '{', '}'를 이용해 표현할 수 있습니다. {{a1}, {a1, a2}, {a1, a2, a3}, {a1, a2, a3, a4}, ... {a1, a2, a3, a4, ..., an}} 예를 들어 튜플이 (2, 1, 3, 4)인 경우 이는 {{2}, {2, 1}, {2, 1, 3}, {2, 1, 3, 4}} 와 같이 표현할 수 있습니다. 이때, 집합은 원소의 순서가 바뀌어도 상관없으므로 {{2}, {2, 1}, {2, 1, 3}, {2, 1, 3, 4}} {{2, 1, 3, 4}, {2}, {2, 1, 3}, {2, 1}} {{1, 2, 3}, {2, 1}, {1, 2, 4, 3}, {2}} 는 모두 같은 튜플 (2, 1, 3, 4)를 나타냅니다. 특정 튜플을 표현하는 집합이 담긴 문자열 s가 매개변수로 주어질 때, s가 표현하는 튜플을 배열에 담아 return 하도록 solution 함수를 완성해주세요. [제한사항] s의 길이는 5 이상 1,000,000 이하입니다. s는 숫자와 '{', '}', ',' 로만 이루어져 있습니다. 숫자가 0으로 시작하는 경우는 없습니다. s는 항상 중복되는 원소가 없는 튜플을 올바르게 표현하고 있습니다. s가 표현하는 튜플의 원소는 1 이상 100,000 이하인 자연수입니다. return 하는 배열의 길이가 1 이상 500 이하인 경우만 입력으로 주어집니다. [입출력 예] s result ""{{2},{2,1},{2,1,3},{2,1,3,4}}"" [2, 1, 3, 4] ""{{1,2,3},{2,1},{1,2,4,3},{2}}"" [2, 1, 3, 4] ""{{20,111},{111}}"" [111, 20] ""{{123}}"" [123] ""{{4,2,3},{3},{2,3,4,1},{2,3}}"" [3, 2, 4, 1] 입출력 예에 대한 설명 입출력 예 #1 문제 예시와 같습니다. 입출력 예 #2 문제 예시와 같습니다. 입출력 예 #3 (111, 20)을 집합 기호를 이용해 표현하면 {{111}, {111,20}}이 되며, 이는 {{20,111},{111}}과 같습니다. 입출력 예 #4 (123)을 집합 기호를 이용해 표현하면 {{123}} 입니다. 입출력 예 #5 (3, 2, 4, 1)을 집합 기호를 이용해 표현하면 {{3},{3,2},{3,2,4},{3,2,4,1}}이 되며, 이는 {{4,2,3},{3},{2,3,4,1},{2,3}}과 같습니다.",normal,Array
434,"개발팀 내에서 이벤트 개발을 담당하고 있는 ""무지""는 최근 진행된 카카오이모티콘 이벤트에 비정상적인 방법으로 당첨을 시도한 응모자들을 발견하였습니다. 이런 응모자들을 따로 모아 불량 사용자라는 이름으로 목록을 만들어서 당첨 처리 시 제외하도록 이벤트 당첨자 담당자인 ""프로도"" 에게 전달하려고 합니다. 이 때 개인정보 보호을 위해 사용자 아이디 중 일부 문자를 '*' 문자로 가려서 전달했습니다. 가리고자 하는 문자 하나에 '*' 문자 하나를 사용하였고 아이디 당 최소 하나 이상의 '*' 문자를 사용하였습니다. ""무지""와 ""프로도""는 불량 사용자 목록에 매핑된 응모자 아이디를 제재 아이디 라고 부르기로 하였습니다. 예를 들어, 이벤트에 응모한 전체 사용자 아이디 목록이 다음과 같다면 응모자 아이디 frodo fradi crodo abc123 frodoc 다음과 같이 불량 사용자 아이디 목록이 전달된 경우, 불량 사용자 fr*d* abc1** 불량 사용자에 매핑되어 당첨에서 제외되어야 야 할 제재 아이디 목록은 다음과 같이 두 가지 경우가 있을 수 있습니다. 제재 아이디 frodo abc123 제재 아이디 fradi abc123 이벤트 응모자 아이디 목록이 담긴 배열 user_id와 불량 사용자 아이디 목록이 담긴 배열 banned_id가 매개변수로 주어질 때, 당첨에서 제외되어야 할 제재 아이디 목록은 몇가지 경우의 수가 가능한 지 return 하도록 solution 함수를 완성해주세요. [제한사항] user_id 배열의 크기는 1 이상 8 이하입니다. user_id 배열 각 원소들의 값은 길이가 1 이상 8 이하인 문자열입니다. 응모한 사용자 아이디들은 서로 중복되지 않습니다. 응모한 사용자 아이디는 알파벳 소문자와 숫자로만으로 구성되어 있습니다. banned_id 배열의 크기는 1 이상 user_id 배열의 크기 이하입니다. banned_id 배열 각 원소들의 값은 길이가 1 이상 8 이하인 문자열입니다. 불량 사용자 아이디는 알파벳 소문자와 숫자, 가리기 위한 문자 '*' 로만 이루어져 있습니다. 불량 사용자 아이디는 '*' 문자를 하나 이상 포함하고 있습니다. 불량 사용자 아이디 하나는 응모자 아이디 중 하나에 해당하고 같은 응모자 아이디가 중복해서 제재 아이디 목록에 들어가는 경우는 없습니다. 제재 아이디 목록들을 구했을 때 아이디들이 나열된 순서와 관계없이 아이디 목록의 내용이 동일하다면 같은 것으로 처리하여 하나로 세면 됩니다. [입출력 예] user_id banned_id result [""frodo"", ""fradi"", ""crodo"", ""abc123"", ""frodoc""] [""fr*d*"", ""abc1**""] 2 [""frodo"", ""fradi"", ""crodo"", ""abc123"", ""frodoc""] [""*rodo"", ""*rodo"", ""******""] 2 [""frodo"", ""fradi"", ""crodo"", ""abc123"", ""frodoc""] [""fr*d*"", ""*rodo"", ""******"", ""******""] 3 입출력 예에 대한 설명 입출력 예 #1 문제 설명과 같습니다. 입출력 예 #2 다음과 같이 두 가지 경우가 있습니다. 제재 아이디 frodo crodo abc123 제재 아이디 frodo crodo frodoc 입출력 예 #3 다음과 같이 세 가지 경우가 있습니다. 제재 아이디 frodo crodo abc123 frodoc 제재 아이디 fradi crodo abc123 frodoc 제재 아이디 fradi frodo abc123 frodoc",normal,Array
435,"[본 문제는 정확성과 효율성 테스트 각각 점수가 있는 문제입니다.] ""스노우타운""에서 호텔을 운영하고 있는 ""스카피""는 호텔에 투숙하려는 고객들에게 방을 배정하려 합니다. 호텔에는 방이 총 k개 있으며, 각각의 방은 1번부터 k번까지 번호로 구분하고 있습니다. 처음에는 모든 방이 비어 있으며 ""스카피""는 다음과 같은 규칙에 따라 고객에게 방을 배정하려고 합니다. 한 번에 한 명씩 신청한 순서대로 방을 배정합니다. 고객은 투숙하기 원하는 방 번호를 제출합니다. 고객이 원하는 방이 비어 있다면 즉시 배정합니다. 고객이 원하는 방이 이미 배정되어 있으면 원하는 방보다 번호가 크면서 비어있는 방 중 가장 번호가 작은 방을 배정합니다. 예를 들어, 방이 총 10개이고, 고객들이 원하는 방 번호가 순서대로 [1, 3, 4, 1, 3, 1] 일 경우 다음과 같이 방을 배정받게 됩니다. 원하는 방 번호 배정된 방 번호 1 1 3 3 4 4 1 2 3 5 1 6 전체 방 개수 k와 고객들이 원하는 방 번호가 순서대로 들어있는 배열 room_number가 매개변수로 주어질 때, 각 고객에게 배정되는 방 번호를 순서대로 배열에 담아 return 하도록 solution 함수를 완성해주세요. [제한사항] k는 1 이상 1012 이하인 자연수입니다. room_number 배열의 크기는 1 이상 200,000 이하입니다. room_number 배열 각 원소들의 값은 1 이상 k 이하인 자연수입니다. room_number 배열은 모든 고객이 방을 배정받을 수 있는 경우만 입력으로 주어집니다. 예를 들어, k = 5, room_number = [5, 5] 와 같은 경우는 방을 배정받지 못하는 고객이 발생하므로 이런 경우는 입력으로 주어지지 않습니다. [입출력 예] k room_number result 10 [1,3,4,1,3,1] [1,3,4,2,5,6] 입출력 예에 대한 설명 입출력 예 #1 문제의 예시와 같습니다. 첫 번째 ~ 세 번째 고객까지는 원하는 방이 비어 있으므로 즉시 배정받을 수 있습니다. 네 번째 고객의 경우 1번 방을 배정받기를 원했는데, 1번 방은 빈 방이 아니므로, 1번 보다 번호가 크고 비어 있는 방 중에서 가장 번호가 작은 방을 배정해야 합니다. 1번 보다 번호가 크면서 비어있는 방은 [2번, 5번, 6번...] 방이며, 이중 가장 번호가 작은 방은 2번 방입니다. 따라서 네 번째 고객은 2번 방을 배정받습니다. 마찬가지로 5, 6번째 고객은 각각 5번, 6번 방을 배정받게 됩니다.",hard,Array
436,"[본 문제는 정확성과 효율성 테스트 각각 점수가 있는 문제입니다.] 카카오 초등학교의 ""니니즈 친구들""이 ""라이언"" 선생님과 함께 가을 소풍을 가는 중에 징검다리가 있는 개울을 만나서 건너편으로 건너려고 합니다. ""라이언"" 선생님은 ""니니즈 친구들""이 무사히 징검다리를 건널 수 있도록 다음과 같이 규칙을 만들었습니다. 징검다리는 일렬로 놓여 있고 각 징검다리의 디딤돌에는 모두 숫자가 적혀 있으며 디딤돌의 숫자는 한 번 밟을 때마다 1씩 줄어듭니다. 디딤돌의 숫자가 0이 되면 더 이상 밟을 수 없으며 이때는 그 다음 디딤돌로 한번에 여러 칸을 건너 뛸 수 있습니다. 단, 다음으로 밟을 수 있는 디딤돌이 여러 개인 경우 무조건 가장 가까운 디딤돌로만 건너뛸 수 있습니다. ""니니즈 친구들""은 개울의 왼쪽에 있으며, 개울의 오른쪽 건너편에 도착해야 징검다리를 건넌 것으로 인정합니다. ""니니즈 친구들""은 한 번에 한 명씩 징검다리를 건너야 하며, 한 친구가 징검다리를 모두 건넌 후에 그 다음 친구가 건너기 시작합니다. 디딤돌에 적힌 숫자가 순서대로 담긴 배열 stones와 한 번에 건너뛸 수 있는 디딤돌의 최대 칸수 k가 매개변수로 주어질 때, 최대 몇 명까지 징검다리를 건널 수 있는지 return 하도록 solution 함수를 완성해주세요. [제한사항] 징검다리를 건너야 하는 니니즈 친구들의 수는 무제한 이라고 간주합니다. stones 배열의 크기는 1 이상 200,000 이하입니다. stones 배열 각 원소들의 값은 1 이상 200,000,000 이하인 자연수입니다. k는 1 이상 stones의 길이 이하인 자연수입니다. [입출력 예] stones k result [2, 4, 5, 3, 2, 1, 4, 2, 5, 1] 3 3 입출력 예에 대한 설명 입출력 예 #1 첫 번째 친구는 다음과 같이 징검다리를 건널 수 있습니다. 첫 번째 친구가 징검다리를 건넌 후 디딤돌에 적힌 숫자는 아래 그림과 같습니다. 두 번째 친구도 아래 그림과 같이 징검다리를 건널 수 있습니다. 두 번째 친구가 징검다리를 건넌 후 디딤돌에 적힌 숫자는 아래 그림과 같습니다. 세 번째 친구도 아래 그림과 같이 징검다리를 건널 수 있습니다. 세 번째 친구가 징검다리를 건넌 후 디딤돌에 적힌 숫자는 아래 그림과 같습니다. 네 번째 친구가 징검다리를 건너려면, 세 번째 디딤돌에서 일곱 번째 디딤돌로 네 칸을 건너뛰어야 합니다. 하지만 k = 3 이므로 건너뛸 수 없습니다. 따라서 최대 3명이 디딤돌을 모두 건널 수 있습니다.",normal,Array
437,"게임개발자인 ""죠르디""는 크레인 인형뽑기 기계를 모바일 게임으로 만들려고 합니다. ""죠르디""는 게임의 재미를 높이기 위해 화면 구성과 규칙을 다음과 같이 게임 로직에 반영하려고 합니다. 게임 화면은 ""1 x 1"" 크기의 칸들로 이루어진 ""N x N"" 크기의 정사각 격자이며 위쪽에는 크레인이 있고 오른쪽에는 바구니가 있습니다. (위 그림은 ""5 x 5"" 크기의 예시입니다). 각 격자 칸에는 다양한 인형이 들어 있으며 인형이 없는 칸은 빈칸입니다. 모든 인형은 ""1 x 1"" 크기의 격자 한 칸을 차지하며 격자의 가장 아래 칸부터 차곡차곡 쌓여 있습니다. 게임 사용자는 크레인을 좌우로 움직여서 멈춘 위치에서 가장 위에 있는 인형을 집어 올릴 수 있습니다. 집어 올린 인형은 바구니에 쌓이게 되는 데, 이때 바구니의 가장 아래 칸부터 인형이 순서대로 쌓이게 됩니다. 다음 그림은 [1번, 5번, 3번] 위치에서 순서대로 인형을 집어 올려 바구니에 담은 모습입니다. 만약 같은 모양의 인형 두 개가 바구니에 연속해서 쌓이게 되면 두 인형은 터뜨려지면서 바구니에서 사라지게 됩니다. 위 상태에서 이어서 [5번] 위치에서 인형을 집어 바구니에 쌓으면 같은 모양 인형 두 개가 없어집니다. 크레인 작동 시 인형이 집어지지 않는 경우는 없으나 만약 인형이 없는 곳에서 크레인을 작동시키는 경우에는 아무런 일도 일어나지 않습니다. 또한 바구니는 모든 인형이 들어갈 수 있을 만큼 충분히 크다고 가정합니다. (그림에서는 화면표시 제약으로 5칸만으로 표현하였음) 게임 화면의 격자의 상태가 담긴 2차원 배열 board와 인형을 집기 위해 크레인을 작동시킨 위치가 담긴 배열 moves가 매개변수로 주어질 때, 크레인을 모두 작동시킨 후 터트려져 사라진 인형의 개수를 return 하도록 solution 함수를 완성해주세요. [제한사항] board 배열은 2차원 배열로 크기는 ""5 x 5"" 이상 ""30 x 30"" 이하입니다. board의 각 칸에는 0 이상 100 이하인 정수가 담겨있습니다. 0은 빈 칸을 나타냅니다. 1 ~ 100의 각 숫자는 각기 다른 인형의 모양을 의미하며 같은 숫자는 같은 모양의 인형을 나타냅니다. moves 배열의 크기는 1 이상 1,000 이하입니다. moves 배열 각 원소들의 값은 1 이상이며 board 배열의 가로 크기 이하인 자연수입니다. 입출력 예 board moves result [[0,0,0,0,0],[0,0,1,0,3],[0,2,5,0,1],[4,2,4,4,2],[3,5,1,3,1]] [1,5,3,5,1,2,1,4] 4 입출력 예에 대한 설명 입출력 예 #1 인형의 처음 상태는 문제에 주어진 예시와 같습니다. 크레인이 [1, 5, 3, 5, 1, 2, 1, 4] 번 위치에서 차례대로 인형을 집어서 바구니에 옮겨 담은 후, 상태는 아래 그림과 같으며 바구니에 담는 과정에서 터트려져 사라진 인형은 4개 입니다.",easy,Array
438,"CART_PRODUCTS 테이블은 장바구니에 담긴 상품 정보를 담은 테이블입니다. CART_PRODUCTS 테이블의 구조는 다음과 같으며, ID, CART_ID, NAME, PRICE는 각각 테이블의 아이디, 장바구니의 아이디, 상품 종류, 가격을 나타냅니다. NAME TYPE ID INT CART_ID INT NAME VARCHAR PRICE INT 데이터 분석 팀에서는 우유(Milk)와 요거트(Yogurt)를 동시에 구입한 장바구니가 있는지 알아보려 합니다. 우유와 요거트를 동시에 구입한 장바구니의 아이디를 조회하는 SQL 문을 작성해주세요. 이때 결과는 장바구니의 아이디 순으로 나와야 합니다. 예시 예를 들어 CART_PRODUCTS 테이블이 다음과 같다면 CART_PRODUCTS 테이블 ID CART_ID NAME PRICE 1630 83 Cereal 3980 1631 83 Multipurpose Supply 3900 5491 286 Yogurt 2980 5504 286 Milk 1880 8435 448 Milk 1880 8437 448 Yogurt 2980 8438 448 Tea 11000 20236 1034 Yogurt 2980 20237 1034 Butter 4890 83번 장바구니에는 Milk와 Yogurt가 모두 없습니다. 286번 장바구니에는 Milk와 Yogurt가 모두 있습니다. 448번 장바구니에는 Milk와 Yogurt가 모두 있습니다. 1034번 장바구니에는 Milk는 없고 Yogurt만 있습니다. 따라서 SQL 문을 실행하면 다음과 같이 나와야 합니다. CART_ID 286 448",hard,database
439,"N x N 크기인 정사각 격자 형태의 지형이 있습니다. 각 격자 칸은 1 x 1 크기이며, 숫자가 하나씩 적혀있습니다. 격자 칸에 적힌 숫자는 그 칸의 높이를 나타냅니다. 이 지형의 아무 칸에서나 출발해 모든 칸을 방문하는 탐험을 떠나려 합니다. 칸을 이동할 때는 상, 하, 좌, 우로 한 칸씩 이동할 수 있는데, 현재 칸과 이동하려는 칸의 높이 차가 height 이하여야 합니다. 높이 차가 height 보다 많이 나는 경우에는 사다리를 설치해서 이동할 수 있습니다. 이때, 사다리를 설치하는데 두 격자 칸의 높이차만큼 비용이 듭니다. 따라서, 최대한 적은 비용이 들도록 사다리를 설치해서 모든 칸으로 이동 가능하도록 해야 합니다. 설치할 수 있는 사다리 개수에 제한은 없으며, 설치한 사다리는 철거하지 않습니다. 각 격자칸의 높이가 담긴 2차원 배열 land와 이동 가능한 최대 높이차 height가 매개변수로 주어질 때, 모든 칸을 방문하기 위해 필요한 사다리 설치 비용의 최솟값을 return 하도록 solution 함수를 완성해주세요. 제한사항 land는 N x N크기인 2차원 배열입니다. land의 최소 크기는 4 x 4, 최대 크기는 300 x 300입니다. land의 원소는 각 격자 칸의 높이를 나타냅니다. 격자 칸의 높이는 1 이상 10,000 이하인 자연수입니다. height는 1 이상 10,000 이하인 자연수입니다. 입출력 예 land height result [[1, 4, 8, 10], [5, 5, 5, 5], [10, 10, 10, 10], [10, 10, 10, 20]] 3 15 [[10, 11, 10, 11], [2, 21, 20, 10], [1, 20, 21, 11], [2, 1, 2, 1]] 1 18 입출력 예 설명 입출력 예 #1 각 칸의 높이는 다음과 같으며, 높이차가 3 이하인 경우 사다리 없이 이동이 가능합니다. 위 그림에서 사다리를 이용하지 않고 이동 가능한 범위는 같은 색으로 칠해져 있습니다. 예를 들어 (1행 2열) 높이 4인 칸에서 (1행 3열) 높이 8인 칸으로 직접 이동할 수는 없지만, 높이가 5인 칸을 이용하면 사다리를 사용하지 않고 이동할 수 있습니다. 따라서 다음과 같이 사다리 두 개만 설치하면 모든 칸을 방문할 수 있고 최소 비용은 15가 됩니다. 높이 5인 칸 → 높이 10인 칸 : 비용 5 높이 10인 칸 → 높이 20인 칸 : 비용 10 입출력 예 #2 각 칸의 높이는 다음과 같으며, 높이차가 1 이하인 경우 사다리 없이 이동이 가능합니다. 위 그림과 같이 (2행 1열) → (1행 1열), (1행 2열) → (2행 2열) 두 곳에 사다리를 설치하면 설치비용이 18로 최소가 됩니다.",hard,Array
440,"가로 길이가 Wcm, 세로 길이가 Hcm인 직사각형 종이가 있습니다. 종이에는 가로, 세로 방향과 평행하게 격자 형태로 선이 그어져 있으며, 모든 격자칸은 1cm x 1cm 크기입니다. 이 종이를 격자 선을 따라 1cm × 1cm의 정사각형으로 잘라 사용할 예정이었는데, 누군가가 이 종이를 대각선 꼭지점 2개를 잇는 방향으로 잘라 놓았습니다. 그러므로 현재 직사각형 종이는 크기가 같은 직각삼각형 2개로 나누어진 상태입니다. 새로운 종이를 구할 수 없는 상태이기 때문에, 이 종이에서 원래 종이의 가로, 세로 방향과 평행하게 1cm × 1cm로 잘라 사용할 수 있는 만큼만 사용하기로 하였습니다. 가로의 길이 W와 세로의 길이 H가 주어질 때, 사용할 수 있는 정사각형의 개수를 구하는 solution 함수를 완성해 주세요. 제한사항 W, H : 1억 이하의 자연수 입출력 예 W H result 8 12 80 입출력 예 설명 입출력 예 #1 가로가 8, 세로가 12인 직사각형을 대각선 방향으로 자르면 총 16개 정사각형을 사용할 수 없게 됩니다. 원래 직사각형에서는 96개의 정사각형을 만들 수 있었으므로, 96 - 16 = 80 을 반환합니다.",normal,Math
441,"로봇개발자 ""무지""는 한 달 앞으로 다가온 ""카카오배 로봇경진대회""에 출품할 로봇을 준비하고 있습니다. 준비 중인 로봇은 2 x 1 크기의 로봇으로 ""무지""는 ""0""과 ""1""로 이루어진 N x N 크기의 지도에서 2 x 1 크기인 로봇을 움직여 (N, N) 위치까지 이동 할 수 있도록 프로그래밍을 하려고 합니다. 로봇이 이동하는 지도는 가장 왼쪽, 상단의 좌표를 (1, 1)로 하며 지도 내에 표시된 숫자 ""0""은 빈칸을 ""1""은 벽을 나타냅니다. 로봇은 벽이 있는 칸 또는 지도 밖으로는 이동할 수 없습니다. 로봇은 처음에 아래 그림과 같이 좌표 (1, 1) 위치에서 가로방향으로 놓여있는 상태로 시작하며, 앞뒤 구분없이 움직일 수 있습니다. 로봇이 움직일 때는 현재 놓여있는 상태를 유지하면서 이동합니다. 예를 들어, 위 그림에서 오른쪽으로 한 칸 이동한다면 (1, 2), (1, 3) 두 칸을 차지하게 되며, 아래로 이동한다면 (2, 1), (2, 2) 두 칸을 차지하게 됩니다. 로봇이 차지하는 두 칸 중 어느 한 칸이라도 (N, N) 위치에 도착하면 됩니다. 로봇은 다음과 같이 조건에 따라 회전이 가능합니다. 위 그림과 같이 로봇은 90도씩 회전할 수 있습니다. 단, 로봇이 차지하는 두 칸 중, 어느 칸이든 축이 될 수 있지만, 회전하는 방향(축이 되는 칸으로부터 대각선 방향에 있는 칸)에는 벽이 없어야 합니다. 로봇이 한 칸 이동하거나 90도 회전하는 데는 걸리는 시간은 정확히 1초 입니다. ""0""과 ""1""로 이루어진 지도인 board가 주어질 때, 로봇이 (N, N) 위치까지 이동하는데 필요한 최소 시간을 return 하도록 solution 함수를 완성해주세요. 제한사항 board의 한 변의 길이는 5 이상 100 이하입니다. board의 원소는 0 또는 1입니다. 로봇이 처음에 놓여 있는 칸 (1, 1), (1, 2)는 항상 0으로 주어집니다. 로봇이 항상 목적지에 도착할 수 있는 경우만 입력으로 주어집니다. 입출력 예 board result [[0, 0, 0, 1, 1],[0, 0, 0, 1, 0],[0, 1, 0, 1, 1],[1, 1, 0, 0, 1],[0, 0, 0, 0, 0]] 7 입출력 예에 대한 설명 문제에 주어진 예시와 같습니다. 로봇이 오른쪽으로 한 칸 이동 후, (1, 3) 칸을 축으로 반시계 방향으로 90도 회전합니다. 다시, 아래쪽으로 3칸 이동하면 로봇은 (4, 3), (5, 3) 두 칸을 차지하게 됩니다. 이제 (5, 3)을 축으로 시계 방향으로 90도 회전 후, 오른쪽으로 한 칸 이동하면 (N, N)에 도착합니다. 따라서 목적지에 도달하기까지 최소 7초가 걸립니다.",normal,Math
442,"레스토랑을 운영하고 있는 ""스카피""는 레스토랑 내부가 너무 낡아 친구들과 함께 직접 리모델링 하기로 했습니다. 레스토랑이 있는 곳은 스노우타운으로 매우 추운 지역이어서 내부 공사를 하는 도중에 주기적으로 외벽의 상태를 점검해야 할 필요가 있습니다. 레스토랑의 구조는 완전히 동그란 모양이고 외벽의 총 둘레는 n미터이며, 외벽의 몇몇 지점은 추위가 심할 경우 손상될 수도 있는 취약한 지점들이 있습니다. 따라서 내부 공사 도중에도 외벽의 취약 지점들이 손상되지 않았는 지, 주기적으로 친구들을 보내서 점검을 하기로 했습니다. 다만, 빠른 공사 진행을 위해 점검 시간을 1시간으로 제한했습니다. 친구들이 1시간 동안 이동할 수 있는 거리는 제각각이기 때문에, 최소한의 친구들을 투입해 취약 지점을 점검하고 나머지 친구들은 내부 공사를 돕도록 하려고 합니다. 편의 상 레스토랑의 정북 방향 지점을 0으로 나타내며, 취약 지점의 위치는 정북 방향 지점으로부터 시계 방향으로 떨어진 거리로 나타냅니다. 또, 친구들은 출발 지점부터 시계, 혹은 반시계 방향으로 외벽을 따라서만 이동합니다. 외벽의 길이 n, 취약 지점의 위치가 담긴 배열 weak, 각 친구가 1시간 동안 이동할 수 있는 거리가 담긴 배열 dist가 매개변수로 주어질 때, 취약 지점을 점검하기 위해 보내야 하는 친구 수의 최소값을 return 하도록 solution 함수를 완성해주세요. 제한사항 n은 1 이상 200 이하인 자연수입니다. weak의 길이는 1 이상 15 이하입니다. 서로 다른 두 취약점의 위치가 같은 경우는 주어지지 않습니다. 취약 지점의 위치는 오름차순으로 정렬되어 주어집니다. weak의 원소는 0 이상 n - 1 이하인 정수입니다. dist의 길이는 1 이상 8 이하입니다. dist의 원소는 1 이상 100 이하인 자연수입니다. 친구들을 모두 투입해도 취약 지점을 전부 점검할 수 없는 경우에는 -1을 return 해주세요. 입출력 예 n weak dist result 12 [1, 5, 6, 10] [1, 2, 3, 4] 2 12 [1, 3, 4, 9, 10] [3, 5, 7] 1 입출력 예에 대한 설명 입출력 예 #1 원형 레스토랑에서 외벽의 취약 지점의 위치는 다음과 같습니다. 친구들을 투입하는 예시 중 하나는 다음과 같습니다. 4m를 이동할 수 있는 친구는 10m 지점에서 출발해 시계방향으로 돌아 1m 위치에 있는 취약 지점에서 외벽 점검을 마칩니다. 2m를 이동할 수 있는 친구는 4.5m 지점에서 출발해 6.5m 지점에서 외벽 점검을 마칩니다. 그 외에 여러 방법들이 있지만, 두 명보다 적은 친구를 투입하는 방법은 없습니다. 따라서 친구를 최소 두 명 투입해야 합니다. 입출력 예 #2 원형 레스토랑에서 외벽의 취약 지점의 위치는 다음과 같습니다. 7m를 이동할 수 있는 친구가 4m 지점에서 출발해 반시계 방향으로 점검을 돌면 모든 취약 지점을 점검할 수 있습니다. 따라서 친구를 최소 한 명 투입하면 됩니다.",normal,Array
443,"빙하가 깨지면서 스노우타운에 떠내려 온 ""죠르디""는 인생 2막을 위해 주택 건축사업에 뛰어들기로 결심하였습니다. ""죠르디""는 기둥과 보를 이용하여 벽면 구조물을 자동으로 세우는 로봇을 개발할 계획인데, 그에 앞서 로봇의 동작을 시뮬레이션 할 수 있는 프로그램을 만들고 있습니다. 프로그램은 2차원 가상 벽면에 기둥과 보를 이용한 구조물을 설치할 수 있는데, 기둥과 보는 길이가 1인 선분으로 표현되며 다음과 같은 규칙을 가지고 있습니다. 기둥은 바닥 위에 있거나 보의 한쪽 끝 부분 위에 있거나, 또는 다른 기둥 위에 있어야 합니다. 보는 한쪽 끝 부분이 기둥 위에 있거나, 또는 양쪽 끝 부분이 다른 보와 동시에 연결되어 있어야 합니다. 단, 바닥은 벽면의 맨 아래 지면을 말합니다. 2차원 벽면은 n x n 크기 정사각 격자 형태이며, 각 격자는 1 x 1 크기입니다. 맨 처음 벽면은 비어있는 상태입니다. 기둥과 보는 격자선의 교차점에 걸치지 않고, 격자 칸의 각 변에 정확히 일치하도록 설치할 수 있습니다. 다음은 기둥과 보를 설치해 구조물을 만든 예시입니다. 예를 들어, 위 그림은 다음 순서에 따라 구조물을 만들었습니다. (1, 0)에서 위쪽으로 기둥을 하나 설치 후, (1, 1)에서 오른쪽으로 보를 하나 만듭니다. (2, 1)에서 위쪽으로 기둥을 하나 설치 후, (2, 2)에서 오른쪽으로 보를 하나 만듭니다. (5, 0)에서 위쪽으로 기둥을 하나 설치 후, (5, 1)에서 위쪽으로 기둥을 하나 더 설치합니다. (4, 2)에서 오른쪽으로 보를 설치 후, (3, 2)에서 오른쪽으로 보를 설치합니다. 만약 (4, 2)에서 오른쪽으로 보를 먼저 설치하지 않고, (3, 2)에서 오른쪽으로 보를 설치하려 한다면 2번 규칙에 맞지 않으므로 설치가 되지 않습니다. 기둥과 보를 삭제하는 기능도 있는데 기둥과 보를 삭제한 후에 남은 기둥과 보들 또한 위 규칙을 만족해야 합니다. 만약, 작업을 수행한 결과가 조건을 만족하지 않는다면 해당 작업은 무시됩니다. 벽면의 크기 n, 기둥과 보를 설치하거나 삭제하는 작업이 순서대로 담긴 2차원 배열 build_frame이 매개변수로 주어질 때, 모든 명령어를 수행한 후 구조물의 상태를 return 하도록 solution 함수를 완성해주세요. 제한사항 n은 5 이상 100 이하인 자연수입니다. build_frame의 세로(행) 길이는 1 이상 1,000 이하입니다. build_frame의 가로(열) 길이는 4입니다. build_frame의 원소는 [x, y, a, b]형태입니다. x, y는 기둥, 보를 설치 또는 삭제할 교차점의 좌표이며, [가로 좌표, 세로 좌표] 형태입니다. a는 설치 또는 삭제할 구조물의 종류를 나타내며, 0은 기둥, 1은 보를 나타냅니다. b는 구조물을 설치할 지, 혹은 삭제할 지를 나타내며 0은 삭제, 1은 설치를 나타냅니다. 벽면을 벗어나게 기둥, 보를 설치하는 경우는 없습니다. 바닥에 보를 설치 하는 경우는 없습니다. 구조물은 교차점 좌표를 기준으로 보는 오른쪽, 기둥은 위쪽 방향으로 설치 또는 삭제합니다. 구조물이 겹치도록 설치하는 경우와, 없는 구조물을 삭제하는 경우는 입력으로 주어지지 않습니다. 최종 구조물의 상태는 아래 규칙에 맞춰 return 해주세요. return 하는 배열은 가로(열) 길이가 3인 2차원 배열로, 각 구조물의 좌표를 담고있어야 합니다. return 하는 배열의 원소는 [x, y, a] 형식입니다. x, y는 기둥, 보의 교차점 좌표이며, [가로 좌표, 세로 좌표] 형태입니다. 기둥, 보는 교차점 좌표를 기준으로 오른쪽, 또는 위쪽 방향으로 설치되어 있음을 나타냅니다. a는 구조물의 종류를 나타내며, 0은 기둥, 1은 보를 나타냅니다. return 하는 배열은 x좌표 기준으로 오름차순 정렬하며, x좌표가 같을 경우 y좌표 기준으로 오름차순 정렬해주세요. x, y좌표가 모두 같은 경우 기둥이 보보다 앞에 오면 됩니다. 입출력 예 n build_frame result 5 [[1,0,0,1],[1,1,1,1],[2,1,0,1],[2,2,1,1],[5,0,0,1],[5,1,0,1],[4,2,1,1],[3,2,1,1]] [[1,0,0],[1,1,1],[2,1,0],[2,2,1],[3,2,1],[4,2,1],[5,0,0],[5,1,0]] 5 [[0,0,0,1],[2,0,0,1],[4,0,0,1],[0,1,1,1],[1,1,1,1],[2,1,1,1],[3,1,1,1],[2,0,0,0],[1,1,1,0],[2,2,0,1]] [[0,0,0],[0,1,1],[1,1,1],[2,1,1],[3,1,1],[4,0,0]] 입출력 예에 대한 설명 입출력 예 #1 문제의 예시와 같습니다. 입출력 예 #2 여덟 번째 작업을 수행 후 아래와 같은 구조물 만들어집니다. 아홉 번째 작업의 경우, (1, 1)에서 오른쪽에 있는 보를 삭제하면 (2, 1)에서 오른쪽에 있는 보는 조건을 만족하지 않으므로 무시됩니다. 열 번째 작업의 경우, (2, 2)에서 위쪽 방향으로 기둥을 세울 경우 조건을 만족하지 않으므로 무시됩니다.",normal,Array
444,"[본 문제는 정확성과 효율성 테스트 각각 점수가 있는 문제입니다.] 친구들로부터 천재 프로그래머로 불리는 ""프로도""는 음악을 하는 친구로부터 자신이 좋아하는 노래 가사에 사용된 단어들 중에 특정 키워드가 몇 개 포함되어 있는지 궁금하니 프로그램으로 개발해 달라는 제안을 받았습니다. 그 제안 사항 중, 키워드는 와일드카드 문자중 하나인 '?'가 포함된 패턴 형태의 문자열을 뜻합니다. 와일드카드 문자인 '?'는 글자 하나를 의미하며, 어떤 문자에도 매치된다고 가정합니다. 예를 들어 ""fro??""는 ""frodo"", ""front"", ""frost"" 등에 매치되지만 ""frame"", ""frozen""에는 매치되지 않습니다. 가사에 사용된 모든 단어들이 담긴 배열 words와 찾고자 하는 키워드가 담긴 배열 queries가 주어질 때, 각 키워드 별로 매치된 단어가 몇 개인지 순서대로 배열에 담아 반환하도록 solution 함수를 완성해 주세요. 가사 단어 제한사항 words의 길이(가사 단어의 개수)는 2 이상 100,000 이하입니다. 각 가사 단어의 길이는 1 이상 10,000 이하로 빈 문자열인 경우는 없습니다. 전체 가사 단어 길이의 합은 2 이상 1,000,000 이하입니다. 가사에 동일 단어가 여러 번 나올 경우 중복을 제거하고 words에는 하나로만 제공됩니다. 각 가사 단어는 오직 알파벳 소문자로만 구성되어 있으며, 특수문자나 숫자는 포함하지 않는 것으로 가정합니다. 검색 키워드 제한사항 queries의 길이(검색 키워드 개수)는 2 이상 100,000 이하입니다. 각 검색 키워드의 길이는 1 이상 10,000 이하로 빈 문자열인 경우는 없습니다. 전체 검색 키워드 길이의 합은 2 이상 1,000,000 이하입니다. 검색 키워드는 중복될 수도 있습니다. 각 검색 키워드는 오직 알파벳 소문자와 와일드카드 문자인 '?' 로만 구성되어 있으며, 특수문자나 숫자는 포함하지 않는 것으로 가정합니다. 검색 키워드는 와일드카드 문자인 '?'가 하나 이상 포함돼 있으며, '?'는 각 검색 키워드의 접두사 아니면 접미사 중 하나로만 주어집니다. 예를 들어 ""??odo"", ""fro??"", ""?????""는 가능한 키워드입니다. 반면에 ""frodo""('?'가 없음), ""fr?do""('?'가 중간에 있음), ""?ro??""('?'가 양쪽에 있음)는 불가능한 키워드입니다. 입출력 예 words queries result [""frodo"", ""front"", ""frost"", ""frozen"", ""frame"", ""kakao""] [""fro??"", ""????o"", ""fr???"", ""fro???"", ""pro?""] [3, 2, 4, 1, 0] 입출력 예에 대한 설명 ""fro??""는 ""frodo"", ""front"", ""frost""에 매치되므로 3입니다. ""????o""는 ""frodo"", ""kakao""에 매치되므로 2입니다. ""fr???""는 ""frodo"", ""front"", ""frost"", ""frame""에 매치되므로 4입니다. ""fro???""는 ""frozen""에 매치되므로 1입니다. ""pro?""는 매치되는 가사 단어가 없으므로 0 입니다.",hard,Array
445,"고고학자인 ""튜브""는 고대 유적지에서 보물과 유적이 가득할 것으로 추정되는 비밀의 문을 발견하였습니다. 그런데 문을 열려고 살펴보니 특이한 형태의 자물쇠로 잠겨 있었고 문 앞에는 특이한 형태의 열쇠와 함께 자물쇠를 푸는 방법에 대해 다음과 같이 설명해 주는 종이가 발견되었습니다. 잠겨있는 자물쇠는 격자 한 칸의 크기가 1 x 1인 N x N 크기의 정사각 격자 형태이고 특이한 모양의 열쇠는 M x M 크기인 정사각 격자 형태로 되어 있습니다. 자물쇠에는 홈이 파여 있고 열쇠 또한 홈과 돌기 부분이 있습니다. 열쇠는 회전과 이동이 가능하며 열쇠의 돌기 부분을 자물쇠의 홈 부분에 딱 맞게 채우면 자물쇠가 열리게 되는 구조입니다. 자물쇠 영역을 벗어난 부분에 있는 열쇠의 홈과 돌기는 자물쇠를 여는 데 영향을 주지 않지만, 자물쇠 영역 내에서는 열쇠의 돌기 부분과 자물쇠의 홈 부분이 정확히 일치해야 하며 열쇠의 돌기와 자물쇠의 돌기가 만나서는 안됩니다. 또한 자물쇠의 모든 홈을 채워 비어있는 곳이 없어야 자물쇠를 열 수 있습니다. 열쇠를 나타내는 2차원 배열 key와 자물쇠를 나타내는 2차원 배열 lock이 매개변수로 주어질 때, 열쇠로 자물쇠를 열수 있으면 true를, 열 수 없으면 false를 return 하도록 solution 함수를 완성해주세요. 제한사항 key는 M x M(3 ≤ M ≤ 20, M은 자연수)크기 2차원 배열입니다. lock은 N x N(3 ≤ N ≤ 20, N은 자연수)크기 2차원 배열입니다. M은 항상 N 이하입니다. key와 lock의 원소는 0 또는 1로 이루어져 있습니다. 0은 홈 부분, 1은 돌기 부분을 나타냅니다. 입출력 예 key lock result [[0, 0, 0], [1, 0, 0], [0, 1, 1]] [[1, 1, 1], [1, 1, 0], [1, 0, 1]] true 입출력 예에 대한 설명 key를 시계 방향으로 90도 회전하고, 오른쪽으로 한 칸, 아래로 한 칸 이동하면 lock의 홈 부분을 정확히 모두 채울 수 있습니다.",normal,Array
446,"카카오에 신입 개발자로 입사한 ""콘""은 선배 개발자로부터 개발역량 강화를 위해 다른 개발자가 작성한 소스 코드를 분석하여 문제점을 발견하고 수정하라는 업무 과제를 받았습니다. 소스를 컴파일하여 로그를 보니 대부분 소스 코드 내 작성된 괄호가 개수는 맞지만 짝이 맞지 않은 형태로 작성되어 오류가 나는 것을 알게 되었습니다. 수정해야 할 소스 파일이 너무 많아서 고민하던 ""콘""은 소스 코드에 작성된 모든 괄호를 뽑아서 올바른 순서대로 배치된 괄호 문자열을 알려주는 프로그램을 다음과 같이 개발하려고 합니다. 용어의 정의 '(' 와 ')' 로만 이루어진 문자열이 있을 경우, '(' 의 개수와 ')' 의 개수가 같다면 이를 균형잡힌 괄호 문자열이라고 부릅니다. 그리고 여기에 '('와 ')'의 괄호의 짝도 모두 맞을 경우에는 이를 올바른 괄호 문자열이라고 부릅니다. 예를 들어, ""(()))(""와 같은 문자열은 ""균형잡힌 괄호 문자열"" 이지만 ""올바른 괄호 문자열""은 아닙니다. 반면에 ""(())()""와 같은 문자열은 ""균형잡힌 괄호 문자열"" 이면서 동시에 ""올바른 괄호 문자열"" 입니다. '(' 와 ')' 로만 이루어진 문자열 w가 ""균형잡힌 괄호 문자열"" 이라면 다음과 같은 과정을 통해 ""올바른 괄호 문자열""로 변환할 수 있습니다. 1. 입력이 빈 문자열인 경우, 빈 문자열을 반환합니다. 2. 문자열 w를 두 ""균형잡힌 괄호 문자열"" u, v로 분리합니다. 단, u는 ""균형잡힌 괄호 문자열""로 더 이상 분리할 수 없어야 하며, v는 빈 문자열이 될 수 있습니다. 3. 문자열 u가 ""올바른 괄호 문자열"" 이라면 문자열 v에 대해 1단계부터 다시 수행합니다. 3-1. 수행한 결과 문자열을 u에 이어 붙인 후 반환합니다. 4. 문자열 u가 ""올바른 괄호 문자열""이 아니라면 아래 과정을 수행합니다. 4-1. 빈 문자열에 첫 번째 문자로 '('를 붙입니다. 4-2. 문자열 v에 대해 1단계부터 재귀적으로 수행한 결과 문자열을 이어 붙입니다. 4-3. ')'를 다시 붙입니다. 4-4. u의 첫 번째와 마지막 문자를 제거하고, 나머지 문자열의 괄호 방향을 뒤집어서 뒤에 붙입니다. 4-5. 생성된 문자열을 반환합니다. ""균형잡힌 괄호 문자열"" p가 매개변수로 주어질 때, 주어진 알고리즘을 수행해 ""올바른 괄호 문자열""로 변환한 결과를 return 하도록 solution 함수를 완성해 주세요. 매개변수 설명 p는 '(' 와 ')' 로만 이루어진 문자열이며 길이는 2 이상 1,000 이하인 짝수입니다. 문자열 p를 이루는 '(' 와 ')' 의 개수는 항상 같습니다. 만약 p가 이미 ""올바른 괄호 문자열""이라면 그대로 return 하면 됩니다. 입출력 예 p result ""(()())()"" ""(()())()"" "")("" ""()"" ""()))((()"" ""()(())()"" 입출력 예에 대한 설명 입출력 예 #1 이미 ""올바른 괄호 문자열"" 입니다. 입출력 예 #2 두 문자열 u, v로 분리합니다. u = "")("" v = """" u가 ""올바른 괄호 문자열""이 아니므로 다음과 같이 새로운 문자열을 만듭니다. v에 대해 1단계부터 재귀적으로 수행하면 빈 문자열이 반환됩니다. u의 앞뒤 문자를 제거하고, 나머지 문자의 괄호 방향을 뒤집으면 """"이 됩니다. 따라서 생성되는 문자열은 ""("" + """" + "")"" + """"이며, 최종적으로 ""()""로 변환됩니다. 입출력 예 #3 두 문자열 u, v로 분리합니다. u = ""()"" v = ""))((()"" 문자열 u가 ""올바른 괄호 문자열""이므로 그대로 두고, v에 대해 재귀적으로 수행합니다. 다시 두 문자열 u, v로 분리합니다. u = ""))(("" v = ""()"" u가 ""올바른 괄호 문자열""이 아니므로 다음과 같이 새로운 문자열을 만듭니다. v에 대해 1단계부터 재귀적으로 수행하면 ""()""이 반환됩니다. u의 앞뒤 문자를 제거하고, 나머지 문자의 괄호 방향을 뒤집으면 ""()""이 됩니다. 따라서 생성되는 문자열은 ""("" + ""()"" + "")"" + ""()""이며, 최종적으로 ""(())()""를 반환합니다. 처음에 그대로 둔 문자열에 반환된 문자열을 이어 붙이면 ""()"" + ""(())()"" = ""()(())()""가 됩니다.",normal,String
447,"데이터 처리 전문가가 되고 싶은 ""어피치""는 문자열을 압축하는 방법에 대해 공부를 하고 있습니다. 최근에 대량의 데이터 처리를 위한 간단한 비손실 압축 방법에 대해 공부를 하고 있는데, 문자열에서 같은 값이 연속해서 나타나는 것을 그 문자의 개수와 반복되는 값으로 표현하여 더 짧은 문자열로 줄여서 표현하는 알고리즘을 공부하고 있습니다. 간단한 예로 ""aabbaccc""의 경우 ""2a2ba3c""(문자가 반복되지 않아 한번만 나타난 경우 1은 생략함)와 같이 표현할 수 있는데, 이러한 방식은 반복되는 문자가 적은 경우 압축률이 낮다는 단점이 있습니다. 예를 들면, ""abcabcdede""와 같은 문자열은 전혀 압축되지 않습니다. ""어피치""는 이러한 단점을 해결하기 위해 문자열을 1개 이상의 단위로 잘라서 압축하여 더 짧은 문자열로 표현할 수 있는지 방법을 찾아보려고 합니다. 예를 들어, ""ababcdcdababcdcd""의 경우 문자를 1개 단위로 자르면 전혀 압축되지 않지만, 2개 단위로 잘라서 압축한다면 ""2ab2cd2ab2cd""로 표현할 수 있습니다. 다른 방법으로 8개 단위로 잘라서 압축한다면 ""2ababcdcd""로 표현할 수 있으며, 이때가 가장 짧게 압축하여 표현할 수 있는 방법입니다. 다른 예로, ""abcabcdede""와 같은 경우, 문자를 2개 단위로 잘라서 압축하면 ""abcabc2de""가 되지만, 3개 단위로 자른다면 ""2abcdede""가 되어 3개 단위가 가장 짧은 압축 방법이 됩니다. 이때 3개 단위로 자르고 마지막에 남는 문자열은 그대로 붙여주면 됩니다. 압축할 문자열 s가 매개변수로 주어질 때, 위에 설명한 방법으로 1개 이상 단위로 문자열을 잘라 압축하여 표현한 문자열 중 가장 짧은 것의 길이를 return 하도록 solution 함수를 완성해주세요. 제한사항 s의 길이는 1 이상 1,000 이하입니다. s는 알파벳 소문자로만 이루어져 있습니다. 입출력 예 s result ""aabbaccc"" 7 ""ababcdcdababcdcd"" 9 ""abcabcdede"" 8 ""abcabcabcabcdededededede"" 14 ""xababcdcdababcdcd"" 17 입출력 예에 대한 설명 입출력 예 #1 문자열을 1개 단위로 잘라 압축했을 때 가장 짧습니다. 입출력 예 #2 문자열을 8개 단위로 잘라 압축했을 때 가장 짧습니다. 입출력 예 #3 문자열을 3개 단위로 잘라 압축했을 때 가장 짧습니다. 입출력 예 #4 문자열을 2개 단위로 자르면 ""abcabcabcabc6de"" 가 됩니다. 문자열을 3개 단위로 자르면 ""4abcdededededede"" 가 됩니다. 문자열을 4개 단위로 자르면 ""abcabcabcabc3dede"" 가 됩니다. 문자열을 6개 단위로 자를 경우 ""2abcabc2dedede""가 되며, 이때의 길이가 14로 가장 짧습니다. 입출력 예 #5 문자열은 제일 앞부터 정해진 길이만큼 잘라야 합니다. 따라서 주어진 문자열을 x / ababcdcd / ababcdcd 로 자르는 것은 불가능 합니다. 이 경우 어떻게 문자열을 잘라도 압축되지 않으므로 가장 짧은 길이는 17이 됩니다. ※ 공지 - 2024년 7월 8일 테스트케이스가 추가되었습니다. 기존에 제출한 코드가 통과하지 못할 수도 있습니다.",normal,String
448,"ANIMAL_INS 테이블은 동물 보호소에 들어온 동물의 정보를 담은 테이블입니다. ANIMAL_INS 테이블 구조는 다음과 같으며, ANIMAL_ID, ANIMAL_TYPE, DATETIME, INTAKE_CONDITION, NAME, SEX_UPON_INTAKE는 각각 동물의 아이디, 생물 종, 보호 시작일, 보호 시작 시 상태, 이름, 성별 및 중성화 여부를 나타냅니다. NAME TYPE NULLABLE ANIMAL_ID VARCHAR(N) FALSE ANIMAL_TYPE VARCHAR(N) FALSE DATETIME DATETIME FALSE INTAKE_CONDITION VARCHAR(N) FALSE NAME VARCHAR(N) TRUE SEX_UPON_INTAKE VARCHAR(N) FALSE 가장 최근에 들어온 동물은 언제 들어왔는지 조회하는 SQL 문을 작성해주세요. 예시 예를 들어 ANIMAL_INS 테이블이 다음과 같다면 ANIMAL_ID ANIMAL_TYPE DATETIME INTAKE_CONDITION NAME SEX_UPON_INTAKE A399552 Dog 2013-10-14 15:38:00 Normal Jack Neutered Male A379998 Dog 2013-10-23 11:42:00 Normal Disciple Intact Male A370852 Dog 2013-11-03 15:04:00 Normal Katie Spayed Female A403564 Dog 2013-11-18 17:03:00 Normal Anna Spayed Female 가장 늦게 들어온 동물은 Anna이고, Anna는 2013-11-18 17:03:00에 들어왔습니다. 따라서 SQL문을 실행하면 다음과 같이 나와야 합니다. 시간 2013-11-18 17:03:00 ※ 컬럼 이름(위 예제에서는 ""시간"")은 일치하지 않아도 됩니다. 본 문제는 Kaggle의 ""Austin Animal Center Shelter Intakes and Outcomes""에서 제공하는 데이터를 사용하였으며 ODbL의 적용을 받습니다.",easy,database
449,"ANIMAL_INS 테이블은 동물 보호소에 들어온 동물의 정보를 담은 테이블입니다. ANIMAL_INS 테이블 구조는 다음과 같으며, ANIMAL_ID, ANIMAL_TYPE, DATETIME, INTAKE_CONDITION, NAME, SEX_UPON_INTAKE는 각각 동물의 아이디, 생물 종, 보호 시작일, 보호 시작 시 상태, 이름, 성별 및 중성화 여부를 나타냅니다. NAME TYPE NULLABLE ANIMAL_ID VARCHAR(N) FALSE ANIMAL_TYPE VARCHAR(N) FALSE DATETIME DATETIME FALSE INTAKE_CONDITION VARCHAR(N) FALSE NAME VARCHAR(N) TRUE SEX_UPON_INTAKE VARCHAR(N) FALSE ANIMAL_INS 테이블에 등록된 모든 레코드에 대해, 각 동물의 아이디와 이름, 들어온 날짜1를 조회하는 SQL문을 작성해주세요. 이때 결과는 아이디 순으로 조회해야 합니다. 예시 예를 들어, ANIMAL_INS 테이블이 다음과 같다면 ANIMAL_INS ANIMAL_ID ANIMAL_TYPE DATETIME INTAKE_CONDITION NAME SEX_UPON_INTAKE A349996 Cat 2018-01-22 14:32:00 Normal Sugar Neutered Male A350276 Cat 2017-08-13 13:50:00 Normal Jewel Spayed Female A350375 Cat 2017-03-06 15:01:00 Normal Meo Neutered Male A352555 Dog 2014-08-08 04:20:00 Normal Harley Spayed Female A352713 Cat 2017-04-13 16:29:00 Normal Gia Spayed Female SQL문을 실행하면 다음과 같이 나와야 합니다. ANIMAL_ID NAME 날짜 A349996 Sugar 2018-01-22 A350276 Jewel 2017-08-13 A350375 Meo 2017-03-06 A352555 Harley 2014-08-08 A352713 Gia 2017-04-13 본 문제는 Kaggle의 ""Austin Animal Center Shelter Intakes and Outcomes""에서 제공하는 데이터를 사용하였으며 ODbL의 적용을 받습니다. 시각(시-분-초)을 제외한 날짜(년-월-일)만 보여주세요. ↩",normal,database
450,"ANIMAL_OUTS 테이블은 동물 보호소에서 입양 보낸 동물의 정보를 담은 테이블입니다. ANIMAL_OUTS 테이블 구조는 다음과 같으며, ANIMAL_ID, ANIMAL_TYPE, DATETIME, NAME, SEX_UPON_OUTCOME는 각각 동물의 아이디, 생물 종, 입양일, 이름, 성별 및 중성화 여부를 나타냅니다. NAME TYPE NULLABLE ANIMAL_ID VARCHAR(N) FALSE ANIMAL_TYPE VARCHAR(N) FALSE DATETIME DATETIME FALSE NAME VARCHAR(N) TRUE SEX_UPON_OUTCOME VARCHAR(N) FALSE 보호소에서는 몇 시에 입양이 가장 활발하게 일어나는지 알아보려 합니다. 0시부터 23시까지, 각 시간대별로 입양이 몇 건이나 발생했는지 조회하는 SQL문을 작성해주세요. 이때 결과는 시간대 순으로 정렬해야 합니다. 예시 SQL문을 실행하면 다음과 같이 나와야 합니다. HOUR COUNT 0 0 1 0 2 0 3 0 4 0 5 0 6 0 7 3 8 1 9 1 10 2 11 13 12 10 13 14 14 9 15 7 16 10 17 12 18 16 19 2 20 0 21 0 22 0 23 0 본 문제는 Kaggle의 ""Austin Animal Center Shelter Intakes and Outcomes""에서 제공하는 데이터를 사용하였으며 ODbL의 적용을 받습니다.",hard,database
451,"ANIMAL_OUTS 테이블은 동물 보호소에서 입양 보낸 동물의 정보를 담은 테이블입니다. ANIMAL_OUTS 테이블 구조는 다음과 같으며, ANIMAL_ID, ANIMAL_TYPE, DATETIME, NAME, SEX_UPON_OUTCOME는 각각 동물의 아이디, 생물 종, 입양일, 이름, 성별 및 중성화 여부를 나타냅니다. NAME TYPE NULLABLE ANIMAL_ID VARCHAR(N) FALSE ANIMAL_TYPE VARCHAR(N) FALSE DATETIME DATETIME FALSE NAME VARCHAR(N) TRUE SEX_UPON_OUTCOME VARCHAR(N) FALSE 보호소에서는 몇 시에 입양이 가장 활발하게 일어나는지 알아보려 합니다. 09:00부터 19:59까지, 각 시간대별로 입양이 몇 건이나 발생했는지 조회하는 SQL문을 작성해주세요. 이때 결과는 시간대 순으로 정렬해야 합니다. 예시 SQL문을 실행하면 다음과 같이 나와야 합니다. HOUR COUNT 9 1 10 2 11 13 12 10 13 14 14 9 15 7 16 10 17 12 18 16 19 2 본 문제는 Kaggle의 ""Austin Animal Center Shelter Intakes and Outcomes""에서 제공하는 데이터를 사용하였으며 ODbL의 적용을 받습니다.",normal,database
452,"ANIMAL_INS 테이블은 동물 보호소에 들어온 동물의 정보를 담은 테이블입니다. ANIMAL_INS 테이블 구조는 다음과 같으며, ANIMAL_ID, ANIMAL_TYPE, DATETIME, INTAKE_CONDITION, NAME, SEX_UPON_INTAKE는 각각 동물의 아이디, 생물 종, 보호 시작일, 보호 시작 시 상태, 이름, 성별 및 중성화 여부를 나타냅니다. NAME TYPE NULLABLE ANIMAL_ID VARCHAR(N) FALSE ANIMAL_TYPE VARCHAR(N) FALSE DATETIME DATETIME FALSE INTAKE_CONDITION VARCHAR(N) FALSE NAME VARCHAR(N) TRUE SEX_UPON_INTAKE VARCHAR(N) FALSE ANIMAL_OUTS 테이블은 동물 보호소에서 입양 보낸 동물의 정보를 담은 테이블입니다. ANIMAL_OUTS 테이블 구조는 다음과 같으며, ANIMAL_ID, ANIMAL_TYPE, DATETIME, NAME, SEX_UPON_OUTCOME는 각각 동물의 아이디, 생물 종, 입양일, 이름, 성별 및 중성화 여부를 나타냅니다. ANIMAL_OUTS 테이블의 ANIMAL_ID는 ANIMAL_INS의 ANIMAL_ID의 외래 키입니다. NAME TYPE NULLABLE ANIMAL_ID VARCHAR(N) FALSE ANIMAL_TYPE VARCHAR(N) FALSE DATETIME DATETIME FALSE NAME VARCHAR(N) TRUE SEX_UPON_OUTCOME VARCHAR(N) FALSE 입양을 간 동물 중, 보호 기간이 가장 길었던 동물 두 마리의 아이디와 이름을 조회하는 SQL문을 작성해주세요. 이때 결과는 보호 기간이 긴 순으로 조회해야 합니다. 예시 예를 들어, ANIMAL_INS 테이블과 ANIMAL_OUTS 테이블이 다음과 같다면 ANIMAL_INS ANIMAL_ID ANIMAL_TYPE DATETIME INTAKE_CONDITION NAME SEX_UPON_INTAKE A354597 Cat 2014-05-02 12:16:00 Normal Ariel Spayed Female A362707 Dog 2016-01-27 12:27:00 Sick Girly Girl Spayed Female A370507 Cat 2014-10-27 14:43:00 Normal Emily Spayed Female A414513 Dog 2016-06-07 09:17:00 Normal Rocky Neutered Male ANIMAL_OUTS ANIMAL_ID ANIMAL_TYPE DATETIME NAME SEX_UPON_OUTCOME A354597 Cat 2014-06-03 12:30:00 Ariel Spayed Female A362707 Dog 2017-01-10 10:44:00 Girly Girl Spayed Female A370507 Cat 2015-08-15 09:24:00 Emily Spayed Female SQL문을 실행하면 다음과 같이 나와야 합니다. ANIMAL_ID NAME A362707 Girly Girl A370507 Emily ※ 입양을 간 동물이 2마리 이상인 경우만 입력으로 주어집니다. 본 문제는 Kaggle의 ""Austin Animal Center Shelter Intakes and Outcomes""에서 제공하는 데이터를 사용하였으며 ODbL의 적용을 받습니다.",normal,database
453,"ANIMAL_INS 테이블은 동물 보호소에 들어온 동물의 정보를 담은 테이블입니다. ANIMAL_INS 테이블 구조는 다음과 같으며, ANIMAL_ID, ANIMAL_TYPE, DATETIME, INTAKE_CONDITION, NAME, SEX_UPON_INTAKE는 각각 동물의 아이디, 생물 종, 보호 시작일, 보호 시작 시 상태, 이름, 성별 및 중성화 여부를 나타냅니다. NAME TYPE NULLABLE ANIMAL_ID VARCHAR(N) FALSE ANIMAL_TYPE VARCHAR(N) FALSE DATETIME DATETIME FALSE INTAKE_CONDITION VARCHAR(N) FALSE NAME VARCHAR(N) TRUE SEX_UPON_INTAKE VARCHAR(N) FALSE 입양 게시판에 동물 정보를 게시하려 합니다. 동물의 생물 종, 이름, 성별 및 중성화 여부를 아이디 순으로 조회하는 SQL문을 작성해주세요. 이때 프로그래밍을 모르는 사람들은 NULL이라는 기호를 모르기 때문에, 이름이 없는 동물의 이름은 ""No name""으로 표시해 주세요. 예시 예를 들어 ANIMAL_INS 테이블이 다음과 같다면 ANIMAL_ID ANIMAL_TYPE DATETIME INTAKE_CONDITION NAME SEX_UPON_INTAKE A350276 Cat 2017-08-13 13:50:00 Normal Jewel Spayed Female A350375 Cat 2017-03-06 15:01:00 Normal Meo Neutered Male A368930 Dog 2014-06-08 13:20:00 Normal NULL Spayed Female 마지막 줄의 개는 이름이 없기 때문에, 이 개의 이름은 ""No name""으로 표시합니다. 따라서 SQL문을 실행하면 다음과 같이 나와야 합니다. ANIMAL_TYPE NAME SEX_UPON_INTAKE Cat Jewel Spayed Female Cat Meo Neutered Male Dog No name Spayed Female ※ 컬럼 이름은 일치하지 않아도 됩니다. 본 문제는 Kaggle의 ""Austin Animal Center Shelter Intakes and Outcomes""에서 제공하는 데이터를 사용하였으며 ODbL의 적용을 받습니다.",normal,database
454,"ANIMAL_INS 테이블은 동물 보호소에 들어온 동물의 정보를 담은 테이블입니다. ANIMAL_INS 테이블 구조는 다음과 같으며, ANIMAL_ID, ANIMAL_TYPE, DATETIME, INTAKE_CONDITION, NAME, SEX_UPON_INTAKE는 각각 동물의 아이디, 생물 종, 보호 시작일, 보호 시작 시 상태, 이름, 성별 및 중성화 여부를 나타냅니다. NAME TYPE NULLABLE ANIMAL_ID VARCHAR(N) FALSE ANIMAL_TYPE VARCHAR(N) FALSE DATETIME DATETIME FALSE INTAKE_CONDITION VARCHAR(N) FALSE NAME VARCHAR(N) TRUE SEX_UPON_INTAKE VARCHAR(N) FALSE 보호소의 동물이 중성화되었는지 아닌지 파악하려 합니다. 중성화된 동물은 SEX_UPON_INTAKE 컬럼에 'Neutered' 또는 'Spayed'라는 단어가 들어있습니다. 동물의 아이디와 이름, 중성화 여부를 아이디 순으로 조회하는 SQL문을 작성해주세요. 이때 중성화가 되어있다면 'O', 아니라면 'X'라고 표시해주세요. 예시 예를 들어 ANIMAL_INS 테이블이 다음과 같다면 ANIMAL_ID ANIMAL_TYPE DATETIME INTAKE_CONDITION NAME SEX_UPON_INTAKE A355753 Dog 2015-09-10 13:14:00 Normal Elijah Neutered Male A373219 Cat 2014-07-29 11:43:00 Normal Ella Spayed Female A382192 Dog 2015-03-13 13:14:00 Normal Maxwell 2 Intact Male 중성화한 동물: Elijah, Ella 중성화하지 않은 동물: Maxwell 2 따라서 SQL문을 실행하면 다음과 같이 나와야 합니다. ANIMAL_ID NAME 중성화 A355753 Elijah O A373219 Ella O A382192 Maxwell 2 X ※ 컬럼 이름은 일치하지 않아도 됩니다. 본 문제는 Kaggle의 ""Austin Animal Center Shelter Intakes and Outcomes""에서 제공하는 데이터를 사용하였으며 ODbL의 적용을 받습니다.",normal,database
455,"ANIMAL_INS 테이블은 동물 보호소에 들어온 동물의 정보를 담은 테이블입니다. ANIMAL_INS 테이블 구조는 다음과 같으며, ANIMAL_ID, ANIMAL_TYPE, DATETIME, INTAKE_CONDITION, NAME, SEX_UPON_INTAKE는 각각 동물의 아이디, 생물 종, 보호 시작일, 보호 시작 시 상태, 이름, 성별 및 중성화 여부를 나타냅니다. NAME TYPE NULLABLE ANIMAL_ID VARCHAR(N) FALSE ANIMAL_TYPE VARCHAR(N) FALSE DATETIME DATETIME FALSE INTAKE_CONDITION VARCHAR(N) FALSE NAME VARCHAR(N) TRUE SEX_UPON_INTAKE VARCHAR(N) FALSE 동물 보호소에 들어온 동물의 이름은 몇 개인지 조회하는 SQL 문을 작성해주세요. 이때 이름이 NULL인 경우는 집계하지 않으며 중복되는 이름은 하나로 칩니다. 예시 예를 들어 ANIMAL_INS 테이블이 다음과 같다면 ANIMAL_ID ANIMAL_TYPE DATETIME INTAKE_CONDITION NAME SEX_UPON_INTAKE A562649 Dog 2014-03-20 18:06:00 Sick NULL Spayed Female A412626 Dog 2016-03-13 11:17:00 Normal *Sam Neutered Male A563492 Dog 2014-10-24 14:45:00 Normal *Sam Neutered Male A513956 Dog 2017-06-14 11:54:00 Normal *Sweetie Spayed Female 보호소에 들어온 동물의 이름은 NULL(없음), *Sam, *Sam, *Sweetie입니다. 이 중 NULL과 중복되는 이름을 고려하면, 보호소에 들어온 동물 이름의 수는 2입니다. 따라서 SQL문을 실행하면 다음과 같이 나와야 합니다. count 2 ※ 컬럼 이름(위 예제에서는 count)은 일치하지 않아도 됩니다. 본 문제는 Kaggle의 ""Austin Animal Center Shelter Intakes and Outcomes""에서 제공하는 데이터를 사용하였으며 ODbL의 적용을 받습니다.",normal,database
456,"ANIMAL_INS 테이블은 동물 보호소에 들어온 동물의 정보를 담은 테이블입니다. ANIMAL_INS 테이블 구조는 다음과 같으며, ANIMAL_ID, ANIMAL_TYPE, DATETIME, INTAKE_CONDITION, NAME, SEX_UPON_INTAKE는 각각 동물의 아이디, 생물 종, 보호 시작일, 보호 시작 시 상태, 이름, 성별 및 중성화 여부를 나타냅니다. NAME TYPE NULLABLE ANIMAL_ID VARCHAR(N) FALSE ANIMAL_TYPE VARCHAR(N) FALSE DATETIME DATETIME FALSE INTAKE_CONDITION VARCHAR(N) FALSE NAME VARCHAR(N) TRUE SEX_UPON_INTAKE VARCHAR(N) FALSE 동물 보호소에 들어온 동물 중, 이름이 있는 동물의 ID를 조회하는 SQL 문을 작성해주세요. 단, ID는 오름차순 정렬되어야 합니다. 예시 예를 들어 ANIMAL_INS 테이블이 다음과 같다면 ANIMAL_ID ANIMAL_TYPE DATETIME INTAKE_CONDITION NAME SEX_UPON_INTAKE A434523 Cat 2015-11-20 14:18:00 Normal NULL Spayed Female A562649 Dog 2014-03-20 18:06:00 Sick NULL Spayed Female A524634 Dog 2015-01-02 18:54:00 Normal *Belle Intact Female A465637 Dog 2017-06-04 08:17:00 Injured *Commander Neutered Male 이름이 있는 동물의 ID는 A524634와 A465637입니다. 따라서 SQL을 실행하면 다음과 같이 출력되어야 합니다. ANIMAL_ID A465637 A524634 본 문제는 Kaggle의 ""Austin Animal Center Shelter Intakes and Outcomes""에서 제공하는 데이터를 사용하였으며 ODbL의 적용을 받습니다.",easy,database
457,"ANIMAL_INS 테이블은 동물 보호소에 들어온 동물의 정보를 담은 테이블입니다. ANIMAL_INS 테이블 구조는 다음과 같으며, ANIMAL_ID, ANIMAL_TYPE, DATETIME, INTAKE_CONDITION, NAME, SEX_UPON_INTAKE는 각각 동물의 아이디, 생물 종, 보호 시작일, 보호 시작 시 상태, 이름, 성별 및 중성화 여부를 나타냅니다. NAME TYPE NULLABLE ANIMAL_ID VARCHAR(N) FALSE ANIMAL_TYPE VARCHAR(N) FALSE DATETIME DATETIME FALSE INTAKE_CONDITION VARCHAR(N) FALSE NAME VARCHAR(N) TRUE SEX_UPON_INTAKE VARCHAR(N) FALSE 동물 보호소에 동물이 몇 마리 들어왔는지 조회하는 SQL 문을 작성해주세요. 예시 예를 들어 ANIMAL_INS 테이블이 다음과 같다면 ANIMAL_ID ANIMAL_TYPE DATETIME INTAKE_CONDITION NAME SEX_UPON_INTAKE A399552 Dog 2013-10-14 15:38:00 Normal Jack Neutered Male A379998 Dog 2013-10-23 11:42:00 Normal Disciple Intact Male A370852 Dog 2013-11-03 15:04:00 Normal Katie Spayed Female A403564 Dog 2013-11-18 17:03:00 Normal Anna Spayed Female 동물 보호소에 들어온 동물은 4마리입니다. 따라서 SQL문을 실행하면 다음과 같이 나와야 합니다. count 4 ※ 컬럼 이름(위 예제에서는 count)은 일치하지 않아도 됩니다. 본 문제는 Kaggle의 ""Austin Animal Center Shelter Intakes and Outcomes""에서 제공하는 데이터를 사용하였으며 ODbL의 적용을 받습니다.",normal,database
458,"ANIMAL_INS 테이블은 동물 보호소에 들어온 동물의 정보를 담은 테이블입니다. ANIMAL_INS 테이블 구조는 다음과 같으며, ANIMAL_ID, ANIMAL_TYPE, DATETIME, INTAKE_CONDITION, NAME, SEX_UPON_INTAKE는 각각 동물의 아이디, 생물 종, 보호 시작일, 보호 시작 시 상태, 이름, 성별 및 중성화 여부를 나타냅니다. NAME TYPE NULLABLE ANIMAL_ID VARCHAR(N) FALSE ANIMAL_TYPE VARCHAR(N) FALSE DATETIME DATETIME FALSE INTAKE_CONDITION VARCHAR(N) FALSE NAME VARCHAR(N) TRUE SEX_UPON_INTAKE VARCHAR(N) FALSE 동물 보호소에 가장 먼저 들어온 동물의 이름을 조회하는 SQL 문을 작성해주세요. 예시 예를 들어 ANIMAL_INS 테이블이 다음과 같다면 ANIMAL_ID ANIMAL_TYPE DATETIME INTAKE_CONDITION NAME SEX_UPON_INTAKE A399552 Dog 2013-10-14 15:38:00 Normal Jack Neutered Male A379998 Dog 2013-10-23 11:42:00 Normal Disciple Intact Male A370852 Dog 2013-11-03 15:04:00 Normal Katie Spayed Female A403564 Dog 2013-11-18 17:03:00 Normal Anna Spayed Female 이 중 가장 보호소에 먼저 들어온 동물은 Jack입니다. 따라서 SQL문을 실행하면 다음과 같이 나와야 합니다. NAME Jack ※ 보호소에 가장 먼저 들어온 동물은 한 마리인 경우만 테스트 케이스로 주어집니다. 본 문제는 Kaggle의 ""Austin Animal Center Shelter Intakes and Outcomes""에서 제공하는 데이터를 사용하였으며 ODbL의 적용을 받습니다.",easy,database
459,"ANIMAL_INS 테이블은 동물 보호소에 들어온 동물의 정보를 담은 테이블입니다. ANIMAL_INS 테이블 구조는 다음과 같으며, ANIMAL_ID, ANIMAL_TYPE, DATETIME, INTAKE_CONDITION, NAME, SEX_UPON_INTAKE는 각각 동물의 아이디, 생물 종, 보호 시작일, 보호 시작 시 상태, 이름, 성별 및 중성화 여부를 나타냅니다. NAME TYPE NULLABLE ANIMAL_ID VARCHAR(N) FALSE ANIMAL_TYPE VARCHAR(N) FALSE DATETIME DATETIME FALSE INTAKE_CONDITION VARCHAR(N) FALSE NAME VARCHAR(N) TRUE SEX_UPON_INTAKE VARCHAR(N) FALSE 동물 보호소에 들어온 모든 동물의 아이디와 이름, 보호 시작일을 이름 순으로 조회하는 SQL문을 작성해주세요. 단, 이름이 같은 동물 중에서는 보호를 나중에 시작한 동물을 먼저 보여줘야 합니다. 예시 예를 들어, ANIMAL_INS 테이블이 다음과 같다면 ANIMAL_ID ANIMAL_TYPE DATETIME INTAKE_CONDITION NAME SEX_UPON_INTAKE A349996 Cat 2018-01-22 14:32:00 Normal Sugar Neutered Male A350276 Cat 2017-08-13 13:50:00 Normal Jewel Spayed Female A396810 Dog 2016-08-22 16:13:00 Injured Raven Spayed Female A410668 Cat 2015-11-19 13:41:00 Normal Raven Spayed Female 이름을 사전 순으로 정렬하면 다음과 같으며, 'Jewel', 'Raven', 'Sugar' 'Raven'이라는 이름을 가진 개와 고양이가 있으므로, 이 중에서는 보호를 나중에 시작한 개를 먼저 조회합니다. 따라서 SQL문을 실행하면 다음과 같이 나와야 합니다. ANIMAL_ID NAME DATETIME A350276 Jewel 2017-08-13 13:50:00 A396810 Raven 2016-08-22 16:13:00 A410668 Raven 2015-11-19 13:41:00 A349996 Sugar 2018-01-22 14:32:00 본 문제는 Kaggle의 ""Austin Animal Center Shelter Intakes and Outcomes""에서 제공하는 데이터를 사용하였으며 ODbL의 적용을 받습니다.",easy,database
460,"ANIMAL_INS 테이블은 동물 보호소에 들어온 동물의 정보를 담은 테이블입니다. ANIMAL_INS 테이블 구조는 다음과 같으며, ANIMAL_ID, ANIMAL_TYPE, DATETIME, INTAKE_CONDITION, NAME, SEX_UPON_INTAKE는 각각 동물의 아이디, 생물 종, 보호 시작일, 보호 시작 시 상태, 이름, 성별 및 중성화 여부를 나타냅니다. NAME TYPE NULLABLE ANIMAL_ID VARCHAR(N) FALSE ANIMAL_TYPE VARCHAR(N) FALSE DATETIME DATETIME FALSE INTAKE_CONDITION VARCHAR(N) FALSE NAME VARCHAR(N) TRUE SEX_UPON_INTAKE VARCHAR(N) FALSE 동물 보호소에 들어온 모든 동물의 아이디와 이름을 ANIMAL_ID순으로 조회하는 SQL문을 작성해주세요. SQL을 실행하면 다음과 같이 출력되어야 합니다. ANIMAL_ID NAME A349996 Sugar A350276 Jewel A350375 Meo A352555 Harley A352713 Gia A352872 Peanutbutter A353259 Bj ((이하 생략)) 본 문제는 Kaggle의 ""Austin Animal Center Shelter Intakes and Outcomes""에서 제공하는 데이터를 사용하였으며 ODbL의 적용을 받습니다.",easy,database
461,"ANIMAL_INS 테이블은 동물 보호소에 들어온 동물의 정보를 담은 테이블입니다. ANIMAL_INS 테이블 구조는 다음과 같으며, ANIMAL_ID, ANIMAL_TYPE, DATETIME, INTAKE_CONDITION, NAME, SEX_UPON_INTAKE는 각각 동물의 아이디, 생물 종, 보호 시작일, 보호 시작 시 상태, 이름, 성별 및 중성화 여부를 나타냅니다. NAME TYPE NULLABLE ANIMAL_ID VARCHAR(N) FALSE ANIMAL_TYPE VARCHAR(N) FALSE DATETIME DATETIME FALSE INTAKE_CONDITION VARCHAR(N) FALSE NAME VARCHAR(N) TRUE SEX_UPON_INTAKE VARCHAR(N) FALSE 보호소에 돌아가신 할머니가 기르던 개를 찾는 사람이 찾아왔습니다. 이 사람이 말하길 할머니가 기르던 개는 이름에 'el'이 들어간다고 합니다. 동물 보호소에 들어온 동물 이름 중, 이름에 ""EL""이 들어가는 개의 아이디와 이름을 조회하는 SQL문을 작성해주세요. 이때 결과는 이름 순으로 조회해주세요. 단, 이름의 대소문자는 구분하지 않습니다. 예시 예를 들어 ANIMAL_INS 테이블이 다음과 같다면 ANIMAL_ID ANIMAL_TYPE DATETIME INTAKE_CONDITION NAME SEX_UPON_INTAKE A355753 Dog 2015-09-10 13:14:00 Normal Elijah Neutered Male A352872 Dog 2015-07-09 17:51:00 Aged Peanutbutter Neutered Male A353259 Dog 2016-05-08 12:57:00 Injured Bj Neutered Male A373219 Cat 2014-07-29 11:43:00 Normal Ella Spayed Female A382192 Dog 2015-03-13 13:14:00 Normal Maxwell 2 Intact Male 이름에 'el'이 들어가는 동물은 Elijah, Ella, Maxwell 2입니다. 이 중, 개는 Elijah, Maxwell 2입니다. 따라서 SQL문을 실행하면 다음과 같이 나와야 합니다. ANIMAL_ID NAME A355753 Elijah A382192 Maxwell 2 본 문제는 Kaggle의 ""Austin Animal Center Shelter Intakes and Outcomes""에서 제공하는 데이터를 사용하였으며 ODbL의 적용을 받습니다.",normal,database
462,"ANIMAL_INS 테이블은 동물 보호소에 들어온 동물의 정보를 담은 테이블입니다. ANIMAL_INS 테이블 구조는 다음과 같으며, ANIMAL_ID, ANIMAL_TYPE, DATETIME, INTAKE_CONDITION, NAME, SEX_UPON_INTAKE는 각각 동물의 아이디, 생물 종, 보호 시작일, 보호 시작 시 상태, 이름, 성별 및 중성화 여부를 나타냅니다. NAME TYPE NULLABLE ANIMAL_ID VARCHAR(N) FALSE ANIMAL_TYPE VARCHAR(N) FALSE DATETIME DATETIME FALSE INTAKE_CONDITION VARCHAR(N) FALSE NAME VARCHAR(N) TRUE SEX_UPON_INTAKE VARCHAR(N) FALSE 동물 보호소에 들어온 동물 중 이름이 Lucy, Ella, Pickle, Rogan, Sabrina, Mitty인 동물의 아이디와 이름, 성별 및 중성화 여부를 조회하는 SQL 문을 작성해주세요. 예시 이때 결과는 아이디 순으로 조회해주세요. 예를 들어 ANIMAL_INS 테이블이 다음과 같다면 ANIMAL_ID ANIMAL_TYPE DATETIME INTAKE_CONDITION NAME SEX_UPON_INTAKE A373219 Cat 2014-07-29 11:43:00 Normal Ella Spayed Female A377750 Dog 2017-10-25 17:17:00 Normal Lucy Spayed Female A353259 Dog 2016-05-08 12:57:00 Injured Bj Neutered Male A354540 Cat 2014-12-11 11:48:00 Normal Tux Neutered Male A354597 Cat 2014-05-02 12:16:00 Normal Ariel Spayed Female SQL문을 실행하면 다음과 같이 나와야 합니다. ANIMAL_ID NAME SEX_UPON_INTAKE A373219 Ella Spayed Female A377750 Lucy Spayed Female 본 문제는 Kaggle의 ""Austin Animal Center Shelter Intakes and Outcomes""에서 제공하는 데이터를 사용하였으며 ODbL의 적용을 받습니다.",normal,database
463,"ANIMAL_INS 테이블은 동물 보호소에 들어온 동물의 정보를 담은 테이블입니다. ANIMAL_INS 테이블 구조는 다음과 같으며, ANIMAL_ID, ANIMAL_TYPE, DATETIME, INTAKE_CONDITION, NAME, SEX_UPON_INTAKE는 각각 동물의 아이디, 생물 종, 보호 시작일, 보호 시작 시 상태, 이름, 성별 및 중성화 여부를 나타냅니다. NAME TYPE NULLABLE ANIMAL_ID VARCHAR(N) FALSE ANIMAL_TYPE VARCHAR(N) FALSE DATETIME DATETIME FALSE INTAKE_CONDITION VARCHAR(N) FALSE NAME VARCHAR(N) TRUE SEX_UPON_INTAKE VARCHAR(N) FALSE ANIMAL_OUTS 테이블은 동물 보호소에서 입양 보낸 동물의 정보를 담은 테이블입니다. ANIMAL_OUTS 테이블 구조는 다음과 같으며, ANIMAL_ID, ANIMAL_TYPE, DATETIME, NAME, SEX_UPON_OUTCOME는 각각 동물의 아이디, 생물 종, 입양일, 이름, 성별 및 중성화 여부를 나타냅니다. ANIMAL_OUTS 테이블의 ANIMAL_ID는 ANIMAL_INS의 ANIMAL_ID의 외래 키입니다. NAME TYPE NULLABLE ANIMAL_ID VARCHAR(N) FALSE ANIMAL_TYPE VARCHAR(N) FALSE DATETIME DATETIME FALSE NAME VARCHAR(N) TRUE SEX_UPON_OUTCOME VARCHAR(N) FALSE 보호소에서 중성화 수술을 거친 동물 정보를 알아보려 합니다. 보호소에 들어올 당시에는 중성화1되지 않았지만, 보호소를 나갈 당시에는 중성화된 동물의 아이디와 생물 종, 이름을 조회하는 아이디 순으로 조회하는 SQL 문을 작성해주세요. 예시 예를 들어, ANIMAL_INS 테이블과 ANIMAL_OUTS 테이블이 다음과 같다면 ANIMAL_INS ANIMAL_ID ANIMAL_TYPE DATETIME INTAKE_CONDITION NAME SEX_UPON_INTAKE A367438 Dog 2015-09-10 16:01:00 Normal Cookie Spayed Female A382192 Dog 2015-03-13 13:14:00 Normal Maxwell 2 Intact Male A405494 Dog 2014-05-16 14:17:00 Normal Kaila Spayed Female A410330 Dog 2016-09-11 14:09:00 Sick Chewy Intact Female ANIMAL_OUTS ANIMAL_ID ANIMAL_TYPE DATETIME NAME SEX_UPON_OUTCOME A367438 Dog 2015-09-12 13:30:00 Cookie Spayed Female A382192 Dog 2015-03-16 13:46:00 Maxwell 2 Neutered Male A405494 Dog 2014-05-20 11:44:00 Kaila Spayed Female A410330 Dog 2016-09-13 13:46:00 Chewy Spayed Female Cookie는 보호소에 들어올 당시에 이미 중성화되어있었습니다. Maxwell 2는 보호소에 들어온 후 중성화되었습니다. Kaila는 보호소에 들어올 당시에 이미 중성화되어있었습니다. Chewy는 보호소에 들어온 후 중성화되었습니다. 따라서 SQL문을 실행하면 다음과 같이 나와야 합니다. ANIMAL_ID ANIMAL_TYPE NAME A382192 Dog Maxwell 2 A410330 Dog Chewy 본 문제는 Kaggle의 ""Austin Animal Center Shelter Intakes and Outcomes""에서 제공하는 데이터를 사용하였으며 ODbL의 적용을 받습니다. 중성화를 거치지 않은 동물은 성별 및 중성화 여부에 Intact, 중성화를 거친 동물은 Spayed 또는 Neutered라고 표시되어있습니다. ↩",hard,database
464,"ANIMAL_INS 테이블은 동물 보호소에 들어온 동물의 정보를 담은 테이블입니다. ANIMAL_INS 테이블 구조는 다음과 같으며, ANIMAL_ID, ANIMAL_TYPE, DATETIME, INTAKE_CONDITION, NAME, SEX_UPON_INTAKE는 각각 동물의 아이디, 생물 종, 보호 시작일, 보호 시작 시 상태, 이름, 성별 및 중성화 여부를 나타냅니다. NAME TYPE NULLABLE ANIMAL_ID VARCHAR(N) FALSE ANIMAL_TYPE VARCHAR(N) FALSE DATETIME DATETIME FALSE INTAKE_CONDITION VARCHAR(N) FALSE NAME VARCHAR(N) TRUE SEX_UPON_INTAKE VARCHAR(N) FALSE ANIMAL_OUTS 테이블은 동물 보호소에서 입양 보낸 동물의 정보를 담은 테이블입니다. ANIMAL_OUTS 테이블 구조는 다음과 같으며, ANIMAL_ID, ANIMAL_TYPE, DATETIME, NAME, SEX_UPON_OUTCOME는 각각 동물의 아이디, 생물 종, 입양일, 이름, 성별 및 중성화 여부를 나타냅니다. ANIMAL_OUTS 테이블의 ANIMAL_ID는 ANIMAL_INS의 ANIMAL_ID의 외래 키입니다. NAME TYPE NULLABLE ANIMAL_ID VARCHAR(N) FALSE ANIMAL_TYPE VARCHAR(N) FALSE DATETIME DATETIME FALSE NAME VARCHAR(N) TRUE SEX_UPON_OUTCOME VARCHAR(N) FALSE 아직 입양을 못 간 동물 중, 가장 오래 보호소에 있었던 동물 3마리의 이름과 보호 시작일을 조회하는 SQL문을 작성해주세요. 이때 결과는 보호 시작일 순으로 조회해야 합니다. 예시 예를 들어, ANIMAL_INS 테이블과 ANIMAL_OUTS 테이블이 다음과 같다면 ANIMAL_INS ANIMAL_ID ANIMAL_TYPE DATETIME INTAKE_CONDITION NAME SEX_UPON_INTAKE A354597 Cat 2014-05-02 12:16:00 Normal Ariel Spayed Female A373687 Dog 2014-03-20 12:31:00 Normal Rosie Spayed Female A412697 Dog 2016-01-03 16:25:00 Normal Jackie Neutered Male A413789 Dog 2016-04-19 13:28:00 Normal Benji Spayed Female A414198 Dog 2015-01-29 15:01:00 Normal Shelly Spayed Female A368930 Dog 2014-06-08 13:20:00 Normal Spayed Female ANIMAL_OUTS ANIMAL_ID ANIMAL_TYPE DATETIME NAME SEX_UPON_OUTCOME A354597 Cat 2014-05-02 12:16:00 Ariel Spayed Female A373687 Dog 2014-03-20 12:31:00 Rosie Spayed Female A368930 Dog 2014-06-13 15:52:00 Spayed Female SQL문을 실행하면 다음과 같이 나와야 합니다. NAME DATETIME Shelly 2015-01-29 15:01:00 Jackie 2016-01-03 16:25:00 Benji 2016-04-19 13:28:00 ※ 입양을 가지 못한 동물이 3마리 이상인 경우만 입력으로 주어집니다. 본 문제는 Kaggle의 ""Austin Animal Center Shelter Intakes and Outcomes""에서 제공하는 데이터를 사용하였으며 ODbL의 적용을 받습니다.",normal,database
465,"ANIMAL_INS 테이블은 동물 보호소에 들어온 동물의 정보를 담은 테이블입니다. ANIMAL_INS 테이블 구조는 다음과 같으며, ANIMAL_ID, ANIMAL_TYPE, DATETIME, INTAKE_CONDITION, NAME, SEX_UPON_INTAKE는 각각 동물의 아이디, 생물 종, 보호 시작일, 보호 시작 시 상태, 이름, 성별 및 중성화 여부를 나타냅니다. NAME TYPE NULLABLE ANIMAL_ID VARCHAR(N) FALSE ANIMAL_TYPE VARCHAR(N) FALSE DATETIME DATETIME FALSE INTAKE_CONDITION VARCHAR(N) FALSE NAME VARCHAR(N) TRUE SEX_UPON_INTAKE VARCHAR(N) FALSE ANIMAL_OUTS 테이블은 동물 보호소에서 입양 보낸 동물의 정보를 담은 테이블입니다. ANIMAL_OUTS 테이블 구조는 다음과 같으며, ANIMAL_ID, ANIMAL_TYPE, DATETIME, NAME, SEX_UPON_OUTCOME는 각각 동물의 아이디, 생물 종, 입양일, 이름, 성별 및 중성화 여부를 나타냅니다. ANIMAL_OUTS 테이블의 ANIMAL_ID는 ANIMAL_INS의 ANIMAL_ID의 외래 키입니다. NAME TYPE NULLABLE ANIMAL_ID VARCHAR(N) FALSE ANIMAL_TYPE VARCHAR(N) FALSE DATETIME DATETIME FALSE NAME VARCHAR(N) TRUE SEX_UPON_OUTCOME VARCHAR(N) FALSE 관리자의 실수로 일부 동물의 입양일이 잘못 입력되었습니다. 보호 시작일보다 입양일이 더 빠른 동물의 아이디와 이름을 조회하는 SQL문을 작성해주세요. 이때 결과는 보호 시작일이 빠른 순으로 조회해야합니다. 예시 예를 들어, ANIMAL_INS 테이블과 ANIMAL_OUTS 테이블이 다음과 같다면 ANIMAL_INS ANIMAL_ID ANIMAL_TYPE DATETIME INTAKE_CONDITION NAME SEX_UPON_INTAKE A350276 Cat 2017-08-13 13:50:00 Normal Jewel Spayed Female A381217 Dog 2017-07-08 09:41:00 Sick Cherokee Neutered Male ANIMAL_OUTS ANIMAL_ID ANIMAL_TYPE DATETIME NAME SEX_UPON_OUTCOME A350276 Cat 2018-01-28 17:51:00 Jewel Spayed Female A381217 Dog 2017-06-09 18:51:00 Cherokee Neutered Male SQL문을 실행하면 다음과 같이 나와야 합니다. ANIMAL_ID NAME A381217 Cherokee 본 문제는 Kaggle의 ""Austin Animal Center Shelter Intakes and Outcomes""에서 제공하는 데이터를 사용하였으며 ODbL의 적용을 받습니다.",normal,database
466,"ANIMAL_INS 테이블은 동물 보호소에 들어온 동물의 정보를 담은 테이블입니다. ANIMAL_INS 테이블 구조는 다음과 같으며, ANIMAL_ID, ANIMAL_TYPE, DATETIME, INTAKE_CONDITION, NAME, SEX_UPON_INTAKE는 각각 동물의 아이디, 생물 종, 보호 시작일, 보호 시작 시 상태, 이름, 성별 및 중성화 여부를 나타냅니다. NAME TYPE NULLABLE ANIMAL_ID VARCHAR(N) FALSE ANIMAL_TYPE VARCHAR(N) FALSE DATETIME DATETIME FALSE INTAKE_CONDITION VARCHAR(N) FALSE NAME VARCHAR(N) TRUE SEX_UPON_INTAKE VARCHAR(N) FALSE ANIMAL_OUTS 테이블은 동물 보호소에서 입양 보낸 동물의 정보를 담은 테이블입니다. ANIMAL_OUTS 테이블 구조는 다음과 같으며, ANIMAL_ID, ANIMAL_TYPE, DATETIME, NAME, SEX_UPON_OUTCOME는 각각 동물의 아이디, 생물 종, 입양일, 이름, 성별 및 중성화 여부를 나타냅니다. ANIMAL_OUTS 테이블의 ANIMAL_ID는 ANIMAL_INS의 ANIMAL_ID의 외래 키입니다. NAME TYPE NULLABLE ANIMAL_ID VARCHAR(N) FALSE ANIMAL_TYPE VARCHAR(N) FALSE DATETIME DATETIME FALSE NAME VARCHAR(N) TRUE SEX_UPON_OUTCOME VARCHAR(N) FALSE 천재지변으로 인해 일부 데이터가 유실되었습니다. 입양을 간 기록은 있는데, 보호소에 들어온 기록이 없는 동물의 ID와 이름을 ID 순으로 조회하는 SQL문을 작성해주세요. 예시 예를 들어, ANIMAL_INS 테이블과 ANIMAL_OUTS 테이블이 다음과 같다면 ANIMAL_INS ANIMAL_ID ANIMAL_TYPE DATETIME INTAKE_CONDITION NAME SEX_UPON_INTAKE A352713 Cat 2017-04-13 16:29:00 Normal Gia Spayed Female A350375 Cat 2017-03-06 15:01:00 Normal Meo Neutered Male ANIMAL_OUTS ANIMAL_ID ANIMAL_TYPE DATETIME NAME SEX_UPON_OUTCOME A349733 Dog 2017-09-27 19:09:00 Allie Spayed Female A352713 Cat 2017-04-25 12:25:00 Gia Spayed Female A349990 Cat 2018-02-02 14:18:00 Spice Spayed Female ANIMAL_OUTS 테이블에서 Allie의 ID는 ANIMAL_INS에 없으므로, Allie의 데이터는 유실되었습니다. Gia의 ID는 ANIMAL_INS에 있으므로, Gia의 데이터는 유실되지 않았습니다. Spice의 ID는 ANIMAL_INS에 없으므로, Spice의 데이터는 유실되었습니다. 따라서 SQL문을 실행하면 다음과 같이 나와야 합니다. ANIMAL_ID NAME A349733 Allie A349990 Spice 본 문제는 Kaggle의 ""Austin Animal Center Shelter Intakes and Outcomes""에서 제공하는 데이터를 사용하였으며 ODbL의 적용을 받습니다.",normal,database
467,"ANIMAL_INS 테이블은 동물 보호소에 들어온 동물의 정보를 담은 테이블입니다. ANIMAL_INS 테이블 구조는 다음과 같으며, ANIMAL_ID, ANIMAL_TYPE, DATETIME, INTAKE_CONDITION, NAME, SEX_UPON_INTAKE는 각각 동물의 아이디, 생물 종, 보호 시작일, 보호 시작 시 상태, 이름, 성별 및 중성화 여부를 나타냅니다. NAME TYPE NULLABLE ANIMAL_ID VARCHAR(N) FALSE ANIMAL_TYPE VARCHAR(N) FALSE DATETIME DATETIME FALSE INTAKE_CONDITION VARCHAR(N) FALSE NAME VARCHAR(N) TRUE SEX_UPON_INTAKE VARCHAR(N) FALSE 동물 보호소에 들어온 동물 이름 중 두 번 이상 쓰인 이름과 해당 이름이 쓰인 횟수를 조회하는 SQL문을 작성해주세요. 이때 결과는 이름이 없는 동물은 집계에서 제외하며, 결과는 이름 순으로 조회해주세요. 예시 예를 들어 ANIMAL_INS 테이블이 다음과 같다면 ANIMAL_ID ANIMAL_TYPE DATETIME INTAKE_CONDITION NAME SEX_UPON_INTAKE A396810 Dog 2016-08-22 16:13:00 Injured Raven Spayed Female A377750 Dog 2017-10-25 17:17:00 Normal Lucy Spayed Female A355688 Dog 2014-01-26 13:48:00 Normal Shadow Neutered Male A399421 Dog 2015-08-25 14:08:00 Normal Lucy Spayed Female A400680 Dog 2017-06-17 13:29:00 Normal Lucy Spayed Female A410668 Cat 2015-11-19 13:41:00 Normal Raven Spayed Female Raven 이름은 2번 쓰였습니다. Lucy 이름은 3번 쓰였습니다 Shadow 이름은 1번 쓰였습니다. 따라서 SQL문을 실행하면 다음과 같이 나와야 합니다. NAME COUNT Lucy 3 Raven 2 본 문제는 Kaggle의 ""Austin Animal Center Shelter Intakes and Outcomes""에서 제공하는 데이터를 사용하였으며 ODbL의 적용을 받습니다.",normal,database
468,"ANIMAL_INS 테이블은 동물 보호소에 들어온 동물의 정보를 담은 테이블입니다. ANIMAL_INS 테이블 구조는 다음과 같으며, ANIMAL_ID, ANIMAL_TYPE, DATETIME, INTAKE_CONDITION, NAME, SEX_UPON_INTAKE는 각각 동물의 아이디, 생물 종, 보호 시작일, 보호 시작 시 상태, 이름, 성별 및 중성화 여부를 나타냅니다. NAME TYPE NULLABLE ANIMAL_ID VARCHAR(N) FALSE ANIMAL_TYPE VARCHAR(N) FALSE DATETIME DATETIME FALSE INTAKE_CONDITION VARCHAR(N) FALSE NAME VARCHAR(N) TRUE SEX_UPON_INTAKE VARCHAR(N) FALSE 동물 보호소에 들어온 동물 중 고양이와 개가 각각 몇 마리인지 조회하는 SQL문을 작성해주세요. 이때 고양이를 개보다 먼저 조회해주세요. 예시 예를 들어 ANIMAL_INS 테이블이 다음과 같다면 ANIMAL_ID ANIMAL_TYPE DATETIME INTAKE_CONDITION NAME SEX_UPON_INTAKE A373219 Cat 2014-07-29 11:43:00 Normal Ella Spayed Female A377750 Dog 2017-10-25 17:17:00 Normal Lucy Spayed Female A354540 Cat 2014-12-11 11:48:00 Normal Tux Neutered Male 고양이는 2마리, 개는 1마리 들어왔습니다. 따라서 SQL문을 실행하면 다음과 같이 나와야 합니다. ANIMAL_TYPE count Cat 2 Dog 1 본 문제는 Kaggle의 ""Austin Animal Center Shelter Intakes and Outcomes""에서 제공하는 데이터를 사용하였으며 ODbL의 적용을 받습니다.",normal,database
469,"ANIMAL_INS 테이블은 동물 보호소에 들어온 동물의 정보를 담은 테이블입니다. ANIMAL_INS 테이블 구조는 다음과 같으며, ANIMAL_ID, ANIMAL_TYPE, DATETIME, INTAKE_CONDITION, NAME, SEX_UPON_INTAKE는 각각 동물의 아이디, 생물 종, 보호 시작일, 보호 시작 시 상태, 이름, 성별 및 중성화 여부를 나타냅니다. NAME TYPE NULLABLE ANIMAL_ID VARCHAR(N) FALSE ANIMAL_TYPE VARCHAR(N) FALSE DATETIME DATETIME FALSE INTAKE_CONDITION VARCHAR(N) FALSE NAME VARCHAR(N) TRUE SEX_UPON_INTAKE VARCHAR(N) FALSE 동물 보호소에 들어온 동물 중, 이름이 없는 채로 들어온 동물의 ID를 조회하는 SQL 문을 작성해주세요. 단, ID는 오름차순 정렬되어야 합니다. 예시 예를 들어 ANIMAL_INS 테이블이 다음과 같다면 ANIMAL_ID ANIMAL_TYPE DATETIME INTAKE_CONDITION NAME SEX_UPON_INTAKE A368930 Dog 2014-06-08 13:20:00 Normal NULL Spayed Female A524634 Dog 2015-01-02 18:54:00 Normal *Belle Intact Female A465637 Dog 2017-06-04 08:17:00 Injured *Commander Neutered Male 이름이 없는 채로 들어온 동물의 ID는 A368930입니다. 따라서 SQL을 실행하면 다음과 같이 출력되어야 합니다. ANIMAL_ID A368930 본 문제는 Kaggle의 ""Austin Animal Center Shelter Intakes and Outcomes""에서 제공하는 데이터를 사용하였으며 ODbL의 적용을 받습니다. ※ 2019년 9월 4일 13시: 예시가 헷갈린다는 의견이 많아, 본문의 예시를 수정하였습니다.",easy,database
470,"ANIMAL_INS 테이블은 동물 보호소에 들어온 동물의 정보를 담은 테이블입니다. ANIMAL_INS 테이블 구조는 다음과 같으며, ANIMAL_ID, ANIMAL_TYPE, DATETIME, INTAKE_CONDITION, NAME, SEX_UPON_INTAKE는 각각 동물의 아이디, 생물 종, 보호 시작일, 보호 시작 시 상태, 이름, 성별 및 중성화 여부를 나타냅니다. NAME TYPE NULLABLE ANIMAL_ID VARCHAR(N) FALSE ANIMAL_TYPE VARCHAR(N) FALSE DATETIME DATETIME FALSE INTAKE_CONDITION VARCHAR(N) FALSE NAME VARCHAR(N) TRUE SEX_UPON_INTAKE VARCHAR(N) FALSE 동물 보호소에 가장 먼저 들어온 동물은 언제 들어왔는지 조회하는 SQL 문을 작성해주세요. 예시 예를 들어 ANIMAL_INS 테이블이 다음과 같다면 ANIMAL_ID ANIMAL_TYPE DATETIME INTAKE_CONDITION NAME SEX_UPON_INTAKE A399552 Dog 2013-10-14 15:38:00 Normal Jack Neutered Male A379998 Dog 2013-10-23 11:42:00 Normal Disciple Intact Male A370852 Dog 2013-11-03 15:04:00 Normal Katie Spayed Female A403564 Dog 2013-11-18 17:03:00 Normal Anna Spayed Female 가장 먼저 들어온 동물은 Jack이고, Jack은 2013-10-14 15:38:00에 들어왔습니다. 따라서 SQL문을 실행하면 다음과 같이 나와야 합니다. 시간 2013-10-14 15:38:00 ※ 컬럼 이름(위 예제에서는 ""시간"")은 일치하지 않아도 됩니다. 본 문제는 Kaggle의 ""Austin Animal Center Shelter Intakes and Outcomes""에서 제공하는 데이터를 사용하였으며 ODbL의 적용을 받습니다.",normal,database
471,"ANIMAL_INS 테이블은 동물 보호소에 들어온 동물의 정보를 담은 테이블입니다. ANIMAL_INS 테이블 구조는 다음과 같으며, ANIMAL_ID, ANIMAL_TYPE, DATETIME, INTAKE_CONDITION, NAME, SEX_UPON_INTAKE는 각각 동물의 아이디, 생물 종, 보호 시작일, 보호 시작 시 상태, 이름, 성별 및 중성화 여부를 나타냅니다. NAME TYPE NULLABLE ANIMAL_ID VARCHAR(N) FALSE ANIMAL_TYPE VARCHAR(N) FALSE DATETIME DATETIME FALSE INTAKE_CONDITION VARCHAR(N) FALSE NAME VARCHAR(N) TRUE SEX_UPON_INTAKE VARCHAR(N) FALSE 동물 보호소에 들어온 동물 중 젊은 동물1의 아이디와 이름을 조회하는 SQL 문을 작성해주세요. 이때 결과는 아이디 순으로 조회해주세요. 예시 예를 들어 ANIMAL_INS 테이블이 다음과 같다면 ANIMAL_ID ANIMAL_TYPE DATETIME INTAKE_CONDITION NAME SEX_UPON_INTAKE A365172 Dog 2014-08-26 12:53:00 Normal Diablo Neutered Male A367012 Dog 2015-09-16 09:06:00 Sick Miller Neutered Male A365302 Dog 2017-01-08 16:34:00 Aged Minnie Spayed Female A381217 Dog 2017-07-08 09:41:00 Sick Cherokee Neutered Male 이 중 젊은 동물은 Diablo, Miller, Cherokee입니다. 따라서 SQL문을 실행하면 다음과 같이 나와야 합니다. ANIMAL_ID NAME A365172 Diablo A367012 Miller A381217 Cherokee 본 문제는 Kaggle의 ""Austin Animal Center Shelter Intakes and Outcomes""에서 제공하는 데이터를 사용하였으며 ODbL의 적용을 받습니다. INTAKE_CONDITION이 Aged가 아닌 경우를 뜻함 ↩",easy,database
472,"ANIMAL_INS 테이블은 동물 보호소에 들어온 동물의 정보를 담은 테이블입니다. ANIMAL_INS 테이블 구조는 다음과 같으며, ANIMAL_ID, ANIMAL_TYPE, DATETIME, INTAKE_CONDITION, NAME, SEX_UPON_INTAKE는 각각 동물의 아이디, 생물 종, 보호 시작일, 보호 시작 시 상태, 이름, 성별 및 중성화 여부를 나타냅니다. NAME TYPE NULLABLE ANIMAL_ID VARCHAR(N) FALSE ANIMAL_TYPE VARCHAR(N) FALSE DATETIME DATETIME FALSE INTAKE_CONDITION VARCHAR(N) FALSE NAME VARCHAR(N) TRUE SEX_UPON_INTAKE VARCHAR(N) FALSE 동물 보호소에 들어온 동물 중 아픈 동물1의 아이디와 이름을 조회하는 SQL 문을 작성해주세요. 이때 결과는 아이디 순으로 조회해주세요. 예시 예를 들어 ANIMAL_INS 테이블이 다음과 같다면 ANIMAL_ID ANIMAL_TYPE DATETIME INTAKE_CONDITION NAME SEX_UPON_INTAKE A365172 Dog 2014-08-26 12:53:00 Normal Diablo Neutered Male A367012 Dog 2015-09-16 09:06:00 Sick Miller Neutered Male A365302 Dog 2017-01-08 16:34:00 Aged Minnie Spayed Female A381217 Dog 2017-07-08 09:41:00 Sick Cherokee Neutered Male 이 중 아픈 동물은 Miller와 Cherokee입니다. 따라서 SQL문을 실행하면 다음과 같이 나와야 합니다. ANIMAL_ID NAME A367012 Miller A381217 Cherokee 본 문제는 Kaggle의 ""Austin Animal Center Shelter Intakes and Outcomes""에서 제공하는 데이터를 사용하였으며 ODbL의 적용을 받습니다. INTAKE_CONDITION이 Sick 인 경우를 뜻함 ↩",easy,database
473,"ANIMAL_INS 테이블은 동물 보호소에 들어온 동물의 정보를 담은 테이블입니다. ANIMAL_INS 테이블 구조는 다음과 같으며, ANIMAL_ID, ANIMAL_TYPE, DATETIME, INTAKE_CONDITION, NAME, SEX_UPON_INTAKE는 각각 동물의 아이디, 생물 종, 보호 시작일, 보호 시작 시 상태, 이름, 성별 및 중성화 여부를 나타냅니다. NAME TYPE NULLABLE ANIMAL_ID VARCHAR(N) FALSE ANIMAL_TYPE VARCHAR(N) FALSE DATETIME DATETIME FALSE INTAKE_CONDITION VARCHAR(N) FALSE NAME VARCHAR(N) TRUE SEX_UPON_INTAKE VARCHAR(N) FALSE 동물 보호소에 들어온 모든 동물의 이름과 보호 시작일을 조회하는 SQL문을 작성해주세요. 이때 결과는 ANIMAL_ID 역순으로 보여주세요. SQL을 실행하면 다음과 같이 출력되어야 합니다. NAME DATETIME Rocky 2016-06-07 09:17:00 Shelly 2015-01-29 15:01:00 Benji 2016-04-19 13:28:00 Jackie 2016-01-03 16:25:00 *Sam 2016-03-13 11:17:00 ..이하 생략 본 문제는 Kaggle의 ""Austin Animal Center Shelter Intakes and Outcomes""에서 제공하는 데이터를 사용하였으며 ODbL의 적용을 받습니다.",easy,database
474,"ANIMAL_INS 테이블은 동물 보호소에 들어온 동물의 정보를 담은 테이블입니다. ANIMAL_INS 테이블 구조는 다음과 같으며, ANIMAL_ID, ANIMAL_TYPE, DATETIME, INTAKE_CONDITION, NAME, SEX_UPON_INTAKE는 각각 동물의 아이디, 생물 종, 보호 시작일, 보호 시작 시 상태, 이름, 성별 및 중성화 여부를 나타냅니다. NAME TYPE NULLABLE ANIMAL_ID VARCHAR(N) FALSE ANIMAL_TYPE VARCHAR(N) FALSE DATETIME DATETIME FALSE INTAKE_CONDITION VARCHAR(N) FALSE NAME VARCHAR(N) TRUE SEX_UPON_INTAKE VARCHAR(N) FALSE 동물 보호소에 들어온 모든 동물의 정보를 ANIMAL_ID순으로 조회하는 SQL문을 작성해주세요. SQL을 실행하면 다음과 같이 출력되어야 합니다. ANIMAL_ID ANIMAL_TYPE DATETIME INTAKE_CONDITION NAME SEX_UPON_INTAKE A349996 Cat 2018-01-22 14:32:00 Normal Sugar Neutered Male A350276 Cat 2017-08-13 13:50:00 Normal Jewel Spayed Female A350375 Cat 2017-03-06 15:01:00 Normal Meo Neutered Male A352555 Dog 2014-08-08 04:20:00 Normal Harley Spayed Female ..이하 생략 본 문제는 Kaggle의 ""Austin Animal Center Shelter Intakes and Outcomes""에서 제공하는 데이터를 사용하였으며 ODbL의 적용을 받습니다.",easy,database
475,"과자를 바구니 단위로 파는 가게가 있습니다. 이 가게는 1번부터 N번까지 차례로 번호가 붙은 바구니 N개가 일렬로 나열해 놨습니다. 철수는 두 아들에게 줄 과자를 사려합니다. 첫째 아들에게는 l번 바구니부터 m번 바구니까지, 둘째 아들에게는 m+1번 바구니부터 r번 바구니까지를 주려합니다. 단, 두 아들이 받을 과자 수는 같아야 합니다(1 <= l <= m, m+1 <= r <= N). 즉, A[i] 를 i번 바구니에 들어있는 과자 수라고 했을 때, A[l]+..+A[m] = A[m+1]+..+A[r] 를 만족해야 합니다. 각 바구니 안에 들은 과자 수가 차례로 들은 배열 cookie가 주어질 때, 조건에 맞게 과자를 살 경우 한 명의 아들에게 줄 수 있는 가장 많은 과자 수를 return 하는 solution 함수를 완성해주세요. (단, 조건에 맞게 과자를 구매할 수 없다면 0을 return 합니다) 제한사항 cookie의 길이는 1 이상 2,000 이하입니다. cookie의 각각의 원소는 1 이상 500 이하인 자연수입니다. 입출력 예 cookie result [1,1,2,3] 3 [1,2,4,5] 0 입출력 예 설명 입출력 예 #1 첫째 아들에게 2, 3번 바구니를, 둘째 아들에게 4번 바구니를 사주면 두 아들은 각각 과자 3개를 받습니다. 입출력 예 #2 주어진 조건에 맞게 과자를 살 방법이 없습니다.",hard,Array
476,"게임 캐릭터를 4가지 명령어를 통해 움직이려 합니다. 명령어는 다음과 같습니다. U: 위쪽으로 한 칸 가기 D: 아래쪽으로 한 칸 가기 R: 오른쪽으로 한 칸 가기 L: 왼쪽으로 한 칸 가기 캐릭터는 좌표평면의 (0, 0) 위치에서 시작합니다. 좌표평면의 경계는 왼쪽 위(-5, 5), 왼쪽 아래(-5, -5), 오른쪽 위(5, 5), 오른쪽 아래(5, -5)로 이루어져 있습니다. 예를 들어, ""ULURRDLLU""로 명령했다면 1번 명령어부터 7번 명령어까지 다음과 같이 움직입니다. 8번 명령어부터 9번 명령어까지 다음과 같이 움직입니다. 이때, 우리는 게임 캐릭터가 지나간 길 중 캐릭터가 처음 걸어본 길의 길이를 구하려고 합니다. 예를 들어 위의 예시에서 게임 캐릭터가 움직인 길이는 9이지만, 캐릭터가 처음 걸어본 길의 길이는 7이 됩니다. (8, 9번 명령어에서 움직인 길은 2, 3번 명령어에서 이미 거쳐 간 길입니다) 단, 좌표평면의 경계를 넘어가는 명령어는 무시합니다. 예를 들어, ""LULLLLLLU""로 명령했다면 1번 명령어부터 6번 명령어대로 움직인 후, 7, 8번 명령어는 무시합니다. 다시 9번 명령어대로 움직입니다. 이때 캐릭터가 처음 걸어본 길의 길이는 7이 됩니다. 명령어가 매개변수 dirs로 주어질 때, 게임 캐릭터가 처음 걸어본 길의 길이를 구하여 return 하는 solution 함수를 완성해 주세요. 제한사항 dirs는 string형으로 주어지며, 'U', 'D', 'R', 'L' 이외에 문자는 주어지지 않습니다. dirs의 길이는 500 이하의 자연수입니다. 입출력 예 dirs answer ""ULURRDLLU"" 7 ""LULLLLLLU"" 7 입출력 예 설명 입출력 예 #1 문제의 예시와 같습니다. 입출력 예 #2 문제의 예시와 같습니다.",normal,String
477,"선행 스킬이란 어떤 스킬을 배우기 전에 먼저 배워야 하는 스킬을 뜻합니다. 예를 들어 선행 스킬 순서가 스파크 → 라이트닝 볼트 → 썬더일때, 썬더를 배우려면 먼저 라이트닝 볼트를 배워야 하고, 라이트닝 볼트를 배우려면 먼저 스파크를 배워야 합니다. 위 순서에 없는 다른 스킬(힐링 등)은 순서에 상관없이 배울 수 있습니다. 따라서 스파크 → 힐링 → 라이트닝 볼트 → 썬더와 같은 스킬트리는 가능하지만, 썬더 → 스파크나 라이트닝 볼트 → 스파크 → 힐링 → 썬더와 같은 스킬트리는 불가능합니다. 선행 스킬 순서 skill과 유저들이 만든 스킬트리1를 담은 배열 skill_trees가 매개변수로 주어질 때, 가능한 스킬트리 개수를 return 하는 solution 함수를 작성해주세요. 제한 조건 스킬은 알파벳 대문자로 표기하며, 모든 문자열은 알파벳 대문자로만 이루어져 있습니다. 스킬 순서와 스킬트리는 문자열로 표기합니다. 예를 들어, C → B → D 라면 ""CBD""로 표기합니다 선행 스킬 순서 skill의 길이는 1 이상 26 이하이며, 스킬은 중복해 주어지지 않습니다. skill_trees는 길이 1 이상 20 이하인 배열입니다. skill_trees의 원소는 스킬을 나타내는 문자열입니다. skill_trees의 원소는 길이가 2 이상 26 이하인 문자열이며, 스킬이 중복해 주어지지 않습니다. 입출력 예 skill skill_trees return ""CBD"" [""BACDE"", ""CBADF"", ""AECB"", ""BDA""] 2 입출력 예 설명 ""BACDE"": B 스킬을 배우기 전에 C 스킬을 먼저 배워야 합니다. 불가능한 스킬트립니다. ""CBADF"": 가능한 스킬트리입니다. ""AECB"": 가능한 스킬트리입니다. ""BDA"": B 스킬을 배우기 전에 C 스킬을 먼저 배워야 합니다. 불가능한 스킬트리입니다. 스킬 트리: 유저가 스킬을 배울 순서 ↩",normal,Array
478,"n명의 권투선수가 권투 대회에 참여했고 각각 1번부터 n번까지 번호를 받았습니다. 권투 경기는 1대1 방식으로 진행이 되고, 만약 A 선수가 B 선수보다 실력이 좋다면 A 선수는 B 선수를 항상 이깁니다. 심판은 주어진 경기 결과를 가지고 선수들의 순위를 매기려 합니다. 하지만 몇몇 경기 결과를 분실하여 정확하게 순위를 매길 수 없습니다. 선수의 수 n, 경기 결과를 담은 2차원 배열 results가 매개변수로 주어질 때 정확하게 순위를 매길 수 있는 선수의 수를 return 하도록 solution 함수를 작성해주세요. 제한사항 선수의 수는 1명 이상 100명 이하입니다. 경기 결과는 1개 이상 4,500개 이하입니다. results 배열 각 행 [A, B]는 A 선수가 B 선수를 이겼다는 의미입니다. 모든 경기 결과에는 모순이 없습니다. 입출력 예 n results return 5 [[4, 3], [4, 2], [3, 2], [1, 2], [2, 5]] 2 입출력 예 설명 2번 선수는 [1, 3, 4] 선수에게 패배했고 5번 선수에게 승리했기 때문에 4위입니다. 5번 선수는 4위인 2번 선수에게 패배했기 때문에 5위입니다.",normal,Array
479,"원점(0,0)에서 시작해서 아래처럼 숫자가 적힌 방향으로 이동하며 선을 긋습니다. ex) 1일때는 오른쪽 위로 이동 그림을 그릴 때, 사방이 막히면 방하나로 샙니다. 이동하는 방향이 담긴 배열 arrows가 매개변수로 주어질 때, 방의 갯수를 return 하도록 solution 함수를 작성하세요. 제한사항 배열 arrows의 크기는 1 이상 100,000 이하 입니다. arrows의 원소는 0 이상 7 이하 입니다. 방은 다른 방으로 둘러 싸여질 수 있습니다. 입출력 예 arrows return [6, 6, 6, 4, 4, 4, 2, 2, 2, 0, 0, 0, 1, 6, 5, 5, 3, 6, 0] 3 입출력 예 설명 (0,0) 부터 시작해서 6(왼쪽) 으로 3번 이동합니다. 그 이후 주어진 arrows 를 따라 그립니다. 삼각형 (1), 큰 사각형(1), 평행사변형(1) = 3 출처",hard,Array
480,"n개의 노드가 있는 그래프가 있습니다. 각 노드는 1부터 n까지 번호가 적혀있습니다. 1번 노드에서 가장 멀리 떨어진 노드의 갯수를 구하려고 합니다. 가장 멀리 떨어진 노드란 최단경로로 이동했을 때 간선의 개수가 가장 많은 노드들을 의미합니다. 노드의 개수 n, 간선에 대한 정보가 담긴 2차원 배열 vertex가 매개변수로 주어질 때, 1번 노드로부터 가장 멀리 떨어진 노드가 몇 개인지를 return 하도록 solution 함수를 작성해주세요. 제한사항 노드의 개수 n은 2 이상 20,000 이하입니다. 간선은 양방향이며 총 1개 이상 50,000개 이하의 간선이 있습니다. vertex 배열 각 행 [a, b]는 a번 노드와 b번 노드 사이에 간선이 있다는 의미입니다. 입출력 예 n vertex return 6 [[3, 6], [4, 3], [3, 2], [1, 3], [1, 2], [2, 4], [5, 2]] 3 입출력 예 설명 예제의 그래프를 표현하면 아래 그림과 같고, 1번 노드에서 가장 멀리 떨어진 노드는 4,5,6번 노드입니다.",normal,Array
481,"n명이 입국심사를 위해 줄을 서서 기다리고 있습니다. 각 입국심사대에 있는 심사관마다 심사하는데 걸리는 시간은 다릅니다. 처음에 모든 심사대는 비어있습니다. 한 심사대에서는 동시에 한 명만 심사를 할 수 있습니다. 가장 앞에 서 있는 사람은 비어 있는 심사대로 가서 심사를 받을 수 있습니다. 하지만 더 빨리 끝나는 심사대가 있으면 기다렸다가 그곳으로 가서 심사를 받을 수도 있습니다. 모든 사람이 심사를 받는데 걸리는 시간을 최소로 하고 싶습니다. 입국심사를 기다리는 사람 수 n, 각 심사관이 한 명을 심사하는데 걸리는 시간이 담긴 배열 times가 매개변수로 주어질 때, 모든 사람이 심사를 받는데 걸리는 시간의 최솟값을 return 하도록 solution 함수를 작성해주세요. 제한사항 입국심사를 기다리는 사람은 1명 이상 1,000,000,000명 이하입니다. 각 심사관이 한 명을 심사하는데 걸리는 시간은 1분 이상 1,000,000,000분 이하입니다. 심사관은 1명 이상 100,000명 이하입니다. 입출력 예 n times return 6 [7, 10] 28 입출력 예 설명 가장 첫 두 사람은 바로 심사를 받으러 갑니다. 7분이 되었을 때, 첫 번째 심사대가 비고 3번째 사람이 심사를 받습니다. 10분이 되었을 때, 두 번째 심사대가 비고 4번째 사람이 심사를 받습니다. 14분이 되었을 때, 첫 번째 심사대가 비고 5번째 사람이 심사를 받습니다. 20분이 되었을 때, 두 번째 심사대가 비지만 6번째 사람이 그곳에서 심사를 받지 않고 1분을 더 기다린 후에 첫 번째 심사대에서 심사를 받으면 28분에 모든 사람의 심사가 끝납니다. 문제가 잘 안풀린다면😢 힌트가 필요한가요? [코딩테스트 연습 힌트 모음집]으로 오세요! → 클릭 ※ 공지 - 2019년 9월 4일 문제에 새로운 테스트 케이스를 추가하였습니다. 도움을 주신 weaver9651 님께 감사드립니다.",normal,Array
482,"출발지점부터 distance만큼 떨어진 곳에 도착지점이 있습니다. 그리고 그사이에는 바위들이 놓여있습니다. 바위 중 몇 개를 제거하려고 합니다. 예를 들어, 도착지점이 25만큼 떨어져 있고, 바위가 [2, 14, 11, 21, 17] 지점에 놓여있을 때 바위 2개를 제거하면 출발지점, 도착지점, 바위 간의 거리가 아래와 같습니다. 제거한 바위의 위치 각 바위 사이의 거리 거리의 최솟값 [21, 17] [2, 9, 3, 11] 2 [2, 21] [11, 3, 3, 8] 3 [2, 11] [14, 3, 4, 4] 3 [11, 21] [2, 12, 3, 8] 2 [2, 14] [11, 6, 4, 4] 4 위에서 구한 거리의 최솟값 중에 가장 큰 값은 4입니다. 출발지점부터 도착지점까지의 거리 distance, 바위들이 있는 위치를 담은 배열 rocks, 제거할 바위의 수 n이 매개변수로 주어질 때, 바위를 n개 제거한 뒤 각 지점 사이의 거리의 최솟값 중에 가장 큰 값을 return 하도록 solution 함수를 작성해주세요. 제한사항 도착지점까지의 거리 distance는 1 이상 1,000,000,000 이하입니다. 바위는 1개 이상 50,000개 이하가 있습니다. n 은 1 이상 바위의 개수 이하입니다. 입출력 예 distance rocks n return 25 [2, 14, 11, 21, 17] 2 4 입출력 예 설명 문제에 나온 예와 같습니다. 출처 ※ 공지 - 2020년 2월 17일 테스트케이스가 추가되었습니다. ※ 공지 - 2023년 5월 15일 테스트케이스가 추가되었습니다. 기존에 제출한 코드가 통과하지 못할 수도 있습니다.",hard,Array
483,"n개의 음이 아닌 정수들이 있습니다. 이 정수들을 순서를 바꾸지 않고 적절히 더하거나 빼서 타겟 넘버를 만들려고 합니다. 예를 들어 [1, 1, 1, 1, 1]로 숫자 3을 만들려면 다음 다섯 방법을 쓸 수 있습니다. -1+1+1+1+1 = 3 +1-1+1+1+1 = 3 +1+1-1+1+1 = 3 +1+1+1-1+1 = 3 +1+1+1+1-1 = 3 사용할 수 있는 숫자가 담긴 배열 numbers, 타겟 넘버 target이 매개변수로 주어질 때 숫자를 적절히 더하고 빼서 타겟 넘버를 만드는 방법의 수를 return 하도록 solution 함수를 작성해주세요. 제한사항 주어지는 숫자의 개수는 2개 이상 20개 이하입니다. 각 숫자는 1 이상 50 이하인 자연수입니다. 타겟 넘버는 1 이상 1000 이하인 자연수입니다. 입출력 예 numbers target return [1, 1, 1, 1, 1] 3 5 [4, 1, 2, 1] 4 2 입출력 예 설명 입출력 예 #1 문제 예시와 같습니다. 입출력 예 #2 +4+1-2+1 = 4 +4-1+2-1 = 4 총 2가지 방법이 있으므로, 2를 return 합니다.",normal,Array
484,"주어진 항공권을 모두 이용하여 여행경로를 짜려고 합니다. 항상 ""ICN"" 공항에서 출발합니다. 항공권 정보가 담긴 2차원 배열 tickets가 매개변수로 주어질 때, 방문하는 공항 경로를 배열에 담아 return 하도록 solution 함수를 작성해주세요. 제한사항 모든 공항은 알파벳 대문자 3글자로 이루어집니다. 주어진 공항 수는 3개 이상 10,000개 이하입니다. tickets의 각 행 [a, b]는 a 공항에서 b 공항으로 가는 항공권이 있다는 의미입니다. 주어진 항공권은 모두 사용해야 합니다. 만일 가능한 경로가 2개 이상일 경우 알파벳 순서가 앞서는 경로를 return 합니다. 모든 도시를 방문할 수 없는 경우는 주어지지 않습니다. 입출력 예 tickets return [[""ICN"", ""JFK""], [""HND"", ""IAD""], [""JFK"", ""HND""]] [""ICN"", ""JFK"", ""HND"", ""IAD""] [[""ICN"", ""SFO""], [""ICN"", ""ATL""], [""SFO"", ""ATL""], [""ATL"", ""ICN""], [""ATL"",""SFO""]] [""ICN"", ""ATL"", ""ICN"", ""SFO"", ""ATL"", ""SFO""] 입출력 예 설명 예제 #1 [""ICN"", ""JFK"", ""HND"", ""IAD""] 순으로 방문할 수 있습니다. 예제 #2 [""ICN"", ""SFO"", ""ATL"", ""ICN"", ""ATL"", ""SFO""] 순으로 방문할 수도 있지만 [""ICN"", ""ATL"", ""ICN"", ""SFO"", ""ATL"", ""SFO""] 가 알파벳 순으로 앞섭니다. 문제가 잘 안풀린다면😢 힌트가 필요한가요? [코딩테스트 연습 힌트 모음집]으로 오세요! → 클릭",normal,Array
485,"두 개의 단어 begin, target과 단어의 집합 words가 있습니다. 아래와 같은 규칙을 이용하여 begin에서 target으로 변환하는 가장 짧은 변환 과정을 찾으려고 합니다. 1. 한 번에 한 개의 알파벳만 바꿀 수 있습니다. 2. words에 있는 단어로만 변환할 수 있습니다. 예를 들어 begin이 ""hit"", target가 ""cog"", words가 [""hot"",""dot"",""dog"",""lot"",""log"",""cog""]라면 ""hit"" -> ""hot"" -> ""dot"" -> ""dog"" -> ""cog""와 같이 4단계를 거쳐 변환할 수 있습니다. 두 개의 단어 begin, target과 단어의 집합 words가 매개변수로 주어질 때, 최소 몇 단계의 과정을 거쳐 begin을 target으로 변환할 수 있는지 return 하도록 solution 함수를 작성해주세요. 제한사항 각 단어는 알파벳 소문자로만 이루어져 있습니다. 각 단어의 길이는 3 이상 10 이하이며 모든 단어의 길이는 같습니다. words에는 3개 이상 50개 이하의 단어가 있으며 중복되는 단어는 없습니다. begin과 target은 같지 않습니다. 변환할 수 없는 경우에는 0를 return 합니다. 입출력 예 begin target words return ""hit"" ""cog"" [""hot"", ""dot"", ""dog"", ""lot"", ""log"", ""cog""] 4 ""hit"" ""cog"" [""hot"", ""dot"", ""dog"", ""lot"", ""log""] 0 입출력 예 설명 예제 #1 문제에 나온 예와 같습니다. 예제 #2 target인 ""cog""는 words 안에 없기 때문에 변환할 수 없습니다.",normal,Hash Table
486,"네트워크란 컴퓨터 상호 간에 정보를 교환할 수 있도록 연결된 형태를 의미합니다. 예를 들어, 컴퓨터 A와 컴퓨터 B가 직접적으로 연결되어있고, 컴퓨터 B와 컴퓨터 C가 직접적으로 연결되어 있을 때 컴퓨터 A와 컴퓨터 C도 간접적으로 연결되어 정보를 교환할 수 있습니다. 따라서 컴퓨터 A, B, C는 모두 같은 네트워크 상에 있다고 할 수 있습니다. 컴퓨터의 개수 n, 연결에 대한 정보가 담긴 2차원 배열 computers가 매개변수로 주어질 때, 네트워크의 개수를 return 하도록 solution 함수를 작성하시오. 제한사항 컴퓨터의 개수 n은 1 이상 200 이하인 자연수입니다. 각 컴퓨터는 0부터 n-1인 정수로 표현합니다. i번 컴퓨터와 j번 컴퓨터가 연결되어 있으면 computers[i][j]를 1로 표현합니다. computer[i][i]는 항상 1입니다. 입출력 예 n computers return 3 [[1, 1, 0], [1, 1, 0], [0, 0, 1]] 2 3 [[1, 1, 0], [1, 1, 1], [0, 1, 1]] 1 입출력 예 설명 예제 #1 아래와 같이 2개의 네트워크가 있습니다. 예제 #2 아래와 같이 1개의 네트워크가 있습니다.",normal,Array
487,"위와 같은 삼각형의 꼭대기에서 바닥까지 이어지는 경로 중, 거쳐간 숫자의 합이 가장 큰 경우를 찾아보려고 합니다. 아래 칸으로 이동할 때는 대각선 방향으로 한 칸 오른쪽 또는 왼쪽으로만 이동 가능합니다. 예를 들어 3에서는 그 아래칸의 8 또는 1로만 이동이 가능합니다. 삼각형의 정보가 담긴 배열 triangle이 매개변수로 주어질 때, 거쳐간 숫자의 최댓값을 return 하도록 solution 함수를 완성하세요. 제한사항 삼각형의 높이는 1 이상 500 이하입니다. 삼각형을 이루고 있는 숫자는 0 이상 9,999 이하의 정수입니다. 입출력 예 triangle result [[7], [3, 8], [8, 1, 0], [2, 7, 4, 4], [4, 5, 2, 6, 5]] 30",normal,Array
488,"계속되는 폭우로 일부 지역이 물에 잠겼습니다. 물에 잠기지 않은 지역을 통해 학교를 가려고 합니다. 집에서 학교까지 가는 길은 m x n 크기의 격자모양으로 나타낼 수 있습니다. 아래 그림은 m = 4, n = 3 인 경우입니다. 가장 왼쪽 위, 즉 집이 있는 곳의 좌표는 (1, 1)로 나타내고 가장 오른쪽 아래, 즉 학교가 있는 곳의 좌표는 (m, n)으로 나타냅니다. 격자의 크기 m, n과 물이 잠긴 지역의 좌표를 담은 2차원 배열 puddles이 매개변수로 주어집니다. 오른쪽과 아래쪽으로만 움직여 집에서 학교까지 갈 수 있는 최단경로의 개수를 1,000,000,007로 나눈 나머지를 return 하도록 solution 함수를 작성해주세요. 제한사항 격자의 크기 m, n은 1 이상 100 이하인 자연수입니다. m과 n이 모두 1인 경우는 입력으로 주어지지 않습니다. 물에 잠긴 지역은 0개 이상 10개 이하입니다. 집과 학교가 물에 잠긴 경우는 입력으로 주어지지 않습니다. 입출력 예 m n puddles return 4 3 [[2, 2]] 4 입출력 예 설명",normal,Array
489,"도둑이 어느 마을을 털 계획을 하고 있습니다. 이 마을의 모든 집들은 아래 그림과 같이 동그랗게 배치되어 있습니다. 각 집들은 서로 인접한 집들과 방범장치가 연결되어 있기 때문에 인접한 두 집을 털면 경보가 울립니다. 각 집에 있는 돈이 담긴 배열 money가 주어질 때, 도둑이 훔칠 수 있는 돈의 최댓값을 return 하도록 solution 함수를 작성하세요. 제한사항 이 마을에 있는 집은 3개 이상 1,000,000개 이하입니다. money 배열의 각 원소는 0 이상 1,000 이하인 정수입니다. 입출력 예 money return [1, 2, 3, 1] 4",hard,Array
490,"아래와 같이 5와 사칙연산만으로 12를 표현할 수 있습니다. 12 = 5 + 5 + (5 / 5) + (5 / 5) 12 = 55 / 5 + 5 / 5 12 = (55 + 5) / 5 5를 사용한 횟수는 각각 6,5,4 입니다. 그리고 이중 가장 작은 경우는 4입니다. 이처럼 숫자 N과 number가 주어질 때, N과 사칙연산만 사용해서 표현 할 수 있는 방법 중 N 사용횟수의 최솟값을 return 하도록 solution 함수를 작성하세요. 제한사항 N은 1 이상 9 이하입니다. number는 1 이상 32,000 이하입니다. 수식에는 괄호와 사칙연산만 가능하며 나누기 연산에서 나머지는 무시합니다. 최솟값이 8보다 크면 -1을 return 합니다. 입출력 예 N number return 5 12 4 2 11 3 입출력 예 설명 예제 #1 문제에 나온 예와 같습니다. 예제 #2 11 = 22 / 2와 같이 2를 3번만 사용하여 표현할 수 있습니다. ※ 공지 - 2020년 9월 3일 테스트케이스가 추가되었습니다.",normal,Math
491,"블록게임 프렌즈 블록이라는 신규 게임이 출시되었고, 어마어마한 상금이 걸린 이벤트 대회가 개최 되었다. 이 대회는 사람을 대신해서 플레이할 프로그램으로 참가해도 된다는 규정이 있어서, 게임 실력이 형편없는 프로도는 프로그램을 만들어서 참가하기로 결심하고 개발을 시작하였다. 프로도가 우승할 수 있도록 도와서 빠르고 정확한 프로그램을 작성해 보자. 게임규칙 아래 그림과 같이 1×1 크기의 블록을 이어 붙여 만든 3 종류의 블록을 회전해서 총 12가지 모양의 블록을 만들 수 있다. 1 x 1 크기의 정사각형으로 이루어진 N x N 크기의 보드 위에 이 블록들이 배치된 채로 게임이 시작된다. (보드 위에 놓인 블록은 회전할 수 없다). 모든 블록은 블록을 구성하는 사각형들이 정확히 보드 위의 사각형에 맞도록 놓여있으며, 선 위에 걸치거나 보드를 벗어나게 놓여있는 경우는 없다. 플레이어는 위쪽에서 1 x 1 크기의 검은 블록을 떨어뜨려 쌓을 수 있다. 검은 블록은 항상 맵의 한 칸에 꽉 차게 떨어뜨려야 하며, 줄에 걸치면 안된다. 이때, 검은 블록과 기존에 놓인 블록을 합해 속이 꽉 채워진 직사각형을 만들 수 있다면 그 블록을 없앨 수 있다. 예를 들어 검은 블록을 떨어뜨려 아래와 같이 만들 경우 주황색 블록을 없앨 수 있다. 빨간 블록을 가로막던 주황색 블록이 없어졌으므로 다음과 같이 빨간 블록도 없앨 수 있다. 그러나 다른 블록들은 검은 블록을 떨어뜨려 직사각형으로 만들 수 없기 때문에 없앨 수 없다. 따라서 위 예시에서 없앨 수 있는 블록은 최대 2개이다. 보드 위에 놓인 블록의 상태가 담긴 2차원 배열 board가 주어질 때, 검은 블록을 떨어뜨려 없앨 수 있는 블록 개수의 최댓값을 구하라. 제한사항 board는 블록의 상태가 들어있는 N x N 크기 2차원 배열이다. N은 4 이상 50 이하다. board의 각 행의 원소는 0 이상 200 이하의 자연수이다. 0 은 빈 칸을 나타낸다. board에 놓여있는 각 블록은 숫자를 이용해 표현한다. 잘못된 블록 모양이 주어지는 경우는 없다. 모양에 관계 없이 서로 다른 블록은 서로 다른 숫자로 표현된다. 예를 들어 문제에 주어진 예시의 경우 다음과 같이 주어진다. 입출력 예 board result [[0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,4,0,0,0],[0,0,0,0,0,4,4,0,0,0],[0,0,0,0,3,0,4,0,0,0],[0,0,0,2,3,0,0,0,5,5],[1,2,2,2,3,3,0,0,0,5],[1,1,1,0,0,0,0,0,0,5]] 2 입출력 예 설명 입출력 예 #1 문제에 주어진 예시와 같음",hard,Array
492,"매칭 점수 프렌즈 대학교 조교였던 제이지는 허드렛일만 시키는 네오 학과장님의 마수에서 벗어나, 카카오에 입사하게 되었다. 평소에 관심있어하던 검색에 마침 결원이 발생하여, 검색개발팀에 편입될 수 있었고, 대망의 첫 프로젝트를 맡게 되었다. 그 프로젝트는 검색어에 가장 잘 맞는 웹페이지를 보여주기 위해 아래와 같은 규칙으로 검색어에 대한 웹페이지의 매칭점수를 계산 하는 것이었다. 한 웹페이지에 대해서 기본점수, 외부 링크 수, 링크점수, 그리고 매칭점수를 구할 수 있다. 한 웹페이지의 기본점수는 해당 웹페이지의 텍스트 중, 검색어가 등장하는 횟수이다. (대소문자 무시) 한 웹페이지의 외부 링크 수는 해당 웹페이지에서 다른 외부 페이지로 연결된 링크의 개수이다. 한 웹페이지의 링크점수는 해당 웹페이지로 링크가 걸린 다른 웹페이지의 기본점수 ÷ 외부 링크 수의 총합이다. 한 웹페이지의 매칭점수는 기본점수와 링크점수의 합으로 계산한다. 예를 들어, 다음과 같이 A, B, C 세 개의 웹페이지가 있고, 검색어가 hi라고 하자. 이때 A 웹페이지의 매칭점수는 다음과 같이 계산할 수 있다. 기본 점수는 각 웹페이지에서 hi가 등장한 횟수이다. A,B,C 웹페이지의 기본점수는 각각 1점, 4점, 9점이다. 외부 링크수는 다른 웹페이지로 링크가 걸린 개수이다. A,B,C 웹페이지의 외부 링크 수는 각각 1점, 2점, 3점이다. A 웹페이지로 링크가 걸린 페이지는 B와 C가 있다. A 웹페이지의 링크점수는 B의 링크점수 2점(4 ÷ 2)과 C의 링크점수 3점(9 ÷ 3)을 더한 5점이 된다. 그러므로, A 웹페이지의 매칭점수는 기본점수 1점 + 링크점수 5점 = 6점이 된다. 검색어 word와 웹페이지의 HTML 목록인 pages가 주어졌을 때, 매칭점수가 가장 높은 웹페이지의 index를 구하라. 만약 그런 웹페이지가 여러 개라면 그중 번호가 가장 작은 것을 구하라. 제한사항 pages는 HTML 형식의 웹페이지가 문자열 형태로 들어있는 배열이고, 길이는 1 이상 20 이하이다. 한 웹페이지 문자열의 길이는 1 이상 1,500 이하이다. 웹페이지의 index는 pages 배열의 index와 같으며 0부터 시작한다. 한 웹페이지의 url은 HTML의 <head> 태그 내에 <meta> 태그의 값으로 주어진다. 예를들어, 아래와 같은 meta tag가 있으면 이 웹페이지의 url은 https://careers.kakao.com/index 이다. 한 웹페이지에서 모든 외부 링크는 의 형태를 가진다. 내에 다른 attribute가 주어지는 경우는 없으며 항상 href로 연결할 사이트의 url만 포함된다. 위의 경우에서 해당 웹페이지는 https://careers.kakao.com/index 로 외부링크를 가지고 있다고 볼 수 있다. 모든 url은 https:// 로만 시작한다. 검색어 word는 하나의 영어 단어로만 주어지며 알파벳 소문자와 대문자로만 이루어져 있다. word의 길이는 1 이상 12 이하이다. 검색어를 찾을 때, 대소문자 구분은 무시하고 찾는다. 예를들어 검색어가 blind일 때, HTML 내에 Blind라는 단어가 있거나, BLIND라는 단어가 있으면 두 경우 모두 해당된다. 검색어는 단어 단위로 비교하며, 단어와 완전히 일치하는 경우에만 기본 점수에 반영한다. 단어는 알파벳을 제외한 다른 모든 문자로 구분한다. 예를들어 검색어가 ""aba"" 일 때, ""abab abababa""는 단어 단위로 일치하는게 없으니, 기본 점수는 0점이 된다. 만약 검색어가 ""aba"" 라면, ""aba@aba aba""는 단어 단위로 세개가 일치하므로, 기본 점수는 3점이다. 결과를 돌려줄때, 동일한 매칭점수를 가진 웹페이지가 여러 개라면 그중 index 번호가 가장 작은 것를 리턴한다 즉, 웹페이지가 세개이고, 각각 매칭점수가 3,1,3 이라면 제일 적은 index 번호인 0을 리턴하면 된다. 입출력 예 #1 word : blind pages : [""<html lang=\""ko\"" xml:lang=\""ko\"" xmlns=\""http://www.w3.org/1999/xhtml\"">\n<head>\n <meta charset=\""utf-8\"">\n <meta property=\""og:url\"" content=\""https://a.com\""/>\n</head> \n<body>\nBlind Lorem Blind ipsum dolor Blind test sit amet, consectetur adipiscing elit. \n<a href=\""https://b.com\""> Link to b </a>\n</body>\n</html>"", ""<html lang=\""ko\"" xml:lang=\""ko\"" xmlns=\""http://www.w3.org/1999/xhtml\"">\n<head>\n <meta charset=\""utf-8\"">\n <meta property=\""og:url\"" content=\""https://b.com\""/>\n</head> \n<body>\nSuspendisse potenti. Vivamus venenatis tellus non turpis bibendum, \n<a href=\""https://a.com\""> Link to a </a>\nblind sed congue urna varius. Suspendisse feugiat nisl ligula, quis malesuada felis hendrerit ut.\n<a href=\""https://c.com\""> Link to c </a>\n</body>\n</html>"", ""<html lang=\""ko\"" xml:lang=\""ko\"" xmlns=\""http://www.w3.org/1999/xhtml\"">\n<head>\n <meta charset=\""utf-8\"">\n <meta property=\""og:url\"" content=\""https://c.com\""/>\n</head> \n<body>\nUt condimentum urna at felis sodales rutrum. Sed dapibus cursus diam, non interdum nulla tempor nec. Phasellus rutrum enim at orci consectetu blind\n<a href=\""https://a.com\""> Link to a </a>\n</body>\n</html>""] pages는 다음과 같이 3개의 웹페이지에 해당하는 HTML 문자열이 순서대로 들어있다. <html lang=""ko"" xml:lang=""ko"" xmlns=""http://www.w3.org/1999/xhtml""> <head> <meta charset=""utf-8""> <meta property=""og:url"" content=""https://a.com""/> </head> <body> Blind Lorem Blind ipsum dolor Blind test sit amet, consectetur adipiscing elit. <a href=""https://b.com""> Link to b </a> </body> </html> <html lang=""ko"" xml:lang=""ko"" xmlns=""http://www.w3.org/1999/xhtml""> <head> <meta charset=""utf-8""> <meta property=""og:url"" content=""https://b.com""/> </head> <body> Suspendisse potenti. Vivamus venenatis tellus non turpis bibendum, <a href=""https://a.com""> Link to a </a> blind sed congue urna varius. Suspendisse feugiat nisl ligula, quis malesuada felis hendrerit ut. <a href=""https://c.com""> Link to c </a> </body> </html> <html lang=""ko"" xml:lang=""ko"" xmlns=""http://www.w3.org/1999/xhtml""> <head> <meta charset=""utf-8""> <meta property=""og:url"" content=""https://c.com""/> </head> <body> Ut condimentum urna at felis sodales rutrum. Sed dapibus cursus diam, non interdum nulla tempor nec. Phasellus rutrum enim at orci consectetu blind <a href=""https://a.com""> Link to a </a> </body> </html> 위의 예를 가지고 각각의 점수를 계산해보자. 기본점수 및 외부 링크수는 아래와 같다. a.com의 기본점수는 3, 외부 링크 수는 1개 b.com의 기본점수는 1, 외부 링크 수는 2개 c.com의 기본점수는 1, 외부 링크 수는 1개 링크점수는 아래와 같다. a.com의 링크점수는 b.com으로부터 0.5점, c.com으로부터 1점 b.com의 링크점수는 a.com으로부터 3점 c.com의 링크점수는 b.com으로부터 0.5점 각 웹 페이지의 매칭 점수는 다음과 같다. a.com : 4.5 점 b.com : 4 점 c.com : 1.5 점 따라서 매칭점수가 제일 높은 첫번째 웹 페이지의 index인 0을 리턴 하면 된다. 입출력 예 #2 word : Muzi pages : [""<html lang=\""ko\"" xml:lang=\""ko\"" xmlns=\""http://www.w3.org/1999/xhtml\"">\n<head>\n <meta charset=\""utf-8\"">\n <meta property=\""og:url\"" content=\""https://careers.kakao.com/interview/list\""/>\n</head> \n<body>\n<a href=\""https://programmers.co.kr/learn/courses/4673\""></a>#!MuziMuzi!)jayg07con&&\n\n</body>\n</html>"", ""<html lang=\""ko\"" xml:lang=\""ko\"" xmlns=\""http://www.w3.org/1999/xhtml\"">\n<head>\n <meta charset=\""utf-8\"">\n <meta property=\""og:url\"" content=\""https://www.kakaocorp.com\""/>\n</head> \n<body>\ncon%\tmuzI92apeach&2<a href=\""https://hashcode.co.kr/tos\""></a>\n\n\t^\n</body>\n</html>""] pages는 다음과 같이 2개의 웹페이지에 해당하는 HTML 문자열이 순서대로 들어있다. <html lang=""ko"" xml:lang=""ko"" xmlns=""http://www.w3.org/1999/xhtml""> <head> <meta charset=""utf-8""> <meta property=""og:url"" content=""https://careers.kakao.com/interview/list""/> </head> <body> <a href=""https://programmers.co.kr/learn/courses/4673""></a>#!MuziMuzi!)jayg07con&& </body> </html> <html lang=""ko"" xml:lang=""ko"" xmlns=""http://www.w3.org/1999/xhtml""> <head> <meta charset=""utf-8""> <meta property=""og:url"" content=""https://www.kakaocorp.com""/> </head> <body> con% muzI92apeach&2<a href=""https://hashcode.co.kr/tos""></a> ^ </body> </html> 기본점수 및 외부 링크수는 아래와 같다. careers.kakao.com/interview/list 의 기본점수는 0, 외부 링크 수는 1개 www.kakaocorp.com 의 기본점수는 1, 외부 링크 수는 1개 링크점수는 아래와 같다. careers.kakao.com/interview/list 의 링크점수는 0점 www.kakaocorp.com 의 링크점수는 0점 각 웹 페이지의 매칭 점수는 다음과 같다. careers.kakao.com/interview/list : 0점 www.kakaocorp.com : 1 점 따라서 매칭점수가 제일 높은 두번째 웹 페이지의 index인 1을 리턴 하면 된다.",normal,Array
493,"길 찾기 게임 전무로 승진한 라이언은 기분이 너무 좋아 프렌즈를 이끌고 특별 휴가를 가기로 했다. 내친김에 여행 계획까지 구상하던 라이언은 재미있는 게임을 생각해냈고 역시 전무로 승진할만한 인재라고 스스로에게 감탄했다. 라이언이 구상한(그리고 아마도 라이언만 즐거울만한) 게임은, 카카오 프렌즈를 두 팀으로 나누고, 각 팀이 같은 곳을 다른 순서로 방문하도록 해서 먼저 순회를 마친 팀이 승리하는 것이다. 그냥 지도를 주고 게임을 시작하면 재미가 덜해지므로, 라이언은 방문할 곳의 2차원 좌표 값을 구하고 각 장소를 이진트리의 노드가 되도록 구성한 후, 순회 방법을 힌트로 주어 각 팀이 스스로 경로를 찾도록 할 계획이다. 라이언은 아래와 같은 특별한 규칙으로 트리 노드들을 구성한다. 트리를 구성하는 모든 노드의 x, y 좌표 값은 정수이다. 모든 노드는 서로 다른 x값을 가진다. 같은 레벨(level)에 있는 노드는 같은 y 좌표를 가진다. 자식 노드의 y 값은 항상 부모 노드보다 작다. 임의의 노드 V의 왼쪽 서브 트리(left subtree)에 있는 모든 노드의 x값은 V의 x값보다 작다. 임의의 노드 V의 오른쪽 서브 트리(right subtree)에 있는 모든 노드의 x값은 V의 x값보다 크다. 아래 예시를 확인해보자. 라이언의 규칙에 맞게 이진트리의 노드만 좌표 평면에 그리면 다음과 같다. (이진트리의 각 노드에는 1부터 N까지 순서대로 번호가 붙어있다.) 이제, 노드를 잇는 간선(edge)을 모두 그리면 아래와 같은 모양이 된다. 위 이진트리에서 전위 순회(preorder), 후위 순회(postorder)를 한 결과는 다음과 같고, 이것은 각 팀이 방문해야 할 순서를 의미한다. 전위 순회 : 7, 4, 6, 9, 1, 8, 5, 2, 3 후위 순회 : 9, 6, 5, 8, 1, 4, 3, 2, 7 다행히 두 팀 모두 머리를 모아 분석한 끝에 라이언의 의도를 간신히 알아차렸다. 그러나 여전히 문제는 남아있다. 노드의 수가 예시처럼 적다면 쉽게 해결할 수 있겠지만, 예상대로 라이언은 그렇게 할 생각이 전혀 없었다. 이제 당신이 나설 때가 되었다. 곤경에 빠진 카카오 프렌즈를 위해 이진트리를 구성하는 노드들의 좌표가 담긴 배열 nodeinfo가 매개변수로 주어질 때, 노드들로 구성된 이진트리를 전위 순회, 후위 순회한 결과를 2차원 배열에 순서대로 담아 return 하도록 solution 함수를 완성하자. 제한사항 nodeinfo는 이진트리를 구성하는 각 노드의 좌표가 1번 노드부터 순서대로 들어있는 2차원 배열이다. nodeinfo의 길이는 1 이상 10,000 이하이다. nodeinfo[i] 는 i + 1번 노드의 좌표이며, [x축 좌표, y축 좌표] 순으로 들어있다. 모든 노드의 좌표 값은 0 이상 100,000 이하인 정수이다. 트리의 깊이가 1,000 이하인 경우만 입력으로 주어진다. 모든 노드의 좌표는 문제에 주어진 규칙을 따르며, 잘못된 노드 위치가 주어지는 경우는 없다. 입출력 예 nodeinfo result [[5,3],[11,5],[13,3],[3,5],[6,1],[1,3],[8,6],[7,2],[2,2]] [[7,4,6,9,1,8,5,2,3],[9,6,5,8,1,4,3,2,7]] 입출력 예 설명 입출력 예 #1 문제에 주어진 예시와 같다.",normal,Array
494,"무지의 먹방 라이브 * 효율성 테스트에 부분 점수가 있는 문제입니다. 평소 식욕이 왕성한 무지는 자신의 재능을 뽐내고 싶어 졌고 고민 끝에 카카오 TV 라이브로 방송을 하기로 마음먹었다. 그냥 먹방을 하면 다른 방송과 차별성이 없기 때문에 무지는 아래와 같이 독특한 방식을 생각해냈다. 회전판에 먹어야 할 N 개의 음식이 있다. 각 음식에는 1부터 N 까지 번호가 붙어있으며, 각 음식을 섭취하는데 일정 시간이 소요된다. 무지는 다음과 같은 방법으로 음식을 섭취한다. 무지는 1번 음식부터 먹기 시작하며, 회전판은 번호가 증가하는 순서대로 음식을 무지 앞으로 가져다 놓는다. 마지막 번호의 음식을 섭취한 후에는 회전판에 의해 다시 1번 음식이 무지 앞으로 온다. 무지는 음식 하나를 1초 동안 섭취한 후 남은 음식은 그대로 두고, 다음 음식을 섭취한다. 다음 음식이란, 아직 남은 음식 중 다음으로 섭취해야 할 가장 가까운 번호의 음식을 말한다. 회전판이 다음 음식을 무지 앞으로 가져오는데 걸리는 시간은 없다고 가정한다. 무지가 먹방을 시작한 지 K 초 후에 네트워크 장애로 인해 방송이 잠시 중단되었다. 무지는 네트워크 정상화 후 다시 방송을 이어갈 때, 몇 번 음식부터 섭취해야 하는지를 알고자 한다. 각 음식을 모두 먹는데 필요한 시간이 담겨있는 배열 food_times, 네트워크 장애가 발생한 시간 K 초가 매개변수로 주어질 때 몇 번 음식부터 다시 섭취하면 되는지 return 하도록 solution 함수를 완성하라. 제한사항 food_times 는 각 음식을 모두 먹는데 필요한 시간이 음식의 번호 순서대로 들어있는 배열이다. k 는 방송이 중단된 시간을 나타낸다. 만약 더 섭취해야 할 음식이 없다면 -1을 반환하면 된다. 정확성 테스트 제한 사항 food_times 의 길이는 1 이상 2,000 이하이다. food_times 의 원소는 1 이상 1,000 이하의 자연수이다. k는 1 이상 2,000,000 이하의 자연수이다. 효율성 테스트 제한 사항 food_times 의 길이는 1 이상 200,000 이하이다. food_times 의 원소는 1 이상 100,000,000 이하의 자연수이다. k는 1 이상 2 x 10^13 이하의 자연수이다. 입출력 예 food_times k result [3, 1, 2] 5 1 입출력 예 설명 입출력 예 #1 0~1초 동안에 1번 음식을 섭취한다. 남은 시간은 [2,1,2] 이다. 1~2초 동안 2번 음식을 섭취한다. 남은 시간은 [2,0,2] 이다. 2~3초 동안 3번 음식을 섭취한다. 남은 시간은 [2,0,1] 이다. 3~4초 동안 1번 음식을 섭취한다. 남은 시간은 [1,0,1] 이다. 4~5초 동안 (2번 음식은 다 먹었으므로) 3번 음식을 섭취한다. 남은 시간은 [1,0,0] 이다. 5초에서 네트워크 장애가 발생했다. 1번 음식을 섭취해야 할 때 중단되었으므로, 장애 복구 후에 1번 음식부터 다시 먹기 시작하면 된다.",hard,Array
495,"후보키 프렌즈대학교 컴퓨터공학과 조교인 제이지는 네오 학과장님의 지시로, 학생들의 인적사항을 정리하는 업무를 담당하게 되었다. 그의 학부 시절 프로그래밍 경험을 되살려, 모든 인적사항을 데이터베이스에 넣기로 하였고, 이를 위해 정리를 하던 중에 후보키(Candidate Key)에 대한 고민이 필요하게 되었다. 후보키에 대한 내용이 잘 기억나지 않던 제이지는, 정확한 내용을 파악하기 위해 데이터베이스 관련 서적을 확인하여 아래와 같은 내용을 확인하였다. 관계 데이터베이스에서 릴레이션(Relation)의 튜플(Tuple)을 유일하게 식별할 수 있는 속성(Attribute) 또는 속성의 집합 중, 다음 두 성질을 만족하는 것을 후보 키(Candidate Key)라고 한다. 유일성(uniqueness) : 릴레이션에 있는 모든 튜플에 대해 유일하게 식별되어야 한다. 최소성(minimality) : 유일성을 가진 키를 구성하는 속성(Attribute) 중 하나라도 제외하는 경우 유일성이 깨지는 것을 의미한다. 즉, 릴레이션의 모든 튜플을 유일하게 식별하는 데 꼭 필요한 속성들로만 구성되어야 한다. 제이지를 위해, 아래와 같은 학생들의 인적사항이 주어졌을 때, 후보 키의 최대 개수를 구하라. 위의 예를 설명하면, 학생의 인적사항 릴레이션에서 모든 학생은 각자 유일한 ""학번""을 가지고 있다. 따라서 ""학번""은 릴레이션의 후보 키가 될 수 있다. 그다음 ""이름""에 대해서는 같은 이름(""apeach"")을 사용하는 학생이 있기 때문에, ""이름""은 후보 키가 될 수 없다. 그러나, 만약 [""이름"", ""전공""]을 함께 사용한다면 릴레이션의 모든 튜플을 유일하게 식별 가능하므로 후보 키가 될 수 있게 된다. 물론 [""이름"", ""전공"", ""학년""]을 함께 사용해도 릴레이션의 모든 튜플을 유일하게 식별할 수 있지만, 최소성을 만족하지 못하기 때문에 후보 키가 될 수 없다. 따라서, 위의 학생 인적사항의 후보키는 ""학번"", [""이름"", ""전공""] 두 개가 된다. 릴레이션을 나타내는 문자열 배열 relation이 매개변수로 주어질 때, 이 릴레이션에서 후보 키의 개수를 return 하도록 solution 함수를 완성하라. 제한사항 relation은 2차원 문자열 배열이다. relation의 컬럼(column)의 길이는 1 이상 8 이하이며, 각각의 컬럼은 릴레이션의 속성을 나타낸다. relation의 로우(row)의 길이는 1 이상 20 이하이며, 각각의 로우는 릴레이션의 튜플을 나타낸다. relation의 모든 문자열의 길이는 1 이상 8 이하이며, 알파벳 소문자와 숫자로만 이루어져 있다. relation의 모든 튜플은 유일하게 식별 가능하다.(즉, 중복되는 튜플은 없다.) 입출력 예 relation result [[""100"",""ryan"",""music"",""2""],[""200"",""apeach"",""math"",""2""],[""300"",""tube"",""computer"",""3""],[""400"",""con"",""computer"",""4""],[""500"",""muzi"",""music"",""3""],[""600"",""apeach"",""music"",""2""]] 2 입출력 예 설명 입출력 예 #1 문제에 주어진 릴레이션과 같으며, 후보 키는 2개이다.",normal,Array
496,"실패율 슈퍼 게임 개발자 오렐리는 큰 고민에 빠졌다. 그녀가 만든 프랜즈 오천성이 대성공을 거뒀지만, 요즘 신규 사용자의 수가 급감한 것이다. 원인은 신규 사용자와 기존 사용자 사이에 스테이지 차이가 너무 큰 것이 문제였다. 이 문제를 어떻게 할까 고민 한 그녀는 동적으로 게임 시간을 늘려서 난이도를 조절하기로 했다. 역시 슈퍼 개발자라 대부분의 로직은 쉽게 구현했지만, 실패율을 구하는 부분에서 위기에 빠지고 말았다. 오렐리를 위해 실패율을 구하는 코드를 완성하라. 실패율은 다음과 같이 정의한다. 스테이지에 도달했으나 아직 클리어하지 못한 플레이어의 수 / 스테이지에 도달한 플레이어 수 전체 스테이지의 개수 N, 게임을 이용하는 사용자가 현재 멈춰있는 스테이지의 번호가 담긴 배열 stages가 매개변수로 주어질 때, 실패율이 높은 스테이지부터 내림차순으로 스테이지의 번호가 담겨있는 배열을 return 하도록 solution 함수를 완성하라. 제한사항 스테이지의 개수 N은 1 이상 500 이하의 자연수이다. stages의 길이는 1 이상 200,000 이하이다. stages에는 1 이상 N + 1 이하의 자연수가 담겨있다. 각 자연수는 사용자가 현재 도전 중인 스테이지의 번호를 나타낸다. 단, N + 1 은 마지막 스테이지(N 번째 스테이지) 까지 클리어 한 사용자를 나타낸다. 만약 실패율이 같은 스테이지가 있다면 작은 번호의 스테이지가 먼저 오도록 하면 된다. 스테이지에 도달한 유저가 없는 경우 해당 스테이지의 실패율은 0 으로 정의한다. 입출력 예 N stages result 5 [2, 1, 2, 6, 2, 4, 3, 3] [3,4,2,1,5] 4 [4,4,4,4,4] [4,1,2,3] 입출력 예 설명 입출력 예 #1 1번 스테이지에는 총 8명의 사용자가 도전했으며, 이 중 1명의 사용자가 아직 클리어하지 못했다. 따라서 1번 스테이지의 실패율은 다음과 같다. 1 번 스테이지 실패율 : 1/8 2번 스테이지에는 총 7명의 사용자가 도전했으며, 이 중 3명의 사용자가 아직 클리어하지 못했다. 따라서 2번 스테이지의 실패율은 다음과 같다. 2 번 스테이지 실패율 : 3/7 마찬가지로 나머지 스테이지의 실패율은 다음과 같다. 3 번 스테이지 실패율 : 2/4 4번 스테이지 실패율 : 1/2 5번 스테이지 실패율 : 0/1 각 스테이지의 번호를 실패율의 내림차순으로 정렬하면 다음과 같다. [3,4,2,1,5] 입출력 예 #2 모든 사용자가 마지막 스테이지에 있으므로 4번 스테이지의 실패율은 1이며 나머지 스테이지의 실패율은 0이다. [4,1,2,3]",easy,Array
497,"오픈채팅방 카카오톡 오픈채팅방에서는 친구가 아닌 사람들과 대화를 할 수 있는데, 본래 닉네임이 아닌 가상의 닉네임을 사용하여 채팅방에 들어갈 수 있다. 신입사원인 김크루는 카카오톡 오픈 채팅방을 개설한 사람을 위해, 다양한 사람들이 들어오고, 나가는 것을 지켜볼 수 있는 관리자창을 만들기로 했다. 채팅방에 누군가 들어오면 다음 메시지가 출력된다. ""[닉네임]님이 들어왔습니다."" 채팅방에서 누군가 나가면 다음 메시지가 출력된다. ""[닉네임]님이 나갔습니다."" 채팅방에서 닉네임을 변경하는 방법은 다음과 같이 두 가지이다. 채팅방을 나간 후, 새로운 닉네임으로 다시 들어간다. 채팅방에서 닉네임을 변경한다. 닉네임을 변경할 때는 기존에 채팅방에 출력되어 있던 메시지의 닉네임도 전부 변경된다. 예를 들어, 채팅방에 ""Muzi""와 ""Prodo""라는 닉네임을 사용하는 사람이 순서대로 들어오면 채팅방에는 다음과 같이 메시지가 출력된다. ""Muzi님이 들어왔습니다."" ""Prodo님이 들어왔습니다."" 채팅방에 있던 사람이 나가면 채팅방에는 다음과 같이 메시지가 남는다. ""Muzi님이 들어왔습니다."" ""Prodo님이 들어왔습니다."" ""Muzi님이 나갔습니다."" Muzi가 나간후 다시 들어올 때, Prodo 라는 닉네임으로 들어올 경우 기존에 채팅방에 남아있던 Muzi도 Prodo로 다음과 같이 변경된다. ""Prodo님이 들어왔습니다."" ""Prodo님이 들어왔습니다."" ""Prodo님이 나갔습니다."" ""Prodo님이 들어왔습니다."" 채팅방은 중복 닉네임을 허용하기 때문에, 현재 채팅방에는 Prodo라는 닉네임을 사용하는 사람이 두 명이 있다. 이제, 채팅방에 두 번째로 들어왔던 Prodo가 Ryan으로 닉네임을 변경하면 채팅방 메시지는 다음과 같이 변경된다. ""Prodo님이 들어왔습니다."" ""Ryan님이 들어왔습니다."" ""Prodo님이 나갔습니다."" ""Prodo님이 들어왔습니다."" 채팅방에 들어오고 나가거나, 닉네임을 변경한 기록이 담긴 문자열 배열 record가 매개변수로 주어질 때, 모든 기록이 처리된 후, 최종적으로 방을 개설한 사람이 보게 되는 메시지를 문자열 배열 형태로 return 하도록 solution 함수를 완성하라. 제한사항 record는 다음과 같은 문자열이 담긴 배열이며, 길이는 1 이상 100,000 이하이다. 다음은 record에 담긴 문자열에 대한 설명이다. 모든 유저는 [유저 아이디]로 구분한다. [유저 아이디] 사용자가 [닉네임]으로 채팅방에 입장 - ""Enter [유저 아이디] [닉네임]"" (ex. ""Enter uid1234 Muzi"") [유저 아이디] 사용자가 채팅방에서 퇴장 - ""Leave [유저 아이디]"" (ex. ""Leave uid1234"") [유저 아이디] 사용자가 닉네임을 [닉네임]으로 변경 - ""Change [유저 아이디] [닉네임]"" (ex. ""Change uid1234 Muzi"") 첫 단어는 Enter, Leave, Change 중 하나이다. 각 단어는 공백으로 구분되어 있으며, 알파벳 대문자, 소문자, 숫자로만 이루어져있다. 유저 아이디와 닉네임은 알파벳 대문자, 소문자를 구별한다. 유저 아이디와 닉네임의 길이는 1 이상 10 이하이다. 채팅방에서 나간 유저가 닉네임을 변경하는 등 잘못 된 입력은 주어지지 않는다. 입출력 예 record result [""Enter uid1234 Muzi"", ""Enter uid4567 Prodo"",""Leave uid1234"",""Enter uid1234 Prodo"",""Change uid4567 Ryan""] [""Prodo님이 들어왔습니다."", ""Ryan님이 들어왔습니다."", ""Prodo님이 나갔습니다."", ""Prodo님이 들어왔습니다.""] 입출력 예 설명 입출력 예 #1 문제의 설명과 같다.",normal,Array
498,"무인도에 갇힌 사람들을 구명보트를 이용하여 구출하려고 합니다. 구명보트는 작아서 한 번에 최대 2명씩 밖에 탈 수 없고, 무게 제한도 있습니다. 예를 들어, 사람들의 몸무게가 [70kg, 50kg, 80kg, 50kg]이고 구명보트의 무게 제한이 100kg이라면 2번째 사람과 4번째 사람은 같이 탈 수 있지만 1번째 사람과 3번째 사람의 무게의 합은 150kg이므로 구명보트의 무게 제한을 초과하여 같이 탈 수 없습니다. 구명보트를 최대한 적게 사용하여 모든 사람을 구출하려고 합니다. 사람들의 몸무게를 담은 배열 people과 구명보트의 무게 제한 limit가 매개변수로 주어질 때, 모든 사람을 구출하기 위해 필요한 구명보트 개수의 최솟값을 return 하도록 solution 함수를 작성해주세요. 제한사항 무인도에 갇힌 사람은 1명 이상 50,000명 이하입니다. 각 사람의 몸무게는 40kg 이상 240kg 이하입니다. 구명보트의 무게 제한은 40kg 이상 240kg 이하입니다. 구명보트의 무게 제한은 항상 사람들의 몸무게 중 최댓값보다 크게 주어지므로 사람들을 구출할 수 없는 경우는 없습니다. 입출력 예 people limit return [70, 50, 80, 50] 100 3 [70, 80, 50] 100 3 ※ 2023년 07월 31일 테스트 케이스가 추가되었습니다. 기존에 제출한 코드가 통과하지 못할 수 있습니다.",normal,Array
499,"고속도로를 이동하는 모든 차량이 고속도로를 이용하면서 단속용 카메라를 한 번은 만나도록 카메라를 설치하려고 합니다. 고속도로를 이동하는 차량의 경로 routes가 매개변수로 주어질 때, 모든 차량이 한 번은 단속용 카메라를 만나도록 하려면 최소 몇 대의 카메라를 설치해야 하는지를 return 하도록 solution 함수를 완성하세요. 제한사항 차량의 대수는 1대 이상 10,000대 이하입니다. routes에는 차량의 이동 경로가 포함되어 있으며 routes[i][0]에는 i번째 차량이 고속도로에 진입한 지점, routes[i][1]에는 i번째 차량이 고속도로에서 나간 지점이 적혀 있습니다. 차량의 진입/진출 지점에 카메라가 설치되어 있어도 카메라를 만난것으로 간주합니다. 차량의 진입 지점, 진출 지점은 -30,000 이상 30,000 이하입니다. 입출력 예 routes return [[-20,-15], [-14,-5], [-18,-13], [-5,-3]] 2 입출력 예 설명 -5 지점에 카메라를 설치하면 두 번째, 네 번째 차량이 카메라를 만납니다. -15 지점에 카메라를 설치하면 첫 번째, 세 번째 차량이 카메라를 만납니다.",normal,Math
500,"어떤 숫자에서 k개의 수를 제거했을 때 얻을 수 있는 가장 큰 숫자를 구하려 합니다. 예를 들어, 숫자 1924에서 수 두 개를 제거하면 [19, 12, 14, 92, 94, 24] 를 만들 수 있습니다. 이 중 가장 큰 숫자는 94 입니다. 문자열 형식으로 숫자 number와 제거할 수의 개수 k가 solution 함수의 매개변수로 주어집니다. number에서 k 개의 수를 제거했을 때 만들 수 있는 수 중 가장 큰 숫자를 문자열 형태로 return 하도록 solution 함수를 완성하세요. 제한 조건 number는 2자리 이상, 1,000,000자리 이하인 숫자입니다. k는 1 이상 number의 자릿수 미만인 자연수입니다. 입출력 예 number k return ""1924"" 2 ""94"" ""1231234"" 3 ""3234"" ""4177252841"" 4 ""775841""",normal,String
501,"점심시간에 도둑이 들어, 일부 학생이 체육복을 도난당했습니다. 다행히 여벌 체육복이 있는 학생이 이들에게 체육복을 빌려주려 합니다. 학생들의 번호는 체격 순으로 매겨져 있어, 바로 앞번호의 학생이나 바로 뒷번호의 학생에게만 체육복을 빌려줄 수 있습니다. 예를 들어, 4번 학생은 3번 학생이나 5번 학생에게만 체육복을 빌려줄 수 있습니다. 체육복이 없으면 수업을 들을 수 없기 때문에 체육복을 적절히 빌려 최대한 많은 학생이 체육수업을 들어야 합니다. 전체 학생의 수 n, 체육복을 도난당한 학생들의 번호가 담긴 배열 lost, 여벌의 체육복을 가져온 학생들의 번호가 담긴 배열 reserve가 매개변수로 주어질 때, 체육수업을 들을 수 있는 학생의 최댓값을 return 하도록 solution 함수를 작성해주세요. 제한사항 전체 학생의 수는 2명 이상 30명 이하입니다. 체육복을 도난당한 학생의 수는 1명 이상 n명 이하이고 중복되는 번호는 없습니다. 여벌의 체육복을 가져온 학생의 수는 1명 이상 n명 이하이고 중복되는 번호는 없습니다. 여벌 체육복이 있는 학생만 다른 학생에게 체육복을 빌려줄 수 있습니다. 여벌 체육복을 가져온 학생이 체육복을 도난당했을 수 있습니다. 이때 이 학생은 체육복을 하나만 도난당했다고 가정하며, 남은 체육복이 하나이기에 다른 학생에게는 체육복을 빌려줄 수 없습니다. 입출력 예 n lost reserve return 5 [2, 4] [1, 3, 5] 5 5 [2, 4] [3] 4 3 [3] [1] 2 입출력 예 설명 예제 #1 1번 학생이 2번 학생에게 체육복을 빌려주고, 3번 학생이나 5번 학생이 4번 학생에게 체육복을 빌려주면 학생 5명이 체육수업을 들을 수 있습니다. 예제 #2 3번 학생이 2번 학생이나 4번 학생에게 체육복을 빌려주면 학생 4명이 체육수업을 들을 수 있습니다. 문제가 잘 안풀린다면😢 힌트가 필요한가요? [코딩테스트 연습 힌트 모음집]으로 오세요! → 클릭 ※ 공지 - 2019년 2월 18일 지문이 리뉴얼되었습니다. ※ 공지 - 2019년 2월 27일, 28일 테스트케이스가 추가되었습니다. ※ 공지 - 2021년 7월 28일 테스트케이스가 추가되었습니다. ※ 공지 - 2021년 8월 30일 테스트케이스가 추가되었습니다. ※ 공지 - 2022년 11월 30일 테스트케이스가 추가되었습니다. ※ 공지 - 2023년 6월 12일 테스트케이스가 추가되었습니다.",easy,Array
502,"n개의 섬 사이에 다리를 건설하는 비용(costs)이 주어질 때, 최소의 비용으로 모든 섬이 서로 통행 가능하도록 만들 때 필요한 최소 비용을 return 하도록 solution을 완성하세요. 다리를 여러 번 건너더라도, 도달할 수만 있으면 통행 가능하다고 봅니다. 예를 들어 A 섬과 B 섬 사이에 다리가 있고, B 섬과 C 섬 사이에 다리가 있으면 A 섬과 C 섬은 서로 통행 가능합니다. 제한사항 섬의 개수 n은 1 이상 100 이하입니다. costs의 길이는 ((n-1) * n) / 2이하입니다. 임의의 i에 대해, costs[i][0] 와 costs[i] [1]에는 다리가 연결되는 두 섬의 번호가 들어있고, costs[i] [2]에는 이 두 섬을 연결하는 다리를 건설할 때 드는 비용입니다. 같은 연결은 두 번 주어지지 않습니다. 또한 순서가 바뀌더라도 같은 연결로 봅니다. 즉 0과 1 사이를 연결하는 비용이 주어졌을 때, 1과 0의 비용이 주어지지 않습니다. 모든 섬 사이의 다리 건설 비용이 주어지지 않습니다. 이 경우, 두 섬 사이의 건설이 불가능한 것으로 봅니다. 연결할 수 없는 섬은 주어지지 않습니다. 입출력 예 n costs return 4 [[0,1,1],[0,2,2],[1,2,5],[1,3,1],[2,3,8]] 4 입출력 예 설명 costs를 그림으로 표현하면 다음과 같으며, 이때 초록색 경로로 연결하는 것이 가장 적은 비용으로 모두를 통행할 수 있도록 만드는 방법입니다.",normal,Math
503,"조이스틱으로 알파벳 이름을 완성하세요. 맨 처음엔 A로만 이루어져 있습니다. ex) 완성해야 하는 이름이 세 글자면 AAA, 네 글자면 AAAA 조이스틱을 각 방향으로 움직이면 아래와 같습니다. ▲ - 다음 알파벳 ▼ - 이전 알파벳 (A에서 아래쪽으로 이동하면 Z로) ◀ - 커서를 왼쪽으로 이동 (첫 번째 위치에서 왼쪽으로 이동하면 마지막 문자에 커서) ▶ - 커서를 오른쪽으로 이동 (마지막 위치에서 오른쪽으로 이동하면 첫 번째 문자에 커서) 예를 들어 아래의 방법으로 ""JAZ""를 만들 수 있습니다. - 첫 번째 위치에서 조이스틱을 위로 9번 조작하여 J를 완성합니다. - 조이스틱을 왼쪽으로 1번 조작하여 커서를 마지막 문자 위치로 이동시킵니다. - 마지막 위치에서 조이스틱을 아래로 1번 조작하여 Z를 완성합니다. 따라서 11번 이동시켜 ""JAZ""를 만들 수 있고, 이때가 최소 이동입니다. 만들고자 하는 이름 name이 매개변수로 주어질 때, 이름에 대해 조이스틱 조작 횟수의 최솟값을 return 하도록 solution 함수를 만드세요. 제한 사항 name은 알파벳 대문자로만 이루어져 있습니다. name의 길이는 1 이상 20 이하입니다. 입출력 예 name return ""JEROEN"" 56 ""JAN"" 23 출처 ※ 공지 - 2019년 2월 28일 테스트케이스가 추가되었습니다. ※ 공지 - 2022년 1월 14일 지문 수정 및 테스트케이스가 추가되었습니다. 이로 인해 이전에 통과하던 코드가 더 이상 통과하지 않을 수 있습니다.",normal,Math
504,"Leo는 카펫을 사러 갔다가 아래 그림과 같이 중앙에는 노란색으로 칠해져 있고 테두리 1줄은 갈색으로 칠해져 있는 격자 모양 카펫을 봤습니다. Leo는 집으로 돌아와서 아까 본 카펫의 노란색과 갈색으로 색칠된 격자의 개수는 기억했지만, 전체 카펫의 크기는 기억하지 못했습니다. Leo가 본 카펫에서 갈색 격자의 수 brown, 노란색 격자의 수 yellow가 매개변수로 주어질 때 카펫의 가로, 세로 크기를 순서대로 배열에 담아 return 하도록 solution 함수를 작성해주세요. 제한사항 갈색 격자의 수 brown은 8 이상 5,000 이하인 자연수입니다. 노란색 격자의 수 yellow는 1 이상 2,000,000 이하인 자연수입니다. 카펫의 가로 길이는 세로 길이와 같거나, 세로 길이보다 깁니다. 입출력 예 brown yellow return 10 2 [4, 3] 8 1 [3, 3] 24 24 [8, 6] 출처 ※ 공지 - 2020년 2월 3일 테스트케이스가 추가되었습니다. ※ 공지 - 2020년 5월 11일 웹접근성을 고려하여 빨간색을 노란색으로 수정하였습니다.",normal,Array
505,"수포자는 수학을 포기한 사람의 준말입니다. 수포자 삼인방은 모의고사에 수학 문제를 전부 찍으려 합니다. 수포자는 1번 문제부터 마지막 문제까지 다음과 같이 찍습니다. 1번 수포자가 찍는 방식: 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, ... 2번 수포자가 찍는 방식: 2, 1, 2, 3, 2, 4, 2, 5, 2, 1, 2, 3, 2, 4, 2, 5, ... 3번 수포자가 찍는 방식: 3, 3, 1, 1, 2, 2, 4, 4, 5, 5, 3, 3, 1, 1, 2, 2, 4, 4, 5, 5, ... 1번 문제부터 마지막 문제까지의 정답이 순서대로 들은 배열 answers가 주어졌을 때, 가장 많은 문제를 맞힌 사람이 누구인지 배열에 담아 return 하도록 solution 함수를 작성해주세요. 제한 조건 시험은 최대 10,000 문제로 구성되어있습니다. 문제의 정답은 1, 2, 3, 4, 5중 하나입니다. 가장 높은 점수를 받은 사람이 여럿일 경우, return하는 값을 오름차순 정렬해주세요. 입출력 예 answers return [1,2,3,4,5] [1] [1,3,2,4,2] [1,2,3] 입출력 예 설명 입출력 예 #1 수포자 1은 모든 문제를 맞혔습니다. 수포자 2는 모든 문제를 틀렸습니다. 수포자 3은 모든 문제를 틀렸습니다. 따라서 가장 문제를 많이 맞힌 사람은 수포자 1입니다. 입출력 예 #2 모든 사람이 2문제씩을 맞췄습니다.",easy,Array
506,"한자리 숫자가 적힌 종이 조각이 흩어져있습니다. 흩어진 종이 조각을 붙여 소수를 몇 개 만들 수 있는지 알아내려 합니다. 각 종이 조각에 적힌 숫자가 적힌 문자열 numbers가 주어졌을 때, 종이 조각으로 만들 수 있는 소수가 몇 개인지 return 하도록 solution 함수를 완성해주세요. 제한사항 numbers는 길이 1 이상 7 이하인 문자열입니다. numbers는 0~9까지 숫자만으로 이루어져 있습니다. ""013""은 0, 1, 3 숫자가 적힌 종이 조각이 흩어져있다는 의미입니다. 입출력 예 numbers return ""17"" 3 ""011"" 2 입출력 예 설명 예제 #1 [1, 7]으로는 소수 [7, 17, 71]를 만들 수 있습니다. 예제 #2 [0, 1, 1]으로는 소수 [11, 101]를 만들 수 있습니다. 11과 011은 같은 숫자로 취급합니다.",normal,String
507,"배열 array의 i번째 숫자부터 j번째 숫자까지 자르고 정렬했을 때, k번째에 있는 수를 구하려 합니다. 예를 들어 array가 [1, 5, 2, 6, 3, 7, 4], i = 2, j = 5, k = 3이라면 array의 2번째부터 5번째까지 자르면 [5, 2, 6, 3]입니다. 1에서 나온 배열을 정렬하면 [2, 3, 5, 6]입니다. 2에서 나온 배열의 3번째 숫자는 5입니다. 배열 array, [i, j, k]를 원소로 가진 2차원 배열 commands가 매개변수로 주어질 때, commands의 모든 원소에 대해 앞서 설명한 연산을 적용했을 때 나온 결과를 배열에 담아 return 하도록 solution 함수를 작성해주세요. 제한사항 array의 길이는 1 이상 100 이하입니다. array의 각 원소는 1 이상 100 이하입니다. commands의 길이는 1 이상 50 이하입니다. commands의 각 원소는 길이가 3입니다. 입출력 예 array commands return [1, 5, 2, 6, 3, 7, 4] [[2, 5, 3], [4, 4, 1], [1, 7, 3]] [5, 6, 3] 입출력 예 설명 [1, 5, 2, 6, 3, 7, 4]를 2번째부터 5번째까지 자른 후 정렬합니다. [2, 3, 5, 6]의 세 번째 숫자는 5입니다. [1, 5, 2, 6, 3, 7, 4]를 4번째부터 4번째까지 자른 후 정렬합니다. [6]의 첫 번째 숫자는 6입니다. [1, 5, 2, 6, 3, 7, 4]를 1번째부터 7번째까지 자릅니다. [1, 2, 3, 4, 5, 6, 7]의 세 번째 숫자는 3입니다.",easy,Array
508,"H-Index는 과학자의 생산성과 영향력을 나타내는 지표입니다. 어느 과학자의 H-Index를 나타내는 값인 h를 구하려고 합니다. 위키백과1에 따르면, H-Index는 다음과 같이 구합니다. 어떤 과학자가 발표한 논문 n편 중, h번 이상 인용된 논문이 h편 이상이고 나머지 논문이 h번 이하 인용되었다면 h의 최댓값이 이 과학자의 H-Index입니다. 어떤 과학자가 발표한 논문의 인용 횟수를 담은 배열 citations가 매개변수로 주어질 때, 이 과학자의 H-Index를 return 하도록 solution 함수를 작성해주세요. 제한사항 과학자가 발표한 논문의 수는 1편 이상 1,000편 이하입니다. 논문별 인용 횟수는 0회 이상 10,000회 이하입니다. 입출력 예 citations return [3, 0, 6, 1, 5] 3 입출력 예 설명 이 과학자가 발표한 논문의 수는 5편이고, 그중 3편의 논문은 3회 이상 인용되었습니다. 그리고 나머지 2편의 논문은 3회 이하 인용되었기 때문에 이 과학자의 H-Index는 3입니다. 문제가 잘 안풀린다면😢 힌트가 필요한가요? [코딩테스트 연습 힌트 모음집]으로 오세요! → 클릭 ※ 공지 - 2019년 2월 28일 테스트 케이스가 추가되었습니다. https://en.wikipedia.org/wiki/H-index ""위키백과"" ↩",normal,Array
509,"0 또는 양의 정수가 주어졌을 때, 정수를 이어 붙여 만들 수 있는 가장 큰 수를 알아내 주세요. 예를 들어, 주어진 정수가 [6, 10, 2]라면 [6102, 6210, 1062, 1026, 2610, 2106]를 만들 수 있고, 이중 가장 큰 수는 6210입니다. 0 또는 양의 정수가 담긴 배열 numbers가 매개변수로 주어질 때, 순서를 재배치하여 만들 수 있는 가장 큰 수를 문자열로 바꾸어 return 하도록 solution 함수를 작성해주세요. 제한 사항 numbers의 길이는 1 이상 100,000 이하입니다. numbers의 원소는 0 이상 1,000 이하입니다. 정답이 너무 클 수 있으니 문자열로 바꾸어 return 합니다. 입출력 예 numbers return [6, 10, 2] ""6210"" [3, 30, 34, 5, 9] ""9534330"" ※ 공지 - 2021년 10월 20일 테스트케이스가 추가되었습니다.",normal,Array
510,"이중 우선순위 큐는 다음 연산을 할 수 있는 자료구조를 말합니다. 명령어 수신 탑(높이) I 숫자 큐에 주어진 숫자를 삽입합니다. D 1 큐에서 최댓값을 삭제합니다. D -1 큐에서 최솟값을 삭제합니다. 이중 우선순위 큐가 할 연산 operations가 매개변수로 주어질 때, 모든 연산을 처리한 후 큐가 비어있으면 [0,0] 비어있지 않으면 [최댓값, 최솟값]을 return 하도록 solution 함수를 구현해주세요. 제한사항 operations는 길이가 1 이상 1,000,000 이하인 문자열 배열입니다. operations의 원소는 큐가 수행할 연산을 나타냅니다. 원소는 “명령어 데이터” 형식으로 주어집니다.- 최댓값/최솟값을 삭제하는 연산에서 최댓값/최솟값이 둘 이상인 경우, 하나만 삭제합니다. 빈 큐에 데이터를 삭제하라는 연산이 주어질 경우, 해당 연산은 무시합니다. 입출력 예 operations return [""I 16"", ""I -5643"", ""D -1"", ""D 1"", ""D 1"", ""I 123"", ""D -1""] [0,0] [""I -45"", ""I 653"", ""D 1"", ""I -642"", ""I 45"", ""I 97"", ""D 1"", ""D -1"", ""I 333""] [333, -45] 입출력 예 설명 입출력 예 #1 16과 -5643을 삽입합니다. 최솟값을 삭제합니다. -5643이 삭제되고 16이 남아있습니다. 최댓값을 삭제합니다. 16이 삭제되고 이중 우선순위 큐는 비어있습니다. 우선순위 큐가 비어있으므로 최댓값 삭제 연산이 무시됩니다. 123을 삽입합니다. 최솟값을 삭제합니다. 123이 삭제되고 이중 우선순위 큐는 비어있습니다. 따라서 [0, 0]을 반환합니다. 입출력 예 #2 -45와 653을 삽입후 최댓값(653)을 삭제합니다. -45가 남아있습니다. -642, 45, 97을 삽입 후 최댓값(97), 최솟값(-642)을 삭제합니다. -45와 45가 남아있습니다. 333을 삽입합니다. 이중 우선순위 큐에 -45, 45, 333이 남아있으므로, [333, -45]를 반환합니다. ※ 공지 - 2024년 7월 22일 테스트케이스가 추가되었습니다. 기존에 제출한 코드가 통과하지 못할 수도 있습니다.",normal,Array
511,"하드디스크는 한 번에 하나의 작업만 수행할 수 있습니다. 디스크 컨트롤러를 구현하는 방법은 여러 가지가 있습니다. 이 문제에서는 우선순위 디스크 컨트롤러라는 가상의 장치를 이용한다고 가정합니다. 우선순위 디스크 컨트롤러는 다음과 같이 동작합니다. 어떤 작업 요청이 들어왔을 때 작업의 번호, 작업의 요청 시각, 작업의 소요 시간을 저장해 두는 대기 큐가 있습니다. 처음에 이 큐는 비어있습니다. 디스크 컨트롤러는 하드디스크가 작업을 하고 있지 않고 대기 큐가 비어있지 않다면 가장 우선순위가 높은 작업을 대기 큐에서 꺼내서 하드디스크에 그 작업을 시킵니다. 이때, 작업의 소요시간이 짧은 것, 작업의 요청 시각이 빠른 것, 작업의 번호가 작은 것 순으로 우선순위가 높습니다. 하드디스크는 작업을 한 번 시작하면 작업을 마칠 때까지 그 작업만 수행합니다. 하드디스크가 어떤 작업을 마치는 시점과 다른 작업 요청이 들어오는 시점이 겹친다면 하드디스크가 작업을 마치자마자 디스크 컨트롤러는 요청이 들어온 작업을 대기 큐에 저장한 뒤 우선순위가 높은 작업을 대기 큐에서 꺼내서 하드디스크에 그 작업을 시킵니다. 또, 하드디스크가 어떤 작업을 마치는 시점에 다른 작업이 들어오지 않더라도 그 작업을 마치자마자 또 다른 작업을 시작할 수 있습니다. 이 과정에서 걸리는 시간은 없다고 가정합니다. 예를 들어 - 0ms 시점에 3ms가 소요되는 0번 작업 요청 - 1ms 시점에 9ms가 소요되는 1번 작업 요청 - 3ms 시점에 5ms가 소요되는 2번 작업 요청 와 같은 요청이 들어왔습니다. 이를 그림으로 표현하면 다음과 같습니다. 이 요청을 우선순위 디스크 컨트롤러가 처리하는 과정은 다음 표와 같습니다. 시점 하드디스크 대기 큐 디스크 컨트롤러 0ms [] 0ms [[0번, 0ms, 3ms]] 0번 작업 요청을 대기 큐에 저장 0ms 0번 작업 시작 [] 대기 큐에서 우선순위가 높은 0번 작업을 꺼내서 작업을 시킴 1ms 0번 작업 중 [[1번, 1ms, 9ms]] 1번 작업 요청을 대기 큐에 저장 3ms 0번 작업 완료 [[1번, 1ms, 9ms]] 3ms [[1번, 1ms, 9ms], [2번, 3ms, 5ms]] 2번 작업 요청을 대기 큐에 저장 3ms 2번 작업 시작 [[1번, 1ms, 9ms]] 대기 큐에서 우선순위가 높은 2번 작업을 꺼내서 작업을 시킴 8ms 2번 작업 완료 [[1번, 1ms, 9ms]] 8ms 1번 작업 시작 [] 대기 큐에서 우선순위가 높은 1번 작업을 꺼내서 작업을 시킴 17ms 1번 작업 완료 [] 모든 요청 작업을 마쳤을 때 각 작업에 대한 반환 시간(turnaround time)은 작업 요청부터 종료까지 걸린 시간으로 정의합니다. 위의 우선순위 디스크 컨트롤러가 처리한 각 작업의 반환 시간은 다음 그림, 표와 같습니다. 작업 번호 요청 시각 작업 종료 시각 반환 시간 0번 0ms 3ms 3ms(= 3ms - 0ms) 1번 1ms 17ms 16ms(= 17ms - 1ms) 2번 3ms 8ms 5ms(= 8ms - 3ms) 우선순위 디스크 컨트롤러에서 모든 요청 작업의 반환 시간의 평균은 8ms(= (3ms + 16ms + 5ms) / 3)가 됩니다. 각 작업에 대해 [작업이 요청되는 시점, 작업의 소요시간]을 담은 2차원 정수 배열 jobs가 매개변수로 주어질 때, 우선순위 디스크 컨트롤러가 이 작업을 처리했을 때 모든 요청 작업의 반환 시간의 평균의 정수부분을 return 하는 solution 함수를 작성해 주세요. 제한 사항 1 ≤ jobs의 길이 ≤ 500 jobs[i]는 i번 작업에 대한 정보이고 [s, l] 형태입니다. s는 작업이 요청되는 시점이며 0 ≤ s ≤ 1,000입니다. l은 작업의 소요시간이며 1 ≤ l ≤ 1,000입니다. 입출력 예 jobs return [[0, 3], [1, 9], [3, 5]] 8 입출력 예 설명 입출력 예 #1 문제에 주어진 예와 같습니다. 문제가 잘 안풀린다면😢 힌트가 필요한가요? [코딩테스트 연습 힌트 모음집]으로 오세요! → 클릭 ※ 공지 - 2024년 11월 14일 문제 지문이 리뉴얼되었습니다. 기존에 제출한 코드가 통과하지 못할 수도 있습니다.",normal,Array
512,"매운 것을 좋아하는 Leo는 모든 음식의 스코빌 지수를 K 이상으로 만들고 싶습니다. 모든 음식의 스코빌 지수를 K 이상으로 만들기 위해 Leo는 스코빌 지수가 가장 낮은 두 개의 음식을 아래와 같이 특별한 방법으로 섞어 새로운 음식을 만듭니다. 섞은 음식의 스코빌 지수 = 가장 맵지 않은 음식의 스코빌 지수 + (두 번째로 맵지 않은 음식의 스코빌 지수 * 2) Leo는 모든 음식의 스코빌 지수가 K 이상이 될 때까지 반복하여 섞습니다. Leo가 가진 음식의 스코빌 지수를 담은 배열 scoville과 원하는 스코빌 지수 K가 주어질 때, 모든 음식의 스코빌 지수를 K 이상으로 만들기 위해 섞어야 하는 최소 횟수를 return 하도록 solution 함수를 작성해주세요. 제한 사항 scoville의 길이는 2 이상 1,000,000 이하입니다. K는 0 이상 1,000,000,000 이하입니다. scoville의 원소는 각각 0 이상 1,000,000 이하입니다. 모든 음식의 스코빌 지수를 K 이상으로 만들 수 없는 경우에는 -1을 return 합니다. 입출력 예 scoville K return [1, 2, 3, 9, 10, 12] 7 2 입출력 예 설명 스코빌 지수가 1인 음식과 2인 음식을 섞으면 음식의 스코빌 지수가 아래와 같이 됩니다. 새로운 음식의 스코빌 지수 = 1 + (2 * 2) = 5 가진 음식의 스코빌 지수 = [5, 3, 9, 10, 12] 스코빌 지수가 3인 음식과 5인 음식을 섞으면 음식의 스코빌 지수가 아래와 같이 됩니다. 새로운 음식의 스코빌 지수 = 3 + (5 * 2) = 13 가진 음식의 스코빌 지수 = [13, 9, 10, 12] 모든 음식의 스코빌 지수가 7 이상이 되었고 이때 섞은 횟수는 2회입니다. ※ 공지 - 2022년 12월 23일 테스트 케이스가 추가되었습니다. 기존에 제출한 코드가 통과하지 못할 수도 있습니다. ※ 공지 - 2023년 03월 23일 테스트 케이스가 추가되었습니다. 기존에 제출한 코드가 통과하지 못할 수도 있습니다.",normal,Array
513,"운영체제의 역할 중 하나는 컴퓨터 시스템의 자원을 효율적으로 관리하는 것입니다. 이 문제에서는 운영체제가 다음 규칙에 따라 프로세스를 관리할 경우 특정 프로세스가 몇 번째로 실행되는지 알아내면 됩니다. 1. 실행 대기 큐(Queue)에서 대기중인 프로세스 하나를 꺼냅니다. 2. 큐에 대기중인 프로세스 중 우선순위가 더 높은 프로세스가 있다면 방금 꺼낸 프로세스를 다시 큐에 넣습니다. 3. 만약 그런 프로세스가 없다면 방금 꺼낸 프로세스를 실행합니다. 3.1 한 번 실행한 프로세스는 다시 큐에 넣지 않고 그대로 종료됩니다. 예를 들어 프로세스 4개 [A, B, C, D]가 순서대로 실행 대기 큐에 들어있고, 우선순위가 [2, 1, 3, 2]라면 [C, D, A, B] 순으로 실행하게 됩니다. 현재 실행 대기 큐(Queue)에 있는 프로세스의 중요도가 순서대로 담긴 배열 priorities와, 몇 번째로 실행되는지 알고싶은 프로세스의 위치를 알려주는 location이 매개변수로 주어질 때, 해당 프로세스가 몇 번째로 실행되는지 return 하도록 solution 함수를 작성해주세요. 제한사항 priorities의 길이는 1 이상 100 이하입니다. priorities의 원소는 1 이상 9 이하의 정수입니다. priorities의 원소는 우선순위를 나타내며 숫자가 클 수록 우선순위가 높습니다. location은 0 이상 (대기 큐에 있는 프로세스 수 - 1) 이하의 값을 가집니다. priorities의 가장 앞에 있으면 0, 두 번째에 있으면 1 … 과 같이 표현합니다. 입출력 예 priorities location return [2, 1, 3, 2] 2 1 [1, 1, 9, 1, 1, 1] 0 5 입출력 예 설명 예제 #1 문제에 나온 예와 같습니다. 예제 #2 6개의 프로세스 [A, B, C, D, E, F]가 대기 큐에 있고 중요도가 [1, 1, 9, 1, 1, 1] 이므로 [C, D, E, F, A, B] 순으로 실행됩니다. 따라서 A는 5번째로 실행됩니다. ※ 공지 - 2023년 4월 21일 문제 지문이 리뉴얼되었습니다.",normal,Array
514,"프로그래머스 팀에서는 기능 개선 작업을 수행 중입니다. 각 기능은 진도가 100%일 때 서비스에 반영할 수 있습니다. 또, 각 기능의 개발속도는 모두 다르기 때문에 뒤에 있는 기능이 앞에 있는 기능보다 먼저 개발될 수 있고, 이때 뒤에 있는 기능은 앞에 있는 기능이 배포될 때 함께 배포됩니다. 먼저 배포되어야 하는 순서대로 작업의 진도가 적힌 정수 배열 progresses와 각 작업의 개발 속도가 적힌 정수 배열 speeds가 주어질 때 각 배포마다 몇 개의 기능이 배포되는지를 return 하도록 solution 함수를 완성하세요. 제한 사항 작업의 개수(progresses, speeds배열의 길이)는 100개 이하입니다. 작업 진도는 100 미만의 자연수입니다. 작업 속도는 100 이하의 자연수입니다. 배포는 하루에 한 번만 할 수 있으며, 하루의 끝에 이루어진다고 가정합니다. 예를 들어 진도율이 95%인 작업의 개발 속도가 하루에 4%라면 배포는 2일 뒤에 이루어집니다. 입출력 예 progresses speeds return [93, 30, 55] [1, 30, 5] [2, 1] [95, 90, 99, 99, 80, 99] [1, 1, 1, 1, 1, 1] [1, 3, 2] 입출력 예 설명 입출력 예 #1 첫 번째 기능은 93% 완료되어 있고 하루에 1%씩 작업이 가능하므로 7일간 작업 후 배포가 가능합니다. 두 번째 기능은 30%가 완료되어 있고 하루에 30%씩 작업이 가능하므로 3일간 작업 후 배포가 가능합니다. 하지만 이전 첫 번째 기능이 아직 완성된 상태가 아니기 때문에 첫 번째 기능이 배포되는 7일째 배포됩니다. 세 번째 기능은 55%가 완료되어 있고 하루에 5%씩 작업이 가능하므로 9일간 작업 후 배포가 가능합니다. 따라서 7일째에 2개의 기능, 9일째에 1개의 기능이 배포됩니다. 입출력 예 #2 모든 기능이 하루에 1%씩 작업이 가능하므로, 작업이 끝나기까지 남은 일수는 각각 5일, 10일, 1일, 1일, 20일, 1일입니다. 어떤 기능이 먼저 완성되었더라도 앞에 있는 모든 기능이 완성되지 않으면 배포가 불가능합니다. 따라서 5일째에 1개의 기능, 10일째에 3개의 기능, 20일째에 2개의 기능이 배포됩니다. ※ 공지 - 2020년 7월 14일 테스트케이스가 추가되었습니다.",normal,Array
515,"초 단위로 기록된 주식가격이 담긴 배열 prices가 매개변수로 주어질 때, 가격이 떨어지지 않은 기간은 몇 초인지를 return 하도록 solution 함수를 완성하세요. 제한사항 prices의 각 가격은 1 이상 10,000 이하인 자연수입니다. prices의 길이는 2 이상 100,000 이하입니다. 입출력 예 prices return [1, 2, 3, 2, 3] [4, 3, 1, 1, 0] 입출력 예 설명 1초 시점의 ₩1은 끝까지 가격이 떨어지지 않았습니다. 2초 시점의 ₩2은 끝까지 가격이 떨어지지 않았습니다. 3초 시점의 ₩3은 1초뒤에 가격이 떨어집니다. 따라서 1초간 가격이 떨어지지 않은 것으로 봅니다. 4초 시점의 ₩2은 1초간 가격이 떨어지지 않았습니다. 5초 시점의 ₩3은 0초간 가격이 떨어지지 않았습니다. ※ 공지 - 2019년 2월 28일 지문이 리뉴얼되었습니다.",normal,Array
516,"트럭 여러 대가 강을 가로지르는 일차선 다리를 정해진 순으로 건너려 합니다. 모든 트럭이 다리를 건너려면 최소 몇 초가 걸리는지 알아내야 합니다. 다리에는 트럭이 최대 bridge_length대 올라갈 수 있으며, 다리는 weight 이하까지의 무게를 견딜 수 있습니다. 단, 다리에 완전히 오르지 않은 트럭의 무게는 무시합니다. 예를 들어, 트럭 2대가 올라갈 수 있고 무게를 10kg까지 견디는 다리가 있습니다. 무게가 [7, 4, 5, 6]kg인 트럭이 순서대로 최단 시간 안에 다리를 건너려면 다음과 같이 건너야 합니다. 경과 시간 다리를 지난 트럭 다리를 건너는 트럭 대기 트럭 0 [] [] [7,4,5,6] 1~2 [] [7] [4,5,6] 3 [7] [4] [5,6] 4 [7] [4,5] [6] 5 [7,4] [5] [6] 6~7 [7,4,5] [6] [] 8 [7,4,5,6] [] [] 따라서, 모든 트럭이 다리를 지나려면 최소 8초가 걸립니다. solution 함수의 매개변수로 다리에 올라갈 수 있는 트럭 수 bridge_length, 다리가 견딜 수 있는 무게 weight, 트럭 별 무게 truck_weights가 주어집니다. 이때 모든 트럭이 다리를 건너려면 최소 몇 초가 걸리는지 return 하도록 solution 함수를 완성하세요. 제한 조건 bridge_length는 1 이상 10,000 이하입니다. weight는 1 이상 10,000 이하입니다. truck_weights의 길이는 1 이상 10,000 이하입니다. 모든 트럭의 무게는 1 이상 weight 이하입니다. 입출력 예 bridge_length weight truck_weights return 2 10 [7,4,5,6] 8 100 100 [10] 101 100 100 [10,10,10,10,10,10,10,10,10,10] 110 출처 ※ 공지 - 2020년 4월 06일 테스트케이스가 추가되었습니다.",normal,Math
517,"스트리밍 사이트에서 장르 별로 가장 많이 재생된 노래를 두 개씩 모아 베스트 앨범을 출시하려 합니다. 노래는 고유 번호로 구분하며, 노래를 수록하는 기준은 다음과 같습니다. 속한 노래가 많이 재생된 장르를 먼저 수록합니다. 장르 내에서 많이 재생된 노래를 먼저 수록합니다. 장르 내에서 재생 횟수가 같은 노래 중에서는 고유 번호가 낮은 노래를 먼저 수록합니다. 노래의 장르를 나타내는 문자열 배열 genres와 노래별 재생 횟수를 나타내는 정수 배열 plays가 주어질 때, 베스트 앨범에 들어갈 노래의 고유 번호를 순서대로 return 하도록 solution 함수를 완성하세요. 제한사항 genres[i]는 고유번호가 i인 노래의 장르입니다. plays[i]는 고유번호가 i인 노래가 재생된 횟수입니다. genres와 plays의 길이는 같으며, 이는 1 이상 10,000 이하입니다. 장르 종류는 100개 미만입니다. 장르에 속한 곡이 하나라면, 하나의 곡만 선택합니다. 모든 장르는 재생된 횟수가 다릅니다. 입출력 예 genres plays return [""classic"", ""pop"", ""classic"", ""classic"", ""pop""] [500, 600, 150, 800, 2500] [4, 1, 3, 0] 입출력 예 설명 classic 장르는 1,450회 재생되었으며, classic 노래는 다음과 같습니다. 고유 번호 3: 800회 재생 고유 번호 0: 500회 재생 고유 번호 2: 150회 재생 pop 장르는 3,100회 재생되었으며, pop 노래는 다음과 같습니다. 고유 번호 4: 2,500회 재생 고유 번호 1: 600회 재생 따라서 pop 장르의 [4, 1]번 노래를 먼저, classic 장르의 [3, 0]번 노래를 그다음에 수록합니다. 장르 별로 가장 많이 재생된 노래를 최대 두 개까지 모아 베스트 앨범을 출시하므로 2번 노래는 수록되지 않습니다. ※ 공지 - 2019년 2월 28일 테스트케이스가 추가되었습니다.",normal,Array
518,"코니는 매일 다른 옷을 조합하여 입는것을 좋아합니다. 예를 들어 코니가 가진 옷이 아래와 같고, 오늘 코니가 동그란 안경, 긴 코트, 파란색 티셔츠를 입었다면 다음날은 청바지를 추가로 입거나 동그란 안경 대신 검정 선글라스를 착용하거나 해야합니다. 종류 이름 얼굴 동그란 안경, 검정 선글라스 상의 파란색 티셔츠 하의 청바지 겉옷 긴 코트 코니는 각 종류별로 최대 1가지 의상만 착용할 수 있습니다. 예를 들어 위 예시의 경우 동그란 안경과 검정 선글라스를 동시에 착용할 수는 없습니다. 착용한 의상의 일부가 겹치더라도, 다른 의상이 겹치지 않거나, 혹은 의상을 추가로 더 착용한 경우에는 서로 다른 방법으로 옷을 착용한 것으로 계산합니다. 코니는 하루에 최소 한 개의 의상은 입습니다. 코니가 가진 의상들이 담긴 2차원 배열 clothes가 주어질 때 서로 다른 옷의 조합의 수를 return 하도록 solution 함수를 작성해주세요. 제한사항 clothes의 각 행은 [의상의 이름, 의상의 종류]로 이루어져 있습니다. 코니가 가진 의상의 수는 1개 이상 30개 이하입니다. 같은 이름을 가진 의상은 존재하지 않습니다. clothes의 모든 원소는 문자열로 이루어져 있습니다. 모든 문자열의 길이는 1 이상 20 이하인 자연수이고 알파벳 소문자 또는 '_' 로만 이루어져 있습니다. 입출력 예 clothes return [[""yellow_hat"", ""headgear""], [""blue_sunglasses"", ""eyewear""], [""green_turban"", ""headgear""]] 5 [[""crow_mask"", ""face""], [""blue_sunglasses"", ""face""], [""smoky_makeup"", ""face""]] 3 입출력 예 설명 예제 #1 headgear에 해당하는 의상이 yellow_hat, green_turban이고 eyewear에 해당하는 의상이 blue_sunglasses이므로 아래와 같이 5개의 조합이 가능합니다. 1. yellow_hat 2. blue_sunglasses 3. green_turban 4. yellow_hat + blue_sunglasses 5. green_turban + blue_sunglasses 예제 #2 face에 해당하는 의상이 crow_mask, blue_sunglasses, smoky_makeup이므로 아래와 같이 3개의 조합이 가능합니다. 1. crow_mask 2. blue_sunglasses 3. smoky_makeup ※ 공지 - 2023년 4월 21일 문제 지문이 리뉴얼되었습니다.",normal,Array
519,"전화번호부에 적힌 전화번호 중, 한 번호가 다른 번호의 접두어인 경우가 있는지 확인하려 합니다. 전화번호가 다음과 같을 경우, 구조대 전화번호는 영석이의 전화번호의 접두사입니다. 구조대 : 119 박준영 : 97 674 223 지영석 : 11 9552 4421 전화번호부에 적힌 전화번호를 담은 배열 phone_book 이 solution 함수의 매개변수로 주어질 때, 어떤 번호가 다른 번호의 접두어인 경우가 있으면 false를 그렇지 않으면 true를 return 하도록 solution 함수를 작성해주세요. 제한 사항 phone_book의 길이는 1 이상 1,000,000 이하입니다. 각 전화번호의 길이는 1 이상 20 이하입니다. 같은 전화번호가 중복해서 들어있지 않습니다. 입출력 예제 phone_book return [""119"", ""97674223"", ""1195524421""] false [""123"",""456"",""789""] true [""12"",""123"",""1235"",""567"",""88""] false 입출력 예 설명 입출력 예 #1 앞에서 설명한 예와 같습니다. 입출력 예 #2 한 번호가 다른 번호의 접두사인 경우가 없으므로, 답은 true입니다. 입출력 예 #3 첫 번째 전화번호, “12”가 두 번째 전화번호 “123”의 접두사입니다. 따라서 답은 false입니다. 알림 2021년 3월 4일, 테스트 케이스가 변경되었습니다. 이로 인해 이전에 통과하던 코드가 더 이상 통과하지 않을 수 있습니다.",normal,Array
520,"수많은 마라톤 선수들이 마라톤에 참여하였습니다. 단 한 명의 선수를 제외하고는 모든 선수가 마라톤을 완주하였습니다. 마라톤에 참여한 선수들의 이름이 담긴 배열 participant와 완주한 선수들의 이름이 담긴 배열 completion이 주어질 때, 완주하지 못한 선수의 이름을 return 하도록 solution 함수를 작성해주세요. 제한사항 마라톤 경기에 참여한 선수의 수는 1명 이상 100,000명 이하입니다. completion의 길이는 participant의 길이보다 1 작습니다. 참가자의 이름은 1개 이상 20개 이하의 알파벳 소문자로 이루어져 있습니다. 참가자 중에는 동명이인이 있을 수 있습니다. 입출력 예 participant completion return [""leo"", ""kiki"", ""eden""] [""eden"", ""kiki""] ""leo"" [""marina"", ""josipa"", ""nikola"", ""vinko"", ""filipa""] [""josipa"", ""filipa"", ""marina"", ""nikola""] ""vinko"" [""mislav"", ""stanko"", ""mislav"", ""ana""] [""stanko"", ""ana"", ""mislav""] ""mislav"" 입출력 예 설명 예제 #1 ""leo""는 참여자 명단에는 있지만, 완주자 명단에는 없기 때문에 완주하지 못했습니다. 예제 #2 ""vinko""는 참여자 명단에는 있지만, 완주자 명단에는 없기 때문에 완주하지 못했습니다. 예제 #3 ""mislav""는 참여자 명단에는 두 명이 있지만, 완주자 명단에는 한 명밖에 없기 때문에 한명은 완주하지 못했습니다. ※ 공지 - 2023년 01월 25일 테스트케이스가 추가되었습니다.",easy,Array
521,"N진수 게임 튜브가 활동하는 코딩 동아리에서는 전통적으로 해오는 게임이 있다. 이 게임은 여러 사람이 둥글게 앉아서 숫자를 하나씩 차례대로 말하는 게임인데, 규칙은 다음과 같다. 숫자를 0부터 시작해서 차례대로 말한다. 첫 번째 사람은 0, 두 번째 사람은 1, … 열 번째 사람은 9를 말한다. 10 이상의 숫자부터는 한 자리씩 끊어서 말한다. 즉 열한 번째 사람은 10의 첫 자리인 1, 열두 번째 사람은 둘째 자리인 0을 말한다. 이렇게 게임을 진행할 경우, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 0, 1, 1, 1, 2, 1, 3, 1, 4, … 순으로 숫자를 말하면 된다. 한편 코딩 동아리 일원들은 컴퓨터를 다루는 사람답게 이진수로 이 게임을 진행하기도 하는데, 이 경우에는 0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, … 순으로 숫자를 말하면 된다. 이진수로 진행하는 게임에 익숙해져 질려가던 사람들은 좀 더 난이도를 높이기 위해 이진법에서 십육진법까지 모든 진법으로 게임을 진행해보기로 했다. 숫자 게임이 익숙하지 않은 튜브는 게임에 져서 벌칙을 받는 굴욕을 피하기 위해, 자신이 말해야 하는 숫자를 스마트폰에 미리 출력해주는 프로그램을 만들려고 한다. 튜브의 프로그램을 구현하라. 입력 형식 진법 n, 미리 구할 숫자의 갯수 t, 게임에 참가하는 인원 m, 튜브의 순서 p 가 주어진다. 2 ≦ n ≦ 16 0 ＜ t ≦ 1000 2 ≦ m ≦ 100 1 ≦ p ≦ m 출력 형식 튜브가 말해야 하는 숫자 t개를 공백 없이 차례대로 나타낸 문자열. 단, 10~15는 각각 대문자 A~F로 출력한다. 입출력 예제 n t m p result 2 4 2 1 ""0111"" 16 16 2 1 ""02468ACE11111111"" 16 16 2 2 ""13579BDF01234567"" 해설 보러가기",normal,String
522,"파일명 정렬 세 차례의 코딩 테스트와 두 차례의 면접이라는 기나긴 블라인드 공채를 무사히 통과해 카카오에 입사한 무지는 파일 저장소 서버 관리를 맡게 되었다. 저장소 서버에는 프로그램의 과거 버전을 모두 담고 있어, 이름 순으로 정렬된 파일 목록은 보기가 불편했다. 파일을 이름 순으로 정렬하면 나중에 만들어진 ver-10.zip이 ver-9.zip보다 먼저 표시되기 때문이다. 버전 번호 외에도 숫자가 포함된 파일 목록은 여러 면에서 관리하기 불편했다. 예컨대 파일 목록이 [""img12.png"", ""img10.png"", ""img2.png"", ""img1.png""]일 경우, 일반적인 정렬은 [""img1.png"", ""img10.png"", ""img12.png"", ""img2.png""] 순이 되지만, 숫자 순으로 정렬된 [""img1.png"", ""img2.png"", ""img10.png"", img12.png""] 순이 훨씬 자연스럽다. 무지는 단순한 문자 코드 순이 아닌, 파일명에 포함된 숫자를 반영한 정렬 기능을 저장소 관리 프로그램에 구현하기로 했다. 소스 파일 저장소에 저장된 파일명은 100 글자 이내로, 영문 대소문자, 숫자, 공백("" ""), 마침표("".""), 빼기 부호(""-"")만으로 이루어져 있다. 파일명은 영문자로 시작하며, 숫자를 하나 이상 포함하고 있다. 파일명은 크게 HEAD, NUMBER, TAIL의 세 부분으로 구성된다. HEAD는 숫자가 아닌 문자로 이루어져 있으며, 최소한 한 글자 이상이다. NUMBER는 한 글자에서 최대 다섯 글자 사이의 연속된 숫자로 이루어져 있으며, 앞쪽에 0이 올 수 있다. 0부터 99999 사이의 숫자로, 00000이나 0101 등도 가능하다. TAIL은 그 나머지 부분으로, 여기에는 숫자가 다시 나타날 수도 있으며, 아무 글자도 없을 수 있다. 파일명 HEAD NUMBER TAIL foo9.txt foo 9 .txt foo010bar020.zip foo 010 bar020.zip F-15 F- 15 (빈 문자열) 파일명을 세 부분으로 나눈 후, 다음 기준에 따라 파일명을 정렬한다. 파일명은 우선 HEAD 부분을 기준으로 사전 순으로 정렬한다. 이때, 문자열 비교 시 대소문자 구분을 하지 않는다. MUZI와 muzi, MuZi는 정렬 시에 같은 순서로 취급된다. 파일명의 HEAD 부분이 대소문자 차이 외에는 같을 경우, NUMBER의 숫자 순으로 정렬한다. 9 < 10 < 0011 < 012 < 13 < 014 순으로 정렬된다. 숫자 앞의 0은 무시되며, 012와 12는 정렬 시에 같은 같은 값으로 처리된다. 두 파일의 HEAD 부분과, NUMBER의 숫자도 같을 경우, 원래 입력에 주어진 순서를 유지한다. MUZI01.zip과 muzi1.png가 입력으로 들어오면, 정렬 후에도 입력 시 주어진 두 파일의 순서가 바뀌어서는 안 된다. 무지를 도와 파일명 정렬 프로그램을 구현하라. 입력 형식 입력으로 배열 files가 주어진다. files는 1000 개 이하의 파일명을 포함하는 문자열 배열이다. 각 파일명은 100 글자 이하 길이로, 영문 대소문자, 숫자, 공백("" ""), 마침표("".""), 빼기 부호(""-"")만으로 이루어져 있다. 파일명은 영문자로 시작하며, 숫자를 하나 이상 포함하고 있다. 중복된 파일명은 없으나, 대소문자나 숫자 앞부분의 0 차이가 있는 경우는 함께 주어질 수 있다. (muzi1.txt, MUZI1.txt, muzi001.txt, muzi1.TXT는 함께 입력으로 주어질 수 있다.) 출력 형식 위 기준에 따라 정렬된 배열을 출력한다. 입출력 예제 입력: [""img12.png"", ""img10.png"", ""img02.png"", ""img1.png"", ""IMG01.GIF"", ""img2.JPG""] 출력: [""img1.png"", ""IMG01.GIF"", ""img02.png"", ""img2.JPG"", ""img10.png"", ""img12.png""] 입력: [""F-5 Freedom Fighter"", ""B-50 Superfortress"", ""A-10 Thunderbolt II"", ""F-14 Tomcat""] 출력: [""A-10 Thunderbolt II"", ""B-50 Superfortress"", ""F-5 Freedom Fighter"", ""F-14 Tomcat""] 해설 보러가기",normal,Array
523,"자동완성 포털 다음에서 검색어 자동완성 기능을 넣고 싶은 라이언은 한 번 입력된 문자열을 학습해서 다음 입력 때 활용하고 싶어 졌다. 예를 들어, go 가 한 번 입력되었다면, 다음 사용자는 g 만 입력해도 go를 추천해주므로 o를 입력할 필요가 없어진다! 단, 학습에 사용된 단어들 중 앞부분이 같은 경우에는 어쩔 수 없이 다른 문자가 나올 때까지 입력을 해야 한다. 효과가 얼마나 좋을지 알고 싶은 라이언은 학습된 단어들을 찾을 때 몇 글자를 입력해야 하는지 궁금해졌다. 예를 들어, 학습된 단어들이 아래와 같을 때 go gone guild go를 찾을 때 go를 모두 입력해야 한다. gone을 찾을 때 gon 까지 입력해야 한다. (gon이 입력되기 전까지는 go 인지 gone인지 확신할 수 없다.) guild를 찾을 때는 gu 까지만 입력하면 guild가 완성된다. 이 경우 총 입력해야 할 문자의 수는 7이다. 라이언을 도와 위와 같이 문자열이 입력으로 주어지면 학습을 시킨 후, 학습된 단어들을 순서대로 찾을 때 몇 개의 문자를 입력하면 되는지 계산하는 프로그램을 만들어보자. 입력 형식 학습과 검색에 사용될 중복 없는 단어 N개가 주어진다. 모든 단어는 알파벳 소문자로 구성되며 단어의 수 N과 단어들의 길이의 총합 L의 범위는 다음과 같다. 2 <= N <= 100,000 2 <= L <= 1,000,000 출력 형식 단어를 찾을 때 입력해야 할 총 문자수를 리턴한다. 입출력 예제 words result [""go"",""gone"",""guild""] 7 [""abc"",""def"",""ghi"",""jklm""] 4 [""word"",""war"",""warrior"",""world""] 15 입출력 설명 첫 번째 예제는 본문 설명과 같다. 두 번째 예제에서는 모든 단어들이 공통된 부분이 없으므로, 가장 앞글자만 입력하면 된다. 세 번째 예제는 총 15 자를 입력해야 하고 설명은 아래와 같다. word는 word모두 입력해야 한다. war는 war 까지 모두 입력해야 한다. warrior는 warr 까지만 입력하면 된다. world는 worl까지 입력해야 한다. (word와 구분되어야 함을 명심하자) 해설 보러가기",hard,String
524,"압축 신입사원 어피치는 카카오톡으로 전송되는 메시지를 압축하여 전송 효율을 높이는 업무를 맡게 되었다. 메시지를 압축하더라도 전달되는 정보가 바뀌어서는 안 되므로, 압축 전의 정보를 완벽하게 복원 가능한 무손실 압축 알고리즘을 구현하기로 했다. 어피치는 여러 압축 알고리즘 중에서 성능이 좋고 구현이 간단한 LZW(Lempel–Ziv–Welch) 압축을 구현하기로 했다. LZW 압축은 1983년 발표된 알고리즘으로, 이미지 파일 포맷인 GIF 등 다양한 응용에서 사용되었다. LZW 압축은 다음 과정을 거친다. 길이가 1인 모든 단어를 포함하도록 사전을 초기화한다. 사전에서 현재 입력과 일치하는 가장 긴 문자열 w를 찾는다. w에 해당하는 사전의 색인 번호를 출력하고, 입력에서 w를 제거한다. 입력에서 처리되지 않은 다음 글자가 남아있다면(c), w+c에 해당하는 단어를 사전에 등록한다. 단계 2로 돌아간다. 압축 알고리즘이 영문 대문자만 처리한다고 할 때, 사전은 다음과 같이 초기화된다. 사전의 색인 번호는 정수값으로 주어지며, 1부터 시작한다고 하자. 색인 번호 1 2 3 ... 24 25 26 단어 A B C ... X Y Z 예를 들어 입력으로 KAKAO가 들어온다고 하자. 현재 사전에는 KAKAO의 첫 글자 K는 등록되어 있으나, 두 번째 글자까지인 KA는 없으므로, 첫 글자 K에 해당하는 색인 번호 11을 출력하고, 다음 글자인 A를 포함한 KA를 사전에 27 번째로 등록한다. 두 번째 글자 A는 사전에 있으나, 세 번째 글자까지인 AK는 사전에 없으므로, A의 색인 번호 1을 출력하고, AK를 사전에 28 번째로 등록한다. 세 번째 글자에서 시작하는 KA가 사전에 있으므로, KA에 해당하는 색인 번호 27을 출력하고, 다음 글자 O를 포함한 KAO를 29 번째로 등록한다. 마지막으로 처리되지 않은 글자 O에 해당하는 색인 번호 15를 출력한다. 현재 입력(w) 다음 글자(c) 출력 사전 추가(w+c) K A 11 27: KA A K 1 28: AK KA O 27 29: KAO O 15 이 과정을 거쳐 다섯 글자의 문장 KAKAO가 4개의 색인 번호 [11, 1, 27, 15]로 압축된다. 입력으로 TOBEORNOTTOBEORTOBEORNOT가 들어오면 다음과 같이 압축이 진행된다. 현재 입력(w) 다음 글자(c) 출력 사전 추가(w+c) T O 20 27: TO O B 15 28: OB B E 2 29: BE E O 5 30: EO O R 15 31: OR R N 18 32: RN N O 14 33: NO O T 15 34: OT T T 20 35: TT TO B 27 36: TOB BE O 29 37: BEO OR T 31 38: ORT TOB E 36 39: TOBE EO R 30 40: EOR RN O 32 41: RNO OT 34 입력 형식 입력으로 영문 대문자로만 이뤄진 문자열 msg가 주어진다. msg의 길이는 1 글자 이상, 1000 글자 이하이다. 출력 형식 주어진 문자열을 압축한 후의 사전 색인 번호를 배열로 출력하라. 입출력 예제 msg answer KAKAO [11, 1, 27, 15] TOBEORNOTTOBEORTOBEORNOT [20, 15, 2, 5, 15, 18, 14, 15, 20, 27, 29, 31, 36, 30, 32, 34] ABABABABABABABAB [1, 2, 27, 29, 28, 31, 30] 해설 보러가기",normal,Array
525,"방금그곡 라디오를 자주 듣는 네오는 라디오에서 방금 나왔던 음악이 무슨 음악인지 궁금해질 때가 많다. 그럴 때 네오는 다음 포털의 '방금그곡' 서비스를 이용하곤 한다. 방금그곡에서는 TV, 라디오 등에서 나온 음악에 관해 제목 등의 정보를 제공하는 서비스이다. 네오는 자신이 기억한 멜로디를 가지고 방금그곡을 이용해 음악을 찾는다. 그런데 라디오 방송에서는 한 음악을 반복해서 재생할 때도 있어서 네오가 기억하고 있는 멜로디는 음악 끝부분과 처음 부분이 이어서 재생된 멜로디일 수도 있다. 반대로, 한 음악을 중간에 끊을 경우 원본 음악에는 네오가 기억한 멜로디가 들어있다 해도 그 곡이 네오가 들은 곡이 아닐 수도 있다. 그렇기 때문에 네오는 기억한 멜로디를 재생 시간과 제공된 악보를 직접 보면서 비교하려고 한다. 다음과 같은 가정을 할 때 네오가 찾으려는 음악의 제목을 구하여라. 방금그곡 서비스에서는 음악 제목, 재생이 시작되고 끝난 시각, 악보를 제공한다. 네오가 기억한 멜로디와 악보에 사용되는 음은 C, C#, D, D#, E, F, F#, G, G#, A, A#, B 12개이다. 각 음은 1분에 1개씩 재생된다. 음악은 반드시 처음부터 재생되며 음악 길이보다 재생된 시간이 길 때는 음악이 끊김 없이 처음부터 반복해서 재생된다. 음악 길이보다 재생된 시간이 짧을 때는 처음부터 재생 시간만큼만 재생된다. 음악이 00:00를 넘겨서까지 재생되는 일은 없다. 조건이 일치하는 음악이 여러 개일 때에는 라디오에서 재생된 시간이 제일 긴 음악 제목을 반환한다. 재생된 시간도 같을 경우 먼저 입력된 음악 제목을 반환한다. 조건이 일치하는 음악이 없을 때에는 “(None)”을 반환한다. 입력 형식 입력으로 네오가 기억한 멜로디를 담은 문자열 m과 방송된 곡의 정보를 담고 있는 배열 musicinfos가 주어진다. m은 음 1개 이상 1439개 이하로 구성되어 있다. musicinfos는 100개 이하의 곡 정보를 담고 있는 배열로, 각각의 곡 정보는 음악이 시작한 시각, 끝난 시각, 음악 제목, 악보 정보가 ','로 구분된 문자열이다. 음악의 시작 시각과 끝난 시각은 24시간 HH:MM 형식이다. 음악 제목은 ',' 이외의 출력 가능한 문자로 표현된 길이 1 이상 64 이하의 문자열이다. 악보 정보는 음 1개 이상 1439개 이하로 구성되어 있다. 출력 형식 조건과 일치하는 음악 제목을 출력한다. 입출력 예시 m musicinfos answer ""ABCDEFG"" [""12:00,12:14,HELLO,CDEFGAB"", ""13:00,13:05,WORLD,ABCDEF""] ""HELLO"" ""CC#BCC#BCC#BCC#B"" [""03:00,03:30,FOO,CC#B"", ""04:00,04:08,BAR,CC#BCC#BCC#B""] ""FOO"" ""ABC"" [""12:00,12:14,HELLO,C#DEFGAB"", ""13:00,13:05,WORLD,ABCDEF""] ""WORLD"" 설명 첫 번째 예시에서 HELLO는 길이가 7분이지만 12:00부터 12:14까지 재생되었으므로 실제로 CDEFGABCDEFGAB로 재생되었고, 이 중에 기억한 멜로디인 ABCDEFG가 들어있다. 세 번째 예시에서 HELLO는 C#DEFGABC#DEFGAB로, WORLD는 ABCDE로 재생되었다. HELLO 안에 있는 ABC#은 기억한 멜로디인 ABC와 일치하지 않고, WORLD 안에 있는 ABC가 기억한 멜로디와 일치한다. 해설 보러가기 ※ 공지 - 2024년 2월 21일 테스트 케이스가 추가되었습니다. 기존에 제출한 코드가 통과하지 못할 수도 있습니다.",normal,Array
526,"다트 게임 카카오톡에 뜬 네 번째 별! 심심할 땐? 카카오톡 게임별~ 카카오톡 게임별의 하반기 신규 서비스로 다트 게임을 출시하기로 했다. 다트 게임은 다트판에 다트를 세 차례 던져 그 점수의 합계로 실력을 겨루는 게임으로, 모두가 간단히 즐길 수 있다. 갓 입사한 무지는 코딩 실력을 인정받아 게임의 핵심 부분인 점수 계산 로직을 맡게 되었다. 다트 게임의 점수 계산 로직은 아래와 같다. 다트 게임은 총 3번의 기회로 구성된다. 각 기회마다 얻을 수 있는 점수는 0점에서 10점까지이다. 점수와 함께 Single(S), Double(D), Triple(T) 영역이 존재하고 각 영역 당첨 시 점수에서 1제곱, 2제곱, 3제곱 (점수1 , 점수2 , 점수3 )으로 계산된다. 옵션으로 스타상(*) , 아차상(#)이 존재하며 스타상(*) 당첨 시 해당 점수와 바로 전에 얻은 점수를 각 2배로 만든다. 아차상(#) 당첨 시 해당 점수는 마이너스된다. 스타상(*)은 첫 번째 기회에서도 나올 수 있다. 이 경우 첫 번째 스타상(*)의 점수만 2배가 된다. (예제 4번 참고) 스타상(*)의 효과는 다른 스타상(*)의 효과와 중첩될 수 있다. 이 경우 중첩된 스타상(*) 점수는 4배가 된다. (예제 4번 참고) 스타상(*)의 효과는 아차상(#)의 효과와 중첩될 수 있다. 이 경우 중첩된 아차상(#)의 점수는 -2배가 된다. (예제 5번 참고) Single(S), Double(D), Triple(T)은 점수마다 하나씩 존재한다. 스타상(*), 아차상(#)은 점수마다 둘 중 하나만 존재할 수 있으며, 존재하지 않을 수도 있다. 0~10의 정수와 문자 S, D, T, *, #로 구성된 문자열이 입력될 시 총점수를 반환하는 함수를 작성하라. 입력 형식 ""점수|보너스|[옵션]""으로 이루어진 문자열 3세트. 예) 1S2D*3T 점수는 0에서 10 사이의 정수이다. 보너스는 S, D, T 중 하나이다. 옵선은 *이나 # 중 하나이며, 없을 수도 있다. 출력 형식 3번의 기회에서 얻은 점수 합계에 해당하는 정수값을 출력한다. 예) 37 입출력 예제 예제 dartResult answer 설명 1 1S2D*3T 37 11 * 2 + 22 * 2 + 33 2 1D2S#10S 9 12 + 21 * (-1) + 101 3 1D2S0T 3 12 + 21 + 03 4 1S*2T*3S 23 11 * 2 * 2 + 23 * 2 + 31 5 1D#2S*3S 5 12 * (-1) * 2 + 21 * 2 + 31 6 1T2D3D# -4 13 + 22 + 32 * (-1) 7 1D2S3T* 59 12 + 21 * 2 + 33 * 2 해설 보러가기",easy,String
527,"비밀지도 네오는 평소 프로도가 비상금을 숨겨놓는 장소를 알려줄 비밀지도를 손에 넣었다. 그런데 이 비밀지도는 숫자로 암호화되어 있어 위치를 확인하기 위해서는 암호를 해독해야 한다. 다행히 지도 암호를 해독할 방법을 적어놓은 메모도 함께 발견했다. 지도는 한 변의 길이가 n인 정사각형 배열 형태로, 각 칸은 ""공백""("" "") 또는 ""벽""(""#"") 두 종류로 이루어져 있다. 전체 지도는 두 장의 지도를 겹쳐서 얻을 수 있다. 각각 ""지도 1""과 ""지도 2""라고 하자. 지도 1 또는 지도 2 중 어느 하나라도 벽인 부분은 전체 지도에서도 벽이다. 지도 1과 지도 2에서 모두 공백인 부분은 전체 지도에서도 공백이다. ""지도 1""과 ""지도 2""는 각각 정수 배열로 암호화되어 있다. 암호화된 배열은 지도의 각 가로줄에서 벽 부분을 1, 공백 부분을 0으로 부호화했을 때 얻어지는 이진수에 해당하는 값의 배열이다. 네오가 프로도의 비상금을 손에 넣을 수 있도록, 비밀지도의 암호를 해독하는 작업을 도와줄 프로그램을 작성하라. 입력 형식 입력으로 지도의 한 변 크기 n 과 2개의 정수 배열 arr1, arr2가 들어온다. 1 ≦ n ≦ 16 arr1, arr2는 길이 n인 정수 배열로 주어진다. 정수 배열의 각 원소 x를 이진수로 변환했을 때의 길이는 n 이하이다. 즉, 0 ≦ x ≦ 2n - 1을 만족한다. 출력 형식 원래의 비밀지도를 해독하여 '#', 공백으로 구성된 문자열 배열로 출력하라. 입출력 예제 매개변수 값 n 5 arr1 [9, 20, 28, 18, 11] arr2 [30, 1, 21, 17, 28] 출력 [""#####"",""# # #"", ""### #"", ""# ##"", ""#####""] 매개변수 값 n 6 arr1 [46, 33, 33 ,22, 31, 50] arr2 [27 ,56, 19, 14, 14, 10] 출력 [""######"", ""### #"", ""## ##"", "" #### "", "" #####"", ""### # ""] 해설 보러가기",easy,Array
528,"캐시 지도개발팀에서 근무하는 제이지는 지도에서 도시 이름을 검색하면 해당 도시와 관련된 맛집 게시물들을 데이터베이스에서 읽어 보여주는 서비스를 개발하고 있다. 이 프로그램의 테스팅 업무를 담당하고 있는 어피치는 서비스를 오픈하기 전 각 로직에 대한 성능 측정을 수행하였는데, 제이지가 작성한 부분 중 데이터베이스에서 게시물을 가져오는 부분의 실행시간이 너무 오래 걸린다는 것을 알게 되었다. 어피치는 제이지에게 해당 로직을 개선하라고 닦달하기 시작하였고, 제이지는 DB 캐시를 적용하여 성능 개선을 시도하고 있지만 캐시 크기를 얼마로 해야 효율적인지 몰라 난감한 상황이다. 어피치에게 시달리는 제이지를 도와, DB 캐시를 적용할 때 캐시 크기에 따른 실행시간 측정 프로그램을 작성하시오. 입력 형식 캐시 크기(cacheSize)와 도시이름 배열(cities)을 입력받는다. cacheSize는 정수이며, 범위는 0 ≦ cacheSize ≦ 30 이다. cities는 도시 이름으로 이뤄진 문자열 배열로, 최대 도시 수는 100,000개이다. 각 도시 이름은 공백, 숫자, 특수문자 등이 없는 영문자로 구성되며, 대소문자 구분을 하지 않는다. 도시 이름은 최대 20자로 이루어져 있다. 출력 형식 입력된 도시이름 배열을 순서대로 처리할 때, ""총 실행시간""을 출력한다. 조건 캐시 교체 알고리즘은 LRU(Least Recently Used)를 사용한다. cache hit일 경우 실행시간은 1이다. cache miss일 경우 실행시간은 5이다. 입출력 예제 캐시크기(cacheSize) 도시이름(cities) 실행시간 3 [""Jeju"", ""Pangyo"", ""Seoul"", ""NewYork"", ""LA"", ""Jeju"", ""Pangyo"", ""Seoul"", ""NewYork"", ""LA""] 50 3 [""Jeju"", ""Pangyo"", ""Seoul"", ""Jeju"", ""Pangyo"", ""Seoul"", ""Jeju"", ""Pangyo"", ""Seoul""] 21 2 [""Jeju"", ""Pangyo"", ""Seoul"", ""NewYork"", ""LA"", ""SanFrancisco"", ""Seoul"", ""Rome"", ""Paris"", ""Jeju"", ""NewYork"", ""Rome""] 60 5 [""Jeju"", ""Pangyo"", ""Seoul"", ""NewYork"", ""LA"", ""SanFrancisco"", ""Seoul"", ""Rome"", ""Paris"", ""Jeju"", ""NewYork"", ""Rome""] 52 2 [""Jeju"", ""Pangyo"", ""NewYork"", ""newyork""] 16 0 [""Jeju"", ""Pangyo"", ""Seoul"", ""NewYork"", ""LA""] 25 해설 보러가기",normal,Array
529,"프렌즈4블록 블라인드 공채를 통과한 신입 사원 라이언은 신규 게임 개발 업무를 맡게 되었다. 이번에 출시할 게임 제목은 ""프렌즈4블록"". 같은 모양의 카카오프렌즈 블록이 2×2 형태로 4개가 붙어있을 경우 사라지면서 점수를 얻는 게임이다. 만약 판이 위와 같이 주어질 경우, 라이언이 2×2로 배치된 7개 블록과 콘이 2×2로 배치된 4개 블록이 지워진다. 같은 블록은 여러 2×2에 포함될 수 있으며, 지워지는 조건에 만족하는 2×2 모양이 여러 개 있다면 한꺼번에 지워진다. 블록이 지워진 후에 위에 있는 블록이 아래로 떨어져 빈 공간을 채우게 된다. 만약 빈 공간을 채운 후에 다시 2×2 형태로 같은 모양의 블록이 모이면 다시 지워지고 떨어지고를 반복하게 된다. 위 초기 배치를 문자로 표시하면 아래와 같다. TTTANT RRFACC RRRFCC TRRRAA TTMMMF TMMTTJ 각 문자는 라이언(R), 무지(M), 어피치(A), 프로도(F), 네오(N), 튜브(T), 제이지(J), 콘(C)을 의미한다 입력으로 블록의 첫 배치가 주어졌을 때, 지워지는 블록은 모두 몇 개인지 판단하는 프로그램을 제작하라. 입력 형식 입력으로 판의 높이 m, 폭 n과 판의 배치 정보 board가 들어온다. 2 ≦ n, m ≦ 30 board는 길이 n인 문자열 m개의 배열로 주어진다. 블록을 나타내는 문자는 대문자 A에서 Z가 사용된다. 출력 형식 입력으로 주어진 판 정보를 가지고 몇 개의 블록이 지워질지 출력하라. 입출력 예제 m n board answer 4 5 [""CCBDE"", ""AAADE"", ""AAABF"", ""CCBBF""] 14 6 6 [""TTTANT"", ""RRFACC"", ""RRRFCC"", ""TRRRAA"", ""TTMMMF"", ""TMMTTJ""] 15 예제에 대한 설명 입출력 예제 1의 경우, 첫 번째에는 A 블록 6개가 지워지고, 두 번째에는 B 블록 4개와 C 블록 4개가 지워져, 모두 14개의 블록이 지워진다. 입출력 예제 2는 본문 설명에 있는 그림을 옮긴 것이다. 11개와 4개의 블록이 차례로 지워지며, 모두 15개의 블록이 지워진다. 해설 보러가기",normal,Array
530,"셔틀버스 카카오에서는 무료 셔틀버스를 운행하기 때문에 판교역에서 편하게 사무실로 올 수 있다. 카카오의 직원은 서로를 '크루'라고 부르는데, 아침마다 많은 크루들이 이 셔틀을 이용하여 출근한다. 이 문제에서는 편의를 위해 셔틀은 다음과 같은 규칙으로 운행한다고 가정하자. 셔틀은 09:00부터 총 n회 t분 간격으로 역에 도착하며, 하나의 셔틀에는 최대 m명의 승객이 탈 수 있다. 셔틀은 도착했을 때 도착한 순간에 대기열에 선 크루까지 포함해서 대기 순서대로 태우고 바로 출발한다. 예를 들어 09:00에 도착한 셔틀은 자리가 있다면 09:00에 줄을 선 크루도 탈 수 있다. 일찍 나와서 셔틀을 기다리는 것이 귀찮았던 콘은, 일주일간의 집요한 관찰 끝에 어떤 크루가 몇 시에 셔틀 대기열에 도착하는지 알아냈다. 콘이 셔틀을 타고 사무실로 갈 수 있는 도착 시각 중 제일 늦은 시각을 구하여라. 단, 콘은 게으르기 때문에 같은 시각에 도착한 크루 중 대기열에서 제일 뒤에 선다. 또한, 모든 크루는 잠을 자야 하므로 23:59에 집에 돌아간다. 따라서 어떤 크루도 다음날 셔틀을 타는 일은 없다. 입력 형식 셔틀 운행 횟수 n, 셔틀 운행 간격 t, 한 셔틀에 탈 수 있는 최대 크루 수 m, 크루가 대기열에 도착하는 시각을 모은 배열 timetable이 입력으로 주어진다. 0 ＜ n ≦ 10 0 ＜ t ≦ 60 0 ＜ m ≦ 45 timetable은 최소 길이 1이고 최대 길이 2000인 배열로, 하루 동안 크루가 대기열에 도착하는 시각이 HH:MM 형식으로 이루어져 있다. 크루의 도착 시각 HH:MM은 00:01에서 23:59 사이이다. 출력 형식 콘이 무사히 셔틀을 타고 사무실로 갈 수 있는 제일 늦은 도착 시각을 출력한다. 도착 시각은 HH:MM 형식이며, 00:00에서 23:59 사이의 값이 될 수 있다. 입출력 예제 n t m timetable answer 1 1 5 [""08:00"", ""08:01"", ""08:02"", ""08:03""] ""09:00"" 2 10 2 [""09:10"", ""09:09"", ""08:00""] ""09:09"" 2 1 2 [""09:00"", ""09:00"", ""09:00"", ""09:00""] ""08:59"" 1 1 5 [""00:01"", ""00:01"", ""00:01"", ""00:01"", ""00:01""] ""00:00"" 1 1 1 [""23:59""] ""09:00"" 10 60 45 [""23:59"",""23:59"", ""23:59"", ""23:59"", ""23:59"", ""23:59"", ""23:59"", ""23:59"", ""23:59"", ""23:59"", ""23:59"", ""23:59"", ""23:59"", ""23:59"", ""23:59"", ""23:59""] ""18:00"" 해설 보러가기",normal,Array
531,"뉴스 클러스터링 여러 언론사에서 쏟아지는 뉴스, 특히 속보성 뉴스를 보면 비슷비슷한 제목의 기사가 많아 정작 필요한 기사를 찾기가 어렵다. Daum 뉴스의 개발 업무를 맡게 된 신입사원 튜브는 사용자들이 편리하게 다양한 뉴스를 찾아볼 수 있도록 문제점을 개선하는 업무를 맡게 되었다. 개발의 방향을 잡기 위해 튜브는 우선 최근 화제가 되고 있는 ""카카오 신입 개발자 공채"" 관련 기사를 검색해보았다. 카카오 첫 공채..'블라인드' 방식 채용 카카오, 합병 후 첫 공채.. 블라인드 전형으로 개발자 채용 카카오, 블라인드 전형으로 신입 개발자 공채 카카오 공채, 신입 개발자 코딩 능력만 본다 카카오, 신입 공채.. ""코딩 실력만 본다"" 카카오 ""코딩 능력만으로 2018 신입 개발자 뽑는다"" 기사의 제목을 기준으로 ""블라인드 전형""에 주목하는 기사와 ""코딩 테스트""에 주목하는 기사로 나뉘는 걸 발견했다. 튜브는 이들을 각각 묶어서 보여주면 카카오 공채 관련 기사를 찾아보는 사용자에게 유용할 듯싶었다. 유사한 기사를 묶는 기준을 정하기 위해서 논문과 자료를 조사하던 튜브는 ""자카드 유사도""라는 방법을 찾아냈다. 자카드 유사도는 집합 간의 유사도를 검사하는 여러 방법 중의 하나로 알려져 있다. 두 집합 A, B 사이의 자카드 유사도 J(A, B)는 두 집합의 교집합 크기를 두 집합의 합집합 크기로 나눈 값으로 정의된다. 예를 들어 집합 A = {1, 2, 3}, 집합 B = {2, 3, 4}라고 할 때, 교집합 A ∩ B = {2, 3}, 합집합 A ∪ B = {1, 2, 3, 4}이 되므로, 집합 A, B 사이의 자카드 유사도 J(A, B) = 2/4 = 0.5가 된다. 집합 A와 집합 B가 모두 공집합일 경우에는 나눗셈이 정의되지 않으니 따로 J(A, B) = 1로 정의한다. 자카드 유사도는 원소의 중복을 허용하는 다중집합에 대해서 확장할 수 있다. 다중집합 A는 원소 ""1""을 3개 가지고 있고, 다중집합 B는 원소 ""1""을 5개 가지고 있다고 하자. 이 다중집합의 교집합 A ∩ B는 원소 ""1""을 min(3, 5)인 3개, 합집합 A ∪ B는 원소 ""1""을 max(3, 5)인 5개 가지게 된다. 다중집합 A = {1, 1, 2, 2, 3}, 다중집합 B = {1, 2, 2, 4, 5}라고 하면, 교집합 A ∩ B = {1, 2, 2}, 합집합 A ∪ B = {1, 1, 2, 2, 3, 4, 5}가 되므로, 자카드 유사도 J(A, B) = 3/7, 약 0.42가 된다. 이를 이용하여 문자열 사이의 유사도를 계산하는데 이용할 수 있다. 문자열 ""FRANCE""와 ""FRENCH""가 주어졌을 때, 이를 두 글자씩 끊어서 다중집합을 만들 수 있다. 각각 {FR, RA, AN, NC, CE}, {FR, RE, EN, NC, CH}가 되며, 교집합은 {FR, NC}, 합집합은 {FR, RA, AN, NC, CE, RE, EN, CH}가 되므로, 두 문자열 사이의 자카드 유사도 J(""FRANCE"", ""FRENCH"") = 2/8 = 0.25가 된다. 입력 형식 입력으로는 str1과 str2의 두 문자열이 들어온다. 각 문자열의 길이는 2 이상, 1,000 이하이다. 입력으로 들어온 문자열은 두 글자씩 끊어서 다중집합의 원소로 만든다. 이때 영문자로 된 글자 쌍만 유효하고, 기타 공백이나 숫자, 특수 문자가 들어있는 경우는 그 글자 쌍을 버린다. 예를 들어 ""ab+""가 입력으로 들어오면, ""ab""만 다중집합의 원소로 삼고, ""b+""는 버린다. 다중집합 원소 사이를 비교할 때, 대문자와 소문자의 차이는 무시한다. ""AB""와 ""Ab"", ""ab""는 같은 원소로 취급한다. 출력 형식 입력으로 들어온 두 문자열의 자카드 유사도를 출력한다. 유사도 값은 0에서 1 사이의 실수이므로, 이를 다루기 쉽도록 65536을 곱한 후에 소수점 아래를 버리고 정수부만 출력한다. 예제 입출력 str1 str2 answer FRANCE french 16384 handshake shake hands 65536 aa1+aa2 AAAA12 43690 E=M*C^2 e=m*c^2 65536 해설 보러가기",normal,String
532,"추석 트래픽 이번 추석에도 시스템 장애가 없는 명절을 보내고 싶은 어피치는 서버를 증설해야 할지 고민이다. 장애 대비용 서버 증설 여부를 결정하기 위해 작년 추석 기간인 9월 15일 로그 데이터를 분석한 후 초당 최대 처리량을 계산해보기로 했다. 초당 최대 처리량은 요청의 응답 완료 여부에 관계없이 임의 시간부터 1초(=1,000밀리초)간 처리하는 요청의 최대 개수를 의미한다. 입력 형식 solution 함수에 전달되는 lines 배열은 N(1 ≦ N ≦ 2,000)개의 로그 문자열로 되어 있으며, 각 로그 문자열마다 요청에 대한 응답완료시간 S와 처리시간 T가 공백으로 구분되어 있다. 응답완료시간 S는 작년 추석인 2016년 9월 15일만 포함하여 고정 길이 2016-09-15 hh:mm:ss.sss 형식으로 되어 있다. 처리시간 T는 0.1s, 0.312s, 2s 와 같이 최대 소수점 셋째 자리까지 기록하며 뒤에는 초 단위를 의미하는 s로 끝난다. 예를 들어, 로그 문자열 2016-09-15 03:10:33.020 0.011s은 ""2016년 9월 15일 오전 3시 10분 33.010초""부터 ""2016년 9월 15일 오전 3시 10분 33.020초""까지 ""0.011초"" 동안 처리된 요청을 의미한다. (처리시간은 시작시간과 끝시간을 포함) 서버에는 타임아웃이 3초로 적용되어 있기 때문에 처리시간은 0.001 ≦ T ≦ 3.000이다. lines 배열은 응답완료시간 S를 기준으로 오름차순 정렬되어 있다. 출력 형식 solution 함수에서는 로그 데이터 lines 배열에 대해 초당 최대 처리량을 리턴한다. 입출력 예제 예제1 입력: [ ""2016-09-15 01:00:04.001 2.0s"", ""2016-09-15 01:00:07.000 2s"" ] 출력: 1 예제2 입력: [ ""2016-09-15 01:00:04.002 2.0s"", ""2016-09-15 01:00:07.000 2s"" ] 출력: 2 설명: 처리시간은 시작시간과 끝시간을 포함하므로 첫 번째 로그는 01:00:02.003 ~ 01:00:04.002에서 2초 동안 처리되었으며, 두 번째 로그는 01:00:05.001 ~ 01:00:07.000에서 2초 동안 처리된다. 따라서, 첫 번째 로그가 끝나는 시점과 두 번째 로그가 시작하는 시점의 구간인 01:00:04.002 ~ 01:00:05.001 1초 동안 최대 2개가 된다. 예제3 입력: [ ""2016-09-15 20:59:57.421 0.351s"", ""2016-09-15 20:59:58.233 1.181s"", ""2016-09-15 20:59:58.299 0.8s"", ""2016-09-15 20:59:58.688 1.041s"", ""2016-09-15 20:59:59.591 1.412s"", ""2016-09-15 21:00:00.464 1.466s"", ""2016-09-15 21:00:00.741 1.581s"", ""2016-09-15 21:00:00.748 2.31s"", ""2016-09-15 21:00:00.966 0.381s"", ""2016-09-15 21:00:02.066 2.62s"" ] 출력: 7 설명: 아래 타임라인 그림에서 빨간색으로 표시된 1초 각 구간의 처리량을 구해보면 (1)은 4개, (2)는 7개, (3)는 2개임을 알 수 있다. 따라서 초당 최대 처리량은 7이 되며, 동일한 최대 처리량을 갖는 1초 구간은 여러 개 존재할 수 있으므로 이 문제에서는 구간이 아닌 개수만 출력한다. 해설 보러가기",normal,Array
533,"xx 회사의 2xN명의 사원들은 N명씩 두 팀으로 나눠 숫자 게임을 하려고 합니다. 두 개의 팀을 각각 A팀과 B팀이라고 하겠습니다. 숫자 게임의 규칙은 다음과 같습니다. 먼저 모든 사원이 무작위로 자연수를 하나씩 부여받습니다. 각 사원은 딱 한 번씩 경기를 합니다. 각 경기당 A팀에서 한 사원이, B팀에서 한 사원이 나와 서로의 수를 공개합니다. 그때 숫자가 큰 쪽이 승리하게 되고, 승리한 사원이 속한 팀은 승점을 1점 얻게 됩니다. 만약 숫자가 같다면 누구도 승점을 얻지 않습니다. 전체 사원들은 우선 무작위로 자연수를 하나씩 부여받았습니다. 그다음 A팀은 빠르게 출전순서를 정했고 자신들의 출전 순서를 B팀에게 공개해버렸습니다. B팀은 그것을 보고 자신들의 최종 승점을 가장 높이는 방법으로 팀원들의 출전 순서를 정했습니다. 이때의 B팀이 얻는 승점을 구해주세요. A 팀원들이 부여받은 수가 출전 순서대로 나열되어있는 배열 A와 i번째 원소가 B팀의 i번 팀원이 부여받은 수를 의미하는 배열 B가 주어질 때, B 팀원들이 얻을 수 있는 최대 승점을 return 하도록 solution 함수를 완성해주세요. 제한사항 A와 B의 길이는 같습니다. A와 B의 길이는 1 이상 100,000 이하입니다. A와 B의 각 원소는 1 이상 1,000,000,000 이하의 자연수입니다. 입출력 예 A B result [5,1,3,7] [2,2,6,8] 3 [2,2,2,2] [1,1,1,1] 0 입출력 예 설명 입출력 예 #1 A 팀은 숫자 5를 부여받은 팀원이 첫번째로 출전하고, 이어서 1,3,7을 부여받은 팀원들이 차례대로 출전합니다. B 팀원들을 4번, 2번, 3번, 1번의 순서대로 출전시킬 경우 팀원들이 부여받은 숫자들은 차례대로 8,2,6,2가 됩니다. 그러면, 첫 번째, 두 번째, 세 번째 경기에서 승리하여 3점을 얻게 되고, 이때가 최대의 승점입니다. 입출력 예 #2 B 팀원들을 어떤 순서로 출전시켜도 B팀의 승점은 0점입니다.",normal,Array
534,"△△ 게임대회가 개최되었습니다. 이 대회는 N명이 참가하고, 토너먼트 형식으로 진행됩니다. N명의 참가자는 각각 1부터 N번을 차례대로 배정받습니다. 그리고, 1번↔2번, 3번↔4번, ... , N-1번↔N번의 참가자끼리 게임을 진행합니다. 각 게임에서 이긴 사람은 다음 라운드에 진출할 수 있습니다. 이때, 다음 라운드에 진출할 참가자의 번호는 다시 1번부터 N/2번을 차례대로 배정받습니다. 만약 1번↔2번 끼리 겨루는 게임에서 2번이 승리했다면 다음 라운드에서 1번을 부여받고, 3번↔4번에서 겨루는 게임에서 3번이 승리했다면 다음 라운드에서 2번을 부여받게 됩니다. 게임은 최종 한 명이 남을 때까지 진행됩니다. 이때, 처음 라운드에서 A번을 가진 참가자는 경쟁자로 생각하는 B번 참가자와 몇 번째 라운드에서 만나는지 궁금해졌습니다. 게임 참가자 수 N, 참가자 번호 A, 경쟁자 번호 B가 함수 solution의 매개변수로 주어질 때, 처음 라운드에서 A번을 가진 참가자는 경쟁자로 생각하는 B번 참가자와 몇 번째 라운드에서 만나는지 return 하는 solution 함수를 완성해 주세요. 단, A번 참가자와 B번 참가자는 서로 붙게 되기 전까지 항상 이긴다고 가정합니다. 제한사항 N : 21 이상 220 이하인 자연수 (2의 지수 승으로 주어지므로 부전승은 발생하지 않습니다.) A, B : N 이하인 자연수 (단, A ≠ B 입니다.) 입출력 예 N A B answer 8 4 7 3 입출력 예 설명 입출력 예 #1 첫 번째 라운드에서 4번 참가자는 3번 참가자와 붙게 되고, 7번 참가자는 8번 참가자와 붙게 됩니다. 항상 이긴다고 가정했으므로 4번 참가자는 다음 라운드에서 2번이 되고, 7번 참가자는 4번이 됩니다. 두 번째 라운드에서 2번은 1번과 붙게 되고, 4번은 3번과 붙게 됩니다. 항상 이긴다고 가정했으므로 2번은 다음 라운드에서 1번이 되고, 4번은 2번이 됩니다. 세 번째 라운드에서 1번과 2번으로 두 참가자가 붙게 되므로 3을 return 하면 됩니다.",normal,Math
535,"XX 게임에서는 지형 편집 기능을 이용하여 플레이어가 직접 게임 속 지형을 수정할 수 있습니다. 이 게임에서는 1 x 1 x 1 크기의 정육면체 블록을 쌓아 게임 속 지형을 표현합니다. 이때, 블록이 공중에 떠 있거나, 블록 하나가 여러 개의 칸에 걸쳐 놓일 수는 없습니다. 따라서 지형을 편집하기 위해서는 각 칸의 제일 위에 블록 1개를 새로 추가하거나, 제일 위에 있는 블록 한 개를 삭제하는 방식으로 지형을 수정해야 합니다. 이때, 블록 한 개를 새로 추가하거나 삭제하기 위해서는 게임머니를 사용해야 하므로 몇 개의 블록을 추가하고 삭제할지 신중한 선택이 필요합니다. 이 게임을 즐기던 한 플레이어는 N x N 크기의 지역에 자신만의 별장을 만들고 싶어졌습니다. 이를 위해서는 울퉁불퉁한 지형의 모든 칸의 높이가 같아지도록 만들어야 합니다. 이때, 블록 한 개를 추가하려면 P의 비용이, 제거하려면 Q의 비용이 들게 됩니다. 다음은 블록 한 개를 추가할 때 5의 비용이, 제거할 때 3의 비용이 드는 경우, 3 x 3 넓이의 모든 칸의 블록 높이가 같아지도록 만드는 예시입니다. 위 그림과 같이 지형 블록이 놓여 있는 경우 모든 칸의 높이가 3으로 같아지도록 한다면 다음과 같은 모양이 됩니다. 이를 위해서는 3보다 높은 칸의 블록 2개를 제거하고, 3보다 낮은 칸에 총 8개의 블록을 추가해야 하며, 2 x 3 + 8 x 5 = 46의 비용이 들게 됩니다. 그러나 아래 그림과 같이 모든 칸의 높이가 2로 같아지도록 할 때는 6개의 블록을 제거하고, 3개의 블록을 추가하면 6 x 3 + 3 x 5 = 33의 비용이 들게 되며, 이때가 최소비용이 됩니다. 현재 지형의 상태를 나타내는 배열 land와 블록 한 개를 추가하는 데 필요한 비용 P, 블록 한 개를 제거하는 데 필요한 비용 Q가 매개변수로 주어질 때, 모든 칸에 쌓여있는 블록의 높이가 같아지도록 하는 데 필요한 비용의 최솟값을 return 하도록 solution 함수를 완성해 주세요. 제한사항 land는 N x N 크기의 2차원 배열이며, N의 범위는 1 ≤ N ≤ 300입니다. land의 각 원소는 각 칸에 놓여 있는 블록의 수를 나타내며, 0 이상 10억 이하의 정수입니다. 각 칸에 블록 하나를 추가하는 데는 P, 제거하는 데는 Q의 비용이 들며, P, Q의 범위는 1 ≤ P, Q ≤ 100인 자연수입니다. 입출력 예 land P Q result [[1, 2], [2, 3]] 3 2 5 [[4, 4, 3], [3, 2, 2], [ 2, 1, 0 ]] 5 3 33 입출력 예 설명 입출력 예 #1 모든 땅의 높이를 1로 맞추는 데는 블록 4개를 제거해야 하므로 8의 비용이 듭니다. 모든 땅의 높이를 2로 맞추는 데는 블록 1개를 추가하고 블록 1개를 제거해야 하므로 5의 비용이 듭니다. 모든 땅의 높이를 3으로 맞추는 데는 블록 4개를 추가해야 하므로 12의 비용이 듭니다. 따라서 최소 비용은 5이므로 5를 return 합니다. 입출력 예 #2 문제의 예시와 같으며 최소 비용은 33입니다.",hard,Array
536,"단어 퍼즐은 주어진 단어 조각들을 이용해서 주어진 문장을 완성하는 퍼즐입니다. 이때, 주어진 각 단어 조각들은 각각 무한개씩 있다고 가정합니다. 예를 들어 주어진 단어 조각이 [“ba”, “na”, “n”, “a”]인 경우 ""ba"", ""na"", ""n"", ""a"" 단어 조각이 각각 무한개씩 있습니다. 이때, 만들어야 하는 문장이 “banana”라면 “ba”, “na”, “n”, “a”의 4개를 사용하여 문장을 완성할 수 있지만, “ba”, “na”, “na”의 3개만을 사용해도 “banana”를 완성할 수 있습니다. 사용 가능한 단어 조각들을 담고 있는 배열 strs와 완성해야 하는 문자열 t가 매개변수로 주어질 때, 주어진 문장을 완성하기 위해 사용해야 하는 단어조각 개수의 최솟값을 return 하도록 solution 함수를 완성해 주세요. 만약 주어진 문장을 완성하는 것이 불가능하면 -1을 return 하세요. 제한사항 strs는 사용 가능한 단어 조각들이 들어있는 배열로, 길이는 1 이상 100 이하입니다. strs의 각 원소는 사용 가능한 단어조각들이 중복 없이 들어있습니다. 사용 가능한 단어 조각들은 문자열 형태이며, 모든 단어 조각의 길이는 1 이상 5 이하입니다. t는 완성해야 하는 문자열이며 길이는 1 이상 20,000 이하입니다. 모든 문자열은 알파벳 소문자로만 이루어져 있습니다. 입출력 예 strs t result [""ba"",""na"",""n"",""a""] ""banana"" 3 [""app"",""ap"",""p"",""l"",""e"",""ple"",""pp""] ""apple"" 2 [""ba"",""an"",""nan"",""ban"",""n""] ""banana"" -1 입출력 예 설명 입출력 예 #1 문제의 예시와 같습니다. 입출력 예 #2 ""ap"" 1개, ""ple"" 1개의 총 2개로 ""apple""을 만들 수 있으므로 필요한 단어 개수의 최솟값은 2를 return 합니다. 입출력 예 #3 주어진 단어로는 ""banana""를 만들 수 없으므로 -1을 return 합니다.",hard,Array
537,"S사에서는 각 부서에 필요한 물품을 지원해 주기 위해 부서별로 물품을 구매하는데 필요한 금액을 조사했습니다. 그러나, 전체 예산이 정해져 있기 때문에 모든 부서의 물품을 구매해 줄 수는 없습니다. 그래서 최대한 많은 부서의 물품을 구매해 줄 수 있도록 하려고 합니다. 물품을 구매해 줄 때는 각 부서가 신청한 금액만큼을 모두 지원해 줘야 합니다. 예를 들어 1,000원을 신청한 부서에는 정확히 1,000원을 지원해야 하며, 1,000원보다 적은 금액을 지원해 줄 수는 없습니다. 부서별로 신청한 금액이 들어있는 배열 d와 예산 budget이 매개변수로 주어질 때, 최대 몇 개의 부서에 물품을 지원할 수 있는지 return 하도록 solution 함수를 완성해주세요. 제한사항 d는 부서별로 신청한 금액이 들어있는 배열이며, 길이(전체 부서의 개수)는 1 이상 100 이하입니다. d의 각 원소는 부서별로 신청한 금액을 나타내며, 부서별 신청 금액은 1 이상 100,000 이하의 자연수입니다. budget은 예산을 나타내며, 1 이상 10,000,000 이하의 자연수입니다. 입출력 예 d budget result [1,3,2,5,4] 9 3 [2,2,3,3] 10 4 입출력 예 설명 입출력 예 #1 각 부서에서 [1원, 3원, 2원, 5원, 4원]만큼의 금액을 신청했습니다. 만약에, 1원, 2원, 4원을 신청한 부서의 물품을 구매해주면 예산 9원에서 7원이 소비되어 2원이 남습니다. 항상 정확히 신청한 금액만큼 지원해 줘야 하므로 남은 2원으로 나머지 부서를 지원해 주지 않습니다. 위 방법 외에 3개 부서를 지원해 줄 방법들은 다음과 같습니다. 1원, 2원, 3원을 신청한 부서의 물품을 구매해주려면 6원이 필요합니다. 1원, 2원, 5원을 신청한 부서의 물품을 구매해주려면 8원이 필요합니다. 1원, 3원, 4원을 신청한 부서의 물품을 구매해주려면 8원이 필요합니다. 1원, 3원, 5원을 신청한 부서의 물품을 구매해주려면 9원이 필요합니다. 3개 부서보다 더 많은 부서의 물품을 구매해 줄 수는 없으므로 최대 3개 부서의 물품을 구매해 줄 수 있습니다. 입출력 예 #2 모든 부서의 물품을 구매해주면 10원이 됩니다. 따라서 최대 4개 부서의 물품을 구매해 줄 수 있습니다.",easy,Array
538,"1부터 n까지 번호가 붙어있는 n명의 사람이 영어 끝말잇기를 하고 있습니다. 영어 끝말잇기는 다음과 같은 규칙으로 진행됩니다. 1번부터 번호 순서대로 한 사람씩 차례대로 단어를 말합니다. 마지막 사람이 단어를 말한 다음에는 다시 1번부터 시작합니다. 앞사람이 말한 단어의 마지막 문자로 시작하는 단어를 말해야 합니다. 이전에 등장했던 단어는 사용할 수 없습니다. 한 글자인 단어는 인정되지 않습니다. 다음은 3명이 끝말잇기를 하는 상황을 나타냅니다. tank → kick → know → wheel → land → dream → mother → robot → tank 위 끝말잇기는 다음과 같이 진행됩니다. 1번 사람이 자신의 첫 번째 차례에 tank를 말합니다. 2번 사람이 자신의 첫 번째 차례에 kick을 말합니다. 3번 사람이 자신의 첫 번째 차례에 know를 말합니다. 1번 사람이 자신의 두 번째 차례에 wheel을 말합니다. (계속 진행) 끝말잇기를 계속 진행해 나가다 보면, 3번 사람이 자신의 세 번째 차례에 말한 tank 라는 단어는 이전에 등장했던 단어이므로 탈락하게 됩니다. 사람의 수 n과 사람들이 순서대로 말한 단어 words 가 매개변수로 주어질 때, 가장 먼저 탈락하는 사람의 번호와 그 사람이 자신의 몇 번째 차례에 탈락하는지를 구해서 return 하도록 solution 함수를 완성해주세요. 제한 사항 끝말잇기에 참여하는 사람의 수 n은 2 이상 10 이하의 자연수입니다. words는 끝말잇기에 사용한 단어들이 순서대로 들어있는 배열이며, 길이는 n 이상 100 이하입니다. 단어의 길이는 2 이상 50 이하입니다. 모든 단어는 알파벳 소문자로만 이루어져 있습니다. 끝말잇기에 사용되는 단어의 뜻(의미)은 신경 쓰지 않으셔도 됩니다. 정답은 [ 번호, 차례 ] 형태로 return 해주세요. 만약 주어진 단어들로 탈락자가 생기지 않는다면, [0, 0]을 return 해주세요. 입출력 예 n words result 3 [""tank"", ""kick"", ""know"", ""wheel"", ""land"", ""dream"", ""mother"", ""robot"", ""tank""] [3,3] 5 [""hello"", ""observe"", ""effect"", ""take"", ""either"", ""recognize"", ""encourage"", ""ensure"", ""establish"", ""hang"", ""gather"", ""refer"", ""reference"", ""estimate"", ""executive""] [0,0] 2 [""hello"", ""one"", ""even"", ""never"", ""now"", ""world"", ""draw""] [1,3] 입출력 예 설명 입출력 예 #1 3명의 사람이 끝말잇기에 참여하고 있습니다. 1번 사람 : tank, wheel, mother 2번 사람 : kick, land, robot 3번 사람 : know, dream, tank 와 같은 순서로 말을 하게 되며, 3번 사람이 자신의 세 번째 차례에 말한 tank라는 단어가 1번 사람이 자신의 첫 번째 차례에 말한 tank와 같으므로 3번 사람이 자신의 세 번째 차례로 말을 할 때 처음 탈락자가 나오게 됩니다. 입출력 예 #2 5명의 사람이 끝말잇기에 참여하고 있습니다. 1번 사람 : hello, recognize, gather 2번 사람 : observe, encourage, refer 3번 사람 : effect, ensure, reference 4번 사람 : take, establish, estimate 5번 사람 : either, hang, executive 와 같은 순서로 말을 하게 되며, 이 경우는 주어진 단어로만으로는 탈락자가 발생하지 않습니다. 따라서 [0, 0]을 return하면 됩니다. 입출력 예 #3 2명의 사람이 끝말잇기에 참여하고 있습니다. 1번 사람 : hello, even, now, draw 2번 사람 : one, never, world 와 같은 순서로 말을 하게 되며, 1번 사람이 자신의 세 번째 차례에 'r'로 시작하는 단어 대신, n으로 시작하는 now를 말했기 때문에 이때 처음 탈락자가 나오게 됩니다.",normal,Array
539,"OO 연구소는 한 번에 K 칸을 앞으로 점프하거나, (현재까지 온 거리) x 2 에 해당하는 위치로 순간이동을 할 수 있는 특수한 기능을 가진 아이언 슈트를 개발하여 판매하고 있습니다. 이 아이언 슈트는 건전지로 작동되는데, 순간이동을 하면 건전지 사용량이 줄지 않지만, 앞으로 K 칸을 점프하면 K 만큼의 건전지 사용량이 듭니다. 그러므로 아이언 슈트를 착용하고 이동할 때는 순간 이동을 하는 것이 더 효율적입니다. 아이언 슈트 구매자는 아이언 슈트를 착용하고 거리가 N 만큼 떨어져 있는 장소로 가려고 합니다. 단, 건전지 사용량을 줄이기 위해 점프로 이동하는 것은 최소로 하려고 합니다. 아이언 슈트 구매자가 이동하려는 거리 N이 주어졌을 때, 사용해야 하는 건전지 사용량의 최솟값을 return하는 solution 함수를 만들어 주세요. 예를 들어 거리가 5만큼 떨어져 있는 장소로 가려고 합니다. 아이언 슈트를 입고 거리가 5만큼 떨어져 있는 장소로 갈 수 있는 경우의 수는 여러 가지입니다. 처음 위치 0 에서 5 칸을 앞으로 점프하면 바로 도착하지만, 건전지 사용량이 5 만큼 듭니다. 처음 위치 0 에서 2 칸을 앞으로 점프한 다음 순간이동 하면 (현재까지 온 거리 : 2) x 2에 해당하는 위치로 이동할 수 있으므로 위치 4로 이동합니다. 이때 1 칸을 앞으로 점프하면 도착하므로 건전지 사용량이 3 만큼 듭니다. 처음 위치 0 에서 1 칸을 앞으로 점프한 다음 순간이동 하면 (현재까지 온 거리 : 1) x 2에 해당하는 위치로 이동할 수 있으므로 위치 2로 이동됩니다. 이때 다시 순간이동 하면 (현재까지 온 거리 : 2) x 2 만큼 이동할 수 있으므로 위치 4로 이동합니다. 이때 1 칸을 앞으로 점프하면 도착하므로 건전지 사용량이 2 만큼 듭니다. 위의 3가지 경우 거리가 5만큼 떨어져 있는 장소로 가기 위해서 3번째 경우가 건전지 사용량이 가장 적으므로 답은 2가 됩니다. 제한 사항 숫자 N: 1 이상 10억 이하의 자연수 숫자 K: 1 이상의 자연수 입출력 예 N result 5 2 6 2 5000 5 입출력 예 설명 입출력 예 #1 위의 예시와 같습니다. 입출력 예 #2 처음 위치 0 에서 1 칸을 앞으로 점프한 다음 순간이동 하면 (현재까지 온 거리 : 1) x 2에 해당하는 위치로 이동할 수 있으므로 위치 2로 이동합니다. 이때 1 칸을 앞으로 점프하면 위치3으로 이동합니다. 이때 다시 순간이동 하면 (현재까지 온 거리 : 3) x 2 이동할 수 있으므로 위치 6에 도착합니다. 이 경우가 건전지 사용량이 가장 적으므로 2를 반환해주면 됩니다. 입출력 예 #3 위와 같은 방식으로 합니다.",normal,Math
540,"N개의 아파트가 일렬로 쭉 늘어서 있습니다. 이 중에서 일부 아파트 옥상에는 4g 기지국이 설치되어 있습니다. 기술이 발전해 5g 수요가 높아져 4g 기지국을 5g 기지국으로 바꾸려 합니다. 그런데 5g 기지국은 4g 기지국보다 전달 범위가 좁아, 4g 기지국을 5g 기지국으로 바꾸면 어떤 아파트에는 전파가 도달하지 않습니다. 예를 들어 11개의 아파트가 쭉 늘어서 있고, [4, 11] 번째 아파트 옥상에는 4g 기지국이 설치되어 있습니다. 만약 이 4g 기지국이 전파 도달 거리가 1인 5g 기지국으로 바뀔 경우 모든 아파트에 전파를 전달할 수 없습니다. (전파의 도달 거리가 W일 땐, 기지국이 설치된 아파트를 기준으로 전파를 양쪽으로 W만큼 전달할 수 있습니다.) 초기에, 1, 2, 6, 7, 8, 9번째 아파트에는 전파가 전달되지 않습니다. 1, 7, 9번째 아파트 옥상에 기지국을 설치할 경우, 모든 아파트에 전파를 전달할 수 있습니다. 더 많은 아파트 옥상에 기지국을 설치하면 모든 아파트에 전파를 전달할 수 있습니다. 이때, 우리는 5g 기지국을 최소로 설치하면서 모든 아파트에 전파를 전달하려고 합니다. 위의 예시에선 최소 3개의 아파트 옥상에 기지국을 설치해야 모든 아파트에 전파를 전달할 수 있습니다. 아파트의 개수 N, 현재 기지국이 설치된 아파트의 번호가 담긴 1차원 배열 stations, 전파의 도달 거리 W가 매개변수로 주어질 때, 모든 아파트에 전파를 전달하기 위해 증설해야 할 기지국 개수의 최솟값을 리턴하는 solution 함수를 완성해주세요 제한사항 N: 200,000,000 이하의 자연수 stations의 크기: 10,000 이하의 자연수 stations는 오름차순으로 정렬되어 있고, 배열에 담긴 수는 N보다 같거나 작은 자연수입니다. W: 10,000 이하의 자연수 입출력 예 N stations W answer 11 [4, 11] 1 3 16 [9] 2 3 입출력 예 설명 입출력 예 #1 문제의 예시와 같습니다 입출력 예 #2 초기에, 1~6, 12~16번째 아파트에는 전파가 전달되지 않습니다. 3, 6, 14번째 아파트 옥상에 기지국을 설치할 경우 모든 아파트에 전파를 전달할 수 있습니다.",normal,Array
541,"N개의 마을로 이루어진 나라가 있습니다. 이 나라의 각 마을에는 1부터 N까지의 번호가 각각 하나씩 부여되어 있습니다. 각 마을은 양방향으로 통행할 수 있는 도로로 연결되어 있는데, 서로 다른 마을 간에 이동할 때는 이 도로를 지나야 합니다. 도로를 지날 때 걸리는 시간은 도로별로 다릅니다. 현재 1번 마을에 있는 음식점에서 각 마을로 음식 배달을 하려고 합니다. 각 마을로부터 음식 주문을 받으려고 하는데, N개의 마을 중에서 K 시간 이하로 배달이 가능한 마을에서만 주문을 받으려고 합니다. 다음은 N = 5, K = 3인 경우의 예시입니다. 위 그림에서 1번 마을에 있는 음식점은 [1, 2, 4, 5] 번 마을까지는 3 이하의 시간에 배달할 수 있습니다. 그러나 3번 마을까지는 3시간 이내로 배달할 수 있는 경로가 없으므로 3번 마을에서는 주문을 받지 않습니다. 따라서 1번 마을에 있는 음식점이 배달 주문을 받을 수 있는 마을은 4개가 됩니다. 마을의 개수 N, 각 마을을 연결하는 도로의 정보 road, 음식 배달이 가능한 시간 K가 매개변수로 주어질 때, 음식 주문을 받을 수 있는 마을의 개수를 return 하도록 solution 함수를 완성해주세요. 제한사항 마을의 개수 N은 1 이상 50 이하의 자연수입니다. road의 길이(도로 정보의 개수)는 1 이상 2,000 이하입니다. road의 각 원소는 마을을 연결하고 있는 각 도로의 정보를 나타냅니다. road는 길이가 3인 배열이며, 순서대로 (a, b, c)를 나타냅니다. a, b(1 ≤ a, b ≤ N, a != b)는 도로가 연결하는 두 마을의 번호이며, c(1 ≤ c ≤ 10,000, c는 자연수)는 도로를 지나는데 걸리는 시간입니다. 두 마을 a, b를 연결하는 도로는 여러 개가 있을 수 있습니다. 한 도로의 정보가 여러 번 중복해서 주어지지 않습니다. K는 음식 배달이 가능한 시간을 나타내며, 1 이상 500,000 이하입니다. 임의의 두 마을간에 항상 이동 가능한 경로가 존재합니다. 1번 마을에 있는 음식점이 K 이하의 시간에 배달이 가능한 마을의 개수를 return 하면 됩니다. 입출력 예 N road K result 5 [[1,2,1],[2,3,3],[5,2,2],[1,4,2],[5,3,1],[5,4,2]] 3 4 6 [[1,2,1],[1,3,2],[2,3,2],[3,4,3],[3,5,2],[3,5,3],[5,6,1]] 4 4 입출력 예 설명 입출력 예 #1 문제의 예시와 같습니다. 입출력 예 #2 주어진 마을과 도로의 모양은 아래 그림과 같습니다. 1번 마을에서 배달에 4시간 이하가 걸리는 마을은 [1, 2, 3, 5] 4개이므로 4를 return 합니다.",normal,Array
542,"주어진 숫자 중 3개의 수를 더했을 때 소수가 되는 경우의 개수를 구하려고 합니다. 숫자들이 들어있는 배열 nums가 매개변수로 주어질 때, nums에 있는 숫자들 중 서로 다른 3개를 골라 더했을 때 소수가 되는 경우의 개수를 return 하도록 solution 함수를 완성해주세요. 제한사항 nums에 들어있는 숫자의 개수는 3개 이상 50개 이하입니다. nums의 각 원소는 1 이상 1,000 이하의 자연수이며, 중복된 숫자가 들어있지 않습니다. 입출력 예 nums result [1,2,3,4] 1 [1,2,7,6,4] 4 입출력 예 설명 입출력 예 #1 [1,2,4]를 이용해서 7을 만들 수 있습니다. 입출력 예 #2 [1,2,4]를 이용해서 7을 만들 수 있습니다. [1,4,6]을 이용해서 11을 만들 수 있습니다. [2,4,7]을 이용해서 13을 만들 수 있습니다. [4,6,7]을 이용해서 17을 만들 수 있습니다.",easy,Array
543,"평면 위에 N개의 직사각형이 놓여있습니다. 직사각형의 각 변은 x축, y축에 평행합니다. 각각의 직사각형은 왼쪽 아래 좌표(x1, y1)과 오른쪽 위 좌표 (x2, y2)를 가지며, (x1, y1, x2, y2)로 나타내고, 서로 겹쳐있을 수 있습니다. 이때 이 직사각형들이 차지하는 면적을 구하려고 합니다. 다음은 N = 5인 경우의 예시입니다. 위 그림에는 5개의 직사각형 (1, 1, 6, 5), (2, 0, 4, 2), (2, 4, 5, 7), (4, 3, 8, 6), (7, 5, 9, 7) 이 놓여있습니다. 이때 전체 직사각형이 덮고 있는 면적은 아래 그림의 검은 테두리 안쪽의 면적과 같습니다. 따라서 위 예시에서 5개의 직사각형이 덮고 있는 면적은 38이 됩니다. 평면 위에 놓여있는 직사각형들의 좌표가 매개변수 rectangles로 주어질 때, 직사각형들이 덮고 있는 면적의 넓이를 return하도록 solution 합수를 완성해 주세요. 제한사항 직사각형의 개수 N : 1 ≤ N ≤ 100,000 직사각형의 좌표 x1, y1, x2, y2 : 0 ≤ x1 < x2 ≤ 109 , 0 ≤ y1 < y2 ≤ 109 x1, y1, x2, y2는 정수 입출력 예 rectangles result [[0, 1, 4, 4], [3, 1, 5, 3]] 14 [[1, 1, 6, 5], [2, 0, 4, 2], [2, 4, 5, 7], [4, 3, 8, 6], [7, 5, 9, 7]] 38 입출력 예 설명 입출력 예 #1 직사각형 (0, 1, 4, 4)가 차지하는 면적은 12이며, 직사각형 (3, 1, 5, 3)이 차지하는 면적은 4입니다. 두 직사각형의 겹치는 면적은 2 이기 때문에 전체 면적은 12 + 4 - 2 = 14입니다. 입출력 예 #2 문제의 예시와 같습니다.",hard,Math
544,"짝지어 제거하기는, 알파벳 소문자로 이루어진 문자열을 가지고 시작합니다. 먼저 문자열에서 같은 알파벳이 2개 붙어 있는 짝을 찾습니다. 그다음, 그 둘을 제거한 뒤, 앞뒤로 문자열을 이어 붙입니다. 이 과정을 반복해서 문자열을 모두 제거한다면 짝지어 제거하기가 종료됩니다. 문자열 S가 주어졌을 때, 짝지어 제거하기를 성공적으로 수행할 수 있는지 반환하는 함수를 완성해 주세요. 성공적으로 수행할 수 있으면 1을, 아닐 경우 0을 리턴해주면 됩니다. 예를 들어, 문자열 S = baabaa 라면 b aa baa → bb aa → aa → 의 순서로 문자열을 모두 제거할 수 있으므로 1을 반환합니다. 제한사항 문자열의 길이 : 1,000,000이하의 자연수 문자열은 모두 소문자로 이루어져 있습니다. 입출력 예 s result baabaa 1 cdcd 0 입출력 예 설명 입출력 예 #1 위의 예시와 같습니다. 입출력 예 #2 문자열이 남아있지만 짝지어 제거할 수 있는 문자열이 더 이상 존재하지 않기 때문에 0을 반환합니다. ※ 공지 - 2020년 6월 8일 테스트케이스가 추가되었습니다. ※ 공지 - 2023년 8월 31일 테스트케이스가 추가되었습니다. 기존에 제출한 코드가 통과하지 못할 수도 있습니다.",normal,String
545,"N개의 스티커가 원형으로 연결되어 있습니다. 다음 그림은 N = 8인 경우의 예시입니다. 원형으로 연결된 스티커에서 몇 장의 스티커를 뜯어내어 뜯어낸 스티커에 적힌 숫자의 합이 최대가 되도록 하고 싶습니다. 단 스티커 한 장을 뜯어내면 양쪽으로 인접해있는 스티커는 찢어져서 사용할 수 없게 됩니다. 예를 들어 위 그림에서 14가 적힌 스티커를 뜯으면 인접해있는 10, 6이 적힌 스티커는 사용할 수 없습니다. 스티커에 적힌 숫자가 배열 형태로 주어질 때, 스티커를 뜯어내어 얻을 수 있는 숫자의 합의 최댓값을 return 하는 solution 함수를 완성해 주세요. 원형의 스티커 모양을 위해 배열의 첫 번째 원소와 마지막 원소가 서로 연결되어 있다고 간주합니다. 제한 사항 sticker는 원형으로 연결된 스티커의 각 칸에 적힌 숫자가 순서대로 들어있는 배열로, 길이(N)는 1 이상 100,000 이하입니다. sticker의 각 원소는 스티커의 각 칸에 적힌 숫자이며, 각 칸에 적힌 숫자는 1 이상 100 이하의 자연수입니다. 원형의 스티커 모양을 위해 sticker 배열의 첫 번째 원소와 마지막 원소가 서로 연결되어있다고 간주합니다. 입출력 예 sticker answer [14, 6, 5, 11, 3, 9, 2, 10] 36 [1, 3, 2, 5, 4] 8 입출력 예 설명 입출력 예 #1 6, 11, 9, 10이 적힌 스티커를 떼어 냈을 때 36으로 최대가 됩니다. 입출력 예 #2 3, 5가 적힌 스티커를 떼어 냈을 때 8로 최대가 됩니다.",normal,Array
546,"이 문제에는 표준 입력으로 두 개의 정수 n과 m이 주어집니다. 별(*) 문자를 이용해 가로의 길이가 n, 세로의 길이가 m인 직사각형 형태를 출력해보세요. 제한 조건 n과 m은 각각 1000 이하인 자연수입니다. 예시 입력 5 3 출력 ***** ***** *****",easy,Design
547,"함수 solution은 정수 x와 자연수 n을 입력 받아, x부터 시작해 x씩 증가하는 숫자를 n개 지니는 리스트를 리턴해야 합니다. 다음 제한 조건을 보고, 조건을 만족하는 함수, solution을 완성해주세요. 제한 조건 x는 -10000000 이상, 10000000 이하인 정수입니다. n은 1000 이하인 자연수입니다. 입출력 예 x n answer 2 5 [2,4,6,8,10] 4 3 [4,8,12] -4 2 [-4, -8]",easy,Array
548,"두 수의 최소공배수(Least Common Multiple)란 입력된 두 수의 배수 중 공통이 되는 가장 작은 숫자를 의미합니다. 예를 들어 2와 7의 최소공배수는 14가 됩니다. 정의를 확장해서, n개의 수의 최소공배수는 n 개의 수들의 배수 중 공통이 되는 가장 작은 숫자가 됩니다. n개의 숫자를 담은 배열 arr이 입력되었을 때 이 수들의 최소공배수를 반환하는 함수, solution을 완성해 주세요. 제한 사항 arr은 길이 1이상, 15이하인 배열입니다. arr의 원소는 100 이하인 자연수입니다. 입출력 예 arr result [2,6,8,14] 168 [1,2,3] 6",normal,Array
549,"가로, 세로 길이가 n인 정사각형으로된 체스판이 있습니다. 체스판 위의 n개의 퀸이 서로를 공격할 수 없도록 배치하고 싶습니다. 예를 들어서 n이 4인경우 다음과 같이 퀸을 배치하면 n개의 퀸은 서로를 한번에 공격 할 수 없습니다. 체스판의 가로 세로의 세로의 길이 n이 매개변수로 주어질 때, n개의 퀸이 조건에 만족 하도록 배치할 수 있는 방법의 수를 return하는 solution함수를 완성해주세요. 제한사항 퀸(Queen)은 가로, 세로, 대각선으로 이동할 수 있습니다. n은 12이하의 자연수 입니다. 입출력 예 n result 4 2 입출력 예 설명 입출력 예 #1 문제의 예시와 같습니다.",normal,Simulation
550,"JadenCase란 모든 단어의 첫 문자가 대문자이고, 그 외의 알파벳은 소문자인 문자열입니다. 단, 첫 문자가 알파벳이 아닐 때에는 이어지는 알파벳은 소문자로 쓰면 됩니다. (첫 번째 입출력 예 참고) 문자열 s가 주어졌을 때, s를 JadenCase로 바꾼 문자열을 리턴하는 함수, solution을 완성해주세요. 제한 조건 s는 길이 1 이상 200 이하인 문자열입니다. s는 알파벳과 숫자, 공백문자("" "")로 이루어져 있습니다. 숫자는 단어의 첫 문자로만 나옵니다. 숫자로만 이루어진 단어는 없습니다. 공백문자가 연속해서 나올 수 있습니다. 입출력 예 s return ""3people unFollowed me"" ""3people Unfollowed Me"" ""for the last week"" ""For The Last Week"" ※ 공지 - 2022년 1월 14일 제한 조건과 테스트 케이스가 추가되었습니다.",normal,String
551,"행렬의 덧셈은 행과 열의 크기가 같은 두 행렬의 같은 행, 같은 열의 값을 서로 더한 결과가 됩니다. 2개의 행렬 arr1과 arr2를 입력받아, 행렬 덧셈의 결과를 반환하는 함수, solution을 완성해주세요. 제한 조건 행렬 arr1, arr2의 행과 열의 길이는 500을 넘지 않습니다. 입출력 예 arr1 arr2 return [[1,2],[2,3]] [[3,4],[5,6]] [[4,6],[7,9]] [[1],[2]] [[3],[4]] [[4],[6]]",easy,Design
552,"2차원 행렬 arr1과 arr2를 입력받아, arr1에 arr2를 곱한 결과를 반환하는 함수, solution을 완성해주세요. 제한 조건 행렬 arr1, arr2의 행과 열의 길이는 2 이상 100 이하입니다. 행렬 arr1, arr2의 원소는 -10 이상 20 이하인 자연수입니다. 곱할 수 있는 배열만 주어집니다. 입출력 예 arr1 arr2 return [[1, 4], [3, 2], [4, 1]] [[3, 3], [3, 3]] [[15, 15], [15, 15], [15, 15]] [[2, 3, 2], [4, 2, 4], [3, 1, 4]] [[5, 4, 3], [2, 4, 1], [3, 1, 1]] [[22, 22, 11], [36, 28, 18], [29, 20, 14]]",normal,Array
553,"프로그래머스 모바일은 개인정보 보호를 위해 고지서를 보낼 때 고객들의 전화번호의 일부를 가립니다. 전화번호가 문자열 phone_number로 주어졌을 때, 전화번호의 뒷 4자리를 제외한 나머지 숫자를 전부 *으로 가린 문자열을 리턴하는 함수, solution을 완성해주세요. 제한 조건 phone_number는 길이 4 이상, 20이하인 문자열입니다. 입출력 예 phone_number return ""01033334444"" ""*******4444"" ""027778888"" ""*****8888""",easy,String
554,"양의 정수 x가 하샤드 수이려면 x의 자릿수의 합으로 x가 나누어져야 합니다. 예를 들어 18의 자릿수 합은 1+8=9이고, 18은 9로 나누어 떨어지므로 18은 하샤드 수입니다. 자연수 x를 입력받아 x가 하샤드 수인지 아닌지 검사하는 함수, solution을 완성해주세요. 제한 조건 x는 1 이상, 10000 이하인 정수입니다. 입출력 예 x return 10 true 12 true 11 false 13 false 입출력 예 설명 입출력 예 #1 10의 모든 자릿수의 합은 1입니다. 10은 1로 나누어 떨어지므로 10은 하샤드 수입니다. 입출력 예 #2 12의 모든 자릿수의 합은 3입니다. 12는 3으로 나누어 떨어지므로 12는 하샤드 수입니다. 입출력 예 #3 11의 모든 자릿수의 합은 2입니다. 11은 2로 나누어 떨어지지 않으므로 11는 하샤드 수가 아닙니다. 입출력 예 #4 13의 모든 자릿수의 합은 4입니다. 13은 4로 나누어 떨어지지 않으므로 13은 하샤드 수가 아닙니다. ※ 공지 - 2023년 5월 27일 문제 지문 오탈자 수정되었습니다.",easy,Math
555,"하노이 탑(Tower of Hanoi)은 퍼즐의 일종입니다. 세 개의 기둥과 이 기동에 꽂을 수 있는 크기가 다양한 원판들이 있고, 퍼즐을 시작하기 전에는 한 기둥에 원판들이 작은 것이 위에 있도록 순서대로 쌓여 있습니다. 게임의 목적은 다음 두 가지 조건을 만족시키면서, 한 기둥에 꽂힌 원판들을 그 순서 그대로 다른 기둥으로 옮겨서 다시 쌓는 것입니다. 한 번에 하나의 원판만 옮길 수 있습니다. 큰 원판이 작은 원판 위에 있어서는 안됩니다. 하노이 탑의 세 개의 기둥을 왼쪽 부터 1번, 2번, 3번이라고 하겠습니다. 1번에는 n개의 원판이 있고 이 n개의 원판을 3번 원판으로 최소 횟수로 옮기려고 합니다. 1번 기둥에 있는 원판의 개수 n이 매개변수로 주어질 때, n개의 원판을 3번 원판으로 최소로 옮기는 방법을 return하는 solution를 완성해주세요. 제한사항 n은 15이하의 자연수 입니다. 입출력 예 n result 2 [ [1,2], [1,3], [2,3] ] 입출력 예 설명 입출력 예 #1 다음과 같이 옮길 수 있습니다.",normal,Math
556,"피보나치 수는 F(0) = 0, F(1) = 1일 때, 1 이상의 n에 대하여 F(n) = F(n-1) + F(n-2) 가 적용되는 수 입니다. 예를들어 F(2) = F(0) + F(1) = 0 + 1 = 1 F(3) = F(1) + F(2) = 1 + 1 = 2 F(4) = F(2) + F(3) = 1 + 2 = 3 F(5) = F(3) + F(4) = 2 + 3 = 5 와 같이 이어집니다. 2 이상의 n이 입력되었을 때, n번째 피보나치 수를 1234567으로 나눈 나머지를 리턴하는 함수, solution을 완성해 주세요. 제한 사항 n은 2 이상 100,000 이하인 자연수입니다. 입출력 예 n return 3 2 5 5 입출력 예 설명 피보나치수는 0번째부터 0, 1, 1, 2, 3, 5, ... 와 같이 이어집니다. 문제가 잘 안풀린다면😢 힌트가 필요한가요? [코딩테스트 연습 힌트 모음집]으로 오세요! → 클릭",normal,Math
557,"정수를 담고 있는 배열 arr의 평균값을 return하는 함수, solution을 완성해보세요. 제한사항 arr은 길이 1 이상, 100 이하인 배열입니다. arr의 원소는 -10,000 이상 10,000 이하인 정수입니다. 입출력 예 arr return [1,2,3,4] 2.5 [5,5] 5",easy,Array
558,"1937년 Collatz란 사람에 의해 제기된 이 추측은, 주어진 수가 1이 될 때까지 다음 작업을 반복하면, 모든 수를 1로 만들 수 있다는 추측입니다. 작업은 다음과 같습니다. 1-1. 입력된 수가 짝수라면 2로 나눕니다. 1-2. 입력된 수가 홀수라면 3을 곱하고 1을 더합니다. 2. 결과로 나온 수에 같은 작업을 1이 될 때까지 반복합니다. 예를 들어, 주어진 수가 6이라면 6 → 3 → 10 → 5 → 16 → 8 → 4 → 2 → 1 이 되어 총 8번 만에 1이 됩니다. 위 작업을 몇 번이나 반복해야 하는지 반환하는 함수, solution을 완성해 주세요. 단, 주어진 수가 1인 경우에는 0을, 작업을 500번 반복할 때까지 1이 되지 않는다면 –1을 반환해 주세요. 제한 사항 입력된 수, num은 1 이상 8,000,000 미만인 정수입니다. 입출력 예 n result 6 8 16 4 626331 -1 입출력 예 설명 입출력 예 #1 문제의 설명과 같습니다. 입출력 예 #2 16 → 8 → 4 → 2 → 1 이 되어 총 4번 만에 1이 됩니다. 입출력 예 #3 626331은 500번을 시도해도 1이 되지 못하므로 -1을 리턴해야 합니다. ※ 공지 - 2022년 6월 10일 다음과 같이 지문이 일부 수정되었습니다. 주어진 수가 1인 경우에 대한 조건 추가",easy,Math
559,"크기가 a by b인 행렬과 크기가 b by c 인 행렬이 있을 때, 두 행렬을 곱하기 위해서는 총 a x b x c 번 곱셈해야합니다. 예를 들어서 크기가 5 by 3인 행렬과 크기가 3 by 2인 행렬을 곱할때는 총 5 x 3 x 2 = 30번의 곱하기 연산을 해야 합니다. 행렬이 2개일 때는 연산 횟수가 일정 하지만, 행렬의 개수가 3개 이상일 때는 연산의 순서에 따라서 곱하기 연산의 횟수가 바뀔 수 있습니다. 예를 들어서 크기가 5 by 3인 행렬 A, 크기가 3 by 10인 행렬 B, 크기가 10 by 6인 행렬 C가 있을 때, 순서대로 A와 B를 먼저 곱하고, 그 결과에 C를 곱하면 A와 B행렬을 곱할 때 150번을, AB 에 C를 곱할 때 300번을 연산을 해서 총 450번의 곱하기 연산을 합니다. 하지만, B와 C를 먼저 곱한 다음 A 와 BC를 곱하면 180 + 90 = 270번 만에 연산이 끝납니다. 각 행렬의 크기 matrix_sizes 가 매개변수로 주어 질 때, 모든 행렬을 곱하기 위한 최소 곱셈 연산의 수를 return하는 solution 함수를 완성해 주세요. 제한 사항 행렬의 개수는 3이상 200이하의 자연수입니다. 각 행렬의 행과 열의 크기는 200이하의 자연수 입니다. 계산을 할 수 없는 행렬은 입력으로 주어지지 않습니다. 입출력 예 matrix_sizes result [[5,3],[3,10],[10,6]] 270 입출력 예 설명 입출력 예#1 문제의 예시와 같습니다. ※ 공지 - 2025년 3월 19일 테스트케이스가 추가되었습니다.",normal,Math
560,"길이가 같은 배열 A, B 두개가 있습니다. 각 배열은 자연수로 이루어져 있습니다. 배열 A, B에서 각각 한 개의 숫자를 뽑아 두 수를 곱합니다. 이러한 과정을 배열의 길이만큼 반복하며, 두 수를 곱한 값을 누적하여 더합니다. 이때 최종적으로 누적된 값이 최소가 되도록 만드는 것이 목표입니다. (단, 각 배열에서 k번째 숫자를 뽑았다면 다음에 k번째 숫자는 다시 뽑을 수 없습니다.) 예를 들어 A = [1, 4, 2] , B = [5, 4, 4] 라면 A에서 첫번째 숫자인 1, B에서 첫번째 숫자인 5를 뽑아 곱하여 더합니다. (누적된 값 : 0 + 5(1x5) = 5) A에서 두번째 숫자인 4, B에서 세번째 숫자인 4를 뽑아 곱하여 더합니다. (누적된 값 : 5 + 16(4x4) = 21) A에서 세번째 숫자인 2, B에서 두번째 숫자인 4를 뽑아 곱하여 더합니다. (누적된 값 : 21 + 8(2x4) = 29) 즉, 이 경우가 최소가 되므로 29를 return 합니다. 배열 A, B가 주어질 때 최종적으로 누적된 최솟값을 return 하는 solution 함수를 완성해 주세요. 제한사항 배열 A, B의 크기 : 1,000 이하의 자연수 배열 A, B의 원소의 크기 : 1,000 이하의 자연수 입출력 예 A B answer [1, 4, 2] [5, 4, 4] 29 [1,2] [3,4] 10 입출력 예 설명 입출력 예 #1 문제의 예시와 같습니다. 입출력 예 #2 A에서 첫번째 숫자인 1, B에서 두번째 숫자인 4를 뽑아 곱하여 더합니다. (누적된 값 : 4) 다음, A에서 두번째 숫자인 2, B에서 첫번째 숫자인 3을 뽑아 곱하여 더합니다. (누적된 값 : 4 + 6 = 10) 이 경우가 최소이므로 10을 return 합니다.",normal,Array
561,"두 수를 입력받아 두 수의 최대공약수와 최소공배수를 반환하는 함수, solution을 완성해 보세요. 배열의 맨 앞에 최대공약수, 그다음 최소공배수를 넣어 반환하면 됩니다. 예를 들어 두 수 3, 12의 최대공약수는 3, 최소공배수는 12이므로 solution(3, 12)는 [3, 12]를 반환해야 합니다. 제한 사항 두 수는 1이상 1000000이하의 자연수입니다. 입출력 예 n m return 3 12 [3, 12] 2 5 [1, 10] 입출력 예 설명 입출력 예 #1 위의 설명과 같습니다. 입출력 예 #2 자연수 2와 5의 최대공약수는 1, 최소공배수는 10이므로 [1, 10]을 리턴해야 합니다.",easy,Array
562,"문자열 s에는 공백으로 구분된 숫자들이 저장되어 있습니다. str에 나타나는 숫자 중 최소값과 최대값을 찾아 이를 ""(최소값) (최대값)""형태의 문자열을 반환하는 함수, solution을 완성하세요. 예를들어 s가 ""1 2 3 4""라면 ""1 4""를 리턴하고, ""-1 -2 -3 -4""라면 ""-4 -1""을 리턴하면 됩니다. 제한 조건 s에는 둘 이상의 정수가 공백으로 구분되어 있습니다. 입출력 예 s return ""1 2 3 4"" ""1 4"" ""-1 -2 -3 -4"" ""-4 -1"" ""-1 -1"" ""-1 -1""",normal,String
563,"자연수 n 개로 이루어진 중복 집합(multi set, 편의상 이후에는 ""집합""으로 통칭) 중에 다음 두 조건을 만족하는 집합을 최고의 집합이라고 합니다. 각 원소의 합이 S가 되는 수의 집합 위 조건을 만족하면서 각 원소의 곱 이 최대가 되는 집합 예를 들어서 자연수 2개로 이루어진 집합 중 합이 9가 되는 집합은 다음과 같이 4개가 있습니다. { 1, 8 }, { 2, 7 }, { 3, 6 }, { 4, 5 } 그중 각 원소의 곱이 최대인 { 4, 5 }가 최고의 집합입니다. 집합의 원소의 개수 n과 모든 원소들의 합 s가 매개변수로 주어질 때, 최고의 집합을 return 하는 solution 함수를 완성해주세요. 제한사항 최고의 집합은 오름차순으로 정렬된 1차원 배열(list, vector) 로 return 해주세요. 만약 최고의 집합이 존재하지 않는 경우에 크기가 1인 1차원 배열(list, vector) 에 -1 을 채워서 return 해주세요. 자연수의 개수 n은 1 이상 10,000 이하의 자연수입니다. 모든 원소들의 합 s는 1 이상, 100,000,000 이하의 자연수입니다. 입출력 예 n s result 2 9 [4, 5] 2 1 [-1] 2 8 [4, 4] 입출력 예 설명 입출력 예#1 문제의 예시와 같습니다. 입출력 예#2 자연수 2개를 가지고는 합이 1인 집합을 만들 수 없습니다. 따라서 -1이 들어있는 배열을 반환합니다. 입출력 예#3 자연수 2개로 이루어진 집합 중 원소의 합이 8인 집합은 다음과 같습니다. { 1, 7 }, { 2, 6 }, { 3, 5 }, { 4, 4 } 그중 각 원소의 곱이 최대인 { 4, 4 }가 최고의 집합입니다.",normal,Array
564,"정수 num이 짝수일 경우 ""Even""을 반환하고 홀수인 경우 ""Odd""를 반환하는 함수, solution을 완성해주세요. 제한 조건 num은 int 범위의 정수입니다. 0은 짝수입니다. 입출력 예 num return 3 ""Odd"" 4 ""Even""",easy,Design
565,"n명의 사람이 일렬로 줄을 서고 있습니다. n명의 사람들에게는 각각 1번부터 n번까지 번호가 매겨져 있습니다. n명이 사람을 줄을 서는 방법은 여러가지 방법이 있습니다. 예를 들어서 3명의 사람이 있다면 다음과 같이 6개의 방법이 있습니다. [1, 2, 3] [1, 3, 2] [2, 1, 3] [2, 3, 1] [3, 1, 2] [3, 2, 1] 사람의 수 n과, 자연수 k가 주어질 때, 사람을 나열 하는 방법을 사전 순으로 나열 했을 때, k번째 방법을 return하는 solution 함수를 완성해주세요. 제한사항 n은 20이하의 자연수 입니다. k는 n! 이하의 자연수 입니다. 입출력 예 n k result 3 5 [3,1,2] 입출력 예시 설명 입출력 예 #1 문제의 예시와 같습니다.",normal,Design
566,"정수를 저장한 배열, arr 에서 가장 작은 수를 제거한 배열을 리턴하는 함수, solution을 완성해주세요. 단, 리턴하려는 배열이 빈 배열인 경우엔 배열에 -1을 채워 리턴하세요. 예를들어 arr이 [4,3,2,1]인 경우는 [4,3,2]를 리턴 하고, [10]면 [-1]을 리턴 합니다. 제한 조건 arr은 길이 1 이상인 배열입니다. 인덱스 i, j에 대해 i ≠ j이면 arr[i] ≠ arr[j] 입니다. 입출력 예 arr return [4,3,2,1] [4,3,2] [10] [-1]",easy,Array
567,"임의의 양의 정수 n에 대해, n이 어떤 양의 정수 x의 제곱인지 아닌지 판단하려 합니다. n이 양의 정수 x의 제곱이라면 x+1의 제곱을 리턴하고, n이 양의 정수 x의 제곱이 아니라면 -1을 리턴하는 함수를 완성하세요. 제한 사항 n은 1이상, 50000000000000 이하인 양의 정수입니다. 입출력 예 n return 121 144 3 -1 입출력 예 설명 입출력 예#1 121은 양의 정수 11의 제곱이므로, (11+1)를 제곱한 144를 리턴합니다. 입출력 예#2 3은 양의 정수의 제곱이 아니므로, -1을 리턴합니다.",easy,Math
568,함수 solution은 정수 n을 매개변수로 입력받습니다. n의 각 자릿수를 큰것부터 작은 순으로 정렬한 새로운 정수를 리턴해주세요. 예를들어 n이 118372면 873211을 리턴하면 됩니다. 제한 조건 n은 1이상 8000000000 이하인 자연수입니다. 입출력 예 n return 118372 873211,easy,Sorting
569,"자연수 n을 뒤집어 각 자리 숫자를 원소로 가지는 배열 형태로 리턴해주세요. 예를들어 n이 12345이면 [5,4,3,2,1]을 리턴합니다. 제한 조건 n은 10,000,000,000이하인 자연수입니다. 입출력 예 n return 12345 [5,4,3,2,1]",easy,Array
570,"자연수 N이 주어지면, N의 각 자릿수의 합을 구해서 return 하는 solution 함수를 만들어 주세요. 예를들어 N = 123이면 1 + 2 + 3 = 6을 return 하면 됩니다. 제한사항 N의 범위 : 100,000,000 이하의 자연수 입출력 예 N answer 123 6 987 24 입출력 예 설명 입출력 예 #1 문제의 예시와 같습니다. 입출력 예 #2 9 + 8 + 7 = 24이므로 24를 return 하면 됩니다.",easy,Math
571,"문자열 s는 한 개 이상의 단어로 구성되어 있습니다. 각 단어는 하나 이상의 공백문자로 구분되어 있습니다. 각 단어의 짝수번째 알파벳은 대문자로, 홀수번째 알파벳은 소문자로 바꾼 문자열을 리턴하는 함수, solution을 완성하세요. 제한 사항 문자열 전체의 짝/홀수 인덱스가 아니라, 단어(공백을 기준)별로 짝/홀수 인덱스를 판단해야합니다. 첫 번째 글자는 0번째 인덱스로 보아 짝수번째 알파벳으로 처리해야 합니다. 입출력 예 s return ""try hello world"" ""TrY HeLlO WoRlD"" 입출력 예 설명 ""try hello world""는 세 단어 ""try"", ""hello"", ""world""로 구성되어 있습니다. 각 단어의 짝수번째 문자를 대문자로, 홀수번째 문자를 소문자로 바꾸면 ""TrY"", ""HeLlO"", ""WoRlD""입니다. 따라서 ""TrY HeLlO WoRlD"" 를 리턴합니다. 문제가 잘 안풀린다면😢 힌트가 필요한가요? [코딩테스트 연습 힌트 모음집]으로 오세요! → 클릭",easy,Array
572,"올바른 괄호란 (())나 ()와 같이 올바르게 모두 닫힌 괄호를 의미합니다. )(나 ())() 와 같은 괄호는 올바르지 않은 괄호가 됩니다. 괄호 쌍의 개수 n이 주어질 때, n개의 괄호 쌍으로 만들 수 있는 모든 가능한 괄호 문자열의 갯수를 반환하는 함수 solution을 완성해 주세요. 제한사항 괄호 쌍의 개수 N : 1 ≤ n ≤ 14, N은 정수 입출력 예 n result 2 2 3 5 입출력 예 설명 입출력 예 #1 2개의 괄호쌍으로 [ ""(())"", ""()()"" ]의 2가지를 만들 수 있습니다. 입출력 예 #2 3개의 괄호쌍으로 [ ""((()))"", ""(()())"", ""(())()"", ""()(())"", ""()()()"" ]의 5가지를 만들 수 있습니다.",hard,String
573,"정수 n을 입력받아 n의 약수를 모두 더한 값을 리턴하는 함수, solution을 완성해주세요. 제한 사항 n은 0 이상 3000이하인 정수입니다. 입출력 예 n return 12 28 5 6 입출력 예 설명 입출력 예 #1 12의 약수는 1, 2, 3, 4, 6, 12입니다. 이를 모두 더하면 28입니다. 입출력 예 #2 5의 약수는 1, 5입니다. 이를 모두 더하면 6입니다.",easy,Design
574,"회사원 Demi는 가끔은 야근을 하는데요, 야근을 하면 야근 피로도가 쌓입니다. 야근 피로도는 야근을 시작한 시점에서 남은 일의 작업량을 제곱하여 더한 값입니다. Demi는 N시간 동안 야근 피로도를 최소화하도록 일할 겁니다.Demi가 1시간 동안 작업량 1만큼을 처리할 수 있다고 할 때, 퇴근까지 남은 N 시간과 각 일에 대한 작업량 works에 대해 야근 피로도를 최소화한 값을 리턴하는 함수 solution을 완성해주세요. 제한 사항 works는 길이 1 이상, 20,000 이하인 배열입니다. works의 원소는 50000 이하인 자연수입니다. n은 1,000,000 이하인 자연수입니다. 입출력 예 works n result [4, 3, 3] 4 12 [2, 1, 2] 1 6 [1,1] 3 0 입출력 예 설명 입출력 예 #1 n=4 일 때, 남은 일의 작업량이 [4, 3, 3] 이라면 야근 지수를 최소화하기 위해 4시간동안 일을 한 결과는 [2, 2, 2]입니다. 이 때 야근 지수는 22 + 22 + 22 = 12 입니다. 입출력 예 #2 n=1일 때, 남은 일의 작업량이 [2,1,2]라면 야근 지수를 최소화하기 위해 1시간동안 일을 한 결과는 [1,1,2]입니다. 야근지수는 12 + 12 + 22 = 6입니다. 입출력 예 #3 남은 작업량이 없으므로 피로도는 0입니다.",normal,Array
575,"어떤 문장의 각 알파벳을 일정한 거리만큼 밀어서 다른 알파벳으로 바꾸는 암호화 방식을 시저 암호라고 합니다. 예를 들어 ""AB""는 1만큼 밀면 ""BC""가 되고, 3만큼 밀면 ""DE""가 됩니다. ""z""는 1만큼 밀면 ""a""가 됩니다. 문자열 s와 거리 n을 입력받아 s를 n만큼 민 암호문을 만드는 함수, solution을 완성해 보세요. 제한 조건 공백은 아무리 밀어도 공백입니다. s는 알파벳 소문자, 대문자, 공백으로만 이루어져 있습니다. s의 길이는 8000이하입니다. n은 1 이상, 25이하인 자연수입니다. 입출력 예 s n result ""AB"" 1 ""BC"" ""z"" 1 ""a"" ""a B z"" 4 ""e F d""",easy,String
576,"문자열 s를 숫자로 변환한 결과를 반환하는 함수, solution을 완성하세요. 제한 조건 s의 길이는 1 이상 5이하입니다. s의 맨앞에는 부호(+, -)가 올 수 있습니다. s는 부호와 숫자로만 이루어져있습니다. s는 ""0""으로 시작하지 않습니다. 입출력 예 예를들어 str이 ""1234""이면 1234를 반환하고, ""-1234""이면 -1234를 반환하면 됩니다. str은 부호(+,-)와 숫자로만 구성되어 있고, 잘못된 값이 입력되는 경우는 없습니다.",easy,String
577,"Finn은 요즘 수학공부에 빠져 있습니다. 수학 공부를 하던 Finn은 자연수 n을 연속한 자연수들로 표현 하는 방법이 여러개라는 사실을 알게 되었습니다. 예를들어 15는 다음과 같이 4가지로 표현 할 수 있습니다. 1 + 2 + 3 + 4 + 5 = 15 4 + 5 + 6 = 15 7 + 8 = 15 15 = 15 자연수 n이 매개변수로 주어질 때, 연속된 자연수들로 n을 표현하는 방법의 수를 return하는 solution를 완성해주세요. 제한사항 n은 10,000 이하의 자연수 입니다. 입출력 예 n result 15 4 입출력 예 설명 입출력 예#1 문제의 예시와 같습니다. ※ 공지 - 2022년 3월 11일 테스트케이스가 추가되었습니다.",normal,Math
578,"그렙시에는 숫자 0이 적힌 블록들이 설치된 도로에 다른 숫자가 적힌 블록들을 설치하기로 하였습니다. 숫자 블록을 설치하는 규칙은 다음과 같습니다. 블록에 적힌 번호가 n 일 때, 가장 첫 블록은 n * 2번째 위치에 설치합니다. 그 다음은 n * 3, 그 다음은 n * 4, ...위치에 설치합니다. 기존에 설치된 블록은 빼고 새로운 블록을 집어넣습니다. 블록은 1이 적힌 블록부터 숫자를 1씩 증가시키며 순서대로 설치합니다. 예를 들어 1이 적힌 블록은 2, 3, 4, 5, ... 인 위치에 우선 설치합니다. 그 다음 2가 적힌 블록은 4, 6, 8, 10, ... 인 위치에 설치하고, 3이 적힌 블록은 6, 9, 12... 인 위치에 설치합니다. 이렇게 3이 적힌 블록까지 설치하고 나면 첫 10개의 블록에 적힌 번호는 [0, 1, 1, 2, 1, 3, 1, 2, 3, 2]가 됩니다. 그렙시는 길이가 1,000,000,000인 도로에 1부터 10,000,000까지의 숫자가 적힌 블록들을 이용해 위의 규칙대로 모두 설치 했습니다. 그렙시의 시장님은 특정 구간에 어떤 블록이 깔려 있는지 알고 싶습니다. 구간을 나타내는 두 정수 begin, end 가 매개변수로 주어 질 때, 그 구간에 깔려 있는 블록의 숫자 배열을 return하는 solution 함수를 완성해 주세요. 제한 사항 1 ≤ begin ≤ end ≤ 1,000,000,000 end - begin ≤ 5,000 입출력 예 begin end result 1 10 [0, 1, 1, 2, 1, 3, 1, 4, 3, 5] 입출력 예 설명 입출력 예 #1 다음과 같이 블럭이 깔리게 됩니다. ※ 공지 - 2019년 4월 07일 테스트케이스가 변경되었습니다. ※ 공지 - 2023년 2월 09일 지문과 테스트 케이스가 수정되었습니다. 기존에 통과되었던 코드가 통과되지 않을 수 있습니다.",normal,Array
579,"길이가 n이고, ""수박수박수박수....""와 같은 패턴을 유지하는 문자열을 리턴하는 함수, solution을 완성하세요. 예를들어 n이 4이면 ""수박수박""을 리턴하고 3이라면 ""수박수""를 리턴하면 됩니다. 제한 조건 n은 길이 10,000이하인 자연수입니다. 입출력 예 n return 3 ""수박수"" 4 ""수박수박""",easy,String
580,"1부터 입력받은 숫자 n 사이에 있는 소수의 개수를 반환하는 함수, solution을 만들어 보세요. 소수는 1과 자기 자신으로만 나누어지는 수를 의미합니다. (1은 소수가 아닙니다.) 제한 조건 n은 2이상 1000000이하의 자연수입니다. 입출력 예 n result 10 4 5 3 입출력 예 설명 입출력 예 #1 1부터 10 사이의 소수는 [2,3,5,7] 4개가 존재하므로 4를 반환 입출력 예 #2 1부터 5 사이의 소수는 [2,3,5] 3개가 존재하므로 3를 반환",easy,Math
581,"처리해야 할 동일한 작업이 n 개가 있고, 이를 처리하기 위한 CPU가 있습니다. 이 CPU는 다음과 같은 특징이 있습니다. CPU에는 여러 개의 코어가 있고, 코어별로 한 작업을 처리하는 시간이 다릅니다. 한 코어에서 작업이 끝나면 작업이 없는 코어가 바로 다음 작업을 수행합니다. 2개 이상의 코어가 남을 경우 앞의 코어부터 작업을 처리 합니다. 처리해야 될 작업의 개수 n과, 각 코어의 처리시간이 담긴 배열 cores 가 매개변수로 주어질 때, 마지막 작업을 처리하는 코어의 번호를 return 하는 solution 함수를 완성해주세요. 제한 사항 코어의 수는 10,000 이하 2이상 입니다. 코어당 작업을 처리하는 시간은 10,000이하 입니다. 처리해야 하는 일의 개수는 50,000개를 넘기지 않습니다. 입출력 예 n cores result 6 [1,2,3] 2 입출력 예 설명 입출력 예 #1 처음 3개의 작업은 각각 1,2,3번에 들어가고, 1시간 뒤 1번 코어에 4번째 작업,다시 1시간 뒤 1,2번 코어에 5,6번째 작업이 들어가므로 2를 반환해주면 됩니다.",normal,Array
582,"String형 배열 seoul의 element중 ""Kim""의 위치 x를 찾아, ""김서방은 x에 있다""는 String을 반환하는 함수, solution을 완성하세요. seoul에 ""Kim""은 오직 한 번만 나타나며 잘못된 값이 입력되는 경우는 없습니다. 제한 사항 seoul은 길이 1 이상, 1000 이하인 배열입니다. seoul의 원소는 길이 1 이상, 20 이하인 문자열입니다. ""Kim""은 반드시 seoul 안에 포함되어 있습니다. 입출력 예 seoul return [""Jane"", ""Kim""] ""김서방은 1에 있다""",easy,Array
583,"문자열 s의 길이가 4 혹은 6이고, 숫자로만 구성돼있는지 확인해주는 함수, solution을 완성하세요. 예를 들어 s가 ""a234""이면 False를 리턴하고 ""1234""라면 True를 리턴하면 됩니다. 제한 사항 s는 길이 1 이상, 길이 8 이하인 문자열입니다. s는 영문 알파벳 대소문자 또는 0부터 9까지 숫자로 이루어져 있습니다. 입출력 예 s return ""a234"" false ""1234"" true 문제가 잘 안풀린다면😢 힌트가 필요한가요? [코딩테스트 연습 힌트 모음집]으로 오세요! → 클릭 공지 - 2022년 7월 22일 테스트케이스가 추가되었습니다. 공지 - 2022년 7월 22일 제한 사항이 추가되었습니다.",easy,String
584,"문자열 s에 나타나는 문자를 큰것부터 작은 순으로 정렬해 새로운 문자열을 리턴하는 함수, solution을 완성해주세요. s는 영문 대소문자로만 구성되어 있으며, 대문자는 소문자보다 작은 것으로 간주합니다. 제한 사항 str은 길이 1 이상인 문자열입니다. 입출력 예 s return ""Zbcdefg"" ""gfedcbZ""",easy,String
585,"대문자와 소문자가 섞여있는 문자열 s가 주어집니다. s에 'p'의 개수와 'y'의 개수를 비교해 같으면 True, 다르면 False를 return 하는 solution를 완성하세요. 'p', 'y' 모두 하나도 없는 경우는 항상 True를 리턴합니다. 단, 개수를 비교할 때 대문자와 소문자는 구별하지 않습니다. 예를 들어 s가 ""pPoooyY""면 true를 return하고 ""Pyy""라면 false를 return합니다. 제한사항 문자열 s의 길이 : 50 이하의 자연수 문자열 s는 알파벳으로만 이루어져 있습니다. 입출력 예 s answer ""pPoooyY"" true ""Pyy"" false 입출력 예 설명 입출력 예 #1 'p'의 개수 2개, 'y'의 개수 2개로 같으므로 true를 return 합니다. 입출력 예 #2 'p'의 개수 1개, 'y'의 개수 2개로 다르므로 false를 return 합니다. ※ 공지 - 2021년 8월 23일 테스트케이스가 추가되었습니다.",easy,String
586,"문자열로 구성된 리스트 strings와, 정수 n이 주어졌을 때, 각 문자열의 인덱스 n번째 글자를 기준으로 오름차순 정렬하려 합니다. 예를 들어 strings가 [""sun"", ""bed"", ""car""]이고 n이 1이면 각 단어의 인덱스 1의 문자 ""u"", ""e"", ""a""로 strings를 정렬합니다. 제한 조건 strings는 길이 1 이상, 50이하인 배열입니다. strings의 원소는 소문자 알파벳으로 이루어져 있습니다. strings의 원소는 길이 1 이상, 100이하인 문자열입니다. 모든 strings의 원소의 길이는 n보다 큽니다. 인덱스 1의 문자가 같은 문자열이 여럿 일 경우, 사전순으로 앞선 문자열이 앞쪽에 위치합니다. 입출력 예 strings n return [""sun"", ""bed"", ""car""] 1 [""car"", ""bed"", ""sun""] [""abce"", ""abcd"", ""cdx""] 2 [""abcd"", ""abce"", ""cdx""] 입출력 예 설명 입출력 예 1 ""sun"", ""bed"", ""car""의 1번째 인덱스 값은 각각 ""u"", ""e"", ""a"" 입니다. 이를 기준으로 strings를 정렬하면 [""car"", ""bed"", ""sun""] 입니다. 입출력 예 2 ""abce""와 ""abcd"", ""cdx""의 2번째 인덱스 값은 ""c"", ""c"", ""x""입니다. 따라서 정렬 후에는 ""cdx""가 가장 뒤에 위치합니다. ""abce""와 ""abcd""는 사전순으로 정렬하면 ""abcd""가 우선하므로, 답은 [""abcd"", ""abce"", ""cdx""] 입니다.",easy,Array
587,"효진이는 멀리 뛰기를 연습하고 있습니다. 효진이는 한번에 1칸, 또는 2칸을 뛸 수 있습니다. 칸이 총 4개 있을 때, 효진이는 (1칸, 1칸, 1칸, 1칸) (1칸, 2칸, 1칸) (1칸, 1칸, 2칸) (2칸, 1칸, 1칸) (2칸, 2칸) 의 5가지 방법으로 맨 끝 칸에 도달할 수 있습니다. 멀리뛰기에 사용될 칸의 수 n이 주어질 때, 효진이가 끝에 도달하는 방법이 몇 가지인지 알아내, 여기에 1234567를 나눈 나머지를 리턴하는 함수, solution을 완성하세요. 예를 들어 4가 입력된다면, 5를 return하면 됩니다. 제한 사항 n은 1 이상, 2000 이하인 정수입니다. 입출력 예 n result 4 5 3 3 입출력 예 설명 입출력 예 #1 위에서 설명한 내용과 같습니다. 입출력 예 #2 (2칸, 1칸) (1칸, 2칸) (1칸, 1칸, 1칸) 총 3가지 방법으로 멀리 뛸 수 있습니다.",normal,Math
588,"땅따먹기 게임을 하려고 합니다. 땅따먹기 게임의 땅(land)은 총 N행 4열로 이루어져 있고, 모든 칸에는 점수가 쓰여 있습니다. 1행부터 땅을 밟으며 한 행씩 내려올 때, 각 행의 4칸 중 한 칸만 밟으면서 내려와야 합니다. 단, 땅따먹기 게임에는 한 행씩 내려올 때, 같은 열을 연속해서 밟을 수 없는 특수 규칙이 있습니다. 예를 들면, | 1 | 2 | 3 | 5 | | 5 | 6 | 7 | 8 | | 4 | 3 | 2 | 1 | 로 땅이 주어졌다면, 1행에서 네번째 칸 (5)를 밟았으면, 2행의 네번째 칸 (8)은 밟을 수 없습니다. 마지막 행까지 모두 내려왔을 때, 얻을 수 있는 점수의 최대값을 return하는 solution 함수를 완성해 주세요. 위 예의 경우, 1행의 네번째 칸 (5), 2행의 세번째 칸 (7), 3행의 첫번째 칸 (4) 땅을 밟아 16점이 최고점이 되므로 16을 return 하면 됩니다. 제한사항 행의 개수 N : 100,000 이하의 자연수 열의 개수는 4개이고, 땅(land)은 2차원 배열로 주어집니다. 점수 : 100 이하의 자연수 입출력 예 land answer [[1,2,3,5],[5,6,7,8],[4,3,2,1]] 16 입출력 예 설명 입출력 예 #1 문제의 예시와 같습니다.",normal,Array
589,"두 정수 a, b가 주어졌을 때 a와 b 사이에 속한 모든 정수의 합을 리턴하는 함수, solution을 완성하세요. 예를 들어 a = 3, b = 5인 경우, 3 + 4 + 5 = 12이므로 12를 리턴합니다. 제한 조건 a와 b가 같은 경우는 둘 중 아무 수나 리턴하세요. a와 b는 -10,000,000 이상 10,000,000 이하인 정수입니다. a와 b의 대소관계는 정해져있지 않습니다. 입출력 예 a b return 3 5 12 3 3 3 5 3 12",easy,Math
590,"자연수 n이 주어졌을 때, n의 다음 큰 숫자는 다음과 같이 정의 합니다. 조건 1. n의 다음 큰 숫자는 n보다 큰 자연수 입니다. 조건 2. n의 다음 큰 숫자와 n은 2진수로 변환했을 때 1의 갯수가 같습니다. 조건 3. n의 다음 큰 숫자는 조건 1, 2를 만족하는 수 중 가장 작은 수 입니다. 예를 들어서 78(1001110)의 다음 큰 숫자는 83(1010011)입니다. 자연수 n이 매개변수로 주어질 때, n의 다음 큰 숫자를 return 하는 solution 함수를 완성해주세요. 제한 사항 n은 1,000,000 이하의 자연수 입니다. 입출력 예 n result 78 83 15 23 입출력 예 설명 입출력 예#1 문제 예시와 같습니다. 입출력 예#2 15(1111)의 다음 큰 숫자는 23(10111)입니다.",normal,Math
591,"array의 각 element 중 divisor로 나누어 떨어지는 값을 오름차순으로 정렬한 배열을 반환하는 함수, solution을 작성해주세요. divisor로 나누어 떨어지는 element가 하나도 없다면 배열에 -1을 담아 반환하세요. 제한사항 arr은 자연수를 담은 배열입니다. 정수 i, j에 대해 i ≠ j 이면 arr[i] ≠ arr[j] 입니다. divisor는 자연수입니다. array는 길이 1 이상인 배열입니다. 입출력 예 arr divisor return [5, 9, 7, 10] 5 [5, 10] [2, 36, 1, 3] 1 [1, 2, 3, 36] [3,2,6] 10 [-1] 입출력 예 설명 입출력 예#1 arr의 원소 중 5로 나누어 떨어지는 원소는 5와 10입니다. 따라서 [5, 10]을 리턴합니다. 입출력 예#2 arr의 모든 원소는 1으로 나누어 떨어집니다. 원소를 오름차순으로 정렬해 [1, 2, 3, 36]을 리턴합니다. 입출력 예#3 3, 2, 6은 10으로 나누어 떨어지지 않습니다. 나누어 떨어지는 원소가 없으므로 [-1]을 리턴합니다.",easy,Array
592,"괄호가 바르게 짝지어졌다는 것은 '(' 문자로 열렸으면 반드시 짝지어서 ')' 문자로 닫혀야 한다는 뜻입니다. 예를 들어 ""()()"" 또는 ""(())()"" 는 올바른 괄호입니다. "")()("" 또는 ""(()("" 는 올바르지 않은 괄호입니다. '(' 또는 ')' 로만 이루어진 문자열 s가 주어졌을 때, 문자열 s가 올바른 괄호이면 true를 return 하고, 올바르지 않은 괄호이면 false를 return 하는 solution 함수를 완성해 주세요. 제한사항 문자열 s의 길이 : 100,000 이하의 자연수 문자열 s는 '(' 또는 ')' 로만 이루어져 있습니다. 입출력 예 s answer ""()()"" true ""(())()"" true "")()("" false ""(()("" false 입출력 예 설명 입출력 예 #1,2,3,4 문제의 예시와 같습니다.",normal,String
593,"Finn은 편의점에서 야간 아르바이트를 하고 있습니다. 야간에 손님이 너무 없어 심심한 Finn은 손님들께 거스름돈을 n 원을 줄 때 방법의 경우의 수를 구하기로 하였습니다. 예를 들어서 손님께 5원을 거슬러 줘야 하고 1원, 2원, 5원이 있다면 다음과 같이 4가지 방법으로 5원을 거슬러 줄 수 있습니다. 1원을 5개 사용해서 거슬러 준다. 1원을 3개 사용하고, 2원을 1개 사용해서 거슬러 준다. 1원을 1개 사용하고, 2원을 2개 사용해서 거슬러 준다. 5원을 1개 사용해서 거슬러 준다. 거슬러 줘야 하는 금액 n과 Finn이 현재 보유하고 있는 돈의 종류 money가 매개변수로 주어질 때, Finn이 n 원을 거슬러 줄 방법의 수를 return 하도록 solution 함수를 완성해 주세요. 제한 사항 n은 100,000 이하의 자연수입니다. 화폐 단위는 100종류 이하입니다. 모든 화폐는 무한하게 있다고 가정합니다. 정답이 커질 수 있으니, 1,000,000,007로 나눈 나머지를 return 해주세요. 입출력 예 n money result 5 [1,2,5] 4 입출력 예 설명 입출력 예 #1 문제의 예시와 같습니다.",normal,Math
594,"배열 arr가 주어집니다. 배열 arr의 각 원소는 숫자 0부터 9까지로 이루어져 있습니다. 이때, 배열 arr에서 연속적으로 나타나는 숫자는 하나만 남기고 전부 제거하려고 합니다. 단, 제거된 후 남은 수들을 반환할 때는 배열 arr의 원소들의 순서를 유지해야 합니다. 예를 들면, arr = [1, 1, 3, 3, 0, 1, 1] 이면 [1, 3, 0, 1] 을 return 합니다. arr = [4, 4, 4, 3, 3] 이면 [4, 3] 을 return 합니다. 배열 arr에서 연속적으로 나타나는 숫자는 제거하고 남은 수들을 return 하는 solution 함수를 완성해 주세요. 제한사항 배열 arr의 크기 : 1,000,000 이하의 자연수 배열 arr의 원소의 크기 : 0보다 크거나 같고 9보다 작거나 같은 정수 입출력 예 arr answer [1,1,3,3,0,1,1] [1,3,0,1] [4,4,4,3,3] [4,3] 입출력 예 설명 입출력 예 #1,2 문제의 예시와 같습니다.",easy,Array
595,"1와 0로 채워진 표(board)가 있습니다. 표 1칸은 1 x 1 의 정사각형으로 이루어져 있습니다. 표에서 1로 이루어진 가장 큰 정사각형을 찾아 넓이를 return 하는 solution 함수를 완성해 주세요. (단, 정사각형이란 축에 평행한 정사각형을 말합니다.) 예를 들어 1 2 3 4 0 1 1 1 1 1 1 1 1 1 1 1 0 0 1 0 가 있다면 가장 큰 정사각형은 1 2 3 4 0 1 1 1 1 1 1 1 1 1 1 1 0 0 1 0 가 되며 넓이는 9가 되므로 9를 반환해 주면 됩니다. 제한사항 표(board)는 2차원 배열로 주어집니다. 표(board)의 행(row)의 크기 : 1,000 이하의 자연수 표(board)의 열(column)의 크기 : 1,000 이하의 자연수 표(board)의 값은 1또는 0으로만 이루어져 있습니다. 입출력 예 board answer [[0,1,1,1],[1,1,1,1],[1,1,1,1],[0,0,1,0]] 9 [[0,0,1,1],[1,1,1,1]] 4 입출력 예 설명 입출력 예 #1 위의 예시와 같습니다. 입출력 예 #2 | 0 | 0 | 1 | 1 | | 1 | 1 | 1 | 1 | 로 가장 큰 정사각형의 넓이는 4가 되므로 4를 return합니다.",normal,Array
596,"앞뒤를 뒤집어도 똑같은 문자열을 팰린드롬(palindrome)이라고 합니다. 문자열 s가 주어질 때, s의 부분문자열(Substring)중 가장 긴 팰린드롬의 길이를 return 하는 solution 함수를 완성해 주세요. 예를들면, 문자열 s가 ""abcdcba""이면 7을 return하고 ""abacde""이면 3을 return합니다. 제한사항 문자열 s의 길이 : 2,500 이하의 자연수 문자열 s는 알파벳 소문자로만 구성 입출력 예 s answer ""abcdcba"" 7 ""abacde"" 3 입출력 예 설명 입출력 예 #1 4번째자리 'd'를 기준으로 문자열 s 전체가 팰린드롬이 되므로 7을 return합니다. 입출력 예 #2 2번째자리 'b'를 기준으로 ""aba""가 팰린드롬이 되므로 3을 return합니다. ※ 공지 - 2023년 8월 21일 테스트케이스가 추가되었습니다. 기존에 제출한 코드가 통과하지 못할 수도 있습니다.",normal,String
597,"단어 s의 가운데 글자를 반환하는 함수, solution을 만들어 보세요. 단어의 길이가 짝수라면 가운데 두글자를 반환하면 됩니다. 재한사항 s는 길이가 1 이상, 100이하인 스트링입니다. 입출력 예 s return ""abcde"" ""c"" ""qwer"" ""we""",easy,Design
598,"가로 길이가 2이고 세로의 길이가 1인 직사각형 모양의 타일이 있습니다. 이 직사각형 타일을 이용하여 세로의 길이가 3이고 가로의 길이가 n인 바닥을 가득 채우려고 합니다. 타일을 채울 때는 다음과 같이 2가지 방법이 있습니다 타일을 가로로 배치 하는 경우 타일을 세로로 배치 하는 경우 예를들어서 n이 8인 직사각형은 다음과 같이 채울 수 있습니다. 직사각형의 가로의 길이 n이 매개변수로 주어질 때, 이 직사각형을 채우는 방법의 수를 return 하는 solution 함수를 완성해주세요. 제한사항 가로의 길이 n은 5,000이하의 자연수 입니다. 경우의 수가 많아 질 수 있으므로, 경우의 수를 1,000,000,007으로 나눈 나머지를 return해주세요. 입출력 예 n result 4 11 입출력 예 설명 입출력 예 #1 다음과 같이 11가지 방법이 있다.",normal,Math
599,"2016년 1월 1일은 금요일입니다. 2016년 a월 b일은 무슨 요일일까요? 두 수 a ,b를 입력받아 2016년 a월 b일이 무슨 요일인지 리턴하는 함수, solution을 완성하세요. 요일의 이름은 일요일부터 토요일까지 각각 SUN,MON,TUE,WED,THU,FRI,SAT 입니다. 예를 들어 a=5, b=24라면 5월 24일은 화요일이므로 문자열 ""TUE""를 반환하세요. 제한 조건 2016년은 윤년입니다. 2016년 a월 b일은 실제로 있는 날입니다. (13월 26일이나 2월 45일같은 날짜는 주어지지 않습니다) 입출력 예 a b result 5 24 ""TUE""",easy,String
600,"가로 길이가 2이고 세로의 길이가 1인 직사각형모양의 타일이 있습니다. 이 직사각형 타일을 이용하여 세로의 길이가 2이고 가로의 길이가 n인 바닥을 가득 채우려고 합니다. 타일을 채울 때는 다음과 같이 2가지 방법이 있습니다. 타일을 가로로 배치 하는 경우 타일을 세로로 배치 하는 경우 예를들어서 n이 7인 직사각형은 다음과 같이 채울 수 있습니다. 직사각형의 가로의 길이 n이 매개변수로 주어질 때, 이 직사각형을 채우는 방법의 수를 return 하는 solution 함수를 완성해주세요. 제한사항 가로의 길이 n은 60,000이하의 자연수 입니다. 경우의 수가 많아 질 수 있으므로, 경우의 수를 1,000,000,007으로 나눈 나머지를 return해주세요. 입출력 예 n result 4 5 입출력 예 설명 입출력 예 #1 다음과 같이 5가지 방법이 있다.",normal,Math
601,"124 나라가 있습니다. 124 나라에서는 10진법이 아닌 다음과 같은 자신들만의 규칙으로 수를 표현합니다. 124 나라에는 자연수만 존재합니다. 124 나라에는 모든 수를 표현할 때 1, 2, 4만 사용합니다. 예를 들어서 124 나라에서 사용하는 숫자는 다음과 같이 변환됩니다. 10진법 124 나라 10진법 124 나라 1 1 6 14 2 2 7 21 3 4 8 22 4 11 9 24 5 12 10 41 자연수 n이 매개변수로 주어질 때, n을 124 나라에서 사용하는 숫자로 바꾼 값을 return 하도록 solution 함수를 완성해 주세요. 제한사항 n은 50,000,000이하의 자연수 입니다. 입출력 예 n result 1 1 2 2 3 4 4 11 ※ 공지 - 2022년 9월 5일 제한사항이 수정되었습니다.",normal,Math
602,"당신은 폰켓몬을 잡기 위한 오랜 여행 끝에, 홍 박사님의 연구실에 도착했습니다. 홍 박사님은 당신에게 자신의 연구실에 있는 총 N 마리의 폰켓몬 중에서 N/2마리를 가져가도 좋다고 했습니다. 홍 박사님 연구실의 폰켓몬은 종류에 따라 번호를 붙여 구분합니다. 따라서 같은 종류의 폰켓몬은 같은 번호를 가지고 있습니다. 예를 들어 연구실에 총 4마리의 폰켓몬이 있고, 각 폰켓몬의 종류 번호가 [3번, 1번, 2번, 3번]이라면 이는 3번 폰켓몬 두 마리, 1번 폰켓몬 한 마리, 2번 폰켓몬 한 마리가 있음을 나타냅니다. 이때, 4마리의 폰켓몬 중 2마리를 고르는 방법은 다음과 같이 6가지가 있습니다. 첫 번째(3번), 두 번째(1번) 폰켓몬을 선택 첫 번째(3번), 세 번째(2번) 폰켓몬을 선택 첫 번째(3번), 네 번째(3번) 폰켓몬을 선택 두 번째(1번), 세 번째(2번) 폰켓몬을 선택 두 번째(1번), 네 번째(3번) 폰켓몬을 선택 세 번째(2번), 네 번째(3번) 폰켓몬을 선택 이때, 첫 번째(3번) 폰켓몬과 네 번째(3번) 폰켓몬을 선택하는 방법은 한 종류(3번 폰켓몬 두 마리)의 폰켓몬만 가질 수 있지만, 다른 방법들은 모두 두 종류의 폰켓몬을 가질 수 있습니다. 따라서 위 예시에서 가질 수 있는 폰켓몬 종류 수의 최댓값은 2가 됩니다. 당신은 최대한 다양한 종류의 폰켓몬을 가지길 원하기 때문에, 최대한 많은 종류의 폰켓몬을 포함해서 N/2마리를 선택하려 합니다. N마리 폰켓몬의 종류 번호가 담긴 배열 nums가 매개변수로 주어질 때, N/2마리의 폰켓몬을 선택하는 방법 중, 가장 많은 종류의 폰켓몬을 선택하는 방법을 찾아, 그때의 폰켓몬 종류 번호의 개수를 return 하도록 solution 함수를 완성해주세요. 제한사항 nums는 폰켓몬의 종류 번호가 담긴 1차원 배열입니다. nums의 길이(N)는 1 이상 10,000 이하의 자연수이며, 항상 짝수로 주어집니다. 폰켓몬의 종류 번호는 1 이상 200,000 이하의 자연수로 나타냅니다. 가장 많은 종류의 폰켓몬을 선택하는 방법이 여러 가지인 경우에도, 선택할 수 있는 폰켓몬 종류 개수의 최댓값 하나만 return 하면 됩니다. 입출력 예 nums result [3,1,2,3] 2 [3,3,3,2,2,4] 3 [3,3,3,2,2,2] 2 입출력 예 설명 입출력 예 #1 문제의 예시와 같습니다. 입출력 예 #2 6마리의 폰켓몬이 있으므로, 3마리의 폰켓몬을 골라야 합니다. 가장 많은 종류의 폰켓몬을 고르기 위해서는 3번 폰켓몬 한 마리, 2번 폰켓몬 한 마리, 4번 폰켓몬 한 마리를 고르면 되며, 따라서 3을 return 합니다. 입출력 예 #3 6마리의 폰켓몬이 있으므로, 3마리의 폰켓몬을 골라야 합니다. 가장 많은 종류의 폰켓몬을 고르기 위해서는 3번 폰켓몬 한 마리와 2번 폰켓몬 두 마리를 고르거나, 혹은 3번 폰켓몬 두 마리와 2번 폰켓몬 한 마리를 고르면 됩니다. 따라서 최대 고를 수 있는 폰켓몬 종류의 수는 2입니다.",easy,Array
603,"ROR 게임은 두 팀으로 나누어서 진행하며, 상대 팀 진영을 먼저 파괴하면 이기는 게임입니다. 따라서, 각 팀은 상대 팀 진영에 최대한 빨리 도착하는 것이 유리합니다. 지금부터 당신은 한 팀의 팀원이 되어 게임을 진행하려고 합니다. 다음은 5 x 5 크기의 맵에, 당신의 캐릭터가 (행: 1, 열: 1) 위치에 있고, 상대 팀 진영은 (행: 5, 열: 5) 위치에 있는 경우의 예시입니다. 위 그림에서 검은색 부분은 벽으로 막혀있어 갈 수 없는 길이며, 흰색 부분은 갈 수 있는 길입니다. 캐릭터가 움직일 때는 동, 서, 남, 북 방향으로 한 칸씩 이동하며, 게임 맵을 벗어난 길은 갈 수 없습니다. 아래 예시는 캐릭터가 상대 팀 진영으로 가는 두 가지 방법을 나타내고 있습니다. 첫 번째 방법은 11개의 칸을 지나서 상대 팀 진영에 도착했습니다. 두 번째 방법은 15개의 칸을 지나서 상대팀 진영에 도착했습니다. 위 예시에서는 첫 번째 방법보다 더 빠르게 상대팀 진영에 도착하는 방법은 없으므로, 이 방법이 상대 팀 진영으로 가는 가장 빠른 방법입니다. 만약, 상대 팀이 자신의 팀 진영 주위에 벽을 세워두었다면 상대 팀 진영에 도착하지 못할 수도 있습니다. 예를 들어, 다음과 같은 경우에 당신의 캐릭터는 상대 팀 진영에 도착할 수 없습니다. 게임 맵의 상태 maps가 매개변수로 주어질 때, 캐릭터가 상대 팀 진영에 도착하기 위해서 지나가야 하는 칸의 개수의 최솟값을 return 하도록 solution 함수를 완성해주세요. 단, 상대 팀 진영에 도착할 수 없을 때는 -1을 return 해주세요. 제한사항 maps는 n x m 크기의 게임 맵의 상태가 들어있는 2차원 배열로, n과 m은 각각 1 이상 100 이하의 자연수입니다. n과 m은 서로 같을 수도, 다를 수도 있지만, n과 m이 모두 1인 경우는 입력으로 주어지지 않습니다. maps는 0과 1로만 이루어져 있으며, 0은 벽이 있는 자리, 1은 벽이 없는 자리를 나타냅니다. 처음에 캐릭터는 게임 맵의 좌측 상단인 (1, 1) 위치에 있으며, 상대방 진영은 게임 맵의 우측 하단인 (n, m) 위치에 있습니다. 입출력 예 maps answer [[1,0,1,1,1],[1,0,1,0,1],[1,0,1,1,1],[1,1,1,0,1],[0,0,0,0,1]] 11 [[1,0,1,1,1],[1,0,1,0,1],[1,0,1,1,1],[1,1,1,0,0],[0,0,0,0,1]] -1 입출력 예 설명 입출력 예 #1 주어진 데이터는 다음과 같습니다. 캐릭터가 적 팀의 진영까지 이동하는 가장 빠른 길은 다음 그림과 같습니다. 따라서 총 11칸을 캐릭터가 지나갔으므로 11을 return 하면 됩니다. 입출력 예 #2 문제의 예시와 같으며, 상대 팀 진영에 도달할 방법이 없습니다. 따라서 -1을 return 합니다.",normal,Array
604,"사칙연산에서 더하기(+)는 결합법칙이 성립하지만, 빼기(-)는 결합법칙이 성립하지 않습니다. 예를 들어 식 1 - 5 - 3은 연산 순서에 따라 다음과 같이 다른 결과를 가집니다. ((1 - 5) - 3) = -7 (1 - (5 - 3)) = -1 위 예시와 같이 뺄셈은 연산 순서에 따라 그 결과가 바뀔 수 있습니다. 또 다른 예로 식 1 - 3 + 5 - 8은 연산 순서에 따라 다음과 같이 5가지 결과가 나옵니다. (((1 - 3) + 5) - 8) = -5 ((1 - (3 + 5)) - 8) = -15 (1 - ((3 + 5) - 8)) = 1 (1 - (3 + (5 - 8))) = 1 ((1 - 3) + (5 - 8)) = -5 위와 같이 서로 다른 연산 순서의 계산 결과는 [-15, -5, -5, 1, 1]이 되며, 이중 최댓값은 1입니다. 문자열 형태의 숫자와, 더하기 기호(""+""), 뺄셈 기호(""-"")가 들어있는 배열 arr가 매개변수로 주어질 때, 서로 다른 연산순서의 계산 결과 중 최댓값을 return 하도록 solution 함수를 완성해 주세요. 제한 사항 arr는 두 연산자 ""+"", ""-"" 와 숫자가 들어있는 배열이며, 길이는 3 이상 201 이하 입니다. arr의 길이는 항상 홀수입니다. arr에 들어있는 숫자의 개수는 2개 이상 101개 이하이며, 연산자의 개수는 (숫자의 개수) -1 입니다. 숫자는 1 이상 1,000 이하의 자연수가 문자열 형태로 들어있습니다.. (ex : ""456"") 배열의 첫 번째 원소와 마지막 원소는 반드시 숫자이며, 숫자와 연산자가 항상 번갈아가며 들어있습니다. 입출력 예 arr result [""1"", ""-"", ""3"", ""+"", ""5"", ""-"", ""8""] 1 [""5"", ""-"", ""3"", ""+"", ""1"", ""+"", ""2"", ""-"", ""4""] 3 입출력 예시 입출력 예 #1 위의 예시와 같이 (1-(3+(5-8))) = 1 입니다. 입출력 예 #2 (5-(3+((1+2)-4))) = 3 입니다.",hard,Array
605,"네오의 귀걸이 귀걸이를 좋아하는 네오는 자신만을 위한 귀걸이를 만들기로 하였다. 기하학적으로 아름다운 귀걸이를 만들고 싶던 네오는 아래와 같은 모습의 귀걸이를 구상 중이다. 2차원 좌표 평면에 N개의 점이 주어져 있다. 점들의 x나 y 좌표가 겹치는 경우는 없다고 하자. 이들 점 중 가장 왼쪽에 위치한 점은 항상 가장 위쪽에 위치한 점과 같다. 이 점을 S라고 부르자. 마찬가지로, 가장 오른쪽에 위치한 점은 항상 가장 아래쪽에 위치한 점과 같다. 이 점을 E라고 부르자. 기하학적으로 아름다운 귀걸이는 다음의 조건을 만족해야 한다. 주어진 점들을 왼쪽 위와 오른쪽 아래 꼭짓점으로 가지는 축에 평행한 직사각형들이 순서대로 놓여있다. 이때, 첫 번째 직사각형은 S를 왼쪽 위 꼭짓점으로 가져야 한다. 순서의 마지막 직사각형은 E를 오른쪽 아래 꼭짓점으로 가져야 한다. 순서에서, 어떤 직사각형 A 바로 다음에 직사각형 B가 등장한다면, A의 오른쪽 아래 꼭짓점은 B의 왼쪽 위 꼭짓점과 같은 점이어야 한다. 주어진 점 각각은 자신의 특징적인 k값을 가지고 있다. 이 값의 의미는 해당 점이 어떤 직사각형의 오른쪽 아래 점이 되는 경우 그 직사각형의 가로 폭과 세로 높이의 합이 정확히 k가 되어야 한다는 뜻이다. 네오는 주어진 점들로 만들 수 있는 기하학적인 귀걸이가 몇 가지인지 궁금하다. 또, 점을 하나 추가했을 때 혹은 점을 하나 제거했을 때의 종류도 몇 가지인지 궁금하다. 네오가 궁금증을 해결하기 위해 여러분의 도움이 필요하다. S와 E는 처음상태에서 고정된다. S와 E가 제거되는 경우와 추가되는 점이 일정한 영역을 벗어나는 경우에 주의하라. 입력 형식 입력은 점의 개수 n, 점의 정보를 담은 배열 point, 점의 추가 또는 삭제 정보를 담은 배열 query로 구성된다. point 배열은 n × 3 크기의 2차원 배열로, 각각의 행은 점의 x좌표, y좌표, 그리고 그 점의 k값으로 이루어져 있다. query 배열은 n × 4 크기의 2차원 배열로, 점을 추가하거나 삭제하는 변화의 정보를 담고 있다. 각 변화는 독립적으로 초기 상태에 대해서 적용됨에 주의하라. 즉, 변화가 누적되는 것이 아니다. 각 행의 첫 번째 값은 변화의 종류를 담은 값으로, 0인 경우 점을 추가하는 경우를 의미하고 1인 경우 최초에 주어진 n개의 점들 중 하나를 제거하는 경우를 의미한다. 점을 추가하는 경우는 새로 추가되는 점의 x좌표, y좌표, k값이 이후의 원소로 주어진다. 점을 삭제하는 경우는 삭제하려는 점의 x좌표, y좌표가 이후의 원소로 주어지며, 마지막 원소는 배열의 크기를 맞추기 위한 것으로 의미 없는 값이다. 제한조건은 다음과 같다. 2 <= n <= 100,000 주어진 점들 중 가장 왼쪽에 위치한 점은 항상 가장 위쪽에 위치한 점과 같음이 보장된다. 또한, 가장 오른쪽에 위치한 점은 항상 가장 아래쪽에 위치한 점과 같음이 보장된다. 추가되는 점은 최초에 주어진 점과 x좌표나 y좌표가 겹치지 않음이 보장된다. 제거되는 점은 최초에 주어진 점들 중 하나임이 보장된다. 모든 좌표 값은 -1,000,000,000 이상 1,000,000,000이하의 정수이다. 출력 형식 리턴 타입은 정수의 배열로, 총 n+1개의 원소로 이루어진 배열을 리턴한다. 첫 번째 원소는 초기 상태에서 가능한 기하학적 귀걸이의 개수를 1,000,000,007로 나눈 나머지여야 한다. 다음 n개의 원소는 각 변화에 대해 그 변화를 적용한 이후 가능한 귀걸이의 개수를 1,000,000,007로 나눈 나머지가 입력의 순서에 맞게 들어있으면 된다. 예제 입출력 n point query answer 3 [[0, 4, 1], [2, 2, 4], [4, 0, 4]] [[0, 3, 3, 4], [0, 3, 1, 2], [1, 2, 2, 0]] [1, 2, 1, 0]",hard,Array
606,"IU와 콘의 보드게임 2017년 8월 5일, 다양한 방법으로 3단 고음을 마스터한 아이유는 신나게 놀기로 했다. 무엇을 할까 고민하던 그녀는 콘이 보드게임을 플레이하고 있는 것을 보고 흥미가 생겼다. 보드판은 다음과 같이 생겼다. 게임판에는 점 A, B, C 위치에 핀이 꼽혀 있으며 이 세 점은 게임판에서 가장 큰 삼각형을 이루고 있다. 고무줄이 세 개가 있는데 각각이 A와 B, B와 C, C와 A에 묶여 있어 삼각형 ABC를 그리고 있다. 이 커다란 삼각형 ABC 안에는 n개의 핀이 무작위로 꼽혀 있다. 이 게임은 세 개의 고무줄을 삼각형 ABC의 안쪽으로 이동시켜 새로운 도형을 만들어 내는 것이 목표이며, 그 과정에서 핀의 위치는 고정되어 움직일 수 없다. 삼각형 ABC 내부의 핀들과 고무줄의 물리적 특성에 의해 이러한 방식으로 만들어지는 도형들은 다음과 같은 성질을 갖는다. 꼭짓점은 모두 어떤 핀에 의해 만들어지며 변은 핀과 핀 사이의 선분이 된다. 끝점이 A와 B에 고정된 고무줄은 A에서 시작하여 B로 끝나는 안쪽으로 오목한 모양을 그리게 된다. 끝점이 B와 C에 고정된 고무줄은 B에서 시작하여 C로 끝나는 안쪽으로 오목한 모양을 그리게 된다. 끝점이 C와 A에 고정된 고무줄은 C에서 시작하여 A로 끝나는 안쪽으로 오목한 모양을 그리게 된다. 여기에 아래의 추가 조건을 만족하는 도형을 모두 찾고 싶다. 임의의 두 고무줄이 서로 교차하지 않으며, 점 A, B, C를 제외한 곳에서 겹치지 않는다. 따라서 만들어지는 도형의 내부와 외부가 명확하게 구분된다. 그 도형의 내부에 다른 핀이 존재하지 않는다. 위의 첫 번째 그림은 게임판의 시작 형태를 보여주고 있다. 여기에는 삼각형 ABC 안에 8개의 핀이 꼽혀 있으며, 세 개의 고무줄은 서로 다른 색으로 표현되어 있다. 두 번째 그림은 추가 조건 두 가지를 모두 만족하는 도형의 예를 보여준다. 세 번째와 네 번째 그림은 고무줄로 만들 수 있는 모양이지만 추가 조건을 만족시키지 못하는 예이다. 세 번째 도형은 두 고무줄이 교차하여 추가 조건 1을 만족하지 못하고 네 번째 도형은 추가 조건 1을 만족하지만 내부에 핀이 존재하여 조건 2를 만족하지 못한다. 위의 두 번째 도형과 같이 추가 조건 1과 2를 모두 만족하는 도형이 몇 개인지 맞히는 사람이 이기는 게임이다. 승부욕이 강한 아이유는 콘에게 지고 싶지 않아 여러분에게 도움을 요청했다. 삼각형 ABC 내부에 위치한 n개의 핀의 좌표가 주어질 때에 위의 조건을 만족하는 도형의 개수를 세는 프로그램을 작성하시오. 입력 형식 입력은 삼각형 내부의 핀의 개수 n, 삼각형의 좌표 triangle, 핀의 좌표 v 배열로 구성되어 있다. triangle은 3 × 2 크기의 2차원 배열이며, v는 n × 2 크기의 2차원 배열이다. 제한조건은 다음과 같다. 0 <= n <= 500 triangle과 v의 원소인 x좌표와 y좌표는 모두 -100,000,000 이상 100,000,000 이하이다. triangle과 v로 주어진 모든 점을 통틀어, 같은 좌표를 가진 두 핀이 입력으로 주어지지 않는다. triangle과 v로 주어진 모든 점을 통틀어, 임의의 세 점이 하나의 직선 위에 놓이는 경우는 없다. 출력 형식 문제에 설명된 조건을 모두 만족하는 도형의 개수를 리턴한다. 예제 입출력 n triangle v answer 2 [[0, 8], [-4, 0], [4, 0]] [[-1, 3], [1, 4]] 6 10 [[-13, 40], [-27, -48], [31, 6]] [[2, 21], [15, -1], [6, -13], [-20, -27], [5, 9], [5, 11], [-18, -26], [-15, 19], [7, 4], [-5, -18]] 73 예제에 대한 설명 첫 번째 예제에는 삼각형의 꼭짓점을 제외하고 총 2개의 핀의 위치가 주어졌다. 삼각형의 좌표를 A(0, 8), B(-4, 0), C(4, 0), 그리고 삼각형 내부의 핀을 D(-1, 3), E(1, 4)라고 하자. 고무줄로 만들 수 있으면서 추가 조건 1, 2를 만족하는 도형은 총 6개로 아래와 같다. 사각형 ABCD, 사각형 AEBC, 오각형 ADBCE, 오각형 ABDCE, 오각형 ADBEC, 오각형 ABDEC 그 외의 도형은 모두 추가 조건 1 혹은 추가 조건 2를 만족하지 못한다.",hard,Array
607,"스마트한 프로도 직장인 프로도는 오늘도 열심히 일한다. 회사에서 인정받는 프로도는 직장 상사에게 문제를 풀어 달라는 요청을 받았다. 문제를 읽은 프로도는 혼자 풀긴 어려운 문제로 보여 여러분에게 도움을 요청하였다. 상사가 전달한 문제는 아래와 같다. 그래프 G에 대해서, 서로 다른 두 정점 사이에 간선이 존재한다면 단지 한 간선만 존재한다. 또한 동일한 정점을 연결하는 간선(셀프 루프)은 존재하지 않는다. G의 두 간선 e_1과 e_2가 인접하다면, e_1이 연결하는 두 정점 중 하나는 e_2가 연결하는 정점과 일치한다. 그래프 G의 매칭 M은 간선들의 집합이고 M에 속하는 임의의 두 간선은 서로 인접하지 않다. 여기서, 공집합은 매칭임에 주목하자. 그래프 G와 정수 k에 대해서, 초기에 |M_0|≥k이고 |M_t|≥k 인 두 매칭 M_0와 M_t가 주어진다. 우리는 매칭 M_0에서 G의 간선을 추가하거나 또는 삭제해서 M_0를 변환한다. 변환의 한 단계에서는 하나의 간선을 추가하거나 삭제할 수 있다. 이렇게 해서 변환된 간선들의 집합 M_1은 다시 매칭이 되어야 한다. 다시 말해서, 각 변환 단계의 결과물은 매칭이어야 한다. 따라서 i번째 단계에서는 매칭 M_i-1를 매칭 M_i로 변환하게 된다. 이런 식으로 M_0에서 시작해서 중간 매칭들로의 변환 단계들을 거쳐서 마지막에 M_t를 만들어야 한다. 다시 말해서, p번의 단계를 거쳐 만들어진 매칭 M_p에 대해서, M_p = M_t를 만족하면 된다. 하지만 중간에 만들어지는 M_i (0 < i < p)는 크기에 제한이 있어서 |M_i| ≥ k-2를 만족해야만 한다. 매칭 M_0에서 M_t로 위의 조건들을 만족하면서 항상 변환할 수 있다는 것이 잘 알려져 있다. 따라서 여러분은 그 변환 과정을 리턴하는 프로그램을 작성하여야 한다. 예를 들어, 아래 그림에서 초기 매칭 M_0 = {e_3, e_6}이고 마지막 매칭 M_t = {e_2, e_4}이고, k = 2 인 경우이다. 그림에서와 같이 간선들을 추가하거나 삭제하면, M_0에서 M_t로 변환할 수 있다. 입력 형식 입력은 총 9가지의 변수로 주어진다. n과 m은 각각 그래프 G의 정점과 간선의 수이다. 그래프 G의 정점들은 1부터 n까지의 정수로, 간선들은 1부터 m까지의 정수로 나타낸다. a와 b는 각각 크기가 m인 1차원 배열로, 간선이 잇는 두 점을 나타낸다. i번째 간선이 잇는 두 정점의 번호가 a와 b의 i번째 원소가 된다. k는 문제에서 설명된 것과 같다. m1과 m2는 각각 초기 매칭 M_0의 크기, 마지막 매칭 M_t의 크기이다. e1과 e2는 각각 M_0와 M_t에 속하는 간선의 정보를 나타내는 1차원 배열이며, 각각의 원소의 개수는 m1과 m2이다. 제한조건은 다음과 같다. 1 <= n <= 100,000 1 <= m <= 1,000,000 1 <= k <= 50,000 m1 >= k, m2 >= k 출력 형식 리턴 타입은 2차원 정수 배열이다. 매칭 M_0에서 M_t로 변환하는데 p단계가 걸린다고 할 때, 배열의 크기는 p × 2가 되어야 한다. 각 행의 첫 번째 원소는 0 또는 1로, 0이면 간선을 삭제했음을 의미하며 1이면 간선을 추가했음을 의미한다. 두 번째 원소는 추가 또는 삭제하는 간선의 번호이다. 답이 될 수 있는 변환이 여러 가지인 경우에는 그중 한 가지를 리턴하면 된다. 변수명 값 n 5 m 6 a [1, 1, 2, 2, 3, 4] b [2, 3, 3, 4, 5, 5] k 2 m1 2 m2 2 e1 [3, 6] e2 [2, 4] answer [[0, 3], [1, 2], [0, 6], [1, 4]] 알림 이 문제의 경우 같은 입력에 대해 정답이 여러 개 존재할 수 있으나, ‘실행’을 눌러 예제 입출력에 대해 테스트를 진행할 때 등록된 한 가지 답만 정답으로 처리되고 있습니다. ‘코드 채점’을 눌러 제출할 시에는 올바르게 채점되니 참고하여 주시기 바랍니다.",hard,Array
608,"튜브의 소개팅 얼마 전 소개팅에 실패해 낙담한 튜브를 안타깝게 여긴 친구들은 튜브에게 새로운 사람을 소개해주기로 했다. 좀 더 자연스러운 자리를 만들기 위해, 튜브와 소개팅녀를 파티에 초대하기로 했다. 친구들은 튜브에게 파티에 초대된 모든 사람의 위치를 알려주었다. 사각형 모양의 파티장 입구는 왼쪽 맨 위였고, 만나야 하는 상대의 좌석은 파티장의 오른쪽 맨 아래였다. 파티장의 가로 길이가 n이라고 하고, 세로 길이를 m이라 할 때, 튜브와 소개팅 상대의 위치는 각각, (0, 0), (m - 1, n - 1)이 된다. 튜브는 (0, 0)에서 (m - 1, n - 1)까지 가는 가장 짧은 길을 알고 싶다. 이동은 좌/우/상/하로만 가능하다. 또한, 조금이라도 더 빠르게 이동하고 싶은 튜브는 이동하는 중에 가능한 덜 수다스러운 친구들만 만나고 싶다. 다시 말해, 목표 지점까지 길이가 같은 여러 개의 경로가 존재할 경우, 경로상에 위치한 친구들과 나눠야 하는 대화 시간의 합이 적은 것을 더 선호한다. 튜브에게는 스트레스를 심하게 받을 경우 미친 오리로 변하는 비밀이 있다. 경로 상에 위치한 친구들과 나눠야 하는 대화 시간의 합이 s를 초과한다면 미친 오리로 변하고 소개팅에 실패하고 말 것이다! 그러므로 아무리 짧은 경로라도 친구들과 나눠야 하는 대화 시간의 합이 s를 초과한다면 그 경로를 진행할 수는 없다. 튜브가 소개팅 상대에게 무사히 갈 수 있는 경로를 알려주자. 입력 형식 입력은 파티장의 크기 m과 n 그리고 튜브가 참을 수 있는 대화 시간의 총합 s, 친구와의 대화에 필요한 시간 t가 담긴 2차원 배열 time_map으로 주어진다. t가 -1인 경우는 파티 테이블이 위치한 경우라 지나갈 수 없다. 그리고 시작 지점과 도착 지점에서는 수다에 필요한 시간이 없다, 즉 t = 0이다. 추가 제한조건은 아래와 같다. 2 <= n, m <= 50 1 <= s <= 2^31-1 -1 <= t <= 2^31-1 모든 입력에는 문제의 조건을 만족하는 경로가 하나 이상 존재한다. 출력 형식 리턴 타입은 원소가 두 개인 정수 배열이다. 튜브가 이동해야 하는 경로의 길이와 해당 경로를 지나갈 때 친구와 나눠야 하는 대화 시간의 총합을 리턴한다. 예제 입출력 m n s time_map answer 3 3 150 [[0, 2, 99], [100, 100, 4], [1, 2, 0]] [4, 103] 4 6 25 [[0, 1, 1, -1, 2, 4], [-1, 7, 2, 1, 5, 7], [-1, 1, -1, 1, 6, 3], [-1, 1, -1, -1, 7, 0]] [8, 15] 5 5 12 [[0, 1, 1, 1, 1], [9, 9, 9, 1, 9], [1, 1, 1, 1, 9], [1, 1, 5, 9, 9], [1, 1, 1, 1, 0]] [12, 11]",hard,Array
609,"몸짱 트레이너 라이언의 고민 헬스장에서 일하는 몸짱 트레이너 라이언은 최근 손님들에게 불평을 많이 들었다. 그것은 옷을 갈아입는데 다른 사람과 너무 가까워서 옷을 갈아입기가 불편하다는 것이었다. 불만을 해결하기 위해 고민하던 라이언은 손님들의 예약시간을 참고해서 되도록이면 서로 멀리 떨어지도록 키를 나눠주기로 마음먹었다. 예를 들어, 락커들이 3x3 정사각형 모양으로 배치되어있고, 동시간대에 2명의 손님이 예약되어있다면 아래와 같이 락커를 할당하는 것을 고려해볼 수 있다. 라이언이 일하는 헬스장은 아래와 같은 상황이라고 가정하자. 락커는 정사각형으로 배치되어있고, 락커 사이에 옷을 갈아입을 공간이 있다. 단, 이 공간은 계산에서 제외된다. 락커 간 거리는 상하좌우는 1로, 대각선은 2로 계산한다. 손님들은 철저하게 예약시간에 맞춰 락커를 이용하고, 퇴실하는 시간까지 락커를 차지한다. 영업시간은 오전 10시부터 오후 10시까지이다. 헬스장은 예약제로 운영되므로 락커의 개수보다 더 많은 손님들이 동시간대에 몰리는 경우는 없다. 이런 조건에서 헬스장을 이용한 손님들 중 가장 가까웠던 손님 간의 거리는 얼마일까? 입력 형식 입력은 정사각형 한 변의 길이 n과 손님수 m, 그리고 각 손님의 예약된 입실/퇴실 시간 timetable로 주어진다. 제한조건은 다음과 같다. 0 < n <= 10 0 <= m <= 1,000 timetable은 m × 2 크기의 2차원 배열이다. 각 행은 손님의 입실시각과 퇴실시각이 분 단위로 환산된 값 (t1, t2)가 들어있다. t1, t2에 대해서는 다음 조건이 성립한다. 600 <= t1 < t2 <= 1,320 출력 형식 할당된 락커들 간 거리 중 최소거리를 리턴한다. 손님 간에 이용 시간이 한 번도 겹치지 않을 경우에는 0을 리턴한다. 예제 입출력 n m timetable answer 3 2 [[1170,1210], [1200,1260]] 4 2 1 [[840,900]] 0 2 2 [[600,630],[630,700]] 2 4 5 [[1140,1200],[1150,1200],[1100,1200],[1210,1300],[1220,1280]] 4 예제에 대한 설명 첫 번째 예제: 손님 2명이 20:00부터 20:10까지 이용시간이 겹치고, 이 상황은 본문에 소개된 예와 같다. 두 번째 예제: 손님이 1명으로 겹치는 시간이 없기 때문에 0을 출력한다. 세 번째 예제: 손님 2명이 10:30에 겹친다. 2x2 정사각형에 2명을 배치해야 하므로 정답은 2가 된다. (ex. (0,0), (1,1)에 배치) 네 번째 예제: 손님 3명이 19:10부터 20:00까지 이용시간이 겹친다. 이 경우 아래와 같이 배치해서 할당된 모든 락커 간 거리가 4가 되도록 할 수 있다. (할당된 락커는 #으로 표시) # 0 0 0 0 0 0 # 0 0 0 0 0 # 0 0 네 번째 예제에서 손님을 모서리부터 배치하는 건 좋은 전략이 아니다. 2명까지는 거리가 6으로 가장 먼 거리가 되지만 예약된 다음 손님이 들어오면 할당된 락커 간 거리는 3이 돼버린다. 이런 경우 라이언은 예약시간을 고려해서 거리가 4가 되도록 배치한다.",normal,Array
610,"GPS 카카오 택시 개발자 Jay-G는 다음 업데이트를 준비하기 위해 개선사항을 위한 여러 피드백을 받았다. 그중에서 손님이 자주 탑승하는 위치를 추천해주었으면 한다는 의견이 많았다. 다음 업데이트 준비를 위해 Jay-G는 택시의 승하차 및 이동 경로를 수집하여 분석하기 시작하였다. 데이터를 분석하던 Jay-G는 몇 가지 특이사항을 발견했다. 택시의 이동 경로를 GPS를 통해 수집하게 되는데, GPS 신호 불량, 통신 오류 등 다양한 원인으로 위치의 오류가 발생한 것을 알게 되었다. 다만 승차 위치와 하차 위치는 오류가 없는 것으로 확인이 되었다. 개발자 Jay-G는 수집한 이동 경로의 오류를 최소한으로 수정하여 좀 더 정확한 이동 경로를 구하고 싶어 한다. 택시는 다음과 같은 조건으로만 이동한다. 먼저 택시는 거점을 이동해 다니며, 거점 간의 이동은 해당하는 도로가 있는 경우에만 가능하다. 또한, 교통 상황에 따라 택시는 한 거점에 머무를 수 있고, 왔던 길을 되돌아갈 수 있다. 모든 도로는 방향이 별도로 없는 왕복 도로이다. 예를 들어, 위 그래프에서 택시가 다음과 같이 시간대별로 이동 경로를 보내왔다. t 위치 1 1 2 2 3 3 4 3 5 6 6 7 하지만 위의 택시가 보내온 경로에는 거점 3에서 거점 6으로 이동할 수 있는 도로가 없으므로 이동 경로에 오류가 있다. 이러한 오류를 최소한으로 수정하여 이동 가능한 경로로 만들고 싶다. 이 경우 1회의 오류를 수정하여 다음과 같이 이동 가능한 경로를 만들 수 있다. 시간 t=4의 위치를 거점 5로 한 번 수정하면 이동 가능한 경로가 된다. t 위치 1 1 2 2 3 3 4 5 5 6 6 7 이와 비슷하게 시간 t=4의 위치를 거점 4로 바꾸거나, 시간 t=5 위치를 거점 5로 바꾸면 이동 가능한 경로로 만들 수 있다. 위의 경우 수정한 오류의 개수는 1개이다. t 위치 1 1 2 2 3 3 4 4 5 6 6 7 t 위치 1 1 2 2 3 3 4 3 5 5 6 7 위와 같이 택시가 보내온 경로에서 이동 가능한 경로로 만드는 최소의 오류 수정 횟수를 구하여라. 입력 형식 주어지는 입력은 총 다섯 가지로, 거점 개수 n과 도로의 개수 m, 각 거점 간의 연결된 도로 정보 edge_list, 택시가 시간대별로 보내오는 거점 정보의 총 개수 k, 그리고 머물렀던 거점의 정보 gps_log이다. 제한조건은 아래와 같다. 2 <= n <= 200 1 <= m <= 10,000 2 <= k <= 100 edge_list는 m × 2 크기의 2차원 배열로, 각 행의 두 값은 도로가 잇는 두 거점의 번호를 의미한다. 거점의 번호는 1부터 n까지 숫자이다. 모든 도로는 양방향 통행이 가능하다. 입력되는 데이터에서 항상 모든 거점 간 경로가 있음이 보장되지 않는다. gps_log의 시작 거점과 도착 거점은 바뀔 수 없다. 출력 형식 이동 가능한 경로로 만들 수 있는 최소의 오류 수정 횟수를 리턴한다. 올바른 경로로 수정하는 것이 불가능할 경우 -1을 리턴한다. 예제 입출력 변수명 값 n 7 m 10 edge_list [[1, 2], [1, 3], [2, 3], [2, 4], [3, 4], [3, 5], [4, 6], [5, 6], [5, 7], [6, 7]] k 6 gps_log [1, 2, 3, 3, 6, 7] answer 1 변수명 값 n 7 m 10 edge_list [[1, 2], [1, 3], [2, 3], [2, 4], [3, 4], [3, 5], [4, 6], [5, 6], [5, 7], [6, 7]] k 6 gps_log [1, 2, 4, 6, 5, 7] answer 0 예제에 대한 설명 두 예제 모두 edge_list의 데이터는 본문의 그림과 같은 예이다. 첫 번째 테스트 케이스에서 gps_log로 주어진 경로 중 거점 3에서 거점 6으로 가는 도로가 없다. 여기서 시간 t=4의 위치를 거점 5로 한 번 수정하면 이동 가능한 경로가 된다. 두 번째 테스트 케이스는 gps_log로 주어진 경로가 모두 도로로 연결된 경우이므로 수정이 필요 없다.",normal,Array
611,"리틀 프렌즈 사천성 언제나 맛있는 음식들이 가득한 평화로운 푸드 타운. 푸드 타운에서 행복하게 사는 리틀 프렌즈들은 마을에 있는 매직 스푼을 보물처럼 보관하고 있다. 매직 스푼은 재료만 준비해서 냄비에 넣고 휘젓기만 하면 순식간에 최고의 요리로 만들어주는 신비의 아이템. 어느 날 매직 스푼을 호시탐탐 노리는 악당들이 보물을 훔쳐간다. 매직 스푼을 되찾고 다시 마을에 평화를 가져오기 위해 프렌즈의 대모험이 시작되는데... 리틀 프렌즈 사천성은 프렌즈 사천성과 유사한 게임이다. 게임은 2차원 배열에서 진행되는데, 여러 가지 무늬로 구성된 타일이 배치되어 있으며 같은 모양의 타일은 두 개씩 배치되어 있다. 게임의 목적은 배치된 모든 타일을 제거하는 것으로, 같은 모양의 타일을 규칙에 따라 제거하면 된다. 타일을 제거할 수 있는 경우는 다음과 같다. 다음 조건을 만족하는 경로가 있을 때 두 타일을 제거할 수 있다. 경로의 양 끝은 제거하려는 두 타일이다. 경로는 두 개 이하의 수평/수직 선분으로 구성되어 있고, 이들은 모두 연결되어 있다. (즉, 경로를 한 번 이하로 꺾을 수 있다) 참고: 프렌즈 사천성은 경로가 세 개 이하의 선분으로 구성되어야 한다는 점이 다르다. (즉, 경로를 두 번 이하로 꺾을 수 있다) 경로 상에는 다른 타일 또는 장애물이 없어야 한다. 위의 배열에서 어피치 타일은 직선의 경로로 이을 수 있으므로 제거 가능하다. 라이언 타일 역시 한 번 꺾인 경로로 연결되므로 제거 가능하다. 무지 타일의 경우 다른 타일을 지나지 않는 경로는 두 번 꺾여야 하므로 제거할 수 없는 타일이며, 튜브 타일 역시 직선의 경로 사이에 장애물이 있으므로 제거 가능하지 않다. 타일 배열이 주어졌을 때, 규칙에 따라 타일을 모두 제거할 수 있는지, 그 경우 어떤 순서로 타일을 제거하면 되는지 구하는 프로그램을 작성해보자. 입력 형식 입력은 게임판의 크기를 나타내는 m과 n, 그리고 배치된 타일의 정보를 담은 문자열 배열 board로 주어진다. 이 배열의 크기는 m이며, 각각의 원소는 n글자의 문자열로 구성되어 있다. 입력되는 값의 제한조건은 다음과 같다. 1 <= m, n <= 100 board의 원소는 아래 나열된 문자로 구성된 문자열이다. 각 문자의 의미는 다음과 같다. .: 빈칸을 나타낸다. *: 막힌 칸을 나타낸다. 알파벳 대문자(A-Z): 타일을 나타낸다. 이 문제에서, 같은 글자로 이루어진 타일은 한 테스트 케이스에 항상 두 개씩만 존재한다. board에는 알파벳 대문자가 항상 존재한다. 즉, 타일이 없는 입력은 주어지지 않는다. 출력 형식 해가 존재하는 경우 타일을 제거하는 순서대로 한 글자씩 이루어진 문자열을, 그렇지 않은 경우 IMPOSSIBLE을 리턴한다. 해가 여러 가지인 경우, 알파벳 순으로 가장 먼저인 문자열을 리턴한다. 예제 입출력 m n board answer 3 3 [""DBA"", ""C*A"", ""CDB""] ""ABCD"" 2 4 [""NRYN"", ""ARYA""] ""RYAN"" 4 4 ["".ZI."", ""M.**"", ""MZU."", "".IU.""] ""MUZI"" 2 2 [""AB"", ""BA""] ""IMPOSSIBLE"" 예제에 대한 설명 첫 번째 테스트 케이스에서 처음으로 제거 가능한 타일은 A와 C이다. 그리고 모든 가능한 경우를 나열하면 ABCD, ACBD, ACDB, CABD, CADB, CDAB이다. 이 중 알파벳 순으로 가장 먼저인 ABCD가 정답이다. 네 번째 테스트 케이스는 초기 상태에서 제거할 수 있는 타일이 없으므로 타일을 모두 제거하는 것이 불가능하다. 따라서 정답은 IMPOSSIBLE이다.",normal,Array
612,"단체사진 찍기 가을을 맞아 카카오프렌즈는 단체로 소풍을 떠났다. 즐거운 시간을 보내고 마지막에 단체사진을 찍기 위해 카메라 앞에 일렬로 나란히 섰다. 그런데 각자가 원하는 배치가 모두 달라 어떤 순서로 설지 정하는데 시간이 오래 걸렸다. 네오는 프로도와 나란히 서기를 원했고, 튜브가 뿜은 불을 맞은 적이 있던 라이언은 튜브에게서 적어도 세 칸 이상 떨어져서 서기를 원했다. 사진을 찍고 나서 돌아오는 길에, 무지는 모두가 원하는 조건을 만족하면서도 다르게 서는 방법이 있지 않았을까 생각해보게 되었다. 각 프렌즈가 원하는 조건을 입력으로 받았을 때 모든 조건을 만족할 수 있도록 서는 경우의 수를 계산하는 프로그램을 작성해보자. 입력 형식 입력은 조건의 개수를 나타내는 정수 n과 n개의 원소로 구성된 문자열 배열 data로 주어진다. data의 원소는 각 프렌즈가 원하는 조건이 N~F=0과 같은 형태의 문자열로 구성되어 있다. 제한조건은 아래와 같다. 1 <= n <= 100 data의 원소는 다섯 글자로 구성된 문자열이다. 각 원소의 조건은 다음과 같다. 첫 번째 글자와 세 번째 글자는 다음 8개 중 하나이다. {A, C, F, J, M, N, R, T} 각각 어피치, 콘, 프로도, 제이지, 무지, 네오, 라이언, 튜브를 의미한다. 첫 번째 글자는 조건을 제시한 프렌즈, 세 번째 글자는 상대방이다. 첫 번째 글자와 세 번째 글자는 항상 다르다. 두 번째 글자는 항상 ~이다. 네 번째 글자는 다음 3개 중 하나이다. {=, <, >} 각각 같음, 미만, 초과를 의미한다. 다섯 번째 글자는 0 이상 6 이하의 정수의 문자형이며, 조건에 제시되는 간격을 의미한다. 이때 간격은 두 프렌즈 사이에 있는 다른 프렌즈의 수이다. 출력 형식 모든 조건을 만족하는 경우의 수를 리턴한다. 예제 입출력 n data answer 2 [""N~F=0"", ""R~T>2""] 3648 2 [""M~C<2"", ""C~M>1""] 0 예제에 대한 설명 첫 번째 예제는 문제에 설명된 바와 같이, 네오는 프로도와의 간격이 0이기를 원하고 라이언은 튜브와의 간격이 2보다 크기를 원하는 상황이다. 두 번째 예제는 무지가 콘과의 간격이 2보다 작기를 원하고, 반대로 콘은 무지와의 간격이 1보다 크기를 원하는 상황이다. 이는 동시에 만족할 수 없는 조건이므로 경우의 수는 0이다.",normal,Array
613,"신비로운 유적 탐험 카카오 고고학 연구팀은 20,000년 전 문명의 발상지를 조사하던 중 벽면에 그려진 비슷한 모양의 그림을 여러 개 발견하게 되었다. 각각의 그림은 트리 형태로 구성되어 있으며 그림의 일부가 유실되어 전체의 정보를 해독할 수는 없었다. 연구팀은 이 그림들이 특정한 부족의 가계도를 그린 것으로 추정하였다. 트리의 루트는 부족의 조상을 의미하며, 루트의 자식들은 트리 상에서 부모-자식 관계로 연결되어 있고, 그들의 자식은 또 새로운 가지로 연결되어 있는 식이다. 이렇게 가족 전체의 관계가 여러 개의 (같은 모양의) 그림으로 남아있으며, 유실된 정보를 제외하고 공통적으로 남아있는 정보를 토대로 이 부족에 대한 연구를 진행할 수 있다고 판단하였다. 다행히 그림의 중심부에는 유실의 흔적이 없어 두 그림의 루트는 같은 사람을 의미한다고 간주할 수 있었다. 아래 그림은 서로 다른 두 그림에서 얻은 정보를 보기 좋은 형태로 나타낸 것이다. 트리의 번호들은 한 트리에서 각각의 정점을 구별하기 위한 것으로 두 트리의 같은 번호가 같은 사람이라는 의미는 아니다. 가설이 맞는지를 확인하기 위해, 두 그림에서 얻은 트리의 공통부분이 얼마나 되는지를 알아보고 싶다. 그림에서 확인할 수 있는 정보는 상대적인 부모-자식 관계가 전부이기 때문에 자식들의 이름이나 순서 등의 정보는 없다. 따라서 자식들의 순서를 무시하고, 각 트리의 루트를 포함하는 부분 트리로서 두 트리에 모두 포함되는 트리를 공통부분으로 정의하자. 두 개의 트리를 입력으로 받아 최대 공통부분의 크기를 계산하는 프로그램을 작성하라. 입력 형식 입력은 두 트리를 나타내는 n1, g1, n2, g2로 주어진다. n1, n2는 각 트리의 노드 수를 의미한다. g1, g2는 트리의 정보를 나타내는 값으로, 각각 크기가 (n1 - 1) × 2와 (n2 - 1) × 2인 2차원 배열로 주어진다. g1, g2의 각각의 행은 연결된 두 노드를 의미하는데, 두 개의 값 중 하나가 부모 노드의 번호, 다른 하나가 자식 노드의 번호이다. 입력되는 값의 제한조건은 아래와 같다. 1 <= n1, n2 <= 100 노드 번호는 각각 1부터 n1, n2까지의 값이 사용되며, 각 트리의 1번 노드가 루트이다. 입력되는 데이터는 항상 올바른 트리임이 보장된다. 출력 형식 두 트리의 최대 공통부분의 노드 수를 리턴한다. 예제 입출력 param value n1 8 g1 [[3, 1], [5, 7], [8, 7], [2, 3], [3, 6], [1, 5], [4, 3]] n2 9 g2 [[1, 5], [5, 6], [3, 7], [3, 1], [7, 4], [7, 2], [9, 8], [5, 9]] answer 7 예제에 대한 설명 본문의 그림과 같은 예이다. 첫 번째 트리에서 1, 2, 3, 4, 5, 7, 8번의 사용자를 포함하는 트리는 두 번째 트리에서 1, 3, 4, 5, 6, 7, 9번 사용자를 포함하는 트리와 모양이 동일하며, 이것이 가장 큰 경우이다.",hard,Array
614,"캠핑 무지를 돌보느라 지친 콘은 한적한 시골의 한 캠핑장에 놀러 갔다. 캠핑장은 텐트를 칠 수 있는 넓은 평지를 제공하고 있는데, 이 평지에는 이미 캠핑장에서 설치해 놓은 n개의 쐐기가 박혀 있다. 캠핑장 이용 고객은 이 쐐기들 중 한 쌍을 골라 다음과 같은 조건을 만족하도록 텐트를 설치해야 한다. 텐트는 직사각형 형태여야 한다. 텐트의 네 면이 정확하게 동, 서, 남, 북을 향해야 한다. 대각에 위치하는 텐트의 두 꼭짓점이 정확하게 선택한 두 개의 쐐기에 위치해야 한다. 텐트가 점유하는 직사각형 영역의 넓이는 0보다는 커야 한다. 텐트가 점유하는 직사각형 영역 내부에 다른 쐐기를 포함하면 안 된다. (다른 쐐기가 경계에 위치하는 경우는 허용함) 캠핑장에서는 위와 같은 조건을 만족하는 위치라면 어디든 고객이 텐트를 설치할 수 있도록 정확한 크기의 텐트를 모두 구비하여 대여해준다고 한다. 당신은 위와 같은 조건을 만족하는 텐트를 설치할 수 있는 쐐기의 쌍의 개수는 총 몇 가지가 될지 궁금해졌다. n개의 쐐기의 위치가 좌표로 주어질 때, 위의 조건을 만족하는 쐐기의 쌍의 개수를 계산하는 프로그램을 작성하시오. 단, 동서 방향은 x축, 남북 방향은 y축과 평행하다고 가정한다. 입력 형식 입력은 쐐기의 개수를 의미하는 정수 n과, n × 2 크기의 2차원 배열 data로 주어지며, 배열의 각 행은 캠핑장에 설치된 쐐기의 x좌표와 y좌표를 의미한다. 제한 조건은 다음과 같다. 2 <= n <= 5,000 n개의 쐐기는 모두 x좌표 0 이상 2^31-1 이하, y좌표 0 이상 2^31-1 이하에 위치한다. 입력되는 n개의 쐐기 중 x좌표와 y좌표가 모두 같은 경우는 없다. 출력 형식 입력에 주어진 각 케이스에 대해 가능한 텐트의 쐐기의 쌍의 개수를 정수 형태로 리턴한다. 예제 입출력 n data answer 4 [[0, 0], [1, 1], [0, 2], [2, 0]] 3 예제에 대한 설명 예제에는 총 4개의 쐐기가 있으며 이 중 (0,0)-(1,1), (0,2)-(1,1), (1,1)-(2,0)의 세 가지 위치에만 텐트를 설치할 수 있다. (0,0)-(0,2)와 (0,0)-(2,0)의 경우에는 직사각형 영역의 넓이가 0이 되기 때문에 조건을 만족하지 못하며, (0,2)-(2,0)의 경우 (1,1) 위치의 쐐기가 직사각형의 내부에 포함되므로 조건을 만족하지 못한다.",normal,Array
615,"보행자 천국 카카오내비 개발자인 제이지는 시내 중심가의 경로 탐색 알고리즘 개발 업무를 담당하고 있다. 최근 들어 보행자가 자유롭고 편리하게 걸을 수 있도록 보행자 중심의 교통 체계가 도입되면서 도심의 일부 구역은 자동차 통행이 금지되고, 일부 교차로에서는 보행자 안전을 위해 좌회전이나 우회전이 금지되기도 했다. 복잡해진 도로 환경으로 인해 기존의 경로 탐색 알고리즘을 보완해야 할 필요가 생겼다. 도시 중심가의 지도는 m × n 크기의 격자 모양 배열 city_map으로 주어진다. 자동차는 오른쪽 또는 아래 방향으로 한 칸씩 이동 가능하다. city_map[i][j]에는 도로의 상황을 나타내는 값이 저장되어 있다. 0인 경우에는 자동차가 자유롭게 지나갈 수 있다. 1인 경우에는 자동차 통행이 금지되어 지나갈 수 없다. 2인 경우는 보행자 안전을 위해 좌회전이나 우회전이 금지된다. (왼쪽에서 오던 차는 오른쪽으로만, 위에서 오던 차는 아래쪽으로만 진행 가능하다) 도시의 도로 상태가 입력으로 주어졌을 때, 왼쪽 위의 출발점에서 오른쪽 아래 도착점까지 자동차로 이동 가능한 전체 가능한 경로 수를 출력하는 프로그램을 작성하라. 이때 가능한 경로의 수는 컴퓨터가 표현할 수 있는 정수의 범위를 넘어설 수 있으므로, 가능한 경로 수를 20170805로 나눈 나머지 값을 출력하라. 입력 형식 입력은 도시의 크기를 나타내는 m과 n, 그리고 지도를 나타내는 2차원 배열 city_map으로 주어진다. 제한조건은 아래와 같다. 1 <= m, n <= 500 city_map의 크기는 m × n이다. 배열의 모든 원소의 값은 0, 1, 2 중 하나이다. 출발점의 좌표는 (0, 0), 도착점의 좌표는 (m - 1, n - 1)이다. 출발점과 도착점의 city_map[i][j] 값은 0이다. 출력 형식 출발점에서 도착점까지 이동 가능한 전체 경로의 수를 20170805로 나눈 나머지를 리턴한다. 예제 입출력 m n city_map answer 3 3 [[0, 0, 0], [0, 0, 0], [0, 0, 0]] 6 3 6 [[0, 2, 0, 0, 0, 2], [0, 0, 2, 0, 1, 0], [1, 0, 0, 2, 2, 0]] 2 예제에 대한 설명 첫 번째 예제는 모든 도로가 제한 없이 통행 가능한 경우로, 가능한 경우의 수는 6가지이다. 두 번째 예제는 문제 설명에 있는 그림의 경우이다. 가능한 경우의 수는 빨간 실선과 노란 점선 2가지뿐이다.",normal,Array
616,"4단 고음 I'm in my dream~↗ ~↗ ~↗ IU는 본인의 장기인 3단 고음으로 유명하다. 그러던 그녀가 어느 날 4단 고음을 성공했고 그녀의 고음은 학계에서 연구가 될 만큼 유명해졌다 [1]. [1] 견두헌, 배명진. “아이유의 고음 발성 특성 분석”, 한국음향학회, 2011년 춘계학술대회 학술발표논문지 폭포 밑 득음 수련을 하던 어느 날, 그녀는 4단 고음이 끝이 아님을 깨달았다. 3단 고음 직후 3단 고음을 연이어하거나, 3단 고음 중 다시 3단 고음을 해서 음높이를 올리는 방법이다. 어떤 순서로 3단 고음을 했는지에 따라 최종 음높이가 달라지기 때문에, 연속 3단 고음을 연습할 때마다 그 결과를 기록으로 남기기로 했다. 3단 고음은 다음과 같이 적용된다. 1단계에서는 음높이가 세 배가 되며, 2단계와 3단계에서 음높이가 각각 1씩 증가한다. 이를 기록으로 남길 때 * 와 + 기호를 사용하기로 했다. 즉, 3단 고음을 한 번 한 경우는 문자열로 나타내면 다음과 같다. *++ 이때 3단 고음을 마치고 연달아 3단 고음을 한 경우는 *++*++ 와 같이 표현할 수 있다. 3단 고음의 2단계를 마친 후 3단 고음을 새로 시작한 다음, 나머지 단계를 이어서 하는 경우는 *+*+++로 표현할 수 있다. (강조된 부분이 2번째 3단 고음을 부른 부분이다.) 이와 같이 * 와 + 로 구성된 문자열이 3단 고음의 규칙을 적용하여 만들 수 있는 문자열인 경우 '올바른 문자열'이라고 하자. 다음의 문자열은 3단 고음의 규칙으로 만들 수 있는 문자열이 아니므로 올바른 문자열이 아니다. +**+++ *+++*+ 올바른 문자열에 대해 음높이는 다음과 같이 계산할 수 있다. 시작 음높이는 항상 1이며, 문자열의 처음부터 순서대로 * 기호의 경우 3을 곱하고 + 기호의 경우 1을 더한다. *+*+++ 의 음높이를 계산하는 과정을 예로 들면 아래와 같다. 시작 음 높이: 1 * + * + + + *3 +1 *3 +1 +1 +1 최종 음높이: 15 그날 기분에 따라 최종 음높이를 정하는 IU는 최종 음높이를 결정했을 때 서로 다른 3단 고음 문자열이 몇 가지나 있는지 궁금하다. 여러분의 도움이 필요하다. 입력 형식 입력은 5 이상 2^31-1 이하의 정수 n으로 주어진다. 출력 형식 입력을 만족하는 서로 다른 문자열의 수를 리턴한다. 예제 입출력 n answer 15 1 24 0 41 2 2147483647 1735 예제에 대한 설명 세 번째 예제의 두 가지 경우는 다음과 같다. **++++*++ *+**+++++",hard,String
617,"브라이언의 고민 알림: '실행'을 눌렀을 시 올바른 코드가 틀린 결과로 표시되는 경우가 있습니다. 하단의 설명을 참고해주세요. 카카오스토리의 개발자 브라이언에게 최근 고민이 생겼다. 하루에도 수백만 명이 사용하는 서비스답게 사람들이 많이 보는 글에 광고성 댓글을 달아 불쾌감을 유발하는 사용자가 증가하고 있는데, 신고를 받은 글이 광고글인지를 운영자가 판단하여 차단하는 시스템으로는 빠르게 늘어나는 광고글을 처리하기 어렵기 때문이다. 그래서 브라이언은 신고된 글이 광고글인지를 자동으로 판단하는 시스템을 만들었다. 이제 사용자가 광고글을 보고 신고하면 그 글이 광고글로 판단된 경우 자동으로 차단된다! 드디어 깨끗한 카카오스토리를 만들었다는 기쁨도 잠시, 광고글을 올리는 사람들이 자동 차단 시스템을 회피할 수 있는 방법을 찾기 시작했고, 얼마 지나지 않아 광고 문구 사이에 특수문자를 넣으면 차단되지 않는다는 점이 알려지게 되었다. 즉, 아래와 같은 식으로 작성하면 광고글 차단이 적용되지 않는다. ♚프☆렌☆즈☆레☆이☆싱♚★사전예약★진행중 $지금$예약시♜이모티콘♜100%※증정※ ★라이언★카트♨전원♨획@득@기@회 즉시이동 http://... 생각지 못한 광고글 패턴에 당황하던 브라이언은 광고글이 일정한 규칙에 의해 만들어진다는 사실을 알게 되었는데, 그 규칙은 다음과 같다. (아래 설명 및 그 이후의 내용에서 영문 대문자는 원래 문구, 소문자는 특수기호를 의미한다.) 광고글은 원래 문구에 다음 규칙을 적용하여 만들 수 있다. (규칙 1) 특정 단어를 선택하여 글자 사이마다 같은 기호를 넣는다. ex) HELLO -> HaEaLaLaO (규칙 2) 특정 단어를 선택하여 단어 앞뒤에 같은 기호를 넣는다. ex) WORLD -> bWORLDb 위의 두 가지 규칙은 한 단어에 모두 적용될 수 있지만 같은 규칙은 두 번 적용될 수 없다. 한 번 쓰인 소문자(특수기호)는 다시 쓰일 수 없다. 마지막으로 원래 문구에 있던 공백을 제거한다. 위의 규칙에 따라, HELLO WORLD는 다음의 광고 문구로 변환될 수 있다. HELLOWORLD (기호 삽입 없이 마지막 규칙인 공백 제거만 적용되었다.) HaEaLaLaObWORLDb (첫 번째 단어에는 규칙 1이, 두 번째 단어에는 규칙 2가 적용되었다.) aHbEbLbLbOacWdOdRdLdDc (모든 단어에 모든 규칙이 적용되었다.) 단, 아래의 문구는 올바르게 변환된 광고문구가 아니다. aHELLOa bWORLDb (공백이 제거되어야 한다.) HaEaLaLObWORLDb (규칙 1은 단어의 모든 글자 사이에 적용되어야 한다. 단, 이 문장은 원문이 HELL O WORLD인 경우 올바른 변환이다.) aHELLOWORLDa (규칙 2는 한 단어에 적용되어야 한다. 단, 이 문장은 원문이 HELLOWORLD인 경우 올바른 변환이다.) HaEaLaLaOWaOaRaLaD (첫 번째 단어에 쓰인 기호 a를 두 번째 단어에 쓸 수 없다.) abHELLObaWORLD (하나의 규칙을 같은 단어에 두 번 적용할 수 없다.) 신고된 글에 대해 위 규칙이 적용되기 전 문구를 찾을 수 있으면 자동 차단 시스템을 다시 온전하게 실행할 수 있게 된다. 카카오스토리가 광고글 없는 깨끗한 공간이 될 수 있도록 프로그램을 만들어보자. 입력 형식 입력은 문자열 변수 sentence로 주어진다. 이 문자열은 영문 대소문자로만 이루어져 있으며, 길이는 1,000 이하이다. 출력 형식 입력으로 주어진 광고 문구의 규칙 적용 전 원래 문구를 리턴한다. 단 원래 문구의 경우 문장 앞뒤의 공백이 없어야 하며, 단어 사이의 공백은 한 글자여야 한다. 가능한 답이 여러 가지인 경우 그중 하나를 리턴하면 된다. 규칙에 따른 변환으로 만들 수 없는 문자열이 입력된 경우에는 소문자로 invalid를 리턴한다. 예제 입출력 sentence answer ""HaEaLaLaObWORLDb"" ""HELLO WORLD"" ""SpIpGpOpNpGJqOqA"" ""SIGONG JOA"" ""AxAxAxAoBoBoB"" ""invalid"" 예제에 대한 설명 첫 번째 테스트 케이스는 문제 설명에 제시된 데이터와 같다. 두 번째 테스트 케이스에서, 기호 q는 규칙 1, 혹은 규칙 2에 의해 추가된 기호일 수 있다. 규칙 1에 해당하는 경우 원문은 SIGONG JOA로 예제 출력과 같으며, 규칙 2에 해당하는 경우의 원문인 SIGONG J O A도 올바른 답이다. 세 번째 테스트 케이스에서 x는 규칙 1에 의해 추가된 기호여야 한다. (규칙 2에 의해 추가되었다면 기호가 단어 앞뒤에 붙게 되므로 2개여야 한다.) 그러므로 AAAA가 한 단어여야 한다. 마찬가지로 o도 규칙 1에 의해 추가된 기호여야 하기 때문에 ABBB가 한 단어여야 한다. 이는 동시에 만족할 수 없는 조건이므로 주어진 문구는 규칙을 만족할 수 없게 된다. 따라서 invalid를 리턴한다. 알림 '실행'을 눌러 기본 테스트케이스에 대해 결과를 확인할 때 정답이 여러 개인 경우에도 하나의 답만 정답으로 처리되고 있습니다. 두 번째 예제 입력에 대해 SIGONG J O A를 리턴하는 코드의 경우 정답이지만 올바르지 않은 결과로 표시됩니다. '코드 채점'을 눌러 제출할 시에는 올바르게 채점되니 참고하여 주시기 바랍니다.",normal,String
618,"카카오 프렌즈 컬러링북 출판사의 편집자인 어피치는 네오에게 컬러링북에 들어갈 원화를 그려달라고 부탁하여 여러 장의 그림을 받았다. 여러 장의 그림을 난이도 순으로 컬러링북에 넣고 싶었던 어피치는 영역이 많으면 색칠하기가 까다로워 어려워진다는 사실을 발견하고 그림의 난이도를 영역의 수로 정의하였다. (영역이란 상하좌우로 연결된 같은 색상의 공간을 의미한다.) 그림에 몇 개의 영역이 있는지와 가장 큰 영역의 넓이는 얼마인지 계산하는 프로그램을 작성해보자. 위의 그림은 총 12개 영역으로 이루어져 있으며, 가장 넓은 영역은 어피치의 얼굴면으로 넓이는 120이다. 입력 형식 입력은 그림의 크기를 나타내는 m과 n, 그리고 그림을 나타내는 m × n 크기의 2차원 배열 picture로 주어진다. 제한조건은 아래와 같다. 1 <= m, n <= 100 picture의 원소는 0 이상 2^31 - 1 이하의 임의의 값이다. picture의 원소 중 값이 0인 경우는 색칠하지 않는 영역을 뜻한다. 출력 형식 리턴 타입은 원소가 두 개인 정수 배열이다. 그림에 몇 개의 영역이 있는지와 가장 큰 영역은 몇 칸으로 이루어져 있는지를 리턴한다. 예제 입출력 m n picture answer 6 4 [[1, 1, 1, 0], [1, 2, 2, 0], [1, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 3], [0, 0, 0, 3]] [4, 5] 예제에 대한 설명 예제로 주어진 그림은 총 4개의 영역으로 구성되어 있으며, 왼쪽 위의 영역과 오른쪽의 영역은 모두 1로 구성되어 있지만 상하좌우로 이어져있지 않으므로 다른 영역이다. 가장 넓은 영역은 왼쪽 위 1이 차지하는 영역으로 총 5칸이다.",normal,Array
619,"Write a function to find the minimum cost path to reach (m, n) from (0, 0) for the given cost matrix cost[][] and a position (m, n) in cost[][].",easy,Array
620,Write a function to find the similar elements from the given two tuple lists.,easy,Hash Table
621,Write a python function to identify non-prime numbers.,easy,Math
622,Write a function to find the largest integers from a given list of numbers using heap queue algorithm.,easy,Heap (Priority Queue)
623,Write a function to find the number of ways to fill it with 2 x 1 dominoes for the given 3 x n board.,normal,Array
624,Write a python function to check whether the two numbers differ at one bit position only or not.,easy,Math
625,Write a function to find all words which are at least 4 characters long in a string by using regex.,easy,String
626,Write a function to find squares of individual elements in a list using lambda function.,easy,Math
627,Write a python function to find the minimum number of rotations required to get the same string.,easy,Array
628,Write a function to get the n smallest items from a dataset.,easy,Heap (Priority Queue)
629,Write a python function to remove first and last occurrence of a given character from the string.,easy,Array
630,Write a function to sort a given matrix in ascending order according to the sum of its rows.,easy,Sorting
631,Write a function to count the most common words in a dictionary.,easy,Simulation
632,Write a python function to find the volume of a triangular prism.,easy,Math
633,Write a function to split a string at lowercase letters.,easy,Array
634,Write a function to find sequences of lowercase letters joined with an underscore.,easy,Array
635,Write a function to find the perimeter of a square.,easy,Math
636,Write a function to remove characters from the first string which are present in the second string.,easy,Array
637,Write a function to find whether a given array of integers contains any duplicate element.,easy,Hash Table
638,Write a function to check if the given number is woodball or not.,easy,Math
639,Write a function to find m number of multiples of n.,easy,Math
640,Write a function to find the first duplicate element in a given array of integers.,easy,Array
641,Write a python function to find the maximum sum of elements of list in a list of lists.,easy,Math
642,Write a function to convert the given binary number to its decimal equivalent.,easy,Math
643,Write a python function to find the product of non-repeated elements in a given array.,easy,Array
644,Write a function to check if the given tuple list has all k elements.,easy,Simulation
645,Write a python function to remove all digits from a list of strings.,easy,Array
646,Write a python function to find binomial co-efficient.,easy,Math
647,Write a python function to find the element occurring odd number of times.,easy,Array
648,Write a python function to count all the substrings starting and ending with same characters.,easy,Array
649,Write a function to find the top k integers that occur most frequently from given lists of sorted and distinct integers using heap queue algorithm.,easy,Hash Table
650,Write a python function to find the largest prime factor of a given number.,easy,Math
651,Write a python function to convert a decimal number to binary number.,easy,Math
652,Write a python function to find the missing number in a sorted array.,easy,Array
653,Write a function to find the n-th rectangular number.,easy,Math
654,Write a python function to find the nth digit in the proper fraction of two given numbers.,easy,Math
655,Write a function to sort a given mixed list of integers and strings.,easy,Array
656,Write a function to find the division of first even and odd number of a given list.,easy,Math
657,Write a function to check if the letters of a given string can be rearranged so that two characters that are adjacent to each other are different.,normal,Heap (Priority Queue)
658,Write a function to find frequency of the elements in a given list of lists using collections module.,easy,Counting
659,Write a function to filter even numbers using lambda function.,easy,Math
660,Write a python function to find the sum of repeated elements in a given array.,easy,Array
661,Write a function to find sequences of lowercase letters joined with an underscore using regex.,easy,Array
662,Write a function that matches a word at the beginning of a string.,easy,Math
663,Write a function to find the gcd of the given array elements.,easy,Array
664,Write a python function to determine whether all the numbers are different from each other are not.,easy,Hash Table
665,Write a python function to find the last digit when factorial of a divides factorial of b.,easy,Math
666,Write a python function to set all odd bits of a given number.,easy,Math
667,Write a function to extract every first or specified element from a given two-dimensional list.,easy,Array
668,Write a function to find the list with minimum length using lambda function.,easy,Simulation
669,Write a function to print check if the triangle is equilateral or not.,easy,Simulation
670,Write a function to caluclate area of a parallelogram.,easy,Math
671,Write a python function to check whether the first and last characters of a given string are equal or not.,easy,Array
672,Write a function to sort the given array by using counting sort.,easy,Array
673,Write a function to find t-nth term of geometric series.,easy,Math
674,Write a python function to check if a given number is one less than twice its reverse.,easy,Math
675,Write a python function to find the largest number that can be formed with the given digits.,easy,Array
676,Write a python function to check whether the given two integers have opposite sign or not.,easy,Simulation
677,Write a function to find the nth octagonal number.,easy,Math
678,Write a function to find the maximum length of the subsequence with difference between adjacent elements for the given array.,easy,Array
679,Write a python function to count number of substrings with the sum of digits equal to their length.,easy,Hash Table
680,Write a python function to find smallest number in a list.,easy,Simulation
681,Write a function to find the maximum difference between available pairs in the given tuple list.,easy,Array
682,Write a function to sort a list of tuples using lambda.,easy,Array
683,Write a function of recursion list sum.,easy,Array
684,Write a python function to count positive numbers in a list.,easy,Math
685,Write a function to find the number of ways to partition a set of bell numbers.,easy,Array
686,Write a python function to check whether the given array is monotonic or not.,easy,Array
687,Write a function to check whether a list contains the given sublist or not.,easy,Array
688,Write a function to find whether all the given tuples have equal length or not.,easy,Simulation
689,Write a function to sort a list of elements using comb sort.,easy,Array
690,Write a python function to check whether the given number can be represented as difference of two squares or not.,easy,Math
691,Write a function to split the given string with multiple delimiters by using regex.,easy,Math
692,Write a function to check whether it follows the sequence given in the patterns array.,easy,Array
693,Write a function to find tuples which have all elements divisible by k from the given list of tuples.,easy,Array
694,Write a python function to count the number of squares in a rectangle.,easy,Math
695,Write a python function to find the difference between sum of even and odd digits.,easy,Math
696,Write a python function to find number of integers with odd number of set bits.,easy,Math
697,Write a python function to check whether the length of the word is odd or not.,easy,Math
698,Write a function to find the nth tetrahedral number.,easy,Math
699,Write a function to zip the two given tuples.,easy,Array
700,Write a function to find the volume of a sphere.,easy,Math
701,Write a python function to find the character made by adding all the characters of the given string.,easy,Array
702,Write a function to find the n-th number in newman conway sequence.,normal,Math
703,Write a function to find the surface area of a sphere.,easy,Math
704,Write a function to find nth centered hexagonal number.,easy,Math
705,Write a function to merge three dictionaries into a single expression.,easy,Hash Table
706,Write a function to get the frequency of the elements in a list.,easy,Hash Table
707,Write a function to find the closest smaller number than n.,easy,Math
708,Write a python function to find the length of the longest word.,easy,Array
709,Write a function to check if a substring is present in a given list of string values.,easy,String
710,Write a function to check whether the given number is undulating or not.,easy,Array
711,Write a function to calculate the value of 'a' to the power 'b'.,easy,Math
712,Write a function to extract the index minimum value record from the given tuples.,easy,Array
713,Write a python function to find the minimum length of sublist.,easy,Simulation
714,Write a python function to find the number of divisors of a given integer.,easy,Array
715,Write a function to find frequency count of list of lists.,easy,Array
716,Write a function to multiply all the numbers in a list and divide with the length of the list.,easy,Math
717,Write a function to convert the given decimal number to its binary equivalent.,easy,Simulation
718,Write a function to find the next smallest palindrome of a specified number.,normal,Array
719,Write a function to find the kth element in the given array.,easy,Array
720,Write a function to convert snake case string to camel case string.,easy,String
721,"Write a function to find eulerian number a(n, m).",normal,Math
722,Write a function to sort each sublist of strings in a given list of lists using lambda function.,easy,Array
723,Write a python function to count true booleans in the given list.,easy,Simulation
724,Write a function to add the given list to the given tuples.,easy,Math
725,Write a python function to count hexadecimal numbers for a given range.,easy,Math
726,Write a function to merge multiple sorted inputs into a single sorted iterator using heap queue algorithm.,easy,Heap (Priority Queue)
727,Write a python function to find the count of rotations of a binary string with odd value.,easy,Array
728,Write a function to extract the ranges that are missing from the given list with the given start range and end range values.,normal,Array
729,Write a function to find common elements in given nested lists. * list item * list item * list item * list item,easy,Math
730,Write a python function to find the perimeter of a cylinder.,easy,Math
731,Write a function to check if a string represents an integer or not.,easy,Array
732,Write a function to assign frequency to each tuple in the given tuple list.,easy,Array
733,Write a function to check whether all dictionaries in a list are empty or not.,easy,Simulation
734,Write a function to convert a given tuple of positive integers into an integer.,easy,String
735,Write a function to convert all possible convertible elements in the list to float.,easy,Array
736,[link text](https:// [link text](https:// [link text](https://)))write a function to convert a string to a list.,easy,String
737,Write a python function to find the element that appears only once in a sorted array.,easy,Array
738,Write a function to find the maximum product from the pairs of tuples within a given list.,easy,Array
739,Write a function to find the triplet with sum of the given array,normal,Array
740,Write a function to find n’th smart number.,normal,Array
741,Write a function to sum all amicable numbers from 1 to a specified number.,normal,Array
742,Write a function to get the angle of a complex number.,easy,Math
743,Write a function to find the maximum difference between the number of 0s and number of 1s in any sub-string of the given binary string.,easy,Array
744,Write a python function to find the sum of common divisors of two given numbers.,easy,Math
745,Write a function to multiply two integers without using the * operator in python.,easy,Math
746,Write a function to shortlist words that are longer than n from a given list of words.,easy,Array
747,Write a function to calculate magic square.,easy,Array
748,Write a function to find the item with maximum frequency in a given list.,easy,Hash Table
749,Write a python function to reverse only the vowels of a given string.,easy,Array
750,Write a function to convert tuple to a string.,easy,String
751,Write a function to calculate the sum of the negative numbers of a given list of numbers using lambda function.,easy,Simulation
752,Write a python function to check whether the last element of given array is even or odd after performing an operation p times.,easy,Array
753,Write a function to find the nth hexagonal number.,easy,Math
754,Write a function to calculate electricity bill.,easy,Math
755,Write a function to find the ration of zeroes in an array of integers.,easy,Math
756,Write a python function to check whether the given number can be represented as sum of non-zero powers of 2 or not.,easy,Math
757,Write a function to find the circumference of a circle.,easy,Math
758,Write a function to extract elements that occur singly in the given tuple list.,easy,Array
759,Write a function to sort a list of elements using pancake sort.,easy,Array
760,Write a function to count the same pair in three given lists.,easy,Simulation
761,Write a function to find number of lists present in the given tuple.,easy,Simulation
762,Write a python function to find the sum of absolute differences in all pairs of the given array.,normal,Array
763,Write a python function to find the maximum difference between any two elements in a given array.,easy,Array
764,Write a function to find the ascii value of total characters in a string.,easy,Array
765,Write a function to find the maximum total path sum in the given triangle.,easy,Array
766,Write a function to divide a number into two parts such that the sum of digits is maximum.,easy,Math
767,Write a function to find the longest subsequence such that the difference between adjacents is one for the given array.,easy,Array
768,Write a python function to find whether the given number is present in the infinite sequence or not.,easy,Math
769,Write a python function to check whether the given number is co-prime or not.,easy,Math
770,Write a function to sort the given array by using merge sort.,easy,Array
771,Write a function to find the vertex of a parabola.,easy,Math
772,Write a function to extract every specified element from a given two dimensional list.,easy,Array
773,Write a python function to toggle all even bits of a given number.,easy,Math
774,Write a function to convert a tuple of string values to a tuple of integer values.,easy,Array
775,Write a function to reflect the run-length encoding from a list.,easy,Counting
776,Write a python function to find k number of operations required to make all elements equal.,easy,Array
777,Write a function to print the season for the given month and day.,easy,Simulation
778,Write a function to find x and y that satisfies ax + by = n.,normal,Math
779,Write a function to remove all elements from a given list present in another list.,easy,Array
780,Write a function to calculate the sum of the positive integers of n+(n-2)+(n-4)... (until n-x =< 0).,easy,Math
781,Write a function to calculate the area of a regular polygon.,easy,Math
782,Write a python function to check whether the sum of divisors are same or not.,easy,Math
783,Write a python function to count characters at same position in a given string (lower and uppercase characters) as in english alphabet.,easy,Array
784,Write a python function to count the pairs with xor as an even number.,easy,Array
785,Write a python function to find smallest power of 2 greater than or equal to n.,easy,Math
786,Write a python function to find the frequency of a number in a given array.,easy,Math
787,Write a function to calculate the nth pell number.,easy,Math
788,Write a function to find sum of the numbers in a list between the indices of a specified range.,easy,Array
789,Write a function to find the perimeter of a pentagon.,easy,Math
790,Write a function to find the occurence of characters 'std' in the given string 1. list item 1. list item 1. list item 2. list item 2. list item 2. list item,easy,Array
791,Write a function to remove everything except alphanumeric characters from a string.,easy,Array
792,Write a function to group a sequence of key-value pairs into a dictionary of lists.,easy,Array
793,Write a function to verify validity of a string of parentheses.,easy,Array
794,Write a function to find the perimeter of a triangle.,easy,Math
795,Write a python function to find two distinct numbers such that their lcm lies within the given range.,easy,Math
796,Write a function to search some literals strings in a string.,easy,String
797,Write a function to find if the given number is a keith number or not.,easy,Array
798,Write a function to calculate distance between two points using latitude and longitude.,easy,Math
799,Write a function to find the longest common prefix in the given set of strings.,easy,Array
800,"Write a function to find uppercase, lowercase, special character and numeric values using regex.",easy,Array
801,Write a function to count all the distinct pairs having a difference of k in any array.,easy,Array
802,Write a function to find all the values in a list that are greater than a specified number.,easy,Simulation
803,Write a function to find the focus of a parabola.,easy,Math
804,Write a function to search some literals strings in a string by using regex.,easy,String
805,Write a function to find the longest common subsequence for the given two sequences.,normal,Array
806,Write a python function to check whether the given number can be represented by product of two squares or not.,easy,Math
807,Write a python function to find the first missing positive number.,hard,Array
808,Write a python function to count the number of integral co-ordinates that lie inside a square.,easy,Math
809,Write a function to check whether the given month name contains 30 days or not.,easy,Simulation
810,Write a python function to check whether a string has atleast one letter and one number.,easy,String
811,Write a function to remove the duplicates from the given tuple.,easy,Hash Table
812,Write a python function to convert octal number to decimal number.,easy,Math
813,Write a python function to find the first position of an element in a sorted array.,easy,Array
814,Write a function to remove all the tuples with length k.,easy,Array
815,Write a function to perform the exponentiation of the given two tuples.,easy,Math
816,Write a function to find the largest triangle that can be inscribed in an ellipse.,normal,Math
817,Write a python function to find highest power of 2 less than or equal to given number.,easy,Math
818,Write a function to find all index positions of the maximum values in a given list.,easy,Array
819,Write a python function to check whether the elements in a list are same or not.,easy,Hash Table
820,Write a function to remove even characters in a string.,easy,Array
821,Write a python function to find the hamming distance between given two integers.,easy,Math
822,Write a python function to count the occurrence of a given character in a string.,easy,Array
823,Write a function to find the inversions of tuple elements in the given tuple list.,easy,Simulation
824,Write a function to perform the adjacent element concatenation in the given tuples.,easy,Array
825,Write a function to count the longest repeating subsequences such that the two subsequences don’t have same string characters at same positions.,normal,Array
826,Write a function to check the given decimal with a precision of 2 by using regex.,easy,Array
827,Write a function to delete the smallest element from the given heap and then insert a new item.,easy,Heap (Priority Queue)
828,"Write a function to check that the given string contains only a certain set of characters(in this case a-z, a-z and 0-9) by using regex.",easy,Array
829,Write a python function to count numbers whose oth and nth bits are set.,easy,Math
830,Write a python function to find the sum of fourth power of n natural numbers.,easy,Math
831,Write a function to perform the concatenation of two string tuples.,easy,Math
832,Write a function to convert radians to degrees.,easy,Math
833,Write a function to decode a run-length encoded given list.,easy,Array
834,Write a function to check if a nested list is a subset of another nested list.,normal,Array
835,Write a python function to find the first repeated character in a given string.,easy,Array
836,Write a python function to find the minimum operations required to make two numbers equal.,easy,Math
837,Write a function to extract maximum and minimum k elements in the given tuple.,easy,Array
838,"Write a function to replace maximum n occurrences of spaces, commas, or dots with a colon.",easy,Array
839,Write a python function to find the first even number in a given list of numbers.,easy,Math
840,Write a function to check if all the elements in tuple have same data type or not.,easy,Array
841,Write a function to check for majority element in the given sorted array.,easy,Array
842,Write a python function to count set bits of a given number.,easy,Math
843,Write a python function to find the minimum element in a sorted and rotated array.,normal,Array
844,Write a python function to remove the characters which have odd index values of a given string.,easy,Array
845,Write a function to find minimum of three numbers.,easy,Simulation
846,Write a python function to check whether all the bits are unset in the given range or not.,easy,Math
847,Write a function to re-arrange the elements of the given array so that all negative elements appear before positive ones.,easy,Array
848,Write a function to replace blank spaces with any character in a string.,easy,String
849,Write a function to find the maximum sum in the given right triangle of numbers.,easy,Array
850,Write a function to get the n largest items from a dataset.,easy,Heap (Priority Queue)
851,Write a function to find the lateral surface area of a cylinder.,easy,Math
852,Write a function to find the volume of a cube.,easy,Math
853,Write a python function to set all even bits of a given number.,easy,Math
854,Write a python function to count the maximum number of equilateral triangles that can be formed within a given equilateral triangle.,easy,Math
855,Write a function to check the occurrences of records which occur similar times in the given tuples.,easy,Hash Table
856,Write a python function to count number of non-empty substrings of a given string.,easy,Math
857,Write a function to find the number of possible sequences of length n such that each of the next element is greater than or equal to twice of the previous element but less than or equal to m.,easy,Array
858,Write a function to replace the last element of the list with another list.,easy,Array
859,Write a function to generate a 3d array having each element as '*'.,easy,Array
860,Write a function to count total characters in a string.,easy,Math
861,Write a function to sort the given list based on the occurrence of first element of tuples.,easy,Array
862,Write a python function to find the next perfect square greater than a given number.,easy,Math
863,Write a function to find the maximum sum of bi-tonic sub-sequence for the given array.,normal,Array
864,Write a function for computing square roots using the babylonian method.,easy,Math
865,Write a function to find the longest palindromic subsequence in the given string.,normal,Array
866,Write a function to calculate the harmonic sum of n-1.,easy,Math
867,Write a function to find the intersection of two arrays using lambda function.,easy,Simulation
868,Write a python function to count the occcurences of an element in a tuple.,easy,Math
869,Write a function to insert an element before each element of a list.,easy,Array
870,Write a python function to convert complex numbers to polar coordinates.,easy,Math
871,Write a python function to count integers from a given list.,easy,Math
872,Write a function to find all words starting with 'a' or 'e' in a given string.,easy,Array
873,Write a function to choose specified number of colours from three different colours and generate all the combinations with repetitions.,easy,Counting
874,Write a python function to count the number of prime numbers less than a given non-negative number.,easy,Math
875,Write a function to swap two numbers.,easy,Simulation
876,Write a function to find number of odd elements in the given list using lambda function.,easy,Math
877,Write a function to maximize the given two tuples.,easy,Simulation
878,Write a function to find the nth newman–shanks–williams prime number.,normal,Math
879,Write a function to perform mathematical division operation across the given tuples.,easy,Math
880,Write a function to split a given list into two parts where the length of the first part of the list is given.,easy,Array
881,Write a function to merge two dictionaries.,easy,Hash Table
882,Write a function to calculate a dog's age in dog's years.,easy,Math
883,Write a function to split a list for every nth element.,easy,Array
884,Write a function to find the lateral surface area of a cube.,easy,Math
885,Write a python function to find the sum of squares of first n odd natural numbers.,easy,Math
886,Write a function to find the n'th star number.,easy,Math
887,Write a function to find the ascii value of a character.,easy,Simulation
888,Write a python function to find the sum of even numbers at even positions.,easy,Array
889,Write a python function to find the sum of fifth power of first n even natural numbers.,easy,Math
890,Write a function to perfom the rear element extraction from list of tuples records.,easy,Array
891,Write a function to substract the contents of one tuple with corresponding index of other tuple.,easy,Math
892,Write a python function to find sum of even index binomial coefficients.,easy,Math
893,Write a python function to find the position of the last removed element from the given array.,easy,Array
894,Write a function to find the volume of a cylinder.,easy,Math
895,Write a function to filter a dictionary based on values.,easy,Simulation
896,Write a function to find the element count that occurs before the record in the given tuple.,easy,Simulation
897,Write a function to find the nth decagonal number.,easy,Math
898,Write a function to search an element in the given array by using sequential search.,easy,Array
899,Write a python function to check if the elements of a given list are unique or not.,easy,Hash Table
900,Write a function to substaract two lists using map and lambda function.,easy,Math
901,Write a python function to check whether the frequency of each digit is less than or equal to the digit itself.,easy,Math
902,Write a function to check whether all items of a list are equal to a given string.,easy,String
903,Write a function that matches a string that has an a followed by two to three 'b'.,easy,String
904,Write a function to find the largest sum of contiguous array in the modified array which is formed by repeating the given array k times.,normal,Array
905,Write a python function to find the sum of squares of first n even natural numbers.,easy,Math
906,Write a function to count array elements having modular inverse under given prime number p equal to itself.,easy,Array
907,Write a python function to calculate the number of odd days in a given year.,easy,Math
908,Write a function to find the list of lists with maximum length.,easy,Simulation
909,Write a function to find out the number of ways of painting the fence such that at most 2 adjacent posts have the same color for the given fence with n posts and k colors.,easy,Array
910,Write a python function to find quotient of two numbers.,easy,Math
911,Write a function to find the third side of a right angled triangle.,easy,Math
912,Write a function to find the maximum value in a given heterogeneous list.,easy,Simulation
913,Write a function to return the sum of all divisors of a number.,easy,Array
914,Write a python function to count inversions in an array.,normal,Array
915,Write a function to flatten a given nested list structure.,easy,Array
916,Write a function to find the nested list elements which are present in another list.,easy,Array
917,Write a function to calculate the maximum aggregate from the list of tuples.,easy,Hash Table
918,Write a function to find the count of all binary sequences of length 2n such that sum of first n bits is same as sum of last n bits.,easy,Math
919,Write a function to find the depth of a dictionary.,easy,Math
920,Write a python function to find the most significant bit number which is also a set bit.,easy,Math
921,Write a python function to check whether the count of inversion of two types are same or not.,easy,Array
922,Write a python function to find element at a given index after number of rotations.,easy,Array
923,Write a function to match two words from a list of words starting with letter 'p'.,easy,Math
924,"Write a function to find the maximum sum of increasing subsequence from prefix till ith index and also including a given kth element which is after i, i.e., k > i .",normal,Array
925,Write a function to get a colon of a tuple.,easy,Array
926,Write a function to find the specified number of largest products from two given lists.,normal,Array
927,Write a python function to find the maximum of two numbers.,easy,Simulation
928,Write a function to convert a given string to a tuple.,easy,String
929,Write a python function to set the left most unset bit.,easy,Math
930,Write a function to find the volume of a cone.,easy,Math
931,Write a python function to print positive numbers in a list.,easy,Simulation
932,Write a function to find out the maximum sum such that no two chosen numbers are adjacent for the given rectangular grid of dimension 2 x n.,easy,Array
933,Write a python function to find the first maximum length of even word.,easy,Array
934,Write a function to find the index of the last occurrence of a given number in a sorted array.,easy,Array
935,Write a function to reflect the modified run-length encoding from a list.,easy,Counting
936,Write a python function to find the maximum volume of a cuboid with given sum of sides.,easy,Math
937,Write a function to find all five characters long word in the given string by using regex.,easy,String
938,Write a function to calculate the difference between the squared sum of first n natural numbers and the sum of squared first n natural numbers.,easy,Math
939,Write a function to find the demlo number for the given number.,easy,Math
940,Write a function to find all index positions of the minimum values in a given list.,easy,Array
941,Write a function to re-arrange the given array in alternating positive and negative items.,normal,Array
942,Write a function to extract the sum of alternate chains of tuples.,easy,Math
943,Write a python function to find the minimum number of squares whose sum is equal to a given number.,normal,Math
944,Write a function to get the word with most number of occurrences in the given strings list.,easy,Hash Table
945,Write a function to print check if the triangle is isosceles or not.,easy,Simulation
946,Write a function to rotate a given list by specified number of items to the left direction.,easy,Array
947,Write a python function to count negative numbers in a list.,easy,Math
948,"Write a function to find all three, four, five characters long words in the given string by using regex.",easy,String
949,Write a python function to count unset bits of a given number.,easy,Math
950,Write a function to count character frequency of a given string.,easy,Array
951,Write a python function to sort a list according to the second element in sublist.,easy,Array
952,Write a python function to check whether the triangle is valid or not if sides are given.,easy,Math
953,Write a function to find the sum of arithmetic progression.,easy,Math
954,Write a function to check whether the given month name contains 28 days or not.,easy,Simulation
955,"Write a function that matches a word at the end of a string, with optional punctuation.",easy,Math
956,Write a python function to count the number of substrings with same first and last characters.,easy,Array
957,Write a python function to find the maximum occuring divisor in an interval.,easy,Simulation
958,Write a python function to find the sum of the three lowest positive numbers from a given list of numbers.,easy,Array
959,Write a function to convert the given set into ordered tuples.,easy,Sorting
960,Write a function to find the smallest range that includes at-least one element from each of the given arrays.,normal,Heap (Priority Queue)
961,Write a function to calculate the number of digits and letters in a string.,easy,Math
962,Write a python function to find number of elements with odd factors in a given range.,easy,Math
963,Write a function to find the difference between two consecutive numbers in a given list.,easy,Array
964,"Write a function to find entringer number e(n, k).",normal,Math
965,Write a python function to count the number of squares in a rectangle.,easy,Math
966,Write a function to count sequences of given length having non-negative prefix sums that can be generated by given values.,easy,Math
967,Write a python function to check whether the given string is a binary string or not.,easy,Hash Table
968,Write a python function to minimize the length of the string by removing occurrence of only one character.,easy,Array
969,Write a python function to find the first element occurring k times in a given array.,easy,Array
970,Write a python function to check whether all the characters in a given string are unique.,easy,Array
971,Write a function to remove a specified column from a given nested list.,easy,Array
972,Write a function to find t-nth term of arithemetic progression.,easy,Math
973,Write a python function to count the number of rectangles in a circle of radius r.,easy,Math
974,Write a function to find the third angle of a triangle using two angles.,easy,Math
975,Write a function to find the maximum element of all the given tuple records.,easy,Simulation
976,Write a function to find modulo division of two lists using map and lambda function.,easy,Math
977,Write a python function to check whether one root of the quadratic equation is twice of the other or not.,easy,Math
978,Write a function to find the n’th carol number.,easy,Math
979,Write a function to remove empty lists from a given list of lists.,easy,Array
980,Write a python function to find the item with maximum occurrences in a given list.,easy,Array
981,Write a function to add the k elements to each element in the tuple.,easy,Array
982,Write a function to find the number of flips required to make the given binary string a sequence of alternate characters.,easy,Array
983,Write a python function to count the number of digits of a given number.,easy,Math
984,Write a python function to find the largest product of the pair of adjacent elements from a given list of integers.,easy,Array
985,Write a function to check if a binary tree is balanced or not.,easy,Math
986,Write a function to repeat the given tuple n times.,easy,Math
987,Write a function to find the lateral surface area of cuboid,easy,Math
988,Write a function to sort a tuple by its float element.,easy,Array
989,Write a function to find the smallest missing element in a sorted array.,easy,Array
990,Write a function to sort a given list of elements in ascending order using heap queue algorithm.,easy,Heap (Priority Queue)
991,Write a function to find the volume of a cuboid.,easy,Math
992,Write a function to print all permutations of a given string including duplicates.,normal,Array
993,Write a function to round the given number to the nearest multiple of a specific number.,easy,Math
994,Write a function to remove tuple elements that occur more than once and replace the duplicates with some custom value.,easy,Hash Table
995,Write a python function to remove all occurrences of a character in a given string.,easy,Math
996,Write a python function to shift last element to first position in the given list.,easy,Array
997,Write a function to find the surface area of a cuboid.,easy,Math
998,Write a function to generate a two-dimensional array.,easy,Array
999,Write a function to sort a list of lists by a given index of the inner list.,easy,Sorting
1000,Write a function to find the number of rotations in a circularly sorted array.,normal,Array
1001,Write a python function to toggle all odd bits of a given number.,easy,Math
1002,Write a python function to find the frequency of the smallest value in a given array.,easy,Array
1003,Write a function to find the n'th perrin number using recursion.,easy,Math
1004,Write a function to find out the minimum no of swaps required for bracket balancing in the given string.,easy,Array
1005,Write a python function to check whether the hexadecimal number is even or odd.,easy,Array
1006,Write a python function to find the highest power of 2 that is less than or equal to n.,easy,Math
1007,Write a function to find the n'th lucas number.,easy,Math
1008,Write a function to insert a given string at the beginning of all items in a list.,easy,Array
1009,Write a function to convert more than one list to nested dictionary.,easy,Array
1010,"Write a function to find the maximum sum possible by using the given equation f(n) = max( (f(n/2) + f(n/3) + f(n/4) + f(n/5)), n).",normal,Array
1011,Write a function to find the list with maximum length using lambda function.,easy,Simulation
1012,Write a function to check if given tuple is distinct or not.,easy,Hash Table
1013,Write a python function to find the first non-repeated character in a given string.,easy,Array
1014,Write a function to check whether the given string starts and ends with the same character or not using regex.,easy,Array
1015,Write a function to find the median of three specific numbers.,easy,Simulation
1016,Write a function to compute the sum of digits of each number of a given list.,easy,Simulation
1017,Write a function to perform the mathematical bitwise xor operation across the given tuples.,easy,Simulation
1018,Write a function to extract the frequency of unique tuples in the given list order irrespective.,easy,Hash Table
1019,Write a function to perform index wise addition of tuple elements in the given two nested tuples.,easy,Math
1020,Write a function to compute the value of ncr%p.,easy,Array
1021,Write a function to check if a url is valid or not using regex.,easy,Array
1022,Write a python function to find the minimum of two numbers.,easy,Simulation
1023,Write a function to check whether an element exists within a tuple.,easy,Simulation
1024,Write a python function to find the parity of a given number.,easy,Simulation
1025,Write a function to create the next bigger number by rearranging the digits of a given number.,normal,Array
1026,Write a function to find k number of pairs which consist of one element from the first array and one element from the second array.,normal,Heap (Priority Queue)
1027,Write a function to find the minimum product from the pairs of tuples within a given list.,easy,Array
1028,Write a function to find the minimum value in a given heterogeneous list.,easy,Simulation
1029,Write a function to convert the given snake case string to camel case string by using regex.,easy,String
1030,Write a python function to remove odd numbers from a given list.,easy,Math
1031,Write a function to extract the nth element from a given list of tuples.,easy,Array
1032,Write a python function to check whether the value exists in a sequence or not.,easy,Array
1033,Write a python function to find a pair with highest product from a given array of integers.,easy,Array
1034,Write a function to find the maximum sum we can make by dividing number in three parts recursively and summing them up together for the given number.,normal,Array
1035,Write a function to find common first element in given list of tuple.,easy,Array
1036,Write a python function to find the sublist having maximum length.,easy,Simulation
1037,Write a function to round every number of a given list of numbers and print the total sum multiplied by the length of the list.,easy,Math
1038,Write a python function to find the cube sum of first n even natural numbers.,easy,Math
1039,Write a function to concatenate each element of tuple by the delimiter.,easy,Array
1040,Write a python function to find the average of cubes of first n natural numbers.,easy,Math
1041,Write a function to solve gold mine problem.,easy,Array
1042,Write a function to extract only the rear index element of each string in the given tuple.,easy,Array
1043,Write a function to count the number of sublists containing a particular element.,easy,Array
1044,Write a function to filter odd numbers using lambda function.,easy,Math
1045,Write a function to convert a date of yyyy-mm-dd format to dd-mm-yyyy format by using regex.,easy,Math
1046,Write a function to sort the given array by using shell sort.,easy,Array
1047,Write a function to extract the elementwise and tuples from the given two tuples.,easy,Simulation
1048,Write a function to find the directrix of a parabola.,easy,Math
1049,Write a function that takes two lists and returns true if they have at least one common element.,easy,Simulation
1050,Write a function to find the median of a trapezium.,easy,Math
1051,Write a function to check whether the entered number is greater than the elements of the given array.,easy,Array
1052,Write a function that matches a string that has an a followed by one or more b's.,easy,Math
1053,Write a python function to find the last digit of a given number.,easy,Math
1054,Write a python function to print negative numbers in a list.,easy,Simulation
1055,Write a function to remove odd characters in a string.,easy,Array
1056,Write a function to count bidirectional tuple pairs.,easy,Array
1057,Write a function to convert a list of multiple integers into a single integer.,easy,String
1058,Write a function to find all adverbs and their positions in a given sentence.,easy,Math
1059,Write a function to find the surface area of a cube.,easy,Math
1060,Write a function to find the ration of positive numbers in an array of integers.,easy,Math
1061,Write a python function to find the largest negative number from the given list.,easy,Array
1062,Write a function to trim each tuple by k in the given tuple list.,easy,Array
1063,Write a function to perform index wise multiplication of tuple elements in the given two tuples.,easy,Math
1064,Write a python function to count the occurence of all elements of list in a tuple.,easy,Math
1065,Write a function to find cubes of individual elements in a list using lambda function.,easy,Math
1066,Write a function to calculate the sum of perrin numbers.,easy,Math
1067,Write a python function to check whether the triangle is valid or not if 3 points are given.,easy,Math
1068,Write a function to extract specified size of strings from a give list of string values.,easy,Array
1069,Write a function to remove all whitespaces from the given string using regex.,easy,Math
1070,Write a function that gives loss amount if the given amount has loss else return none.,easy,Math
1071,Write a python function to find the sum of even factors of a number.,normal,Math
1072,Write a function that matches a word containing 'z'.,easy,Math
1073,Write a function to check whether the given month number contains 31 days or not.,easy,Simulation
1074,Write a function to reverse strings in a given list of string values.,easy,Array
1075,Write a python function to find the sublist having minimum length.,easy,Simulation
1076,Write a function to find the area of a rectangle.,easy,Math
1077,Write a function to remove uppercase substrings from a given string by using regex.,easy,Array
1078,Write a python function to get the first element of each sublist.,easy,Array
1079,Write a python function to count the upper case characters in a given string.,easy,Array
1080,Write a function to find all possible combinations of the elements of a given list.,easy,Array
1081,Write a function to find the maximum product subarray of the given array.,normal,Array
1082,Write a function to check if all values are same in a dictionary.,easy,Simulation
1083,Write a function to drop empty items from a given dictionary.,easy,Simulation
1084,Write a function to find the peak element in the given array.,normal,Array
1085,Write a python function to convert decimal number to octal number.,easy,Math
1086,Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.,normal,Array
1087,Write a function to find the maximum profit earned from a maximum of k stock transactions,hard,Array
1088,Write a function to find the pairwise addition of the elements of the given tuples.,easy,Array
1089,Write a python function to find remainder of array multiplication divided by n.,easy,Array
1090,Write a python function to check whether the given list contains consecutive numbers or not.,easy,Math
1091,Write a function to find the tuple intersection of elements in the given tuple list irrespective of their order.,easy,Array
1092,Write a function to replace characters in a string.,easy,String
1093,Write a function to sort counter by value.,easy,Simulation
1094,Write a python function to find the sum of the largest and smallest value in a given array.,easy,Math
1095,Write a python function to convert the given string to lower case.,easy,String
1096,Write a function to remove lowercase substrings from a given string.,easy,Array
1097,Write a python function to find the first digit of a given number.,easy,Math
1098,Write a python function to find the maximum occurring character in a given string.,easy,Array
1099,Write a function to determine if there is a subset of the given set with sum equal to the given sum.,normal,Array
1100,Write a function to find sequences of one upper case letter followed by lower case letters in the given string by using regex.,easy,Array
1101,Write a python function to find the first natural number whose factorial is divisible by x.,normal,Math
1102,Write a function to remove the matching tuples from the given two tuples.,easy,Array
1103,Write a function to find the largest palindromic number in the given array.,easy,Array
1104,Write a function to compute binomial probability for the given number.,easy,Math
1105,Write a function to sort a list of tuples in increasing order by the last element in each tuple.,easy,Array
1106,Write a function to find the area of a pentagon.,easy,Math
1107,Write a python function to find the frequency of the largest value in a given array.,easy,Array
1108,Write a function to extract all the pairs which are symmetric in the given tuple list.,easy,Hash Table
1109,Write a function to find the sum of geometric progression series.,easy,Math
1110,Write a function to search an element in the given array by using binary search.,easy,Array
1111,"Write a function to calculate a grid of hexagon coordinates where function returns a list of lists containing 6 tuples of x, y point coordinates.",easy,Array
1112,Write a function to convert the given binary tuple to integer.,easy,String
1113,Write a function to remove lowercase substrings from a given string by using regex.,easy,Array
1114,Write a function to find the smallest integers from a given list of numbers using heap queue algorithm.,easy,Heap (Priority Queue)
1115,Write a function to find the surface area of a cone.,easy,Math
1116,Write a python function to find gcd of two positive integers.,easy,Math
1117,Write a function to find the diameter of a circle.,easy,Math
1118,Write a function to concatenate all elements of the given list into a string.,easy,Math
1119,Write a python function to find common divisor between two numbers in a given pair.,easy,Math
1120,Write a python function to find remainder of two numbers.,easy,Math
1121,Write a function to add consecutive numbers of a given list.,easy,Array
1122,Write a python function to find the cube sum of first n natural numbers.,easy,Math
1123,Write a function to move all zeroes to the end of the given array.,easy,Array
1124,"Write a function to calculate the permutation coefficient of given p(n, k).",easy,Array
1125,Write a function to remove specific words from a given list.,easy,Simulation
1126,Write a function to check if the common elements between two given lists are in the same order or not.,easy,Array
1127,Write a python function to find the average of odd numbers till a given odd number.,easy,Math
1128,Write a function to find the number of subsequences having product smaller than k for the given non negative array.,normal,Array
1129,Write a python function to find minimum sum of factors of a given number.,easy,Math
1130,Write a function to count the element frequency in the mixed nested tuple.,easy,Array
1131,Write a function to convert tuple into list by adding the given string after every element.,easy,Array
1132,Write a function to find the summation of tuple elements in the given tuple list.,easy,Simulation
1133,Write a function to check if there is a subset with sum divisible by m.,normal,Array
1134,Write a function to sort a list of elements using radix sort.,normal,Array
1135,Write a python function to find the largest postive number from the given list.,easy,Array
1136,Write a function to find the square root of a perfect number.,easy,Math
1137,Write a function to calculate volume of a tetrahedron.,easy,Math
1138,Write a function to find the lcm of the given array elements.,easy,Array
1139,Write a function to print check if the triangle is scalene or not.,easy,Simulation
1140,Write a function to find the longest bitonic subsequence for the given array.,normal,Array
1141,"Write a function to check whether a given string has a capital letter, a lower case letter, a number and specified length using lambda function.",easy,Array
1142,Write a function to find the sum of maximum increasing subsequence of the given array.,normal,Array
1143,Write a python function to check whether two given lines are parallel or not.,easy,Array
1144,Write a python function to capitalize first and last letters of each word of a given string.,easy,Array
1145,Write a function to find all pairs in an integer array whose sum is equal to a given number.,easy,Array
1146,Write a function to find the list of lists with minimum length.,easy,Simulation
1147,Write a function to find the nth jacobsthal-lucas number.,easy,Array
1148,Write a function to find the ration of negative numbers in an array of integers.,easy,Math
1149,Write a function to find minimum number of coins that make a given value.,normal,Array
1150,Write a function to check if the two given strings are permutations of each other.,easy,Array
1151,Write a function to remove particular data type elements from the given tuple.,easy,Array
1152,Write a function to search a literals string in a string and also find the location within the original string where the pattern occurs.,easy,String
1153,Write a function to find the top or bottom surface area of a cylinder.,easy,Math
1154,Write a function to select the nth items of a list.,easy,Array
1155,Write a python function to find the first repeated word in a given string.,easy,Hash Table
1156,Write a python function to convert a given string list to a tuple.,easy,String
1157,Write a function to create a list containing the power of said number in bases raised to the corresponding number in the index using map function.,easy,Simulation
1158,Write a python function to find the difference between highest and least frequencies in a given array.,easy,Array
1159,Write a function to find if the given number is abundant or not.,easy,Math
1160,"Write a function to replace all occurrences of spaces, commas, or dots with a colon in the given string by using regex.",easy,Array
1161,Write a function to add two numbers and print number of digits of sum.,easy,Math
1162,Write a function to flatten the tuple list to a string.,easy,Array
1163,Write a python function to toggle only first and last bits of a given number.,normal,Math
1164,Write a function to find the last occurrence of a character in a string.,easy,Array
1165,Write a python function to find the sum of hamming distances of all consecutive numbers from o to n.,easy,Math
1166,Write a function to find the length of the longest increasing subsequence of the given sequence.,normal,Array
1167,Write a python function to find the sum of fifth power of first n odd natural numbers.,easy,Math
1168,Write a python function to find the maximum element in a sorted and rotated array.,normal,Array
1169,Write a function to extract a specified column from a given nested list.,easy,Array
1170,Write a python function to check whether a given sequence is linear or not.,easy,Array
1171,Write a function to convert the given tuple to a floating-point number.,easy,String
1172,Write a python function to find odd numbers from a mixed list.,easy,Array
1173,Write a python function to find the difference between sum of cubes of first n natural numbers and the sum of first n natural numbers.,easy,Math
1174,Write a python function to count the pairs with xor as an odd number.,easy,Array
1175,Write a function to toggle characters case in a string.,easy,String
1176,Write a python function to find the digit distance between two integers.,easy,Math
1177,Write a function to find the largest sum of contiguous subarray in the given array.,easy,Array
1178,Write a function to find the union of elements of the given tuples.,easy,Hash Table
1179,"Write a function to assign with each element, its pair elements from other similar pairs in the given tuple.",easy,Hash Table
1180,Write a python function to find the maximum length of sublist.,easy,Simulation
1181,Write a function to extract values between quotation marks of a string.,easy,Math
1182,Write a python function to count unequal element pairs from the given array.,easy,Array
1183,Write a python function to split a string into characters.,easy,Array
1184,Write a function to get the sum of a non-negative integer.,easy,Math
1185,Write a function to check whether a specified list is sorted or not.,easy,Array
1186,Write a function to create a list of empty dictionaries.,easy,Array
1187,Write a function to sort each sublist of strings in a given list of lists.,easy,String
1188,Write a function to remove words from a given list of strings containing a character or string.,easy,Array
1189,Write a function to find maximum possible sum of disjoint pairs for the given array of integers and a number k.,easy,Array
1190,Write a python function to remove two duplicate numbers from a given number of lists.,easy,Array
1191,Write a python function to calculate the product of the unique numbers of a given list.,easy,Hash Table
1192,Write a function to find the surface area of a cylinder.,easy,Math
1193,Write a python function to find nth number in a sequence which is not a multiple of a given number.,easy,Math
1194,Write a python function to check whether an array is subarray of another or not.,easy,Array
1195,Write a python function to find the last digit in factorial of a given number.,easy,Simulation
1196,Write a function to interleave lists of the same length.,easy,Array
1197,Write a function to find the dissimilar elements in the given two tuples.,easy,Hash Table
1198,Write a function to extract the even elements in the nested mixed tuple.,easy,Math
1199,Write a python function to find the surface area of the square pyramid.,easy,Math
1200,Write a function to check if a dictionary is empty or not.,easy,Hash Table
1201,Write a function for nth catalan number.,normal,Math
1202,Write a function to find all adverbs and their positions in a given sentence by using regex.,easy,Math
1203,Write a function to find the n - expensive price items from a given dataset using heap queue algorithm.,easy,Heap (Priority Queue)
1204,Write a python function to split the array and add the first part to the end.,easy,Array
1205,Write a function to convert a list to a tuple.,easy,Simulation
1206,Write a python function to find the difference between largest and smallest value in a given array.,easy,Math
1207,Write a function to find perfect squares between two given numbers.,easy,Array
1208,Write a function to convert polar coordinates to rectangular coordinates.,easy,Math
1209,Write a python function to interchange the first and last elements in a list.,easy,Array
1210,Write a python function to find sum of product of binomial co-efficients.,easy,Array
1211,Write a function to remove leading zeroes from an ip address.,easy,Array
1212,Write a function to find the difference of first even and odd number of a given list.,easy,Math
1213,Write a python function to count minimum number of swaps required to convert one binary string to another.,easy,Array
1214,Write a function to find the size of the given tuple.,easy,Simulation
1215,Write a function to find kth element from the given two sorted arrays.,normal,Array
1216,Write a function to check whether the given number is armstrong or not.,easy,Math
1217,Write a function to find sum and average of first n natural numbers.,easy,Math
1218,Write a python function to check whether the given number is even or not using bitwise operator.,easy,Math
1219,Write a function to find the longest chain which can be formed from the given set of pairs.,normal,Array
1220,Write a python function to find the first repeated character in a given string.,easy,Array
1221,Write a function to get a lucid number smaller than or equal to n.,normal,Array
1222,Write a function to reverse words in a given string.,easy,String
1223,Write a function to check if the given integer is a prime number.,easy,Math
1224,Write a function to convert degrees to radians.,easy,Math
1225,Write a function to search a literals string in a string and also find the location within the original string where the pattern occurs by using regex.,easy,String
1226,Write a python function to find nth bell number.,normal,Array
1227,Write a python function to find minimum possible value for the given periodic function.,easy,Math
1228,Write a python function to remove the k'th element from a given list.,easy,Array
1229,Write a function to find the maximum of nth column from the given tuple list.,easy,Array
1230,Write a python function to merge the first and last elements separately in a list of lists.,easy,Array
1231,Write a function to find the maximum value in record list as tuple attribute in the given tuple list.,easy,Array
1232,Write a function to find the cumulative sum of all the values that are present in the given tuple list.,easy,Simulation
1233,Write a function to find average value of the numbers in a given tuple of tuples.,easy,Array
1234,Write a function to perfom the modulo of tuple elements in the given two tuples.,easy,Math
1235,"Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.",easy,Math
1236,Write a function to divide two lists using map and lambda function.,easy,Math
1237,Write a function to move all the numbers in it to the given string.,easy,Math
1238,Write a function to find the largest subset where each pair is divisible.,normal,Array
1239,Write a function to increment the numeric values in the given strings by k.,easy,Array
1240,Write a function to find the median of two sorted arrays of same size.,normal,Array
1241,Write a function to find the n-th power of individual elements in a list using lambda function.,easy,Math
1242,Write a python function to convert the given string to upper case.,easy,String
1243,Write a python function to interchange first and last elements in a given list.,easy,Array
1244,Write a python function to find the largest triangle that can be inscribed in the semicircle.,easy,Math
1245,Write a python function to find the smallest missing number from the given array.,easy,Array
1246,Write a function to replace all spaces in the given string with character * list item * list item * list item * list item '%20'.,easy,Array
1247,Write a python function to find even numbers from a mixed list.,easy,Array
1248,Write a function to extract all the adjacent coordinates of the given coordinate tuple.,easy,Array
1249,Write a function to replace whitespaces with an underscore and vice versa in a given string by using regex.,easy,String
1250,Write a python function to move all zeroes to the end of the given list.,easy,Array
1251,Write a python function to find the sum of xor of all pairs of numbers in the given array.,easy,Array
1252,Write a python function to find the sum of fourth power of first n even natural numbers.,easy,Math
1253,Write a function to push all values into a heap and then pop off the smallest values one at a time.,easy,Heap (Priority Queue)
1254,Write a python function to check if roots of a quadratic equation are reciprocal of each other or not.,easy,Simulation
1255,Write a function to check whether the given amount has no profit and no loss,easy,Simulation
1256,Write a function to calculate wind chill index.,easy,Math
1257,Write a function to sum the length of the names of a given list of names after removing the names that start with a lowercase letter.,easy,Array
1258,Write a function to remove the parenthesis area in a string.,easy,Array
1259,Write a function to find the nth nonagonal number.,easy,Math
1260,Write a function to remove similar rows from the given tuple matrix.,easy,Array
1261,"Write a function that matches a word containing 'z', not at the start or end of the word.",easy,Simulation
1262,Write a python function to reverse an array upto a given position.,easy,Array
1263,Write a function to find the product of it’s kth index in the given tuples.,easy,Array
1264,Write a python function to count number of cubes of size k in a cube of size n.,easy,Math
1265,Write a function to split a string at uppercase letters.,easy,Array
1266,Write a function to exchange the position of every n-th value with (n+1)th value and (n+1)th value with n-th value in a given list.,easy,Counting
1267,Write a python function to calculate the sum of the numbers in a list between the indices of a specified range.,easy,Array
1268,Write a python function to check whether the given two arrays are equal or not.,easy,Array
1269,Write a function to check if one tuple is a subset of another tuple.,easy,Hash Table
1270,Write a function to flatten the given tuple matrix into the tuple list with each tuple representing each column.,easy,Array
1271,Write a function to group a sequence of key-value pairs into a dictionary of lists using collections module.,easy,Hash Table
1272,Write a function to find the perimeter of a rectangle.,easy,Math
1273,Write a python function to find the sum of fifth power of n natural numbers.,easy,Math
1274,Write a python function to find the minimum sum of absolute differences of two arrays.,easy,Array
1275,Write a python function to find the first digit in factorial of a given number.,normal,Math
1276,Write a function to find the item with maximum occurrences in a given list.,easy,Array
1277,Write a python function to print duplicants from a list of integers.,easy,Array
1278,Write a python function to choose points from two ranges such that no point lies in both the ranges.,easy,Math
1279,Write a function to find the maximum sum that can be formed which has no three consecutive elements present.,easy,Array
1280,Write a function to sort a list in a dictionary.,easy,Hash Table
1281,Write a function to find the largest possible value of k such that k modulo x is y.,easy,Math
1282,Write a python function to find the average of even numbers till a given even number.,easy,Math
1283,Write a python function to shift first element to the end of given list.,easy,Array
1284,Write a function to count occurrence of a character in a string.,easy,Array
1285,Write a python function to count number of vowels in the string.,easy,Array
1286,Write a python function to replace multiple occurence of character by single.,easy,Math
1287,Write a function to check whether the given ip address is valid or not using regex.,easy,Array
1288,Write a python function to check whether a sequence of numbers has a decreasing trend or not.,easy,Sorting
1289,Write a python function to set the right most unset bit.,easy,Math
1290,Write a function to find maximum of three numbers.,easy,Simulation
1291,Write a python function to convert a list of multiple integers into a single integer.,easy,Array
1292,Write a function to remove duplicate words from a given string using collections module.,easy,Hash Table
1293,"Write a function to add two integers. however, if the sum is between the given range it will return 20.",easy,Math
1294,Write a function to remove everything except alphanumeric characters from the given string by using regex.,easy,Array
1295,Write a function to check if the triangle is valid or not.,easy,Math
1296,Write a python function to remove spaces from a given string.,easy,String
1297,Write a function to access dictionary key’s element by index.,easy,Array
1298,Write a python function to check whether a sequence of numbers has an increasing trend or not.,easy,Sorting
1299,Write a python function to find the smallest prime divisor of a number.,easy,Math
1300,Write a function to multiply two lists using map and lambda function.,easy,Math
1301,Write a python function to check whether the given number can be represented by sum of two squares or not.,easy,Math
1302,Write a python function to count occurences of a character in a repeated string.,easy,Array
1303,Write a python function to find sum of prime numbers between 1 to n.,easy,Array
1304,Write a function to find the frequency of each element in the given list.,easy,Hash Table
1305,Write a function to find the greatest common divisor (gcd) of two integers by using recursion.,easy,Math
1306,Write a function to get the length of a complex number.,easy,Simulation
1307,## write a function to find the minimum number of jumps to reach the end of the array for the given array of integers where each element represents the max number of steps that can be made forward from that element. > indented block > indented block,normal,Array
1308,Write a function to multiply consecutive numbers of a given list.,easy,Array
1309,Write a function to group the 1st elements on the basis of 2nd elements in the given tuple list.,easy,Counting
1310,Write a python function to find the last two digits in factorial of a given number.,easy,Math
1311,Write a function to remove multiple spaces in a string by using regex.,easy,Math
1312,Write a function to extract unique values from the given dictionary values.,easy,Sorting
1313,Write a function to check if each element of the second tuple is greater than its corresponding index in the first tuple.,easy,Simulation
1314,Write a function to zip two given lists of lists.,easy,Simulation
1315,Write a function to find number of even elements in the given list using lambda function.,easy,Math
1316,Write a function to sort dictionary items by tuple product of keys for the given dictionary with tuple keys.,easy,Array
1317,Write a python function to find the minimum number of swaps required to convert one binary string to another.,easy,Array
1318,Write a function to count the number of elements in a list which are within a specific range.,easy,Math
1319,Write a function to find the equilibrium index of the given array.,easy,Math
1320,Write a function to find the minimum number of elements that should be removed such that amax-amin<=k.,easy,Array
1321,Write a function to check whether the given key is present in the dictionary or not.,easy,Simulation
1322,Write a function to calculate the harmonic sum of n-1.,easy,Math
1323,Write a function to sort a list of lists by length and value.,easy,Sorting
1324,Write a function to find whether an array is subset of another array.,easy,Array
1325,Write a python function to count the total set bits from 1 to n.,normal,Math
1326,Write a python function to convert a string to a list.,easy,String
1327,Write a function to count unique keys for each value present in the tuple.,easy,Hash Table
1328,Write a function to access the initial and last data of the given tuple record.,easy,Array
1329,Write a python function to check whether the product of digits of a number at even and odd places is equal or not.,easy,Math
1330,Write a function to remove duplicates from a list of lists.,easy,Counting
1331,Write a function to check if the given tuple contains all valid values or not.,easy,Simulation
1332,Write a python function to count the number of distinct power of prime factor of given number.,easy,Math
1333,Write a function to convert the given string of integers into a tuple.,easy,String
1334,Write a function to find the perimeter of a rombus.,easy,Math
1335,Write a function to calculate the standard deviation.,easy,Array
1336,Write a function to create a list taking alternate elements from another given list.,easy,Array
1337,Write a function that matches a string that has an a followed by zero or more b's.,easy,Math
1338,Write a function to add a dictionary to the tuple.,easy,Simulation
1339,Write a function to find a path with the maximum average over all existing paths for the given square matrix of size n*n.,easy,Array
1340,Write a function to filter the height and width of students which are stored in a dictionary.,easy,Array
1341,Write a function to count the same pair in two given lists using map function.,easy,Simulation
1342,Write a function to calculate the sum of all digits of the base to the specified power.,easy,Array
1343,Write a function to extract values between quotation marks of the given string by using regex.,easy,Math
1344,Write a function to multiply the adjacent elements of the given tuple.,easy,Array
1345,Write a function to remove all characters except letters and numbers using regex,easy,Array
1346,Write a function to sum elements in two lists.,easy,Array
1347,Write a function to add two lists using map and lambda function.,easy,Math
1348,Write a function to remove consecutive duplicates of a given list.,easy,Counting
1349,Write a function to find the lateral surface area of a cone.,easy,Math
1350,"Write a function to replace all occurrences of spaces, commas, or dots with a colon.",easy,Array
1351,Write a function to find the index of the first occurrence of a given number in a sorted array.,easy,Array
1352,Write a python function to find sum of products of all possible subarrays.,easy,Array
1353,Write a python function to toggle bits of the number except the first and the last bit.,normal,Simulation
1354,Write a function to locate the left insertion point for a specified value in sorted order.,easy,Binary Search
1355,Write a function to check whether the given string is starting with a vowel or not using regex.,easy,Array
1356,Write a function to calculate the geometric sum of n-1.,easy,Math
1357,Write a python function to find the index of smallest triangular number with n digits.,easy,Math
1358,Write a function to convert the given tuple to a key-value dictionary using adjacent elements.,easy,Hash Table
1359,Write a python function to check whether all the characters are same or not.,easy,Array
1360,Write a function to caluclate the area of a tetrahedron.,easy,Math
1361,Write a function to rotate a given list by specified number of items to the right direction.,easy,Array
1362,Write a function to check if the given tuple has any none value or not.,easy,Simulation
1363,Write a function to find numbers within a given range where every number is divisible by every digit it contains.,easy,Array
1364,Write a function to find area of a sector.,easy,Math
1365,Write a function to find the longest common subsequence for the given three string sequence.,normal,Array
1366,Write a function to put spaces between words starting with capital letters in a given string by using regex.,easy,Array
1367,Write a function to sort a given list of strings of numbers numerically.,easy,Array
1368,Write a function to add the given tuple to the given list.,easy,Math
1369,Write a function to check if the given array represents min heap or not.,easy,Array
1370,Write a function to find the nth jacobsthal number.,easy,Array
1371,Write a function to find minimum k records from tuple list.,easy,Array
1372,Write a function to find common index elements from three lists.,easy,Array
1373,Write a function to find the second smallest number in a list.,easy,Array
1374,Write a function that matches a string that has an a followed by zero or one 'b'.,easy,String
1375,Write a function to count the pairs of reverse strings in the given string list.,easy,Array
1376,Write a function to count number of unique lists within a list.,easy,Array
1377,Write a function to check a decimal with a precision of 2.,easy,Array
1378,Write a python function to check whether an array contains only one distinct element or not.,easy,Hash Table
1379,Write a function to caluclate arc length of an angle.,easy,Math
1380,Write a function to check whether the given month number contains 30 days or not.,easy,Simulation
1381,Write a python function to find the minimum difference between any two elements in a given array.,easy,Array
1382,Write a python function to count numeric values in a given string.,easy,Array
1383,Write a function to find nth polite number.,easy,Math
1384,Write a function to iterate over all pairs of consecutive items in a given list.,easy,Array
1385,Write a python function to count the number of pairs whose sum is equal to ‘sum’.,easy,Array
1386,Write a python function to check for odd parity of a given number.,easy,Math
1387,Write a python function to get the difference between two lists.,easy,Hash Table
1388,Write a python function to find the sum of fourth power of first n odd natural numbers.,easy,Math
1389,Write a function to check if the given expression is balanced or not.,easy,Array
1390,Write a function to remove all the words with k length in the given string.,easy,Array
1391,Write a function to find the occurrence and position of the substrings within a string.,easy,Array
1392,Write a function to check if the string is a valid email address or not using regex.,easy,Array
1393,Write a python function to check whether every odd index contains odd numbers of a given list.,easy,Array
1394,Write a function to count those characters which have vowels as their neighbors in the given string.,easy,Array
1395,Write a python function to find the sum of non-repeated elements in a given array.,easy,Array
1396,Write a function to pack consecutive duplicates of a given list elements into sublists.,easy,Counting
1397,Write a function to count the number of unique lists within a list.,easy,Array
1398,Write a function to find the combinations of sums with tuples in the given tuple list.,easy,Counting
1399,Write a python function to check whether the count of divisors is even or odd.,easy,Math
1400,Write a python function to find the sum of all odd length subarrays.,easy,Array
1401,Write a function to convert rgb color to hsv color.,easy,Math
1402,Write a function to find the product of first even and odd number of a given list.,easy,Math
1403,Write a function to convert tuple string to integer tuple.,easy,String
1404,Write a function to locate the right insertion point for a specified value in sorted order.,easy,Binary Search
1405,Write a function that matches a string that has an a followed by three 'b'.,easy,String
1406,Write a function to create a new tuple from the given string and list.,easy,Array
1407,Write a function to calculate the perimeter of a regular polygon.,easy,Math
1408,Write a python function to check whether every even index contains even numbers of a given list.,easy,Array
1409,Write a function to remove the nested record from the given tuple.,easy,Math
1410,Write a python function to count the number of lists in a given number of lists.,easy,Simulation
1411,Write a python function to find the last position of an element in a sorted array.,easy,Array
1412,"Write a function that matches a string that has an 'a' followed by anything, ending in 'b'.",easy,Math
1413,Write a function to find the n - cheap price items from a given dataset using heap queue algorithm.,easy,Heap (Priority Queue)
1414,Write function to find the sum of all items in the given dictionary.,easy,Math
1415,Write a python function to find the sum of all odd natural numbers within the range l and r.,easy,Math
1416,Write a python function to find the sum of an array.,easy,Math
1417,Write a python function to left rotate the bits of a given number.,easy,Math
1418,Write a function to remove all whitespaces from a string.,easy,Math
1419,Write a python function to count the number of equal numbers from three given integers.,easy,Array
1420,Write a python function to count the number of rotations required to generate a sorted array.,easy,Array
1421,Write a python function to check whether the given number is a perfect square or not.,easy,Math
1422,Write a python function to check whether the product of numbers is even or not.,easy,Array
1423,Write a function to find the list in a list of lists whose sum of elements is the highest.,easy,Simulation
1424,Write a function to find maximum run of uppercase characters in the given string.,easy,Array
1425,Write a python function to find the first odd number in a given list of numbers.,easy,Math
1426,Write a function to check if the given tuples contain the k or not.,easy,Simulation
1427,Write a function to check if each element of second tuple is smaller than its corresponding index in first tuple.,easy,Simulation
1428,Write a function to iterate over elements repeating each as many times as its count.,easy,Simulation
1429,Write a function to check if two lists of tuples are identical or not.,easy,Simulation
1430,Write a function to abbreviate 'road' as 'rd.' in a given string.,easy,String
1431,Write a function to find length of the string.,easy,Math
1432,Write a function to find the area of a rombus.,easy,Math
1433,"Write a function to sort the given array without using any sorting algorithm. the given array consists of only 0, 1, and 2.",easy,Array
1434,Write a function to clear the values of the given tuples.,easy,Simulation
1435,Write a function to find numbers divisible by m or n from a list of numbers using lambda function.,easy,Math
1436,Write a python function to count lower case letters in a given string.,easy,Array
1437,Write a function to count the frequency of consecutive duplicate elements in a given list of numbers.,easy,Array
1438,Write a function to check whether the given month number contains 28 days or not.,easy,Simulation
1439,Write a function to merge two dictionaries into a single expression.,easy,Hash Table
1440,Write a function to return true if the password is valid.,easy,Array
1441,Write a function to check if the given string starts with a substring using regex.,easy,Math
1442,Write a python function to remove even numbers from a given list.,easy,Math
1443,Write a python function to access multiple elements of specified index from a given list.,easy,Array
1444,Write a python function to find the type of triangle from the given sides.,easy,Math
1445,Write a function to sum a specific column of a list in a given list of lists.,easy,Array
1446,"Write a function to count alphabets,digits and special charactes in a given string.",easy,Array
1447,Write a function to find out the second most repeated (or frequent) string in the given sequence.,easy,Array
1448,Write a function to round up a number to specific digits.,easy,Math
1449,Write a python function to count equal element pairs from the given array.,easy,Array
1450,Write a function to extract the maximum numeric value from a string by using regex.,easy,Math
1451,Write a function to get dictionary keys as a list.,easy,Array
1452,Write a function to generate a square matrix filled with elements from 1 to n raised to the power of 2 in spiral order.,normal,Array
1453,Write a python function to find the slope of a line.,easy,Math
1454,Write a function to find length of the subarray having maximum sum.,easy,Array
1455,Write a python function to find the cube sum of first n odd natural numbers.,easy,Math
1456,Write a python function to find minimum number swaps required to make two binary strings equal.,easy,Array
1457,Write a function to sort the tuples alphabetically by the first item of each tuple.,easy,Array
1458,Write a python function to check whether the roots of a quadratic equation are numerically equal but opposite in sign or not.,easy,Simulation
1459,Write a function to count the number of inversions in the given array.,normal,Array
1460,Write a function to find the number which occurs for odd number of times in the given array.,easy,Array
1461,Write a function to find the nth super ugly number from a given prime list of size k using heap queue algorithm.,normal,Heap (Priority Queue)
1462,Write a python function to find the kth element in an array containing odd elements first and then even elements.,easy,Array
1463,Write a python function to count the number of digits in factorial of a given number.,easy,Math
1464,Write a function to find the minimum number of platforms required for a railway/bus station.,easy,Array
1465,Write a python function to copy a list from a singleton tuple.,easy,Array
1466,Write a function to find the area of a trapezium.,easy,Math
1467,Write a python function to find sum of all prime divisors of a given number.,easy,Array
1468,Write a function to check if a triangle of positive area is possible with the given angles.,easy,Math
1469,Write a python function to find sum of inverse of divisors.,easy,Math
1470,Write a python function to remove negative numbers from a list.,easy,Simulation
1471,Write a python function to find sum of odd factors of a number.,easy,Math
1472,Write a function which accepts an arbitrary list and converts it to a heap using heap queue algorithm.,easy,Heap (Priority Queue)
1473,Write a python function to check for even parity of a given number.,easy,Math
1474,Write a python function to find minimum adjacent swaps required to sort binary array.,easy,Array
1475,Write a function to list out the list of given strings individually using map function.,easy,String
1476,Write a function to count number of lists in a given list of lists and square the count.,easy,Math
1477,Write a function to generate all sublists of a given list.,easy,Counting
1478,Write a function to check whether the given string is ending with only alphanumeric characters or not using regex.,easy,Array
1479,Write a function to find all anagrams of a string in a given list of strings using lambda function.,easy,String
1480,Write a function to find the occurrences of n most common words in a given text.,easy,Math
1481,Write a function to find the length of the longest sub-sequence such that elements in the subsequences are consecutive integers.,normal,Array
1482,Write a function to find palindromes in a given list of strings using lambda function.,easy,String
1483,Write a function to print n-times a list using map function.,easy,Math
1484,Write a function to check whether the given month name contains 31 days or not.,easy,Simulation
1485,Write a python function to add a minimum number such that the sum of array becomes even.,easy,Array
1486,Write a python function to find the length of the last word in a given string.,easy,Array
1487,"Write a function to remove sublists from a given list of lists, which are outside a given range.",easy,Array
1488,Write a function to calculate the sum of the positive numbers of a given list of numbers using lambda function.,easy,Simulation
1489,Write a python function to check whether the given strings are rotations of each other or not.,easy,Math
1490,Write a function to check if a nested list is a subset of another nested list.,normal,Hash Table
1491,Write a function to solve the fibonacci sequence using recursion.,easy,Math
1492,Write a python function to check if the string is a concatenation of another string.,easy,Array
1493,Write a function to find the minimum difference in the tuple pairs of given tuples.,easy,Array
1494,Write a python function to find lcm of two positive integers.,easy,Math
1495,Write a python function to sort the given string.,easy,Sorting
1496,Write a function to check if the given tuple contains only k elements.,easy,Simulation
1497,"Write a function that matches a string that has an 'a' followed by anything, ending in 'b' by using regex.",easy,Math
1498,Write a python function to find number of solutions in quadratic equation.,easy,Math
1499,Write a function to find the sum of first even and odd number of a given list.,easy,Math
1500,Write a function to caluclate perimeter of a parallelogram.,easy,Math
1501,Write a function to find numbers divisible by m and n from a list of numbers using lambda function.,easy,Math
1502,Write a python function to check whether all the bits are within a given range or not.,easy,Math
1503,Write a python function to check whether the two given strings are isomorphic to each other or not.,easy,Array
1504,Write a function to add all the numbers in a list and divide it with the length of the list.,easy,Math
1505,Write a python function to check whether the given number is odd or not using bitwise operator.,easy,Math
1506,Write a function to substract the elements of the given nested tuples.,easy,Math
1507,Write a function to reverse each list in a given list of lists.,easy,Sorting
1508,Write a python function to find the index of an extra element present in one sorted array.,easy,Array
1509,Write a python function to check whether the given two numbers have same number of digits or not.,easy,Math
1510,Write a function to remove multiple spaces in a string.,easy,Math
1511,Write a python function to get the last element of each sublist.,easy,Array
1512,Write a function to convert the given string of float type into tuple.,easy,String
1513,Write a function to find the maximum sum of subsequences of given array with no adjacent elements.,easy,Array
1514,Write a function to sort a list in increasing order by the last element in each tuple from a given list of non-empty tuples.,easy,Array
1515,Write a python function to check whether the word is present in a given sentence or not.,easy,String
1516,"Write a function to extract specified number of elements from a given list, which follow each other continuously.",easy,Counting
1517,Write a python function to check whether an array can be sorted or not by picking only the corner elements.,easy,Array
1518,Write a function where a string will start with a specific number.,easy,String
1519,Write a function to find the smallest multiple of the first n numbers.,normal,Array
1520,Write a function to combine two dictionaries by adding values for common keys.,easy,Hash Table
1521,Write a python function to count the total unset bits from 1 to n.,normal,Math
1522,Write a function to return true if the given number is even else return false.,easy,Math
1523,Write a python function to find the sum of squares of binomial co-efficients.,easy,Math
1524,"Write a function to extract year, month and date from a url by using regex.",easy,Math
1525,Write a function to print the first n lucky numbers.,normal,Array
1526,Write a function to find the fixed point in the given array.,easy,Array
1527,Write a function to find the previous palindrome of a specified number.,easy,Array
1528,Write a function to validate a gregorian date.,easy,Simulation
1529,Write a function to compute maximum product of three numbers of a given array of integers using heap queue algorithm.,easy,Heap (Priority Queue)
1530,"Write a function to find ln, m lobb number.",easy,Array
1531,Write a function to check for a number at the end of a string.,easy,Array
1532,Write a python function to check whether the given string is made up of two alternating characters or not.,easy,Array
1533,Write a function to rearrange positive and negative numbers in a given array using lambda function.,easy,Math
1534,Write a function to find if there is a triplet in the array whose sum is equal to a given value.,easy,Array
1535,Write a function to find the sequences of one upper case letter followed by lower case letters.,easy,Array
1536,Write a function to count coin change.,normal,Array
1537,Write a python function to multiply all items in the list.,easy,Math
1538,Write a function to remove all tuples with all none values in the given tuple list.,easy,Array
1539,Write a function to perform chunking of tuples each of size n.,easy,Array
1540,Write a function to find a pair with the highest product from a given array of integers.,easy,Array
1541,Write a function to find the length of the shortest string that has both str1 and str2 as subsequences.,normal,Array
1542,Write a function to find maximum of two numbers.,easy,Simulation
1543,Write a python function to calculate the product of all the numbers of a given tuple.,easy,Math
1544,Write a function to find n-th rencontres number.,normal,Math
1545,Write a function to calculate the height of the given binary tree.,easy,Math
1546,Write a function to convert a date of yyyy-mm-dd format to dd-mm-yyyy format.,easy,Math
1547,Write a function to count repeated items of a tuple.,easy,Simulation
1548,Write a function that matches a string that has an a followed by zero or more b's by using regex.,easy,Math
1549,Write a function to calculate the sum of series 1³+2³+3³+….+n³.,easy,Math
1550,Write a function to remove duplicate words from a given list of strings.,easy,Array
1551,Write a function to convert camel case string to snake case string by using regex.,easy,Array
1552,Write a function to find the nth delannoy number.,normal,Math
1553,Write a function to calculate the sum of series 1²+2²+3²+….+n².,easy,Math
1554,Write a function to re-arrange the given tuples based on the given ordered list.,easy,Hash Table
1555,Write a function to count the most common character in a given string.,easy,String
1556,Write a function to find three closest elements from three sorted arrays.,normal,Array
1557,Write a function to sort a list of dictionaries using lambda function.,easy,Array
1558,Write a function to sort the given array by using heap sort.,normal,Array
1559,Write a function to count the elements in a list until an element is a tuple.,easy,Math
1560,Write a function to check if any list element is present in the given list.,easy,Simulation
1561,Write a function to combine two given sorted lists using heapq module.,easy,Heap (Priority Queue)
1562,Write a function to separate and print the numbers and their position of a given string.,easy,Math
1563,Write a function to convert the given tuples into set.,easy,Hash Table
1564,Write a function to find the most common elements and their counts of a specified text.,easy,Simulation
1565,Write a python function to find the length of the shortest word.,easy,Array
1566,Write a function to get an item of a tuple.,easy,Array
1567,Write a function to sort the given tuple list basis the total digits in tuple.,easy,Array
1568,Write a function to display sign of the chinese zodiac for given year.,easy,Math
1569,Write a function to find the maximum of similar indices in two lists of tuples.,easy,Array
1570,Write a function to compute the value of ncr mod p.,easy,Array
1571,Write a python function to find the minimun number of subsets with distinct elements.,easy,Array
1572,Write a function that gives profit amount if the given amount has profit else return none.,easy,Math
1573,"Write a function to find out, if the given number is abundant.",easy,Array
1574,Write a function to split the given string at uppercase letters by using regex.,easy,Array
1575,Write a python function to get the position of rightmost set bit.,easy,Math
1576,Write a function to convert an integer into a roman numeral.,easy,Array
1577,Write a python function to find the average of a list.,easy,Math
1578,Write a function to solve tiling problem.,easy,Math
1579,Write a function to convert a roman numeral to an integer.,easy,Array
1580,Write a python function to find the sum of all even natural numbers within the range l and r.,easy,Math
1581,Write a function to calculate the discriminant value.,easy,Math
1582,Write a python function to check whether the length of the word is even or not.,easy,Math
1583,Write a function to convert camel case string to snake case string.,easy,Array
1584,Write a function to remove an empty tuple from a list of tuples.,easy,Array
1585,Write a python function to accept the strings which contains all vowels.,easy,Hash Table
1586,Write a python function to find maximum possible value for the given periodic function.,easy,Math
1587,Write a function to join the tuples if they have similar initial elements.,easy,Array
1588,Write a function to find minimum of two numbers.,easy,Simulation
1589,"Write a function to find the maximum number of segments of lengths a, b and c that can be formed from n.",easy,Array
1590,Write a function to concatenate the given two tuples to a nested tuple.,easy,Math
1591,Write a python function to left rotate the string.,easy,Array
1592,Write a function to find the minimum total path sum in the given triangle.,normal,Array

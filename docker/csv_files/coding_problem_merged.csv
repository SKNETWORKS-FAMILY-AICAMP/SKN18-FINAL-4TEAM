id,problem,difficulty,category
1,"도넛 모양 그래프, 막대 모양 그래프, 8자 모양 그래프들이 있습니다. 이 그래프들은 1개 이상의 정점과, 정점들을 연결하는 단방향 간선으로 이루어져 있습니다. 크기가 n인 도넛 모양 그래프는 n개의 정점과 n개의 간선이 있습니다. 도넛 모양 그래프의 아무 한 정점에서 출발해 이용한 적 없는 간선을 계속 따라가면 나머지 n-1개의 정점들을 한 번씩 방문한 뒤 원래 출발했던 정점으로 돌아오게 됩니다. 도넛 모양 그래프의 형태는 다음과 같습니다. 크기가 n인 막대 모양 그래프는 n개의 정점과 n-1개의 간선이 있습니다. 막대 모양 그래프는 임의의 한 정점에서 출발해 간선을 계속 따라가면 나머지 n-1개의 정점을 한 번씩 방문하게 되는 정점이 단 하나 존재합니다. 막대 모양 그래프의 형태는 다음과 같습니다. 크기가 n인 8자 모양 그래프는 2n+1개의 정점과 2n+2개의 간선이 있습니다. 8자 모양 그래프는 크기가 동일한 2개의 도넛 모양 그래프에서 정점을 하나씩 골라 결합시킨 형태의 그래프입니다. 8자 모양 그래프의 형태는 다음과 같습니다. 도넛 모양 그래프, 막대 모양 그래프, 8자 모양 그래프가 여러 개 있습니다. 이 그래프들과 무관한 정점을 하나 생성한 뒤, 각 도넛 모양 그래프, 막대 모양 그래프, 8자 모양 그래프의 임의의 정점 하나로 향하는 간선들을 연결했습니다. 그 후 각 정점에 서로 다른 번호를 매겼습니다. 이때 당신은 그래프의 간선 정보가 주어지면 생성한 정점의 번호와 정점을 생성하기 전 도넛 모양 그래프의 수, 막대 모양 그래프의 수, 8자 모양 그래프의 수를 구해야 합니다. 그래프의 간선 정보를 담은 2차원 정수 배열 edges가 매개변수로 주어집니다. 이때, 생성한 정점의 번호, 도넛 모양 그래프의 수, 막대 모양 그래프의 수, 8자 모양 그래프의 수를 순서대로 1차원 정수 배열에 담아 return 하도록 solution 함수를 완성해 주세요. 제한사항 1 ≤ edges의 길이 ≤ 1,000,000 edges의 원소는 [a,b] 형태이며, a번 정점에서 b번 정점으로 향하는 간선이 있다는 것을 나타냅니다. 1 ≤ a, b ≤ 1,000,000 문제의 조건에 맞는 그래프가 주어집니다. 도넛 모양 그래프, 막대 모양 그래프, 8자 모양 그래프의 수의 합은 2이상입니다.",normal,Array
2,"A와 B가 n개의 주사위를 가지고 승부를 합니다. 주사위의 6개 면에 각각 하나의 수가 쓰여 있으며, 주사위를 던졌을 때 각 면이 나올 확률은 동일합니다. 각 주사위는 1 ~ n의 번호를 가지고 있으며, 주사위에 쓰인 수의 구성은 모두 다릅니다. A가 먼저 n / 2개의 주사위를 가져가면 B가 남은 n / 2개의 주사위를 가져갑니다. 각각 가져간 주사위를 모두 굴린 뒤, 나온 수들을 모두 합해 점수를 계산합니다. 점수가 더 큰 쪽이 승리하며, 점수가 같다면 무승부입니다. A는 자신이 승리할 확률이 가장 높아지도록 주사위를 가져가려 합니다. 다음은 n = 4인 예시입니다. 주사위 구성 #1 [1, 2, 3, 4, 5, 6] #2 [3, 3, 3, 3, 4, 4] #3 [1, 3, 3, 4, 4, 4] #4 [1, 1, 4, 4, 5, 5] 예를 들어 A가 주사위 #1, #2를 가져간 뒤 6, 3을 굴리고, B가 주사위 #3, #4를 가져간 뒤 4, 1을 굴린다면 A의 승리입니다. (6 + 3 > 4 + 1) A가 가져가는 주사위 조합에 따라, 주사위를 굴린 1296가지 경우의 승패 결과를 세어보면 아래 표와 같습니다. A의 주사위 승 무 패 #1, #2 596 196 504 #1, #3 560 176 560 #1, #4 616 184 496 #2, #3 496 184 616 #2, #4 560 176 560 #3, #4 504 196 596 A가 승리할 확률이 가장 높아지기 위해선 주사위 #1, #4를 가져가야 합니다. 주사위에 쓰인 수의 구성을 담은 2차원 정수 배열 dice가 매개변수로 주어집니다. 이때, 자신이 승리할 확률이 가장 높아지기 위해 A가 골라야 하는 주사위 번호를 오름차순으로 1차원 정수 배열에 담아 return 하도록 solution 함수를 완성해 주세요. 승리할 확률이 가장 높은 주사위 조합이 유일한 경우만 주어집니다. 제한사항 2 ≤ dice의 길이 = n ≤ 10 n은 2의 배수입니다. dice[i]는 i+1번 주사위에 쓰인 6개의 수를 담고 있습니다. dice[i]의 길이 = 6 1 ≤ dice[i]의 원소 ≤ 100 입출력 예 dice result [[1, 2, 3, 4, 5, 6], [3, 3, 3, 3, 4, 4], [1, 3, 3, 4, 4, 4], [1, 1, 4, 4, 5, 5]] [1, 4] [[1, 2, 3, 4, 5, 6], [2, 2, 4, 4, 6, 6]] [2] [[40, 41, 42, 43, 44, 45], [43, 43, 42, 42, 41, 41], [1, 1, 80, 80, 80, 80], [70, 70, 1, 1, 70, 70]] [1, 3] 입출력 예 설명",normal,Array
3,"당신은 1~n 사이의 수가 적힌 카드가 하나씩 있는 카드 뭉치와 동전 coin개를 이용한 게임을 하려고 합니다. 카드 뭉치에서 카드를 뽑는 순서가 정해져 있으며, 게임은 다음과 같이 진행합니다. 처음에 카드 뭉치에서 카드 n/3장을 뽑아 모두 가집니다. (n은 6의 배수입니다.) 당신은 카드와 교환 가능한 동전 coin개를 가지고 있습니다. 게임은 1라운드부터 시작되며, 각 라운드가 시작할 때 카드를 두 장 뽑습니다. 카드 뭉치에 남은 카드가 없다면 게임을 종료합니다. 뽑은 카드는 카드 한 장당 동전 하나를 소모해 가지거나, 동전을 소모하지 않고 버릴 수 있습니다. 카드에 적힌 수의 합이 n+1이 되도록 카드 두 장을 내고 다음 라운드로 진행할 수 있습니다. 만약 카드 두 장을 낼 수 없다면 게임을 종료합니다. 예를 들어 n = 12, coin = 4이고 [3, 6, 7, 2, 1, 10, 5, 9, 8, 12, 11, 4] 순서대로 카드를 뽑도록 카드 뭉치가 섞여 있습니다. 처음에 3, 6, 7, 2 카드 4장(= n/3)과 동전 4개(= coin)를 가지고 시작합니다. 다음 라운드로 진행하기 위해 내야 할 카드 두 장에 적힌 수의 합은 13(= n+1)입니다. 다음과 같은 방법으로 최대 5라운드까지 도달할 수 있습니다. 1라운드에서 뽑은 카드 1, 10을 동전 두 개를 소모해서 모두 가집니다. 카드 3, 10을 내고 다음 라운드로 진행합니다. 이때 손에 남은 카드는 1, 2, 6, 7이고 동전이 2개 남습니다. 2라운드에서 뽑은 카드 5, 9를 동전을 소모하지 않고 모두 버립니다. 카드 6, 7을 내고 다음 라운드로 진행합니다. 이때 손에 남은 카드는 1, 2고 동전이 2개 남습니다. 3라운드에서 뽑은 카드 8, 12 중 동전 한 개를 소모해서 카드 12를 가집니다. 카드 1, 12을 내고 다음 라운드로 진행합니다. 이때 손에 남은 카드는 2이고 동전이 1개 남습니다. 4라운드에서 뽑은 카드 11, 4 중 동전 한 개를 소모해서 카드 11을 가집니다. 카드 2, 11을 내고 다음 라운드로 진행합니다. 이때 손에 남은 카드와 동전은 없습니다. 5라운드에서 카드 뭉치에 남은 카드가 없으므로 게임을 종료합니다. 처음에 가진 동전수를 나타내는 정수 coin과 카드를 뽑는 순서대로 카드에 적힌 수를 담은 1차원 정수 배열 cards가 매개변수로 주어질 때, 게임에서 도달 가능한 최대 라운드의 수를 return 하도록 solution 함수를 완성해 주세요. 제한사항 0 ≤ coin ≤ n 6 ≤ cards의 길이 = n < 1,000 cards[i]는 i+1번째로 뽑는 카드에 적힌 수를 나타냅니다. 1 ≤ cards[i] ≤ n cards의 원소는 중복되지 않습니다. n은 6의 배수입니다. 입출력 예 coin cards result 4 [3, 6, 7, 2, 1, 10, 5, 9, 8, 12, 11, 4] 5 3 [1, 2, 3, 4, 5, 8, 6, 7, 9, 10, 11, 12] 2 2 [5, 8, 1, 2, 9, 4, 12, 11, 3, 10, 6, 7] 4 10 [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18] 1 입출력 예 설명",normal,Array
4,"한 변의 길이가 1인 정삼각형 2n+1개를 이어붙여 윗변의 길이가 n, 아랫변의 길이가 n+1인 사다리꼴을 만들 수 있습니다. 이때 사다리꼴의 윗변과 변을 공유하는 n개의 정삼각형 중 일부의 위쪽에 같은 크기의 정삼각형을 붙여 새로운 모양을 만들었습니다. 예를 들어 n이 4이고, 1번째, 2번째, 4번째 정삼각형 위에 정삼각형을 붙인 모양은 다음과 같습니다. 이렇게 만든 모양을 정삼각형 타일 또는 정삼각형 2개를 이어 붙인 마름모 타일로 빈 곳이 없도록 채우려고 합니다. 정삼각형 타일과 마름모 타일은 돌려서 사용할 수 있습니다. 타일을 놓을 때 다른 타일과 겹치거나 모양을 벗어나게 놓을 수는 없습니다. 위의 예시 모양을 채우는 방법 중 일부는 다음과 같습니다. 사다리꼴의 윗변의 길이를 나타내는 정수 n과 사다리꼴 윗변에 붙인 정삼각형을 나타내는 1차원 정수 배열 tops가 매개변수로 주어집니다. 이때 문제 설명에 따라 만든 모양을 정삼각형 또는 마름모 타일로 빈 곳이 없도록 채우는 경우의 수를 10007로 나눈 나머지를 return 하도록 solution 함수를 완성해 주세요. 제한사항 1 ≤ n ≤ 100,000 tops의 길이 = n tops[i]는 사다리꼴의 윗변과 변을 공유하는 i+1번째 정삼각형의 위쪽에 정삼각형을 붙이는 경우 1, 붙이지 않는 경우 0입니다. 입출력 예 n tops result 4 [1, 1, 0, 1] 149 2 [0, 1] 11 10 [0, 0, 0, 0, 0, 0, 0, 0, 0, 0] 7704 입출력 예 설명",normal,Array
5,"[본 문제는 정확성과 효율성 테스트 각각 점수가 있는 문제입니다.] 세로길이가 n 가로길이가 m인 격자 모양의 땅 속에서 석유가 발견되었습니다. 석유는 여러 덩어리로 나누어 묻혀있습니다. 당신이 시추관을 수직으로 단 하나만 뚫을 수 있을 때, 가장 많은 석유를 뽑을 수 있는 시추관의 위치를 찾으려고 합니다. 시추관은 열 하나를 관통하는 형태여야 하며, 열과 열 사이에 시추관을 뚫을 수 없습니다. 예를 들어 가로가 8, 세로가 5인 격자 모양의 땅 속에 위 그림처럼 석유가 발견되었다고 가정하겠습니다. 상, 하, 좌, 우로 연결된 석유는 하나의 덩어리이며, 석유 덩어리의 크기는 덩어리에 포함된 칸의 수입니다. 그림에서 석유 덩어리의 크기는 왼쪽부터 8, 7, 2입니다. 시추관은 위 그림처럼 설치한 위치 아래로 끝까지 뻗어나갑니다. 만약 시추관이 석유 덩어리의 일부를 지나면 해당 덩어리에 속한 모든 석유를 뽑을 수 있습니다. 시추관이 뽑을 수 있는 석유량은 시추관이 지나는 석유 덩어리들의 크기를 모두 합한 값입니다. 시추관을 설치한 위치에 따라 뽑을 수 있는 석유량은 다음과 같습니다. 시추관의 위치 획득한 덩어리 총 석유량 1 [8] 8 2 [8] 8 3 [8] 8 4 [7] 7 5 [7] 7 6 [7] 7 7 [7, 2] 9 8 [2] 2 오른쪽 그림처럼 7번 열에 시추관을 설치하면 크기가 7, 2인 덩어리의 석유를 얻어 뽑을 수 있는 석유량이 9로 가장 많습니다. 석유가 묻힌 땅과 석유 덩어리를 나타내는 2차원 정수 배열 land가 매개변수로 주어집니다. 이때 시추관 하나를 설치해 뽑을 수 있는 가장 많은 석유량을 return 하도록 solution 함수를 완성해 주세요. 제한사항 1 ≤ land의 길이 = 땅의 세로길이 = n ≤ 500 1 ≤ land[i]의 길이 = 땅의 가로길이 = m ≤ 500 land[i][j]는 i+1행 j+1열 땅의 정보를 나타냅니다. land[i][j]는 0 또는 1입니다. land[i][j]가 0이면 빈 땅을, 1이면 석유가 있는 땅을 의미합니다. 정확성 테스트 케이스 제한사항 1 ≤ land의 길이 = 땅의 세로길이 = n ≤ 100 1 ≤ land[i]의 길이 = 땅의 가로길이 = m ≤ 100 효율성 테스트 케이스 제한사항 주어진 조건 외 추가 제한사항 없습니다. 입출력 예 land result [[0, 0, 0, 1, 1, 1, 0, 0], [0, 0, 0, 0, 1, 1, 0, 0], [1, 1, 0, 0, 0, 1, 1, 0], [1, 1, 1, 0, 0, 0, 0, 0], [1, 1, 1, 0, 0, 0, 1, 1]] 9 [[1, 0, 1, 0, 1, 1], [1, 0, 1, 0, 0, 0], [1, 0, 1, 0, 0, 1], [1, 0, 0, 1, 0, 0], [1, 0, 0, 1, 0, 1], [1, 0, 0, 0, 0, 0], [1, 1, 1, 1, 1, 1]] 16 입출력 예 설명",normal,Array
6,"시침, 분침, 초침이 있는 아날로그시계가 있습니다. 시계의 시침은 12시간마다, 분침은 60분마다, 초침은 60초마다 시계를 한 바퀴 돕니다. 따라서 시침, 분침, 초침이 움직이는 속도는 일정하며 각각 다릅니다. 이 시계에는 초침이 시침/분침과 겹칠 때마다 알람이 울리는 기능이 있습니다. 당신은 특정 시간 동안 알람이 울린 횟수를 알고 싶습니다. 다음은 0시 5분 30초부터 0시 7분 0초까지 알람이 울린 횟수를 세는 예시입니다. 가장 짧은 바늘이 시침, 중간 길이인 바늘이 분침, 가장 긴 바늘이 초침입니다. 알람이 울리는 횟수를 세기 시작한 시각은 0시 5분 30초입니다. 이후 0시 6분 0초까지 초침과 시침/분침이 겹치는 일은 없습니다. 약 0시 6분 0.501초에 초침과 시침이 겹칩니다. 이때 알람이 한 번 울립니다. 이후 0시 6분 6초까지 초침과 시침/분침이 겹치는 일은 없습니다. 약 0시 6분 6.102초에 초침과 분침이 겹칩니다. 이때 알람이 한 번 울립니다. 이후 0시 7분 0초까지 초침과 시침/분침이 겹치는 일은 없습니다. 0시 5분 30초부터 0시 7분 0초까지는 알람이 두 번 울립니다. 이후 약 0시 7분 0.584초에 초침과 시침이 겹쳐서 울리는 세 번째 알람은 횟수에 포함되지 않습니다. 다음은 12시 0분 0초부터 12시 0분 30초까지 알람이 울린 횟수를 세는 예시입니다. 알람이 울리는 횟수를 세기 시작한 시각은 12시 0분 0초입니다. 초침과 시침, 분침이 겹칩니다. 이때 알람이 한 번 울립니다. 이와 같이 0시 정각, 12시 정각에 초침과 시침, 분침이 모두 겹칠 때는 알람이 한 번만 울립니다. 이후 12시 0분 30초까지 초침과 시침/분침이 겹치는 일은 없습니다. 12시 0분 0초부터 12시 0분 30초까지는 알람이 한 번 울립니다. 알람이 울리는 횟수를 센 시간을 나타내는 정수 h1, m1, s1, h2, m2, s2가 매개변수로 주어집니다. 이때, 알람이 울리는 횟수를 return 하도록 solution 함수를 완성해주세요. 제한사항 0 ≤ h1, h2 ≤ 23 0 ≤ m1, m2 ≤ 59 0 ≤ s1, s2 ≤ 59 h1시 m1분 s1초부터 h2시 m2분 s2초까지 알람이 울리는 횟수를 센다는 의미입니다. h1시 m1분 s1초 < h2시 m2분 s2초 시간이 23시 59분 59초를 초과해서 0시 0분 0초로 돌아가는 경우는 주어지지 않습니다. 입출력 예 h1 m1 s1 h2 m2 s2 result 0 5 30 0 7 0 2 12 0 0 12 0 30 1 0 6 1 0 6 6 0 11 59 30 12 0 0 1 11 58 59 11 59 0 1 1 5 5 1 5 6 2 0 0 0 23 59 59 2852 입출력 예 설명",normal,Math
7,"n x m 크기 격자 모양의 퍼즐판이 주어집니다. 퍼즐판에는 빨간색 수레와 파란색 수레가 하나씩 존재합니다. 각 수레들은 자신의 시작 칸에서부터 자신의 도착 칸까지 이동해야 합니다. 모든 수레들을 각자의 도착 칸으로 이동시키면 퍼즐을 풀 수 있습니다. 당신은 각 턴마다 반드시 모든 수레를 상하좌우로 인접한 칸 중 한 칸으로 움직여야 합니다. 단, 수레를 움직일 때는 아래와 같은 규칙이 있습니다. 수레는 벽이나 격자 판 밖으로 움직일 수 없습니다. 수레는 자신이 방문했던 칸으로 움직일 수 없습니다. 자신의 도착 칸에 위치한 수레는 움직이지 않습니다. 계속 해당 칸에 고정해 놓아야 합니다. 동시에 두 수레를 같은 칸으로 움직일 수 없습니다. 수레끼리 자리를 바꾸며 움직일 수 없습니다. 예를 들어, 아래 그림처럼 n = 3, m = 2인 퍼즐판이 있습니다. 속이 빨간색인 원은 빨간색 수레를 나타냅니다. 속이 파란색인 원은 파란색 수레를 나타냅니다. 테두리가 빨간색인 원은 빨간색 수레의 도착 칸을 나타냅니다. 테두리가 파란색인 원은 파란색 수레의 도착 칸을 나타냅니다. 위 퍼즐판은 아래와 같은 순서로 3턴만에 풀 수 있습니다. 빨간색 사선이 처진 칸은 빨간색 수레가 방문했던 칸을 나타냅니다. 규칙에 따라 빨간색 수레는 빨간색 사선이 처진 칸(방문했던 칸)으로는 이동할 수 없습니다. 파란색 사선이 처진 칸은 파란색 수레가 방문했던 칸을 나타냅니다. 규칙에 따라 파란색 수레는 파란색 사선이 처진 칸(방문했던 칸)으로는 이동할 수 없습니다. 위처럼 동시에 수레를 같은 칸으로 움직일 수는 없습니다. 퍼즐판의 정보를 나타내는 2차원 정수 배열 maze가 매개변수로 주어집니다. 퍼즐을 푸는데 필요한 턴의 최솟값을 return 하도록 solution 함수를 완성해 주세요. 퍼즐을 풀 수 없는 경우 0을 return 해주세요. 제한사항 1 ≤ maze의 길이 (= 세로 길이) ≤ 4 1 ≤ maze[i]의 길이 (= 가로 길이) ≤ 4 maze[i][j]는 0,1,2,3,4,5 중 하나의 값을 갖습니다. maze[i][j] 의미 0 빈칸 1 빨간 수레의 시작 칸 2 파란 수레의 시작 칸 3 빨간 수레의 도착 칸 4 파란 수레의 도착 칸 5 벽 빨간 수레의 시작 칸, 빨간 수레의 도착 칸, 파란 수레의 시작 칸, 파란 수레의 도착 칸은 퍼즐판에 1개씩 존재합니다. 입출력 예 maze result [[1, 4], [0, 0], [2, 3]] 3 [[1, 0, 2], [0, 0, 0], [5, 0 ,5], [4, 0, 3]] 7 [[1, 5], [2, 5], [4, 5], [3, 5]] 0 [[4, 1, 2, 3]] 0 입출력 예 설명",normal,Array
8,"현대모비스에서는 운전자와 탑승자의 편의를 위한 인포테인먼트 헤드유닛이 탑재되어 있습니다. 인포테인먼트 헤드유닛은 운전자와 탑승자에게 차량내/외의 다양한 정보를 제공하면서 동시에 내비게이션, 음성인식, 텔레매틱스 서비스, 멀티미디어 기능 등 엔터테인먼트 및 편의 서비스를 통합적으로 제공하는 기기입니다. n × m 직사각형 격자 모양의 도로가 나 있는 미로가 있습니다. 미로에서 왼쪽 아래 구석의 좌표는 (0, 0), 오른쪽 위 구석의 좌표는 (n, m) 입니다. 정수 좌표 (a, b)에는 표지판이 있습니다. 자동차의 내비게이션 기능과 차량의 주행 능력을 검증하기 위해 미로의 다양한 위치에서 출발하여 표지판까지 최단 경로를 따라 이동한 테스트 기록이 있습니다. 각 테스트는 출발점의 좌표, 남은 연료량에 따른 최대 주행 거리, 표지판 도달 여부가 기록되어 있습니다. 출발점의 위치와 표지판의 위치가 같을 수 있으며, 이때는 최대 주행 거리에 상관없이 항상 표지판에 도달한 것으로 간주합니다. 테스트 기록을 토대로 표지판의 위치를 알아내려 합니다. 예를 들어 n = 3, m = 5이고 테스트 기록이 다음과 같은 경우를 생각해 봅시다. 번호 출발점 좌표 최대 주행 거리 표지판 도달 여부 #1 (2, 3) 2 O #2 (1, 0) 4 X #3 (0, 4) 1 X 이때 표지판이 있을 수 있는 좌표는 (2, 4), (2, 5), (3, 3), (3, 4)의 4개입니다. 격자의 가로 길이 n, 세로 길이 m, 테스트 기록을 나타내는 2차원 정수 배열 tests가 매개변수로 주어집니다. 표지판이 있을 수 있는 좌표의 개수를 return 하도록 solution 함수를 완성해 주세요. 제한사항 3 ≤ n ≤ 109 3 ≤ m ≤ 109 1 ≤ tests의 길이 ≤ 250,000 tests의 원소는 [x, y, d, flag] 형태의 길이가 4인 정수 배열입니다. 출발점의 좌표가 (x, y), 최대 주행 거리가 d이고, flag가 1인 경우 표지판에 도달했음을, 0인 경우 표지판에 도달하지 못했음을 의미합니다. 0 ≤ x ≤ n 0 ≤ y ≤ m 0 ≤ d ≤ n + m 0 ≤ flag ≤ 1 표지판이 있을 수 있는 좌표가 하나 이상 존재합니다. 입출력 예 n m tests result 3 5 [[2, 3, 2, 1], [1, 0, 4, 0], [0, 4, 1, 0]] 4 99999 99999 [[0, 0, 199997, 1]] 9999999999 99999 99999 [[50000, 50000, 3, 0]] 9999999975 300 100 [[123, 28, 124, 1], [183, 22, 34, 0], [188, 81, 116, 1], [167, 53, 33, 0], [125, 55, 20, 0]] 6535 입출력 예 설명",hard,Array
9,"현대모비스의 주행시험장 트랙을 주행해 볼 수 있는 가상 시뮬레이션 프로그램이 있습니다. 시뮬레이션의 트랙에는 1 ~ n의 서로 다른 번호가 붙은 지점이 n개 있으며, 각 지점마다 고유한 스탬프가 있습니다. 각 지점을 방문할 때 해당 지점의 스탬프를 얻을 수 있습니다. 당신은 1번 지점에서 시작하여 각 지점을 최소 한 번씩 방문해 n가지 스탬프를 모두 모으려 합니다. 지점들은 m개의 단방향 도로로 연결되어 있습니다. 당신은 지점 사이를 이동하기 위해 단방향 도로를 이용할 수 있습니다. 다음은 n = 6인 예시입니다. 각 원은 지점을 나타내며, 원 안에 적힌 수는 지점의 번호를 나타냅니다. 화살표는 두 지점을 연결하고 있는 단방향 도로를 나타냅니다. 위 예시에서 1번 지점에서 출발해 1 - 2 - 6과 같은 경로로 움직이면 1, 2, 6번 지점의 스탬프 3가지를 모을 수 있습니다. 하지만 6번 지점에 도착하면 더 이상 이용할 수 있는 도로가 없습니다. 시뮬레이션에는 단방향 도로를 이용하는 것 외의 이동 방법으로 빠른 이동 기능이 있습니다. 빠른 이동이란 당신이 스탬프를 얻은 지점 중 원하는 곳으로 순간 이동할 수 있는 기능입니다. 예를 들어 위 예시에서 1 - 2 - 6 - 2(빠른 이동) - 4 - 3 - 5와 같은 경로로 움직이면 모든 지점을 한 번씩 방문해 n가지 스탬프를 모두 모을 수 있습니다. 당신은 n가지 스탬프를 모두 모으기 위해 필요한 빠른 이동의 최소 사용 횟수를 알고 싶습니다. 지점의 수를 나타내는 정수 n과 지점을 연결하는 단방향 도로들의 정보를 담고 있는 2차원 정수 배열 roads가 매개변수로 주어집니다. 이때, 1번 지점에서 출발해 n가지 스탬프를 모두 모으기 위해 필요한 빠른 이동의 최소 사용 횟수를 return 하도록 solution 함수를 완성해 주세요. 제한사항 2 ≤ n ≤ 500 n - 1 ≤ roads의 길이 = m ≤ 100,000 roads의 원소는 [a, b] 형태입니다. a번 지점에서 b번 지점으로 이동할 수 있는 단방향 도로를 의미합니다. 1 ≤ a, b ≤ n a ≠ b 같은 도로는 최대 한 번만 주어집니다. 도착 불가능한 지점이 있는 경우는 주어지지 않습니다. 입출력 예 n roads result 6 [[1, 2], [2, 6], [2, 4], [4, 3], [3, 2], [3, 5]] 1 5 [[1, 2], [2, 3], [3, 4], [4, 5]] 0 8 [[6, 4], [2, 3], [1, 6], [4, 5], [1, 2], [1, 8], [3, 7], [7, 2]] 2 9 [[1, 2], [1, 3], [1, 4], [2, 5], [4, 5], [5, 6], [5, 7], [6, 9], [7, 9], [5, 8]] 3 7 [[1, 2], [2, 3], [3, 4], [4, 5], [3, 6], [1, 7], [7, 4]] 1 입출력 예 설명",hard,Array
10,"현대모비스의 자율주행 시스템은 출발지와 목적지를 입력하면 목적지에 도착하기까지의 가장 빠른 예상 소요 시간을 알려줍니다. 자율주행 시스템은 도시 내에 있는 n개의 지점을 연결하는 양방향 도로 m개의 교통량을 분석해서 예상 소요 시간을 실시간으로 계산합니다. 만약 어떤 도로의 길이가 L이고 교통량이 T라면 해당 도로를 통과하는데 L + T분이 소요됩니다. (0 ≤ T) 다음은 n = 5, m = 7인 예시입니다. 원은 지점을 나타내며, 원에 적힌 수는 지점의 번호입니다. 항상 1번 지점이 출발지, n번 지점이 목적지입니다. 선분은 지점을 연결하는 도로를 나타내며, 선분 옆에 적힌 수는 [#도로 번호] 길이/교통량을 의미합니다. 목적지에 도착하기까지의 가장 빠른 예상 소요 시간은 1-2-4-5와 같이 이동했을 때 20(= 10 + 8 + 2)분입니다. 이때 7번 도로의 교통량이 3 증가한다고 가정해 보겠습니다. 목적지에 도착하기까지의 가장 빠른 예상 소요 시간은 1-2-5와 같이 이동했을 때 22(= 10 + 12)분으로, 교통량이 변하기 전에 비해 2분 증가했습니다. 7번 도로 대신 2번 도로의 교통량이 2 증가한다고 가정해 보겠습니다. 목적지에 도착하기까지의 가장 빠른 예상 소요 시간은 1-3-4-5와 같이 이동했을 때 20(= 9 + 9 + 2)분으로, 교통량이 변하기 전과 같습니다. 2, 7번 도로 대신 5번 도로의 교통량이 6 감소한다고 가정해 보겠습니다. 목적지에 도착하기까지의 가장 빠른 예상 소요 시간은 1-3-5와 같이 이동했을 때 19(= 10 + 9)분으로, 교통량이 변하기 전에 비해 1분 감소했습니다. 모든 도로의 교통량 정보를 실시간으로 업데이트하는 것은 비효율적이기 때문에, 위와 같이 한 도로의 교통량이 변했을 때 가장 빠른 예상 소요 시간이 변할 수 있는 도로(5, 7번 도로)에 대해서만 실시간으로 교통량 정보를 업데이트해야 합니다. 지점의 수를 나타내는 정수 n과 도로의 정보를 나타내는 2차원 정수 배열 roads가 매개변수로 주어집니다. 이때 한 도로의 교통량이 변했을 때 1번 지점에서 출발해 n번 지점에 도착하는 가장 빠른 예상 소요 시간이 변할 수 있는 도로의 번호를 오름차순으로 1차원 정수 배열에 담아 return 하도록 solution 함수를 완성해 주세요. 만약 그러한 도로가 없다면 [-1]을 return 합니다. 제한사항 2 ≤ n ≤ 50,000 1번 지점이 출발지, n번 지점이 목적지입니다. n - 1 ≤ roads의 길이 = m ≤ 200,000 roads[i]는 i+1번 도로에 대한 정보를 담고 있으며 [U, V, L, T] 형태의 길이가 4인 1차원 정수 배열입니다. U번 지점과 V번 지점을 연결하는 길이 L, 교통량 T인 도로를 의미합니다. 1 ≤ U < V ≤ n 1 ≤ L ≤ 109 0 ≤ T ≤ 109 서로 다른 두 지점을 직접 연결하는 도로는 최대 1개입니다. 도로를 통해 한 지점에서 다른 지점으로 이동하는 방법이 항상 존재합니다. 입출력 예 n roads result 5 [[1, 2, 10, 0], [2, 4, 8, 0], [1, 3, 9, 0], [3, 4, 9, 0], [3, 5, 10, 6], [2, 5, 10, 2], [4, 5, 2, 0]] [5, 7] 4 [[1, 2, 10, 10], [2, 3, 10, 10], [3, 4, 10, 10]] [1, 2, 3] 4 [[1, 2, 5, 0], [2, 4, 5, 0], [1, 3, 5, 0], [3, 4, 5, 0]] [-1] 4 [[1, 2, 5, 0], [2, 4, 5, 0], [1, 3, 5, 0], [3, 4, 5, 0], [1, 4, 5, 5]] [5] 입출력 예 설명",hard,Array
11,"현대모비스에서 개발한 자율주행을 이용한 레이싱 대회가 열렸습니다. 당신은 관람객들이 레이싱 대회를 재밌게 즐길 수 있도록 레이싱 경기장을 설계하려고 합니다. 레이싱 경기장은 n개의 지점으로 구성됩니다. 각 지점의 높이는 정해져 있지만, 그 순서는 자유롭게 바꿀 수 있습니다. 당신의 목표는 이웃한 지점끼리의 높이 차이의 최솟값이 최대가 되도록 높이 순서를 정하는 것입니다. 예를 들어 n이 3이고 세 지점의 높이가 각각 1, 5, 8인 경우를 생각해 봅시다. 높이를 [1, 5, 8] 순서로 배치하면 1번과 2번 지점의 높이 차이는 4, 2번과 3번 지점의 높이 차이는 3이므로 높이 차이의 최솟값은 3입니다. 높이를 [5, 1, 8] 순서로 배치하면 1번과 2번 지점의 높이 차이는 4, 2번과 3번 지점의 높이 차이는 7이므로 높이 차이의 최솟값은 4입니다. 높이 차이의 최솟값을 4보다 크게 만드는 방법은 없습니다. 지점 n개의 높이를 담은 1차원 정수 배열 heights가 매개변수로 주어집니다. 높이 차이의 최솟값이 최대가 되도록 레이싱 경기장을 설계했을 때의 높이 차이의 최솟값을 return 하도록 solution 함수를 완성해 주세요. 제한사항 2 ≤ heights의 길이 = n ≤ 200,000 1 ≤ heights의 원소 ≤ 109 입출력 예 heights result [1, 8, 5] 4 [11, 6, 4, 11] 5 [9, 9, 9, 9, 30] 0 입출력 예 설명",hard,Array
12,"정수 0 ~ n-1을 담고 있는 크기가 n인 1차원 정수 배열 a가 있습니다. 배열의 각 원소마다 하나의 집합을 이루고 있습니다. 당신은 여기에 다음 쿼리들을 실행하려고 합니다. [1, x, y] 형태의 쿼리가 주어집니다. y가 포함된 집합의 원소들을 모두 x가 포함된 집합으로 옮깁니다. x와 y가 같은 집합에 속해있다면 해당 쿼리는 실행하지 않습니다. [2, x, y] 형태의 쿼리가 주어집니다. 새로운 집합을 생성합니다. x와 y가 포함된 집합에서 x와 같거나 늦게 집합으로 들어왔으면서 y와 같거나 빠르게 집합으로 들어온 원소들을 새로 생성한 집합으로 옮깁니다. 집합에 들어온 순서는 몇 번째 쿼리로 집합에 들어왔는지로 판별합니다. 같은 쿼리로 집합에 들어왔다면 같은 순서로 집합에 들어왔다는 것을 의미합니다. x와 y는 항상 같은 집합에 포함되어 있습니다. [3, x, y] 형태의 쿼리가 주어집니다. x와 y가 같은 집합에 속해있다면 ""Yes""를, 그렇지 않다면 ""No""를 return 할 배열의 뒤에 추가합니다. 집합은 크기가 0이 되면 사라지며, 초기 집합들은 0번째 쿼리로 형성됩니다. a의 길이를 나타내는 정수 n, 쿼리들을 담은 2차원 정수 배열 queries가 매개변수로 주어집니다. 쿼리들을 순서대로 실행했을 때, 3번 쿼리의 결과를 순서대로 담아 return 하도록 solution 함수를 완성해주세요. 제한사항 1 ≤ n ≤ 500,000 1 ≤ queries의 길이 ≤ 500,000 queries[i]는 i+1번째로 실행할 쿼리를 나타내며, [q, x, y] 형태의 1차원 정수 배열입니다. 1 ≤ q ≤ 3 0 ≤ x, y < n 2번 쿼리의 경우 x와 y는 항상 같은 집합에 속해 있습니다. 3번 쿼리는 1개 이상 주어집니다. 입출력 예 n queries result 4 [[3, 2, 3], [1, 3, 2], [3, 2, 3], [1, 2, 0], [3, 0, 1], [2, 2, 0], [3, 2, 3], [3, 0, 2]] [""No"", ""Yes"", ""No"", ""No"", ""Yes""] 7 [[1, 0, 1], [1, 2, 3], [3, 1, 3], [1, 2, 0], [3, 1, 3], [1, 1, 5], [1, 5, 4], [3, 4, 5], [2, 2, 5], [3, 4, 5]] [""No"", ""Yes"", ""Yes"", ""No""] 입출력 예 설명",hard,Array
13,"현대모비스에서 전기차로 경사로 주행 테스트를 하려고 합니다. 경사로 테스트는 n×m 크기의 격자 형태의 공간에서 진행되며, 각 칸에 적힌 숫자는 높이를 나타냅니다. 전기차는 격자 내의 모든 칸에서 출발 가능하며, 상하좌우로 인접한 칸으로만 이동 가능하고 격자 밖을 벗어날 수는 없습니다. 전기차가 인접한 칸으로 이동하는 길의 경사는 이동하려는 칸의 높이에서 현재 칸의 높이를 뺀 값입니다. 예를 들어 높이가 5인 칸에서 7인 칸으로 이동하는 길의 경사는 2(= 7 - 5)이고, 높이가 6인 칸에서 높이가 1인 칸으로 이동하는 길의 경사는 -5(= 1 - 6)입니다. 경사 수열 d가 주어집니다. 경사 수열은 테스트에서 전기차가 이동할 길의 경사를 나타내며, d[i]는 전기차가 i+1번째로 이동할 때 경사가 d[i]인 길을 지나야 함을 나타냅니다. 전기차가 경사로를 반복적으로 이동할 때 받는 스트레스를 관찰하기 위해 주어진 경사수열을 k번 반복할 수 있는 경로를 찾으려 합니다. 같은 칸을 여러 번 방문하거나 지나온 길을 바로 되돌아가는 경로도 가능합니다. 예를 들어 아래와 같은 격자에서 경사 수열 d = [1, -2, -1, 0, 2]이고 k = 2라고 가정해 보겠습니다. 이 경사 수열을 k = 2 번 반복할 수 있는 경로 중 하나는 아래 그림과 같습니다. 위 경로에서 방문한 칸의 높이는 방문 순서대로 [5, 6, 4, 3, 3, 5, 6, 4, 3, 3, 5]입니다. 길의 경사가 순서대로 [1, -2, -1, 0, 2, 1, -2, -1, 0, 2]으로, d가 2번 반복되었습니다. 격자 칸의 높이를 담은 2차원 정수 배열 grid, 경사 수열을 담은 1차원 정수 배열 d와 경사 수열을 반복하는 횟수를 나타내는 정수 k가 매개변수로 주어집니다. 이때, 격자 내에서 조건을 만족하는 경로의 수를 return 하도록 solution 함수를 완성해 주세요. 단, 답이 커질 수 있으므로 1,000,000,007(= 109 + 7)로 나눈 나머지를 return 해주세요. 제한사항 3 ≤ grid의 길이 = n ≤ 8 3 ≤ grid[i]의 길이 = m ≤ 8 0 ≤ grid[i][j] ≤ 1,000 grid[i][j]는 각자의 i+1번째 행, j+1번째 열에 위치한 칸의 높이를 나타냅니다. 1 ≤ d의 길이 ≤ 100 -100 ≤ d의 원소 ≤ 100 1 ≤ k ≤ 109 입출력 예 grid d k result [[3, 4, 6, 5, 3], [3, 5, 5, 3, 6], [5, 6, 4, 3, 6], [7, 4, 3, 5, 0]] [1, -2, -1, 0, 2] 2 16 [[3, 6, 11, 12], [4, 8, 15, 10], [2, 7, 0, 16]] [1, -2, 5] 3 1 [[0, 0, 0], [1, 0, 0], [0, 0, 0], [0, 0, 1], [1, 0, 0]] [0, 0, 1, -1, 0, 0, 1, -1] 10 595737277 입출력 예 설명",hard,Array
14,"현대모비스에서 개발한 실내공조 제어 시스템은 차내에 승객이 탑승 중일 때 항상 쾌적한 실내온도(t1 ~ t21)를 유지할 수 있도록 합니다. 현재(0분) 실내온도는 실외온도와 같습니다. 실내공조 제어 시스템은 실내온도를 조절하기 위해 에어컨의 전원을 켜 희망온도를 설정합니다. 희망온도는 에어컨의 전원이 켜져 있는 동안 원하는 값으로 변경할 수 있습니다. 실내온도와 희망온도가 다르다면 1분 뒤 실내온도가 희망온도와 같아지는 방향으로 1도 상승 또는 하강합니다. 실내온도가 희망온도와 같다면 에어컨이 켜져 있는 동안은 실내온도가 변하지 않습니다. 에어컨의 전원을 끄면 실내온도가 실외온도와 같아지는 방향으로 매 분 1도 상승 또는 하강합니다. 실내온도와 실외온도가 같다면 실내온도는 변하지 않습니다. 에어컨의 소비전력은 현재 실내온도에 따라 달라집니다. 에어컨의 희망온도와 실내온도가 다르다면 매 분 전력을 a만큼 소비하고, 희망온도와 실내온도가 같다면 매 분 전력을 b만큼 소비합니다. 에어컨이 꺼져 있다면 전력을 소비하지 않으며, 에어컨을 켜고 끄는데 필요한 시간과 전력은 0이라고 가정합니다. 실내공조 제어 시스템은 차내에 승객이 탑승 중일 때 실내온도를 t1 ~ t2도 사이로 유지하면서, 에어컨의 소비전력을 최소화합니다. 다음은 실외온도가 28도, t1= 18, t2 = 26, a = 10 b = 8인 예시입니다. 시간(분) 승객 탑승 0 x 1 x 2 o 3 o 4 o 5 o 6 o 승객이 탑승 중인 2 ~ 6분의 실내온도를 18 ~ 26도 사이로 유지해야 합니다. 다음은 2 ~ 6분의 실내온도를 쾌적한 온도로 유지하는 방법 중 하나입니다. 시간(분) 승객 탑승 실내온도 희망온도 0 x 28 26 1 x 27 26 2 o 26 26 3 o 26 26 4 o 26 26 5 o 26 26 6 o 26 off 0분의 실내온도는 항상 실외온도와 같습니다. 6분에 에어컨의 전원을 껐습니다. 0 ~ 5분에 에어컨의 희망온도를 26도로 설정했습니다. 0 ~ 1분에 희망온도와 실내온도가 다르므로 전력을 매 분 10씩, 2 ~ 5분에 희망온도와 실내온도가 같으므로 전력을 매 분 8씩 소비했습니다. 이때 총 소비전력은 52(= 2 × 10 + 4 × 8)입니다. 다음은 2 ~ 6분의 실내온도를 쾌적한 온도로 유지하는 또 다른 방법입니다. 시간(분) 승객 탑승 실내온도 희망온도 0 x 28 24 1 x 27 24 2 o 26 24 3 o 25 24 4 o 24 off 5 o 25 off 6 o 26 off 0 ~ 3분에 에어컨의 희망온도를 24도로 설정해 전력을 매 분 10씩 소비했습니다. 이때 총 소비전력은 40(= 4 × 10)이며, 이보다 소비전력이 적어지는 방법은 없습니다. 실외온도를 나타내는 정수 temperature, 쾌적한 실내온도의 범위를 나타내는 정수 t1, t2, 에어컨의 소비전력을 나타내는 정수 a, b와 승객이 탑승 중인 시간을 나타내는 1차원 정수 배열 onboard가 매개변수로 주어집니다. 승객이 탑승 중인 시간에 쾌적한 실내온도를 유지하기 위한 최소 소비전력을 return 하도록 solution 함수를 완성해 주세요. 제한사항 -10 ≤ temperature ≤ 40 -10 ≤ t1 < t2 ≤ 40 temperature는 t1 ~ t2 범위 밖의 값입니다. 1 ≤ a, b ≤ 100 a는 에어컨의 희망온도와 실내온도가 다를 때의 1분당 소비전력을 나타냅니다. b는 에어컨의 희망온도와 실내온도가 같을 때의 1분당 소비전력을 나타냅니다. 2 ≤ onboard의 길이 ≤ 1,000 onboard[i]는 0 혹은 1이며, onboard[i]가 1이라면 i분에 승객이 탑승 중이라는 것을 의미합니다. onboard[0] = 0 onboard에 1이 최소 한 번 이상 등장합니다. 승객이 탑승 중인 시간에 쾌적한 실내온도를 유지하는 것이 불가능한 경우는 주어지지 않습니다. 입출력 예 temperature t1 t2 a b onboard result 28 18 26 10 8 [0, 0, 1, 1, 1, 1, 1] 40 -10 -5 5 5 1 [0, 0, 0, 0, 0, 1, 0] 25 11 8 10 10 1 [0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1] 20 11 8 10 10 100 [0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1] 60 입출력 예 설명",normal,Array
15,"현대모비스는 우수한 SW 인재 채용을 위해 상시로 채용 설명회를 진행하고 있습니다. 채용 설명회에서는 채용과 관련된 상담을 원하는 참가자에게 멘토와 1:1로 상담할 수 있는 기회를 제공합니다. 채용 설명회에는 멘토 n명이 있으며, 1~k번으로 분류되는 상담 유형이 있습니다. 각 멘토는 k개의 상담 유형 중 하나만 담당할 수 있습니다. 멘토는 자신이 담당하는 유형의 상담만 가능하며, 다른 유형의 상담은 불가능합니다. 멘토는 동시에 참가자 한 명과만 상담 가능하며, 상담 시간은 정확히 참가자가 요청한 시간만큼 걸립니다. 참가자가 상담 요청을 하면 아래와 같은 규칙대로 상담을 진행합니다.상담을 원하는 참가자가 상담 요청을 했을 때, 참가자의 상담 유형을 담당하는 멘토 중 상담 중이 아닌 멘토와 상담을 시작합니다.만약 참가자의 상담 유형을 담당하는 멘토가 모두 상담 중이라면, 자신의 차례가 올 때까지 기다립니다. 참가자가 기다린 시간은 참가자가 상담 요청했을 때부터 멘토와 상담을 시작할 때까지의 시간입니다. 모든 멘토는 상담이 끝났을 때 자신의 상담 유형의 상담을 받기 위해 기다리고 있는 참가자가 있으면 즉시 상담을 시작합니다. 이때, 먼저 상담 요청한 참가자가 우선됩니다.참가자의 상담 요청 정보가 주어질 때, 참가자가 상담을 요청했을 때부터 상담을 시작하기까지 기다린 시간의 합이 최소가 되도록 각 상담 유형별로 멘토 인원을 정하려 합니다. 단, 각 유형별로 멘토 인원이 적어도 한 명 이상이어야 합니다. 예를 들어, 5명의 멘토가 있고 1~3번의 3가지 상담 유형이 있을 때 아래와 같은 참가자의 상담 요청이 있습니다.참가자의 상담 요청 참가자 번호시각상담 시간상담 유형 1번 참가자10분60분1번 유형2번 참가자15분100분3번 유형3번 참가자20분30분1번 유형4번 참가자30분50분3번 유형5번 참가자50분40분1번 유형6번 참가자60분30분2번 유형7번 참가자65분30분1번 유형8번 참가자70분100분2번 유형 이때, 멘토 인원을 아래와 같이 정하면, 참가자가 기다린 시간의 합이 25로 최소가 됩니다. 1번 유형2번 유형3번 유형 2명1명2명 1번 유형1번 유형을 담당하는 멘토가 2명 있습니다.1번 참가자가 상담 요청했을 때, 멘토#1과 10분~70분 동안 상담을 합니다.3번 참가자가 상담 요청했을 때, 멘토#2와 20분~50분 동안 상담을 합니다.5번 참가자가 상담 요청했을 때, 멘토#2와 50분~90분 동안 상담을 합니다.7번 참가자가 상담 요청했을 때, 모든 멘토가 상담 중이므로 1번 참가자의 상담이 끝날 때까지 5분 동안 기다리고 멘토#1과 70분~100분 동안 상담을 합니다. 2번 유형2번 유형을 담당하는 멘토가 1명 있습니다.6번 참가자가 상담 요청했을 때, 멘토와 60분~90분 동안 상담을 합니다.8번 참가자가 상담 요청했을 때, 모든 멘토가 상담 중이므로 6번 참가자의 상담이 끝날 때까지 20분 동안 기다리고 90분~190분 동안 상담을 합니다.3번 유형3번 유형을 담당하는 멘토가 2명 있습니다.2번 참가자가 상담 요청했을 때, 멘토#1과 15분~115분 동안 상담을 합니다.4번 참가자가 상담 요청했을 때, 멘토#2와 30분~80분 동안 상담을 합니다.상담 유형의 수를 나타내는 정수 k, 멘토의 수를 나타내는 정수 n과 참가자의 상담 요청을 담은 2차원 정수 배열 reqs가 매개변수로 주어집니다. 멘토 인원을 적절히 배정했을 때 참가자들이 상담을 받기까지 기다린 시간을 모두 합한 값의 최솟값을 return 하도록 solution 함수를 완성해 주세요.제한사항1 ≤ k ≤ 5k ≤ n ≤ 203 ≤ reqs의 길이 ≤ 300reqs의 원소는 [a, b, c] 형태의 길이가 3인 정수 배열이며, c번 유형의 상담을 원하는 참가자가 a분에 b분 동안의 상담을 요청했음을 의미합니다.1 ≤ a ≤ 1,0001 ≤ b ≤ 1001 ≤ c ≤ kreqs는 a를 기준으로 오름차순으로 정렬되어 있습니다.reqs 배열에서 a는 중복되지 않습니다. 즉, 참가자가 상담 요청한 시각은 모두 다릅니다.입출력 예 knreqsresult 35[[10, 60, 1], [15, 100, 3], [20, 30, 1], [30, 50, 3], [50, 40, 1], [60, 30, 2], [65, 30, 1], [70, 100, 2]]2523[[5, 55, 2], [10, 90, 2], [20, 40, 2], [50, 45, 2], [100, 50, 2]]90 입출력 예 설명",normal,Array
16,"A 나라가 B 나라를 침공하였습니다. B 나라의 대부분의 전략 자원은 아이기스 군사 기지에 집중되어 있기 때문에 A 나라는 B 나라의 아이기스 군사 기지에 융단폭격을 가했습니다. A 나라의 공격에 대항하여 아이기스 군사 기지에서는 무수히 쏟아지는 폭격 미사일들을 요격하려고 합니다. 이곳에는 백발백중을 자랑하는 요격 시스템이 있지만 운용 비용이 상당하기 때문에 미사일을 최소로 사용해서 모든 폭격 미사일을 요격하려 합니다. A 나라와 B 나라가 싸우고 있는 이 세계는 2 차원 공간으로 이루어져 있습니다. A 나라가 발사한 폭격 미사일은 x 축에 평행한 직선 형태의 모양이며 개구간을 나타내는 정수 쌍 (s, e) 형태로 표현됩니다. B 나라는 특정 x 좌표에서 y 축에 수평이 되도록 미사일을 발사하며, 발사된 미사일은 해당 x 좌표에 걸쳐있는 모든 폭격 미사일을 관통하여 한 번에 요격할 수 있습니다. 단, 개구간 (s, e)로 표현되는 폭격 미사일은 s와 e에서 발사하는 요격 미사일로는 요격할 수 없습니다. 요격 미사일은 실수인 x 좌표에서도 발사할 수 있습니다. 각 폭격 미사일의 x 좌표 범위 목록 targets이 매개변수로 주어질 때, 모든 폭격 미사일을 요격하기 위해 필요한 요격 미사일 수의 최솟값을 return 하도록 solution 함수를 완성해 주세요. 제한 사항 1 ≤ targets의 길이 ≤ 500,000 targets의 각 행은 [s,e] 형태입니다. 이는 한 폭격 미사일의 x 좌표 범위를 나타내며, 개구간 (s, e)에서 요격해야 합니다. 0 ≤ s < e ≤ 100,000,000 입출력 예 targets result [[4,5],[4,8],[10,14],[11,13],[5,12],[3,7],[1,4]] 3 입출력 예 설명 위 그림과 같이 최소 세 번의 요격 미사일 발사로 전부 방어할 수 있습니다.",normal,Math
17,"x축과 y축으로 이루어진 2차원 직교 좌표계에 중심이 원점인 서로 다른 크기의 원이 두 개 주어집니다. 반지름을 나타내는 두 정수 r1, r2가 매개변수로 주어질 때, 두 원 사이의 공간에 x좌표와 y좌표가 모두 정수인 점의 개수를 return하도록 solution 함수를 완성해주세요. ※ 각 원 위의 점도 포함하여 셉니다. 제한 사항 1 ≤ r1 < r2 ≤ 1,000,000 입출력 예 r1 r2 result 2 3 20 입출력 예 설명 그림과 같이 정수 쌍으로 이루어진 점은 총 20개 입니다.",normal,Simulation
18,"정우는 예술적 감각이 뛰어난 타일공입니다. 그는 단순한 타일을 활용하여 불규칙하면서도 화려하게 타일링을 하곤 합니다. 어느 날 정우는 가로 길이 n, 세로 길이 3 인 판을 타일링하는 의뢰를 맡았습니다. 아방가르드한 디자인 영감이 떠오른 정우는 다음과 같은 두 가지 종류의 타일로 타일링을 하기로 결정했습니다. 각 타일은 90도씩 회전할 수 있으며 타일의 개수는 제한이 없습니다. n이 주어졌을 때, 이 두 가지 종류의 타일로 n x 3 크기의 판을 타일링하는 방법의 수를 return 하도록 solution 함수를 완성해주세요. 제한 사항 1 ≤ n ≤ 100,000 결과는 매우 클 수 있으므로 1,000,000,007 로 나눈 나머지를 return합니다. 입출력 예 n result 2 3 3 10 입출력 예 설명",normal,Math
19,"비내림차순으로 정렬된 수열이 주어질 때, 다음 조건을 만족하는 부분 수열을 찾으려고 합니다. 기존 수열에서 임의의 두 인덱스의 원소와 그 사이의 원소를 모두 포함하는 부분 수열이어야 합니다. 부분 수열의 합은 k입니다. 합이 k인 부분 수열이 여러 개인 경우 길이가 짧은 수열을 찾습니다. 길이가 짧은 수열이 여러 개인 경우 앞쪽(시작 인덱스가 작은)에 나오는 수열을 찾습니다. 수열을 나타내는 정수 배열 sequence와 부분 수열의 합을 나타내는 정수 k가 매개변수로 주어질 때, 위 조건을 만족하는 부분 수열의 시작 인덱스와 마지막 인덱스를 배열에 담아 return 하는 solution 함수를 완성해주세요. 이때 수열의 인덱스는 0부터 시작합니다. 제한사항 5 ≤ sequence의 길이 ≤ 1,000,000 1 ≤ sequence의 원소 ≤ 1,000 sequence는 비내림차순으로 정렬되어 있습니다. 5 ≤ k ≤ 1,000,000,000 k는 항상 sequence의 부분 수열로 만들 수 있는 값입니다. 입출력 예 sequence k result [1, 2, 3, 4, 5] 7 [2, 3] [1, 1, 1, 2, 3, 4, 5] 5 [6, 6] [2, 2, 2, 2, 2] 6 [0, 2] 입출력 예 설명",normal,Array
20,"과제를 받은 루는 다음과 같은 순서대로 과제를 하려고 계획을 세웠습니다. 과제는 시작하기로 한 시각이 되면 시작합니다. 새로운 과제를 시작할 시각이 되었을 때, 기존에 진행 중이던 과제가 있다면 진행 중이던 과제를 멈추고 새로운 과제를 시작합니다. 진행중이던 과제를 끝냈을 때, 잠시 멈춘 과제가 있다면, 멈춰둔 과제를 이어서 진행합니다. 만약, 과제를 끝낸 시각에 새로 시작해야 되는 과제와 잠시 멈춰둔 과제가 모두 있다면, 새로 시작해야 하는 과제부터 진행합니다. 멈춰둔 과제가 여러 개일 경우, 가장 최근에 멈춘 과제부터 시작합니다. 과제 계획을 담은 이차원 문자열 배열 plans가 매개변수로 주어질 때, 과제를 끝낸 순서대로 이름을 배열에 담아 return 하는 solution 함수를 완성해주세요. 제한사항 3 ≤ plans의 길이 ≤ 1,000 plans의 원소는 [name, start, playtime]의 구조로 이루어져 있습니다. name : 과제의 이름을 의미합니다. 2 ≤ name의 길이 ≤ 10 name은 알파벳 소문자로만 이루어져 있습니다. name이 중복되는 원소는 없습니다. start : 과제의 시작 시각을 나타냅니다. ""hh:mm""의 형태로 ""00:00"" ~ ""23:59"" 사이의 시간값만 들어가 있습니다. 모든 과제의 시작 시각은 달라서 겹칠 일이 없습니다. 과제는 ""00:00"" ... ""23:59"" 순으로 시작하면 됩니다. 즉, 시와 분의 값이 작을수록 더 빨리 시작한 과제입니다. playtime : 과제를 마치는데 걸리는 시간을 의미하며, 단위는 분입니다. 1 ≤ playtime ≤ 100 playtime은 0으로 시작하지 않습니다. 배열은 시간순으로 정렬되어 있지 않을 수 있습니다. 진행중이던 과제가 끝나는 시각과 새로운 과제를 시작해야하는 시각이 같은 경우 진행중이던 과제는 끝난 것으로 판단합니다. 입출력 예 plans result [[""korean"", ""11:40"", ""30""], [""english"", ""12:10"", ""20""], [""math"", ""12:30"", ""40""]] [""korean"", ""english"", ""math""] [[""science"", ""12:40"", ""50""], [""music"", ""12:20"", ""40""], [""history"", ""14:00"", ""30""], [""computer"", ""12:30"", ""100""]] [""science"", ""history"", ""computer"", ""music""] [[""aaa"", ""12:00"", ""20""], [""bbb"", ""12:10"", ""30""], [""ccc"", ""12:40"", ""10""]] [""bbb"", ""ccc"", ""aaa""] 입출력 예 설명",normal,Array
21,"마인은 곡괭이로 광산에서 광석을 캐려고 합니다. 마인은 다이아몬드 곡괭이, 철 곡괭이, 돌 곡괭이를 각각 0개에서 5개까지 가지고 있으며, 곡괭이로 광물을 캘 때는 피로도가 소모됩니다. 각 곡괭이로 광물을 캘 때의 피로도는 아래 표와 같습니다. 예를 들어, 철 곡괭이는 다이아몬드를 캘 때 피로도 5가 소모되며, 철과 돌을 캘때는 피로도가 1씩 소모됩니다. 각 곡괭이는 종류에 상관없이 광물 5개를 캔 후에는 더 이상 사용할 수 없습니다. 마인은 다음과 같은 규칙을 지키면서 최소한의 피로도로 광물을 캐려고 합니다. 사용할 수 있는 곡괭이중 아무거나 하나를 선택해 광물을 캡니다. 한 번 사용하기 시작한 곡괭이는 사용할 수 없을 때까지 사용합니다. 광물은 주어진 순서대로만 캘 수 있습니다. 광산에 있는 모든 광물을 캐거나, 더 사용할 곡괭이가 없을 때까지 광물을 캡니다. 즉, 곡괭이를 하나 선택해서 광물 5개를 연속으로 캐고, 다음 곡괭이를 선택해서 광물 5개를 연속으로 캐는 과정을 반복하며, 더 사용할 곡괭이가 없거나 광산에 있는 모든 광물을 캘 때까지 과정을 반복하면 됩니다. 마인이 갖고 있는 곡괭이의 개수를 나타내는 정수 배열 picks와 광물들의 순서를 나타내는 문자열 배열 minerals가 매개변수로 주어질 때, 마인이 작업을 끝내기까지 필요한 최소한의 피로도를 return 하는 solution 함수를 완성해주세요. 제한사항 picks는 [dia, iron, stone]과 같은 구조로 이루어져 있습니다. 0 ≤ dia, iron, stone ≤ 5 dia는 다이아몬드 곡괭이의 수를 의미합니다. iron은 철 곡괭이의 수를 의미합니다. stone은 돌 곡괭이의 수를 의미합니다. 곡괭이는 최소 1개 이상 가지고 있습니다. 5 ≤ minerals의 길이 ≤ 50 minerals는 다음 3개의 문자열로 이루어져 있으며 각각의 의미는 다음과 같습니다. diamond : 다이아몬드 iron : 철 stone : 돌 입출력 예 picks minerals result [1, 3, 2] [""diamond"", ""diamond"", ""diamond"", ""iron"", ""iron"", ""diamond"", ""iron"", ""stone""] 12 [0, 1, 1] [""diamond"", ""diamond"", ""diamond"", ""diamond"", ""diamond"", ""iron"", ""iron"", ""iron"", ""iron"", ""iron"", ""diamond""] 50 입출력 예 설명",normal,Array
22,"리코쳇 로봇이라는 보드게임이 있습니다. 이 보드게임은 격자모양 게임판 위에서 말을 움직이는 게임으로, 시작 위치에서 출발한 뒤 목표 위치에 정확하게 멈추기 위해 최소 몇 번의 이동이 필요한지 말하는 게임입니다. 이 게임에서 말의 이동은 현재 위치에서 상, 하, 좌, 우 중 한 방향으로 게임판 위의 장애물이나 게임판 가장자리까지 부딪힐 때까지 미끄러져 움직이는 것을 한 번의 이동으로 정의합니다. 다음은 보드게임판을 나타낸 예시입니다. ("".""은 빈 공간을, ""R""은 로봇의 처음 위치를, ""D""는 장애물의 위치를, ""G""는 목표지점을 나타냅니다.) ...D..R .D.G... ....D.D D....D. ..D.... 이때 최소 움직임은 7번이며 ""R"" 위치에서 아래, 왼쪽, 위, 왼쪽, 아래, 오른쪽, 위 순서로 움직이면 ""G"" 위치에 멈춰 설 수 있습니다. 게임판의 상태를 나타내는 문자열 배열 board가 주어졌을 때, 말이 목표위치에 도달하는데 최소 몇 번 이동해야 하는지 return 하는 solution함수를 완성해주세요. 만약 목표위치에 도달할 수 없다면 -1을 return 해주세요. 제한 사항 3 ≤ board의 길이 ≤ 100 3 ≤ board의 원소의 길이 ≤ 100 board의 원소의 길이는 모두 동일합니다. 문자열은 ""."", ""D"", ""R"", ""G""로만 구성되어 있으며 각각 빈 공간, 장애물, 로봇의 처음 위치, 목표 지점을 나타냅니다. ""R""과 ""G""는 한 번씩 등장합니다. 입출력 예 board result [""...D..R"", "".D.G..."", ""....D.D"", ""D....D."", ""..D....""] 7 ["".D.R"", ""...."", "".G.."", ""...D""] -1 입출력 예 설명",normal,Array
23,"프로그래머스의 마스코트인 머쓱이는 최근 취미로 당구를 치기 시작했습니다. 머쓱이는 손 대신 날개를 사용해야 해서 당구를 잘 못 칩니다. 하지만 끈기가 강한 머쓱이는 열심히 노력해서 당구를 잘 치려고 당구 학원에 다니고 있습니다. 오늘도 당구 학원에 나온 머쓱이에게 당구 선생님이""원쿠션""(당구에서 공을 쳐서 벽에 맞히는 걸 쿠션이라고 부르고, 벽에 한 번 맞힌 후 공에 맞히면 원쿠션이라고 부릅니다) 연습을 하라면서 당구공의 위치가 담긴 리스트를 건네줬습니다. 리스트에는 머쓱이가 맞춰야 하는 공들의 위치가 담겨있습니다. 머쓱이는 리스트에 담긴 각 위치에 순서대로 공을 놓아가며 ""원쿠션"" 연습을 하면 됩니다. 이때, 머쓱이는 항상 같은 위치에 공을 놓고 쳐서 리스트에 담긴 위치에 놓인 공을 맞춥니다. 머쓱이와 달리 최근 취미로 알고리즘 문제를 풀기 시작한 당신은, 머쓱이가 친 공이 각각의 목표로한 공에 맞을 때까지 최소 얼마의 거리를 굴러가야 하는지가 궁금해졌습니다. 당구대의 가로 길이 m, 세로 길이 n과 머쓱이가 쳐야 하는 공이 놓인 위치 좌표를 나타내는 두 정수 startX, startY, 그리고 매 회마다 목표로 해야하는 공들의 위치 좌표를 나타내는 정수 쌍들이 들어있는 2차원 정수배열 balls가 주어집니다. ""원쿠션"" 연습을 위해 머쓱이가 공을 적어도 벽에 한 번은 맞춘 후 목표 공에 맞힌다고 할 때, 각 회마다 머쓱이가 친 공이 굴러간 거리의 최솟값의 제곱을 배열에 담아 return 하도록 solution 함수를 완성해 주세요. 단, 머쓱이가 친 공이 벽에 부딪힐 때 진행 방향은 항상 입사각과 반사각이 동일하며, 만약 꼭짓점에 부딪힐 경우 진입 방향의 반대방향으로 공이 진행됩니다. 공의 크기는 무시하며, 두 공의 좌표가 정확히 일치하는 경우에만 두 공이 서로 맞았다고 판단합니다. 공이 목표 공에 맞기 전에 멈추는 경우는 없으며, 목표 공에 맞으면 바로 멈춘다고 가정합니다. 위 그림은 친 공이 벽에 맞았을 때의 움직임을 나타낸 그림입니다. 치기 전 공의 위치가 점 A입니다. 위 그림은 친 공이 꼭짓점에 맞았을 때의 움직임을 나타낸 그림입니다. 치기 전 공의 위치가 점 A입니다. 제한사항 3 ≤ m, n ≤ 1,000 0 < startX < m 0 < startY < n 2 ≤ balls의 길이 ≤ 1,000 balls의 원소는 [a, b] 형태입니다. a, b는 머쓱이가 맞춰야 할 공이 놓인 좌표를 의미합니다. 0 < a < m, 0 < b < n (a, b) = ( startX, startY )인 입력은 들어오지 않습니다. 입출력 예 m n startX startY balls result 10 10 3 7 [[7, 7], [2, 7], [7, 3]] [52, 37, 116] 입출력 예 설명",normal,Array
24,"다음은 중고거래 게시판 정보를 담은 USED_GOODS_BOARD 테이블입니다. USED_GOODS_BOARD 테이블은 다음과 같으며 BOARD_ID, WRITER_ID, TITLE, CONTENTS, PRICE, CREATED_DATE, STATUS, VIEWS은 게시글 ID, 작성자 ID, 게시글 제목, 게시글 내용, 가격, 작성일, 거래상태, 조회수를 의미합니다. Column name Type Nullable BOARD_ID VARCHAR(5) FALSE WRITER_ID VARCHAR(50) FALSE TITLE VARCHAR(100) FALSE CONTENTS VARCHAR(1000) FALSE PRICE NUMBER FALSE CREATED_DATE DATE FALSE STATUS VARCHAR(10) FALSE VIEWS NUMBER FALSE 문제 USED_GOODS_BOARD 테이블에서 2022년 10월 5일에 등록된 중고거래 게시물의 게시글 ID, 작성자 ID, 게시글 제목, 가격, 거래상태를 조회하는 SQL문을 작성해주세요. 거래상태가 SALE 이면 판매중, RESERVED이면 예약중, DONE이면 거래완료 분류하여 출력해주시고, 결과는 게시글 ID를 기준으로 내림차순 정렬해주세요. 예시 USED_GOODS_BOARD 테이블이 다음과 같을 때 BOARD_ID WRITER_ID TITLE CONTENTS PRICE CREATED_DATE STATUS VIEWS B0007 s2s2123 커피글라인더 새상품처럼 깨끗합니다. 7000 2022-10-04 DONE 210 B0008 hong02 자전거 판매합니다 출퇴근용으로 구매했다가 사용하지 않아서 내놔요 40000 2022-10-04 SALE 301 B0009 yawoong67 선반 팝니다 6단 선반. 환불 반품 안됩니다. 12000 2022-10-05 DONE 202 B0010 keel1990 철제선반5단 철제선반 5단 조립식 팜 10000 2022-10-05 SALE 194 SQL을 실행하면 다음과 같이 출력되어야 합니다. BOARD_ID WRITER_ID TITLE PRICE STATUS B0010 keel1990 철제선반5단 10000 판매중 B0009 yawoong67 선반 팝니다 12000 거래완료",normal,database
25,"다음은 중고거래 게시판 정보를 담은 USED_GOODS_BOARD 테이블과 중고거래 게시판 첨부파일 정보를 담은 USED_GOODS_FILE 테이블입니다. USED_GOODS_BOARD 테이블은 다음과 같으며 BOARD_ID, WRITER_ID, TITLE, CONTENTS, PRICE, CREATED_DATE, STATUS, VIEWS은 게시글 ID, 작성자 ID, 게시글 제목, 게시글 내용, 가격, 작성일, 거래상태, 조회수를 의미합니다. Column name Type Nullable BOARD_ID VARCHAR(5) FALSE WRITER_ID VARCHAR(50) FALSE TITLE VARCHAR(100) FALSE CONTENTS VARCHAR(1000) FALSE PRICE NUMBER FALSE CREATED_DATE DATE FALSE STATUS VARCHAR(10) FALSE VIEWS NUMBER FALSE USED_GOODS_FILE 테이블은 다음과 같으며 FILE_ID, FILE_EXT, FILE_NAME, BOARD_ID는 각각 파일 ID, 파일 확장자, 파일 이름, 게시글 ID를 의미합니다. Column name Type Nullable FILE_ID VARCHAR(10) FALSE FILE_EXT VARCHAR(5) FALSE FILE_NAME VARCHAR(256) FALSE BOARD_ID VARCHAR(10) FALSE 문제 USED_GOODS_BOARD와 USED_GOODS_FILE 테이블에서 조회수가 가장 높은 중고거래 게시물에 대한 첨부파일 경로를 조회하는 SQL문을 작성해주세요. 첨부파일 경로는 FILE ID를 기준으로 내림차순 정렬해주세요. 기본적인 파일경로는 /home/grep/src/ 이며, 게시글 ID를 기준으로 디렉토리가 구분되고, 파일이름은 파일 ID, 파일 이름, 파일 확장자로 구성되도록 출력해주세요. 조회수가 가장 높은 게시물은 하나만 존재합니다. 예시 USED_GOODS_BOARD 테이블이 다음과 같고 BOARD_ID WRITER_ID TITLE CONTENTS PRICE CREATED_DATE STATUS VIEWS B0001 kwag98 반려견 배변패드 팝니다 정말 저렴히 판매합니다. 전부 미개봉 새상품입니다. 12000 2022-10-01 DONE 250 B0002 lee871201 국내산 볶음참깨 직접 농사지은 참깨입니다. 3000 2022-10-02 DONE 121 B0003 goung12 배드민턴 라켓 사놓고 방치만 해서 팝니다. 9000 2022-10-02 SALE 212 B0004 keel1990 디올 귀걸이 신세계강남점에서 구입. 정품 아닐시 백퍼센트 환불 130000 2022-10-02 SALE 199 B0005 haphli01 스팸클래식 팔아요 유통기한 2025년까지에요 10000 2022-10-02 SALE 121 USED_GOODS_FILE 테이블이 다음과 같을 때 FILE_ID FILE_EXT FILE_NAME BOARD_ID IMG_000001 .jpg photo1 B0001 IMG_000002 .jpg photo2 B0001 IMG_000003 .png 사진 B0002 IMG_000004 .jpg 사진 B0003 IMG_000005 .jpg photo B0004 SQL을 실행하면 다음과 같이 출력되어야 합니다. FILE_PATH /home/grep/src/B0001/IMG_000001photo1.jpg /home/grep/src/B0001/IMG_000002photo2.jpg",normal,database
26,"다음은 중고 거래 게시판 정보를 담은 USED_GOODS_BOARD 테이블과 중고 거래 게시판 첨부파일 정보를 담은 USED_GOODS_USER 테이블입니다. USED_GOODS_BOARD 테이블은 다음과 같으며 BOARD_ID, WRITER_ID, TITLE, CONTENTS, PRICE, CREATED_DATE, STATUS, VIEWS는 게시글 ID, 작성자 ID, 게시글 제목, 게시글 내용, 가격, 작성일, 거래상태, 조회수를 의미합니다. Column name Type Nullable BOARD_ID VARCHAR(5) FALSE WRITER_ID VARCHAR(50) FALSE TITLE VARCHAR(100) FALSE CONTENTS VARCHAR(1000) FALSE PRICE NUMBER FALSE CREATED_DATE DATE FALSE STATUS VARCHAR(10) FALSE VIEWS NUMBER FALSE USED_GOODS_USER 테이블은 다음과 같으며 USER_ID, NICKNAME, CITY, STREET_ADDRESS1, STREET_ADDRESS2, TLNO는 각각 회원 ID, 닉네임, 시, 도로명 주소, 상세 주소, 전화번호를 의미합니다. Column name Type Nullable USER_ID VARCHAR(50) FALSE NICKANME VARCHAR(100) FALSE CITY VARCHAR(100) FALSE STREET_ADDRESS1 VARCHAR(100) FALSE STREET_ADDRESS2 VARCHAR(100) TRUE TLNO VARCHAR(20) FALSE 문제 USED_GOODS_BOARD와 USED_GOODS_USER 테이블에서 중고 거래 게시물을 3건 이상 등록한 사용자의 사용자 ID, 닉네임, 전체주소, 전화번호를 조회하는 SQL문을 작성해주세요. 이때, 전체 주소는 시, 도로명 주소, 상세 주소가 함께 출력되도록 해주시고, 전화번호의 경우 xxx-xxxx-xxxx 같은 형태로 하이픈 문자열(-)을 삽입하여 출력해주세요. 결과는 회원 ID를 기준으로 내림차순 정렬해주세요. 예시 USED_GOODS_BOARD 테이블이 다음과 같고 BOARD_ID WRITER_ID TITLE CONTENTS PRICE CREATED_DATE STATUS VIEWS B0001 dhfkzmf09 칼라거펠트 코트 양모 70%이상 코트입니다. 120000 2022-10-14 DONE 104 B0002 lee871201 국내산 볶음참깨 직접 농사지은 참깨입니다. 3000 2022-10-02 DONE 121 B0003 dhfkzmf09 나이키 숏패팅 사이즈는 M입니다. 40000 2022-10-17 DONE 98 B0004 kwag98 반려견 배변패드 팝니다 정말 저렴히 판매합니다. 전부 미개봉 새상품입니다. 12000 2022-10-01 DONE 250 B0005 dhfkzmf09 PS4 PS5 구매로인해 팝니다. 250000 2022-11-03 DONE 111 USED_GOODS_USER 테이블이 다음과 같을 때 USER_ID NICKNAME CITY STREET_ADDRESS1 STREET_ADDRESS2 TLNO dhfkzmf09 찐찐 성남시 분당구 수내로 13 A동 1107호 01053422914 dlPcks90 썹썹 성남시 분당구 수내로 74 401호 01034573944 cjfwls91 점심만금식 성남시 분당구 내정로 185 501호 01036344964 dlfghks94 희망 성남시 분당구 내정로 101 203동 102호 01032634154 rkdhs95 용기 성남시 분당구 수내로 23 501호 01074564564 SQL을 실행하면 다음과 같이 출력되어야 합니다. USER_ID NICKNAME 전체주소 전화번호 dhfkzmf09 찐찐 성남시 분당구 수내로 13 A동 1107호 010-5342-2914",normal,database
27,"다음은 중고 거래 게시판 정보를 담은 USED_GOODS_BOARD 테이블과 중고 거래 게시판 사용자 정보를 담은 USED_GOODS_USER 테이블입니다. USED_GOODS_BOARD 테이블은 다음과 같으며 BOARD_ID, WRITER_ID, TITLE, CONTENTS, PRICE, CREATED_DATE, STATUS, VIEWS는 게시글 ID, 작성자 ID, 게시글 제목, 게시글 내용, 가격, 작성일, 거래상태, 조회수를 의미합니다. Column name Type Nullable BOARD_ID VARCHAR(5) FALSE WRITER_ID VARCHAR(50) FALSE TITLE VARCHAR(100) FALSE CONTENTS VARCHAR(1000) FALSE PRICE NUMBER FALSE CREATED_DATE DATE FALSE STATUS VARCHAR(10) FALSE VIEWS NUMBER FALSE USED_GOODS_USER 테이블은 다음과 같으며 USER_ID, NICKNAME, CITY, STREET_ADDRESS1, STREET_ADDRESS2, TLNO는 각각 회원 ID, 닉네임, 시, 도로명 주소, 상세 주소, 전화번호를 를 의미합니다. Column name Type Nullable USER_ID VARCHAR(50) FALSE NICKNAME VARCHAR(100) FALSE CITY VARCHAR(100) FALSE STREET_ADDRESS1 VARCHAR(100) FALSE STREET_ADDRESS2 VARCHAR(100) TRUE TLNO VARCHAR(20) FALSE 문제 USED_GOODS_BOARD와 USED_GOODS_USER 테이블에서 완료된 중고 거래의 총금액이 70만 원 이상인 사람의 회원 ID, 닉네임, 총거래금액을 조회하는 SQL문을 작성해주세요. 결과는 총거래금액을 기준으로 오름차순 정렬해주세요. 예시 USED_GOODS_BOARD 테이블이 다음과 같고 BOARD_ID WRITER_ID TITLE CONTENTS PRICE CREATED_DATE STATUS VIEWS B0001 zkzkdh1 캠핑의자 가벼워요 깨끗한 상태입니다. 2개 25000 2022-11-29 SALE 34 B0002 miyeon89 벽걸이 에어컨 엘지 휘센 7평 100000 2022-11-29 SALE 55 B0003 dhfkzmf09 에어팟 맥스 에어팟 맥스 스카이 블루 색상 판매합니다. 450000 2022-11-26 DONE 67 B0004 sangjune1 파파야나인 포르쉐 푸쉬카 예민하신분은 피해주세요 30000 2022-11-30 DONE 78 B0005 zkzkdh1 애플워치7 애플워치7 실버 스텐 45미리 판매합니다. 700000 2022-11-30 DONE 99 USED_GOODS_USER 테이블이 다음과 같을 때 USER_ID NICKNAME CITY STREET_ADDRESS1 STREET_ADDRESS2 TLNO cjfwls91 점심만금식 성남시 분당구 내정로 185 501호 01036344964 zkzkdh1 후후후 성남시 분당구 내정로 35 가동 1202호 01032777543 spdlqj12 크크큭 성남시 분당구 수내로 206 2019동 801호 01087234922 xlqpfh2 잉여킹 성남시 분당구 수내로 1 001-004 01064534911 dhfkzmf09 찐찐 성남시 분당구 수내로 13 A동 1107호 01053422914 SQL을 실행하면 다음과 같이 출력되어야 합니다. USER_ID NICKNAME TOTAL_SALES zkzkdh1 후후후 700000",normal,database
28,"어떤 수열의 연속 부분 수열에 같은 길이의 펄스 수열을 각 원소끼리 곱하여 연속 펄스 부분 수열을 만들려 합니다. 펄스 수열이란 [1, -1, 1, -1 …] 또는 [-1, 1, -1, 1 …] 과 같이 1 또는 -1로 시작하면서 1과 -1이 번갈아 나오는 수열입니다. 예를 들어 수열 [2, 3, -6, 1, 3, -1, 2, 4]의 연속 부분 수열 [3, -6, 1]에 펄스 수열 [1, -1, 1]을 곱하면 연속 펄스 부분수열은 [3, 6, 1]이 됩니다. 또 다른 예시로 연속 부분 수열 [3, -1, 2, 4]에 펄스 수열 [-1, 1, -1, 1]을 곱하면 연속 펄스 부분수열은 [-3, -1, -2, 4]이 됩니다. 정수 수열 sequence가 매개변수로 주어질 때, 연속 펄스 부분 수열의 합 중 가장 큰 것을 return 하도록 solution 함수를 완성해주세요. 제한 사항 1 ≤ sequence의 길이 ≤ 500,000 -100,000 ≤ sequence의 원소 ≤ 100,000 sequence의 원소는 정수입니다. 입출력 예 sequence result [2, 3, -6, 1, 3, -1, 2, 4] 10 입출력 예 설명 주어진 수열의 연속 부분 수열 [3, -6, 1]에 펄스 수열 [1, -1, 1]을 곱하여 연속 펄스 부분 수열 [3, 6, 1]을 얻을 수 있고 그 합은 10으로서 가장 큽니다.",normal,Math
29,"틱택토는 두 사람이 하는 게임으로 처음에 3x3의 빈칸으로 이루어진 게임판에 선공이 ""O"", 후공이 ""X""를 번갈아가면서 빈칸에 표시하는 게임입니다. 가로, 세로, 대각선으로 3개가 같은 표시가 만들어지면 같은 표시를 만든 사람이 승리하고 게임이 종료되며 9칸이 모두 차서 더 이상 표시를 할 수 없는 경우에는 무승부로 게임이 종료됩니다. 할 일이 없어 한가한 머쓱이는 두 사람이 하는 게임인 틱택토를 다음과 같이 혼자서 하려고 합니다. 혼자서 선공과 후공을 둘 다 맡는다. 틱택토 게임을 시작한 후 ""O""와 ""X""를 혼자서 번갈아 가면서 표시를 하면서 진행한다. 틱택토는 단순한 규칙으로 게임이 금방 끝나기에 머쓱이는 한 게임이 종료되면 다시 3x3 빈칸을 그린 뒤 다시 게임을 반복했습니다. 그렇게 틱택토 수 십 판을 했더니 머쓱이는 게임 도중에 다음과 같이 규칙을 어기는 실수를 했을 수도 있습니다. ""O""를 표시할 차례인데 ""X""를 표시하거나 반대로 ""X""를 표시할 차례인데 ""O""를 표시한다. 선공이나 후공이 승리해서 게임이 종료되었음에도 그 게임을 진행한다. 게임 도중 게임판을 본 어느 순간 머쓱이는 본인이 실수를 했는지 의문이 생겼습니다. 혼자서 틱택토를 했기에 게임하는 과정을 지켜본 사람이 없어 이를 알 수는 없습니다. 그러나 게임판만 봤을 때 실제로 틱택토 규칙을 지켜서 진행했을 때 나올 수 있는 상황인지는 판단할 수 있을 것 같고 문제가 없다면 게임을 이어서 하려고 합니다. 머쓱이가 혼자서 게임을 진행하다 의문이 생긴 틱택토 게임판의 정보를 담고 있는 문자열 배열 board가 매개변수로 주어질 때, 이 게임판이 규칙을 지켜서 틱택토를 진행했을 때 나올 수 있는 게임 상황이면 1을 아니라면 0을 return 하는 solution 함수를 작성해 주세요. 제한사항 board의 길이 = board[i]의 길이 = 3 board의 원소는 모두 ""O"", ""X"", "".""으로만 이루어져 있습니다. board[i][j]는 i + 1행 j + 1열에 해당하는 칸의 상태를 나타냅니다. "".""은 빈칸을, ""O""와 ""X""는 해당 문자로 칸이 표시되어 있다는 의미입니다. 입출력 예 board result [""O.X"", "".O."", ""..X""] 1 [""OOO"", ""..."", ""XXX""] 0 [""..."", "".X."", ""...""] 0 [""..."", ""..."", ""...""] 1 입출력 예 설명",normal,Array
30,"1 x 1 크기의 칸들로 이루어진 직사각형 격자 형태의 미로에서 탈출하려고 합니다. 각 칸은 통로 또는 벽으로 구성되어 있으며, 벽으로 된 칸은 지나갈 수 없고 통로로 된 칸으로만 이동할 수 있습니다. 통로들 중 한 칸에는 미로를 빠져나가는 문이 있는데, 이 문은 레버를 당겨서만 열 수 있습니다. 레버 또한 통로들 중 한 칸에 있습니다. 따라서, 출발 지점에서 먼저 레버가 있는 칸으로 이동하여 레버를 당긴 후 미로를 빠져나가는 문이 있는 칸으로 이동하면 됩니다. 이때 아직 레버를 당기지 않았더라도 출구가 있는 칸을 지나갈 수 있습니다. 미로에서 한 칸을 이동하는데 1초가 걸린다고 할 때, 최대한 빠르게 미로를 빠져나가는데 걸리는 시간을 구하려 합니다. 미로를 나타낸 문자열 배열 maps가 매개변수로 주어질 때, 미로를 탈출하는데 필요한 최소 시간을 return 하는 solution 함수를 완성해주세요. 만약, 탈출할 수 없다면 -1을 return 해주세요. 제한사항 5 ≤ maps의 길이 ≤ 100 5 ≤ maps[i]의 길이 ≤ 100 maps[i]는 다음 5개의 문자들로만 이루어져 있습니다. S : 시작 지점 E : 출구 L : 레버 O : 통로 X : 벽 시작 지점과 출구, 레버는 항상 다른 곳에 존재하며 한 개씩만 존재합니다. 출구는 레버가 당겨지지 않아도 지나갈 수 있으며, 모든 통로, 출구, 레버, 시작점은 여러 번 지나갈 수 있습니다. 입출력 예 maps result [""SOOOL"",""XXXXO"",""OOOOO"",""OXXXX"",""OOOOE""] 16 [""LOOXS"",""OOOOX"",""OOOOO"",""OOOOO"",""EOOOO""] -1 입출력 예 설명",normal,Array
31,"다음은 어느 자동차 대여 회사의 자동차 대여 기록 정보를 담은 CAR_RENTAL_COMPANY_RENTAL_HISTORY 테이블입니다. CAR_RENTAL_COMPANY_RENTAL_HISTORY 테이블은 아래와 같은 구조로 되어있으며, HISTORY_ID, CAR_ID, START_DATE, END_DATE 는 각각 자동차 대여 기록 ID, 자동차 ID, 대여 시작일, 대여 종료일을 나타냅니다. Column name Type Nullable HISTORY_ID INTEGER FALSE CAR_ID INTEGER FALSE START_DATE DATE FALSE END_DATE DATE FALSE 문제 CAR_RENTAL_COMPANY_RENTAL_HISTORY 테이블에서 평균 대여 기간이 7일 이상인 자동차들의 자동차 ID와 평균 대여 기간(컬럼명: AVERAGE_DURATION) 리스트를 출력하는 SQL문을 작성해주세요. 평균 대여 기간은 소수점 두번째 자리에서 반올림하고, 결과는 평균 대여 기간을 기준으로 내림차순 정렬해주시고, 평균 대여 기간이 같으면 자동차 ID를 기준으로 내림차순 정렬해주세요. 예시 예를 들어 CAR_RENTAL_COMPANY_RENTAL_HISTORY 테이블이 다음과 같다면 HISTORY_ID CAR_ID START_DATE END_DATE 1 1 2022-09-27 2022-10-01 2 1 2022-10-03 2022-11-04 3 2 2022-09-05 2022-09-05 4 2 2022-09-08 2022-09-10 5 3 2022-09-16 2022-10-15 6 1 2022-11-07 2022-12-06 자동차 별 평균 대여 기간은 자동차 ID가 1인 자동차의 경우, 대여 기간이 각각 5일, 33일, 30일인 기록이 존재하므로 평균 22.7일 자동차 ID가 2인 자동차의 경우, 대여 기간이 각각 1일, 3일인 기록이 존재하므로 평균 2일 자동차 ID가 3인 자동차의 경우, 대여 기간이 30일인 기록만 존재하므로 평균 30일 입니다. 평균 대여 기간이 7일 이상인 자동차는 자동차 ID가 1, 3인 자동차이고, 평균 대여 기간 내림차순 및 자동차 ID를 기준으로 내림차순 정렬하면 다음과 같이 나와야 합니다. CAR_ID AVERAGE_DURATION 3 30.0 1 22.7",normal,database
32,"다음은 어느 자동차 대여 회사에서 대여 중인 자동차들의 정보를 담은 CAR_RENTAL_COMPANY_CAR 테이블과 자동차 대여 기록 정보를 담은 CAR_RENTAL_COMPANY_RENTAL_HISTORY 테이블입니다. CAR_RENTAL_COMPANY_CAR 테이블은 아래와 같은 구조로 되어있으며, CAR_ID, CAR_TYPE, DAILY_FEE, OPTIONS 는 각각 자동차 ID, 자동차 종류, 일일 대여 요금(원), 자동차 옵션 리스트를 나타냅니다. Column name Type Nullable CAR_ID INTEGER FALSE CAR_TYPE VARCHAR(255) FALSE DAILY_FEE INTEGER FALSE OPTIONS VARCHAR(255) FALSE 자동차 종류는 '세단', 'SUV', '승합차', '트럭', '리무진' 이 있습니다. 자동차 옵션 리스트는 콤마(',')로 구분된 키워드 리스트(예: '열선시트', '스마트키', '주차감지센서')로 되어있으며, 키워드 종류는 '주차감지센서', '스마트키', '네비게이션', '통풍시트', '열선시트', '후방카메라', '가죽시트' 가 있습니다. CAR_RENTAL_COMPANY_RENTAL_HISTORY 테이블은 아래와 같은 구조로 되어있으며, HISTORY_ID, CAR_ID, START_DATE, END_DATE 는 각각 자동차 대여 기록 ID, 자동차 ID, 대여 시작일, 대여 종료일을 나타냅니다. Column name Type Nullable HISTORY_ID INTEGER FALSE CAR_ID INTEGER FALSE START_DATE DATE FALSE END_DATE DATE FALSE 문제 CAR_RENTAL_COMPANY_CAR 테이블과 CAR_RENTAL_COMPANY_RENTAL_HISTORY 테이블에서 자동차 종류가 '세단'인 자동차들 중 10월에 대여를 시작한 기록이 있는 자동차 ID 리스트를 출력하는 SQL문을 작성해주세요. 자동차 ID 리스트는 중복이 없어야 하며, 자동차 ID를 기준으로 내림차순 정렬해주세요. 예시 예를 들어 CAR_RENTAL_COMPANY_CAR 테이블이 다음과 같고 CAR_ID CAR_TYPE DAILY_FEE OPTIONS 1 세단 16000 가죽시트,열선시트,후방카메라 2 SUV 14000 스마트키,네비게이션,열선시트 3 세단 22000 주차감지센서,후방카메라,가죽시트 4 세단 12000 주차감지센서 CAR_RENTAL_COMPANY_RENTAL_HISTORY 테이블이 다음과 같다면 HISTORY_ID CAR_ID START_DATE END_DATE 1 4 2022-09-27 2022-09-27 2 3 2022-10-03 2022-10-04 3 2 2022-10-05 2022-10-05 4 1 2022-10-11 2022-10-14 5 3 2022-10-13 2022-10-15 10월에 대여를 시작한 기록이 있는 '세단' 종류의 자동차는 자동차 ID가 1, 3 인 자동차이고, 자동차 ID를 기준으로 내림차순 정렬하면 다음과 같이 나와야 합니다. CAR_ID 3 1",normal,database
33,"다음은 어느 자동차 대여 회사의 자동차 대여 기록 정보를 담은 CAR_RENTAL_COMPANY_RENTAL_HISTORY 테이블입니다. CAR_RENTAL_COMPANY_RENTAL_HISTORY 테이블은 아래와 같은 구조로 되어있으며, HISTORY_ID, CAR_ID, START_DATE, END_DATE 는 각각 자동차 대여 기록 ID, 자동차 ID, 대여 시작일, 대여 종료일을 나타냅니다. Column name Type Nullable HISTORY_ID INTEGER FALSE CAR_ID INTEGER FALSE START_DATE DATE FALSE END_DATE DATE FALSE 문제 CAR_RENTAL_COMPANY_RENTAL_HISTORY 테이블에서 2022년 10월 16일에 대여 중인 자동차인 경우 '대여중' 이라고 표시하고, 대여 중이지 않은 자동차인 경우 '대여 가능'을 표시하는 컬럼(컬럼명: AVAILABILITY)을 추가하여 자동차 ID와 AVAILABILITY 리스트를 출력하는 SQL문을 작성해주세요. 이때 반납 날짜가 2022년 10월 16일인 경우에도 '대여중'으로 표시해주시고 결과는 자동차 ID를 기준으로 내림차순 정렬해주세요. 예시 예를 들어 CAR_RENTAL_COMPANY_RENTAL_HISTORY 테이블이 다음과 같다면 HISTORY_ID CAR_ID START_DATE END_DATE 1 4 2022-09-27 2022-09-27 2 3 2022-10-03 2022-10-04 3 2 2022-10-05 2022-10-05 4 1 2022-10-11 2022-10-16 5 3 2022-10-13 2022-10-15 6 2 2022-10-15 2022-10-17 2022년 10월 16일에 대여 중인 자동차는 자동차 ID가 1, 2인 자동차이고, 대여 가능한 자동차는 자동차 ID가 3, 4이므로, '대여중' 또는 '대여 가능' 을 표시하는 컬럼을 추가하고, 자동차 ID를 기준으로 내림차순 정렬하면 다음과 같이 나와야 합니다. CAR_ID AVAILABILITY 4 대여 가능 3 대여 가능 2 대여중 1 대여중",normal,database
34,"다음은 어느 자동차 대여 회사에서 대여 중인 자동차들의 정보를 담은 CAR_RENTAL_COMPANY_CAR 테이블과 자동차 대여 기록 정보를 담은 CAR_RENTAL_COMPANY_RENTAL_HISTORY 테이블과 자동차 종류 별 대여 기간 종류 별 할인 정책 정보를 담은 CAR_RENTAL_COMPANY_DISCOUNT_PLAN 테이블 입니다. CAR_RENTAL_COMPANY_CAR 테이블은 아래와 같은 구조로 되어있으며, CAR_ID, CAR_TYPE, DAILY_FEE, OPTIONS 는 각각 자동차 ID, 자동차 종류, 일일 대여 요금(원), 자동차 옵션 리스트를 나타냅니다. Column name Type Nullable CAR_ID INTEGER FALSE CAR_TYPE VARCHAR(255) FALSE DAILY_FEE INTEGER FALSE OPTIONS VARCHAR(255) FALSE 자동차 종류는 '세단', 'SUV', '승합차', '트럭', '리무진' 이 있습니다. 자동차 옵션 리스트는 콤마(',')로 구분된 키워드 리스트(예: ''열선시트,스마트키,주차감지센서'')로 되어있으며, 키워드 종류는 '주차감지센서', '스마트키', '네비게이션', '통풍시트', '열선시트', '후방카메라', '가죽시트' 가 있습니다. CAR_RENTAL_COMPANY_RENTAL_HISTORY 테이블은 아래와 같은 구조로 되어있으며, HISTORY_ID, CAR_ID, START_DATE, END_DATE 는 각각 자동차 대여 기록 ID, 자동차 ID, 대여 시작일, 대여 종료일을 나타냅니다. Column name Type Nullable HISTORY_ID INTEGER FALSE CAR_ID INTEGER FALSE START_DATE DATE FALSE END_DATE DATE FALSE CAR_RENTAL_COMPANY_DISCOUNT_PLAN 테이블은 아래와 같은 구조로 되어있으며, PLAN_ID, CAR_TYPE, DURATION_TYPE, DISCOUNT_RATE 는 각각 요금 할인 정책 ID, 자동차 종류, 대여 기간 종류, 할인율(%)을 나타냅니다. Column name Type Nullable PLAN_ID INTEGER FALSE CAR_TYPE VARCHAR(255) FALSE DURATION_TYPE VARCHAR(255) FALSE DISCOUNT_RATE INTEGER FALSE 할인율이 적용되는 대여 기간 종류로는 '7일 이상' (대여 기간이 7일 이상 30일 미만인 경우), '30일 이상' (대여 기간이 30일 이상 90일 미만인 경우), '90일 이상' (대여 기간이 90일 이상인 경우) 이 있습니다. 대여 기간이 7일 미만인 경우 할인정책이 없습니다. 문제 CAR_RENTAL_COMPANY_CAR 테이블과 CAR_RENTAL_COMPANY_RENTAL_HISTORY 테이블과 CAR_RENTAL_COMPANY_DISCOUNT_PLAN 테이블에서 자동차 종류가 '세단' 또는 'SUV' 인 자동차 중 2022년 11월 1일부터 2022년 11월 30일까지 대여 가능하고 30일간의 대여 금액이 50만원 이상 200만원 미만인 자동차에 대해서 자동차 ID, 자동차 종류, 대여 금액(컬럼명: FEE) 리스트를 출력하는 SQL문을 작성해주세요. 결과는 대여 금액을 기준으로 내림차순 정렬하고, 대여 금액이 같은 경우 자동차 종류를 기준으로 오름차순 정렬, 자동차 종류까지 같은 경우 자동차 ID를 기준으로 내림차순 정렬해주세요. 예시 예를 들어 CAR_RENTAL_COMPANY_CAR 테이블과 CAR_RENTAL_COMPANY_RENTAL_HISTORY 테이블과 CAR_RENTAL_COMPANY_DISCOUNT_PLAN 테이블이 다음과 같다면 CAR_ID CAR_TYPE DAILY_FEE OPTIONS 1 SUV 25000 가죽시트,열선시트,후방카메라 2 세단 14000 스마트키,네비게이션,열선시트 3 트럭 32000 주차감지센서,후방카메라,가죽시트 4 세단 12000 열선시트,후방카메라 5 세단 22000 스마트키,주차감지센서 HISTORY_ID CAR_ID START_DATE END_DATE 1 1 2022-08-27 2022-09-02 2 1 2022-10-03 2022-10-04 3 2 2022-10-05 2022-10-20 4 2 2022-10-10 2022-11-12 5 3 2022-10-16 2022-10-17 PLAN_ID CAR_TYPE DURATION_TYPE DISCOUNT_RATE 1 트럭 7일 이상 5% 2 트럭 30일 이상 7% 3 트럭 90일 이상 10% 4 세단 7일 이상 5% 5 세단 30일 이상 10% 6 세단 90일 이상 15% 7 SUV 7일 이상 3% 8 SUV 30일 이상 8% 9 SUV 90일 이상 12% 자동차 종류가 '세단' 또는 'SUV' 인 자동차 중 2022년 11월 1일 부터 2022년 11월 30일까지 대여가능한 자동차는 자동차 ID가 1, 4, 5인 자동차입니다. 일일 대여 요금에 자동차 종류 별 대여기간이 30일 이상인 경우의 할인율을 적용하여 30일간의 대여 금액을 구하면, 자동차 ID가 1인 경우, 일일 대여 금액 25,000원에서 8% 할인율을 적용하고 30일을 곱하면 총 대여 금액은 690,000원 자동차 ID가 4인 경우, 일일 대여 금액 12,000원에서 10% 할인율을 적용하고 30일을 곱하면 총 대여 금액은 324,000원 자동차 ID가 5인 경우, 일일 대여 금액 22,000원에서 10% 할인율을 적용하고 30일을 곱하면 총 대여 금액은 621,000원이고, 대여 금액이 50만원 이상 200만원 미만인 경우에 대해서 대여 금액을 기준으로 내림차순, 자동차 종류를 기준으로 오름차순 및 자동차 ID를 기준으로 내림차순 정렬하면 다음과 같아야 합니다. CAR_ID CAR_TYPE FEE 5 세단 690000 1 SUV 621000 주의사항 FEE의 경우 예시처럼 정수부분만 출력되어야 합니다.",hard,database
35,"호텔을 운영 중인 코니는 최소한의 객실만을 사용하여 예약 손님들을 받으려고 합니다. 한 번 사용한 객실은 퇴실 시간을 기준으로 10분간 청소를 하고 다음 손님들이 사용할 수 있습니다. 예약 시각이 문자열 형태로 담긴 2차원 배열 book_time이 매개변수로 주어질 때, 코니에게 필요한 최소 객실의 수를 return 하는 solution 함수를 완성해주세요. 제한사항 1 ≤ book_time의 길이 ≤ 1,000 book_time[i]는 [""HH:MM"", ""HH:MM""]의 형태로 이루어진 배열입니다 [대실 시작 시각, 대실 종료 시각] 형태입니다. 시각은 HH:MM 형태로 24시간 표기법을 따르며, ""00:00"" 부터 ""23:59"" 까지로 주어집니다. 예약 시각이 자정을 넘어가는 경우는 없습니다. 시작 시각은 항상 종료 시각보다 빠릅니다. 입출력 예 book_time result [[""15:00"", ""17:00""], [""16:40"", ""18:20""], [""14:20"", ""15:20""], [""14:10"", ""19:20""], [""18:20"", ""21:20""]] 3 [[""09:10"", ""10:10""], [""10:20"", ""12:20""]] 1 [[""10:20"", ""12:30""], [""10:20"", ""12:30""], [""10:20"", ""12:30""]] 3 입출력 예 설명",normal,Array
36,"메리는 여름을 맞아 무인도로 여행을 가기 위해 지도를 보고 있습니다. 지도에는 바다와 무인도들에 대한 정보가 표시돼 있습니다. 지도는 1 x 1크기의 사각형들로 이루어진 직사각형 격자 형태이며, 격자의 각 칸에는 'X' 또는 1에서 9 사이의 자연수가 적혀있습니다. 지도의 'X'는 바다를 나타내며, 숫자는 무인도를 나타냅니다. 이때, 상, 하, 좌, 우로 연결되는 땅들은 하나의 무인도를 이룹니다. 지도의 각 칸에 적힌 숫자는 식량을 나타내는데, 상, 하, 좌, 우로 연결되는 칸에 적힌 숫자를 모두 합한 값은 해당 무인도에서 최대 며칠동안 머물 수 있는지를 나타냅니다. 어떤 섬으로 놀러 갈지 못 정한 메리는 우선 각 섬에서 최대 며칠씩 머물 수 있는지 알아본 후 놀러갈 섬을 결정하려 합니다. 지도를 나타내는 문자열 배열 maps가 매개변수로 주어질 때, 각 섬에서 최대 며칠씩 머무를 수 있는지 배열에 오름차순으로 담아 return 하는 solution 함수를 완성해주세요. 만약 지낼 수 있는 무인도가 없다면 -1을 배열에 담아 return 해주세요. 제한사항 3 ≤ maps의 길이 ≤ 100 3 ≤ maps[i]의 길이 ≤ 100 maps[i]는 'X' 또는 1 과 9 사이의 자연수로 이루어진 문자열입니다. 지도는 직사각형 형태입니다. 입출력 예 maps result [""X591X"",""X1X5X"",""X231X"", ""1XXX1""] [1, 1, 27] [""XXX"",""XXX"",""XXX""] [-1] 입출력 예 설명",normal,Array
37,"정수로 이루어진 배열 numbers가 있습니다. 배열 의 각 원소들에 대해 자신보다 뒤에 있는 숫자 중에서 자신보다 크면서 가장 가까이 있는 수를 뒷 큰수라고 합니다. 정수 배열 numbers가 매개변수로 주어질 때, 모든 원소에 대한 뒷 큰수들을 차례로 담은 배열을 return 하도록 solution 함수를 완성해주세요. 단, 뒷 큰수가 존재하지 않는 원소는 -1을 담습니다. 제한사항 4 ≤ numbers의 길이 ≤ 1,000,000 1 ≤ numbers[i] ≤ 1,000,000 입출력 예 numbers result [2, 3, 3, 5] [3, 5, 5, -1] [9, 1, 5, 3, 6, 2] [-1, 5, 6, 6, -1, -1] 입출력 예 설명",normal,Array
38,"자연수 x를 y로 변환하려고 합니다. 사용할 수 있는 연산은 다음과 같습니다. x에 n을 더합니다 x에 2를 곱합니다. x에 3을 곱합니다. 자연수 x, y, n이 매개변수로 주어질 때, x를 y로 변환하기 위해 필요한 최소 연산 횟수를 return하도록 solution 함수를 완성해주세요. 이때 x를 y로 만들 수 없다면 -1을 return 해주세요. 제한사항 1 ≤ x ≤ y ≤ 1,000,000 1 ≤ n < y 입출력 예 x y n result 10 40 5 2 10 40 30 1 2 5 4 -1 입출력 예 설명",normal,Math
39,"어느 공원 놀이터에는 시소가 하나 설치되어 있습니다. 이 시소는 중심으로부터 2(m), 3(m), 4(m) 거리의 지점에 좌석이 하나씩 있습니다. 이 시소를 두 명이 마주 보고 탄다고 할 때, 시소가 평형인 상태에서 각각에 의해 시소에 걸리는 토크의 크기가 서로 상쇄되어 완전한 균형을 이룰 수 있다면 그 두 사람을 시소 짝꿍이라고 합니다. 즉, 탑승한 사람의 무게와 시소 축과 좌석 간의 거리의 곱이 양쪽 다 같다면 시소 짝꿍이라고 할 수 있습니다. 사람들의 몸무게 목록 weights이 주어질 때, 시소 짝꿍이 몇 쌍 존재하는지 구하여 return 하도록 solution 함수를 완성해주세요. 제한 사항 2 ≤ weights의 길이 ≤ 100,000 100 ≤ weights[i] ≤ 1,000 몸무게 단위는 N(뉴턴)으로 주어집니다. 몸무게는 모두 정수입니다. 입출력 예 weights result [100,180,360,100,270] 4 입출력 예 설명 {100, 100} 은 서로 같은 거리에 마주보고 앉으면 균형을 이룹니다. {180, 360} 은 각각 4(m), 2(m) 거리에 마주보고 앉으면 균형을 이룹니다. {180, 270} 은 각각 3(m), 2(m) 거리에 마주보고 앉으면 균형을 이룹니다. {270, 360} 은 각각 4(m), 3(m) 거리에 마주보고 앉으면 균형을 이룹니다.",normal,Math
40,"완호네 회사는 연말마다 1년 간의 인사고과에 따라 인센티브를 지급합니다. 각 사원마다 근무 태도 점수와 동료 평가 점수가 기록되어 있는데 만약 어떤 사원이 다른 임의의 사원보다 두 점수가 모두 낮은 경우가 한 번이라도 있다면 그 사원은 인센티브를 받지 못합니다. 그렇지 않은 사원들에 대해서는 두 점수의 합이 높은 순으로 석차를 내어 석차에 따라 인센티브가 차등 지급됩니다. 이때, 두 점수의 합이 동일한 사원들은 동석차이며, 동석차의 수만큼 다음 석차는 건너 뜁니다. 예를 들어 점수의 합이 가장 큰 사원이 2명이라면 1등이 2명이고 2등 없이 다음 석차는 3등부터입니다. 각 사원의 근무 태도 점수와 동료 평가 점수 목록 scores이 주어졌을 때, 완호의 석차를 return 하도록 solution 함수를 완성해주세요. 제한 사항 1 ≤ scores의 길이 ≤ 100,000 scores의 각 행은 한 사원의 근무 태도 점수와 동료 평가 점수를 나타내며 [a, b] 형태입니다. scores[0]은 완호의 점수입니다. 0 ≤ a, b ≤ 100,000 완호가 인센티브를 받지 못하는 경우 -1을 return 합니다. 입출력 예 scores result [[2,2],[1,4],[3,2],[3,2],[2,1]] 4",normal,Math
41,"다음은 어느 자동차 대여 회사에서 대여 중인 자동차들의 정보를 담은 CAR_RENTAL_COMPANY_CAR 테이블과 자동차 대여 기록 정보를 담은 CAR_RENTAL_COMPANY_RENTAL_HISTORY 테이블과 자동차 종류 별 대여 기간 종류 별 할인 정책 정보를 담은 CAR_RENTAL_COMPANY_DISCOUNT_PLAN 테이블 입니다. CAR_RENTAL_COMPANY_CAR 테이블은 아래와 같은 구조로 되어있으며, CAR_ID, CAR_TYPE, DAILY_FEE, OPTIONS 는 각각 자동차 ID, 자동차 종류, 일일 대여 요금(원), 자동차 옵션 리스트를 나타냅니다. Column name Type Nullable CAR_ID INTEGER FALSE CAR_TYPE VARCHAR(255) FALSE DAILY_FEE INTEGER FALSE OPTIONS VARCHAR(255) FALSE 자동차 종류는 '세단', 'SUV', '승합차', '트럭', '리무진' 이 있습니다. 자동차 옵션 리스트는 콤마(',')로 구분된 키워드 리스트(예: ''열선시트,스마트키,주차감지센서'')로 되어있으며, 키워드 종류는 '주차감지센서', '스마트키', '네비게이션', '통풍시트', '열선시트', '후방카메라', '가죽시트' 가 있습니다. CAR_RENTAL_COMPANY_RENTAL_HISTORY 테이블은 아래와 같은 구조로 되어있으며, HISTORY_ID, CAR_ID, START_DATE, END_DATE 는 각각 자동차 대여 기록 ID, 자동차 ID, 대여 시작일, 대여 종료일을 나타냅니다. Column name Type Nullable HISTORY_ID INTEGER FALSE CAR_ID INTEGER FALSE START_DATE DATE FALSE END_DATE DATE FALSE CAR_RENTAL_COMPANY_DISCOUNT_PLAN 테이블은 아래와 같은 구조로 되어있으며, PLAN_ID, CAR_TYPE, DURATION_TYPE, DISCOUNT_RATE 는 각각 요금 할인 정책 ID, 자동차 종류, 대여 기간 종류, 할인율(%)을 나타냅니다. Column name Type Nullable PLAN_ID INTEGER FALSE CAR_TYPE VARCHAR(255) FALSE DURATION_TYPE VARCHAR(255) FALSE DISCOUNT_RATE INTEGER FALSE 할인율이 적용되는 대여 기간 종류로는 '7일 이상' (대여 기간이 7일 이상 30일 미만인 경우), '30일 이상' (대여 기간이 30일 이상 90일 미만인 경우), '90일 이상' (대여 기간이 90일 이상인 경우) 이 있습니다. 대여 기간이 7일 미만인 경우 할인정책이 없습니다. 문제 CAR_RENTAL_COMPANY_CAR 테이블과 CAR_RENTAL_COMPANY_RENTAL_HISTORY 테이블과 CAR_RENTAL_COMPANY_DISCOUNT_PLAN 테이블에서 자동차 종류가 '트럭'인 자동차의 대여 기록에 대해서 대여 기록 별로 대여 금액(컬럼명: FEE)을 구하여 대여 기록 ID와 대여 금액 리스트를 출력하는 SQL문을 작성해주세요. 결과는 대여 금액을 기준으로 내림차순 정렬하고, 대여 금액이 같은 경우 대여 기록 ID를 기준으로 내림차순 정렬해주세요. 예시 예를 들어 CAR_RENTAL_COMPANY_CAR 테이블과 CAR_RENTAL_COMPANY_RENTAL_HISTORY 테이블과 CAR_RENTAL_COMPANY_DISCOUNT_PLAN 테이블이 다음과 같다면 CAR_ID CAR_TYPE DAILY_FEE OPTIONS 1 트럭 26000 가죽시트,열선시트,후방카메라 2 SUV 14000 스마트키,네비게이션,열선시트 3 트럭 32000 주차감지센서,후방카메라,가죽시트 HISTORY_ID CAR_ID START_DATE END_DATE 1 1 2022-07-27 2022-08-02 2 1 2022-08-03 2022-08-04 3 2 2022-08-05 2022-08-05 4 2 2022-08-09 2022-08-12 5 3 2022-09-16 2022-10-15 PLAN_ID CAR_TYPE DURATION_TYPE DISCOUNT_RATE 1 트럭 7일 이상 5% 2 트럭 30일 이상 7% 3 트럭 90일 이상 10% 4 세단 7일 이상 5% 5 세단 30일 이상 10% 6 세단 90일 이상 15% 자동차 종류가 '트럭' 인 자동차의 대여 기록에 대해서 대여 기간을 구하면, 대여 기록 ID가 1인 경우, 7일 대여 기록 ID가 2인 경우, 2일 대여 기록 ID가 5인 경우, 30일입니다. 대여 기간 별로 일일 대여 요금에 알맞은 할인율을 곱하여 금액을 구하면 다음과 같습니다. 대여 기록 ID가 1인 경우, 일일 대여 금액 26,000원에서 5% 할인율을 적용하고 7일을 곱하면 총 대여 금액은 172,900원 대여 기록 ID가 2인 경우, 일일 대여 금액 26,000원에 2일을 곱하면 총 대여 금액은 52,000원 대여 기록 ID가 5인 경우, 일일 대여 금액 32,000원에서 7% 할인율을 적용하고 30일을 곱하면 총 대여 금액은 892,800원이 되므로, 대여 금액을 기준으로 내림차순 정렬 및 대여 기록 ID를 기준으로 내림차순 정렬하면 다음과 같아야 합니다. HISTORY_ID FEE 5 892800 1 172900 2 52000 주의사항 FEE의 경우 예시처럼 정수부분만 출력되어야 합니다.",hard,database
42,"다음은 어느 자동차 대여 회사의 자동차 대여 기록 정보를 담은 CAR_RENTAL_COMPANY_RENTAL_HISTORY 테이블입니다. CAR_RENTAL_COMPANY_RENTAL_HISTORY 테이블은 아래와 같은 구조로 되어있으며, HISTORY_ID, CAR_ID, START_DATE, END_DATE 는 각각 자동차 대여 기록 ID, 자동차 ID, 대여 시작일, 대여 종료일을 나타냅니다. Column name Type Nullable HISTORY_ID INTEGER FALSE CAR_ID INTEGER FALSE START_DATE DATE FALSE END_DATE DATE FALSE 문제 CAR_RENTAL_COMPANY_RENTAL_HISTORY 테이블에서 대여 시작일을 기준으로 2022년 8월부터 2022년 10월까지 총 대여 횟수가 5회 이상인 자동차들에 대해서 해당 기간 동안의 월별 자동차 ID 별 총 대여 횟수(컬럼명: RECORDS) 리스트를 출력하는 SQL문을 작성해주세요. 결과는 월을 기준으로 오름차순 정렬하고, 월이 같다면 자동차 ID를 기준으로 내림차순 정렬해주세요. 특정 월의 총 대여 횟수가 0인 경우에는 결과에서 제외해주세요. 예시 예를 들어 CAR_RENTAL_COMPANY_RENTAL_HISTORY 테이블이 다음과 같다면 HISTORY_ID CAR_ID START_DATE END_DATE 1 1 2022-07-27 2022-08-02 2 1 2022-08-03 2022-08-04 3 2 2022-08-05 2022-08-05 4 2 2022-08-09 2022-08-12 5 3 2022-09-16 2022-10-15 6 1 2022-08-24 2022-08-30 7 3 2022-10-16 2022-10-19 8 1 2022-09-03 2022-09-07 9 1 2022-09-18 2022-09-19 10 2 2022-09-08 2022-09-10 11 2 2022-10-16 2022-10-19 12 1 2022-09-29 2022-10-06 13 2 2022-10-30 2022-11-01 14 2 2022-11-05 2022-11-05 15 3 2022-11-11 2022-11-11 대여 시작일을 기준으로 총 대여 횟수가 5회 이상인 자동차는 자동차 ID가 1, 2인 자동차입니다. 월 별 자동차 ID별 총 대여 횟수를 구하고 월 오름차순, 자동차 ID 내림차순으로 정렬하면 다음과 같이 나와야 합니다. MONTH CAR_ID RECORDS 8 2 2 8 1 2 9 2 1 9 1 3 10 2 2",normal,database
43,"다음은 어느 자동차 대여 회사에서 대여중인 자동차들의 정보를 담은 CAR_RENTAL_COMPANY_CAR 테이블입니다. CAR_RENTAL_COMPANY_CAR 테이블은 아래와 같은 구조로 되어있으며, CAR_ID, CAR_TYPE, DAILY_FEE, OPTIONS 는 각각 자동차 ID, 자동차 종류, 일일 대여 요금(원), 자동차 옵션 리스트를 나타냅니다. Column name Type Nullable CAR_ID INTEGER FALSE CAR_TYPE VARCHAR(255) FALSE DAILY_FEE INTEGER FALSE OPTIONS VARCHAR(255) FALSE 자동차 종류는 '세단', 'SUV', '승합차', '트럭', '리무진' 이 있습니다. 자동차 옵션 리스트는 콤마(',')로 구분된 키워드 리스트(옵션 리스트 값 예시: '열선시트', '스마트키', '주차감지센서')로 되어있으며, 키워드 종류는 '주차감지센서', '스마트키', '네비게이션', '통풍시트', '열선시트', '후방카메라', '가죽시트' 가 있습니다. 문제 CAR_RENTAL_COMPANY_CAR 테이블에서 '통풍시트', '열선시트', '가죽시트' 중 하나 이상의 옵션이 포함된 자동차가 자동차 종류 별로 몇 대인지 출력하는 SQL문을 작성해주세요. 이때 자동차 수에 대한 컬럼명은 CARS로 지정하고, 결과는 자동차 종류를 기준으로 오름차순 정렬해주세요. 예시 예를 들어 CAR_RENTAL_COMPANY_CAR 테이블이 다음과 같다면 CAR_ID CAR_TYPE DAILY_FEE OPTIONS 1 세단 16000 가죽시트,열선시트,후방카메라 2 SUV 14000 스마트키,네비게이션,열선시트 3 SUV 22000 주차감지센서,후방카메라 4 트럭 35000 주차감지센서,네비게이션,열선시트 5 SUV 16000 가죽시트,네비게이션,열선시트,후방카메라,주차감지센서 '통풍시트', '열선시트', '가죽시트' 중 하나 이상의 옵션이 포함된 자동차는 자동차 ID가 1, 2, 4, 5인 자동차이고, 자동차 종류 별로 몇 대인지 구하고 자동차 종류를 기준으로 오름차순 정렬하면 다음과 같은 결과가 나와야 합니다. CAR_TYPE CARS SUV 2 세단 1 트럭 1",normal,database
44,"당신은 일렬로 나열된 n개의 집에 택배를 배달하려 합니다. 배달할 물건은 모두 크기가 같은 재활용 택배 상자에 담아 배달하며, 배달을 다니면서 빈 재활용 택배 상자들을 수거하려 합니다. 배달할 택배들은 모두 재활용 택배 상자에 담겨서 물류창고에 보관되어 있고, i번째 집은 물류창고에서 거리 i만큼 떨어져 있습니다. 또한 i번째 집은 j번째 집과 거리 j - i만큼 떨어져 있습니다. (1 ≤ i ≤ j ≤ n) 트럭에는 재활용 택배 상자를 최대 cap개 실을 수 있습니다. 트럭은 배달할 재활용 택배 상자들을 실어 물류창고에서 출발해 각 집에 배달하면서, 빈 재활용 택배 상자들을 수거해 물류창고에 내립니다. 각 집마다 배달할 재활용 택배 상자의 개수와 수거할 빈 재활용 택배 상자의 개수를 알고 있을 때, 트럭 하나로 모든 배달과 수거를 마치고 물류창고까지 돌아올 수 있는 최소 이동 거리를 구하려 합니다. 각 집에 배달 및 수거할 때, 원하는 개수만큼 택배를 배달 및 수거할 수 있습니다. 다음은 cap=4 일 때, 최소 거리로 이동하면서 5개의 집에 배달 및 수거하는 과정을 나타낸 예시입니다. 배달 및 수거할 재활용 택배 상자 개수 집 #1 집 #2 집 #3 집 #4 집 #5 배달 1개 0개 3개 1개 2개 수거 0개 3개 0개 4개 0개 배달 및 수거 과정 집 #1 집 #2 집 #3 집 #4 집 #5 설명 남은 배달/수거 1/0 0/3 3/0 1/4 2/0 물류창고에서 택배 3개를 트럭에 실어 출발합니다. 남은 배달/수거 1/0 0/3 3/0 0/4 0/0 물류창고에서 5번째 집까지 이동하면서(거리 5) 4번째 집에 택배 1개를 배달하고, 5번째 집에 택배 2개를 배달합니다. 남은 배달/수거 1/0 0/3 3/0 0/0 0/0 5번째 집에서 물류창고까지 이동하면서(거리 5) 4번째 집에서 빈 택배 상자 4개를 수거한 후, 수거한 빈 택배 상자를 물류창고에 내리고 택배 4개를 트럭에 싣습니다. 남은 배달/수거 0/0 0/3 0/0 0/0 0/0 물류창고에서 3번째 집까지 이동하면서(거리 3) 1번째 집에 택배 1개를 배달하고, 3번째 집에 택배 3개를 배달합니다. 남은 배달/수거 0/0 0/0 0/0 0/0 0/0 3번째 집에서 물류창고까지 이동하면서(거리 3) 2번째 집에서 빈 택배 상자 3개를 수거한 후, 수거한 빈 택배 상자를 물류창고에 내립니다. 16(=5+5+3+3)의 거리를 이동하면서 모든 배달 및 수거를 마쳤습니다. 같은 거리로 모든 배달 및 수거를 마치는 다른 방법이 있지만, 이보다 짧은 거리로 모든 배달 및 수거를 마치는 방법은 없습니다. 트럭에 실을 수 있는 재활용 택배 상자의 최대 개수를 나타내는 정수 cap, 배달할 집의 개수를 나타내는 정수 n, 각 집에 배달할 재활용 택배 상자의 개수를 담은 1차원 정수 배열 deliveries와 각 집에서 수거할 빈 재활용 택배 상자의 개수를 담은 1차원 정수 배열 pickups가 매개변수로 주어집니다. 이때, 트럭 하나로 모든 배달과 수거를 마치고 물류창고까지 돌아올 수 있는 최소 이동 거리를 return 하도록 solution 함수를 완성해 주세요. 제한사항 1 ≤ cap ≤ 50 1 ≤ n ≤ 100,000 deliveries의 길이 = pickups의 길이 = n deliveries[i]는 i+1번째 집에 배달할 재활용 택배 상자의 개수를 나타냅니다. pickups[i]는 i+1번째 집에서 수거할 빈 재활용 택배 상자의 개수를 나타냅니다. 0 ≤ deliveries의 원소 ≤ 50 0 ≤ pickups의 원소 ≤ 50 트럭의 초기 위치는 물류창고입니다. 입출력 예 cap n deliveries pickups result 4 5 [1, 0, 3, 1, 2] [0, 3, 0, 4, 0] 16 2 7 [1, 0, 2, 0, 1, 0, 2] [0, 2, 0, 1, 0, 2, 0] 30 입출력 예 설명",normal,Array
45,"카카오톡에서는 이모티콘을 무제한으로 사용할 수 있는 이모티콘 플러스 서비스 가입자 수를 늘리려고 합니다. 이를 위해 카카오톡에서는 이모티콘 할인 행사를 하는데, 목표는 다음과 같습니다. 이모티콘 플러스 서비스 가입자를 최대한 늘리는 것. 이모티콘 판매액을 최대한 늘리는 것. 1번 목표가 우선이며, 2번 목표가 그 다음입니다. 이모티콘 할인 행사는 다음과 같은 방식으로 진행됩니다. n명의 카카오톡 사용자들에게 이모티콘 m개를 할인하여 판매합니다. 이모티콘마다 할인율은 다를 수 있으며, 할인율은 10%, 20%, 30%, 40% 중 하나로 설정됩니다. 카카오톡 사용자들은 다음과 같은 기준을 따라 이모티콘을 사거나, 이모티콘 플러스 서비스에 가입합니다. 각 사용자들은 자신의 기준에 따라 일정 비율 이상 할인하는 이모티콘을 모두 구매합니다. 각 사용자들은 자신의 기준에 따라 이모티콘 구매 비용의 합이 일정 가격 이상이 된다면, 이모티콘 구매를 모두 취소하고 이모티콘 플러스 서비스에 가입합니다. 다음은 2명의 카카오톡 사용자와 2개의 이모티콘이 있을때의 예시입니다. 사용자 비율 가격 1 40 10,000 2 25 10,000 이모티콘 가격 1 7,000 2 9,000 1번 사용자는 40%이상 할인하는 이모티콘을 모두 구매하고, 이모티콘 구매 비용이 10,000원 이상이 되면 이모티콘 구매를 모두 취소하고 이모티콘 플러스 서비스에 가입합니다. 2번 사용자는 25%이상 할인하는 이모티콘을 모두 구매하고, 이모티콘 구매 비용이 10,000원 이상이 되면 이모티콘 구매를 모두 취소하고 이모티콘 플러스 서비스에 가입합니다. 1번 이모티콘의 가격은 7,000원, 2번 이모티콘의 가격은 9,000원입니다. 만약, 2개의 이모티콘을 모두 40%씩 할인한다면, 1번 사용자와 2번 사용자 모두 1,2번 이모티콘을 구매하게 되고, 결과는 다음과 같습니다. 사용자 구매한 이모티콘 이모티콘 구매 비용 이모티콘 플러스 서비스 가입 여부 1 1, 2 9,600 X 2 1, 2 9,600 X 이모티콘 플러스 서비스 가입자는 0명이 늘어나고 이모티콘 판매액은 19,200원이 늘어납니다. 하지만, 1번 이모티콘을 30% 할인하고 2번 이모티콘을 40% 할인한다면 결과는 다음과 같습니다. 사용자 구매한 이모티콘 이모티콘 구매 비용 이모티콘 플러스 서비스 가입 여부 1 2 5,400 X 2 1, 2 10,300 O 2번 사용자는 이모티콘 구매 비용을 10,000원 이상 사용하여 이모티콘 구매를 모두 취소하고 이모티콘 플러스 서비스에 가입하게 됩니다. 따라서, 이모티콘 플러스 서비스 가입자는 1명이 늘어나고 이모티콘 판매액은 5,400원이 늘어나게 됩니다. 카카오톡 사용자 n명의 구매 기준을 담은 2차원 정수 배열 users, 이모티콘 m개의 정가를 담은 1차원 정수 배열 emoticons가 주어집니다. 이때, 행사 목적을 최대한으로 달성했을 때의 이모티콘 플러스 서비스 가입 수와 이모티콘 매출액을 1차원 정수 배열에 담아 return 하도록 solution 함수를 완성해주세요. 제한사항 1 ≤ users의 길이 = n ≤ 100 users의 원소는 [비율, 가격]의 형태입니다. users[i]는 i+1번 고객의 구매 기준을 의미합니다. 비율% 이상의 할인이 있는 이모티콘을 모두 구매한다는 의미입니다. 1 ≤ 비율 ≤ 40 가격이상의 돈을 이모티콘 구매에 사용한다면, 이모티콘 구매를 모두 취소하고 이모티콘 플러스 서비스에 가입한다는 의미입니다. 100 ≤ 가격 ≤ 1,000,000 가격은 100의 배수입니다. 1 ≤ emoticons의 길이 = m ≤ 7 emoticons[i]는 i+1번 이모티콘의 정가를 의미합니다. 100 ≤ emoticons의 원소 ≤ 1,000,000 emoticons의 원소는 100의 배수입니다. 입출력 예 users emoticons result [[40, 10000], [25, 10000]] [7000, 9000] [1, 5400] [[40, 2900], [23, 10000], [11, 5200], [5, 5900], [40, 3100], [27, 9200], [32, 6900]] [1300, 1500, 1600, 4900] [4, 13860] 입출력 예 설명",normal,Array
46,"당신은 이진트리를 수로 표현하는 것을 좋아합니다. 이진트리를 수로 표현하는 방법은 다음과 같습니다. 이진수를 저장할 빈 문자열을 생성합니다. 주어진 이진트리에 더미 노드를 추가하여 포화 이진트리로 만듭니다. 루트 노드는 그대로 유지합니다. 만들어진 포화 이진트리의 노드들을 가장 왼쪽 노드부터 가장 오른쪽 노드까지, 왼쪽에 있는 순서대로 살펴봅니다. 노드의 높이는 살펴보는 순서에 영향을 끼치지 않습니다. 살펴본 노드가 더미 노드라면, 문자열 뒤에 0을 추가합니다. 살펴본 노드가 더미 노드가 아니라면, 문자열 뒤에 1을 추가합니다. 문자열에 저장된 이진수를 십진수로 변환합니다. 이진트리에서 리프 노드가 아닌 노드는 자신의 왼쪽 자식이 루트인 서브트리의 노드들보다 오른쪽에 있으며, 자신의 오른쪽 자식이 루트인 서브트리의 노드들보다 왼쪽에 있다고 가정합니다. 다음은 이진트리를 수로 표현하는 예시입니다. 주어진 이진트리는 다음과 같습니다. 주어진 이진트리에 더미노드를 추가하여 포화 이진트리로 만들면 다음과 같습니다. 더미 노드는 점선으로 표시하였고, 노드 안의 수는 살펴보는 순서를 의미합니다. 노드들을 왼쪽에 있는 순서대로 살펴보며 0과 1을 생성한 문자열에 추가하면 ""0111010""이 됩니다. 이 이진수를 십진수로 변환하면 58입니다. 당신은 수가 주어졌을때, 하나의 이진트리로 해당 수를 표현할 수 있는지 알고 싶습니다. 이진트리로 만들고 싶은 수를 담은 1차원 정수 배열 numbers가 주어집니다. numbers에 주어진 순서대로 하나의 이진트리로 해당 수를 표현할 수 있다면 1을, 표현할 수 없다면 0을 1차원 정수 배열에 담아 return 하도록 solution 함수를 완성해주세요. 제한사항 1 ≤ numbers의 길이 ≤ 10,000 1 ≤ numbers의 원소 ≤ 1015 입출력 예 numbers result [7, 42, 5] [1, 1, 0] [63, 111, 95] [1, 1, 0] 입출력 예 설명",normal,Array
47,"당신은 표 편집 프로그램을 작성하고 있습니다. 표의 크기는 50 × 50으로 고정되어있고 초기에 모든 셀은 비어 있습니다. 각 셀은 문자열 값을 가질 수 있고, 다른 셀과 병합될 수 있습니다. 위에서 r번째, 왼쪽에서 c번째 위치를 (r, c)라고 표현할 때, 당신은 다음 명령어들에 대한 기능을 구현하려고 합니다. ""UPDATE r c value"" (r, c) 위치의 셀을 선택합니다. 선택한 셀의 값을 value로 바꿉니다. ""UPDATE value1 value2"" value1을 값으로 가지고 있는 모든 셀을 선택합니다. 선택한 셀의 값을 value2로 바꿉니다. ""MERGE r1 c1 r2 c2"" (r1, c1) 위치의 셀과 (r2, c2) 위치의 셀을 선택하여 병합합니다. 선택한 두 위치의 셀이 같은 셀일 경우 무시합니다. 선택한 두 셀은 서로 인접하지 않을 수도 있습니다. 이 경우 (r1, c1) 위치의 셀과 (r2, c2) 위치의 셀만 영향을 받으며, 그 사이에 위치한 셀들은 영향을 받지 않습니다. 두 셀 중 한 셀이 값을 가지고 있을 경우 병합된 셀은 그 값을 가지게 됩니다. 두 셀 모두 값을 가지고 있을 경우 병합된 셀은 (r1, c1) 위치의 셀 값을 가지게 됩니다. 이후 (r1, c1) 와 (r2, c2) 중 어느 위치를 선택하여도 병합된 셀로 접근합니다. ""UNMERGE r c"" (r, c) 위치의 셀을 선택하여 해당 셀의 모든 병합을 해제합니다. 선택한 셀이 포함하고 있던 모든 셀은 프로그램 실행 초기의 상태로 돌아갑니다. 병합을 해제하기 전 셀이 값을 가지고 있었을 경우 (r, c) 위치의 셀이 그 값을 가지게 됩니다. ""PRINT r c"" (r, c) 위치의 셀을 선택하여 셀의 값을 출력합니다. 선택한 셀이 비어있을 경우 ""EMPTY""를 출력합니다. 아래는 UPDATE 명령어를 실행하여 빈 셀에 값을 입력하는 예시입니다. commands 효과 UPDATE 1 1 menu (1,1)에 ""menu"" 입력 UPDATE 1 2 category (1,2)에 ""category"" 입력 UPDATE 2 1 bibimbap (2,1)에 ""bibimbap"" 입력 UPDATE 2 2 korean (2,2)에 ""korean"" 입력 UPDATE 2 3 rice (2,3)에 ""rice"" 입력 UPDATE 3 1 ramyeon (3,1)에 ""ramyeon"" 입력 UPDATE 3 2 korean (3,2)에 ""korean"" 입력 UPDATE 3 3 noodle (3,3)에 ""noodle"" 입력 UPDATE 3 4 instant (3,4)에 ""instant"" 입력 UPDATE 4 1 pasta (4,1)에 ""pasta"" 입력 UPDATE 4 2 italian (4,2)에 ""italian"" 입력 UPDATE 4 3 noodle (4,3)에 ""noodle"" 입력 위 명령어를 실행하면 아래 그림과 같은 상태가 됩니다. 아래는 MERGE 명령어를 실행하여 셀을 병합하는 예시입니다. commands 효과 MERGE 1 2 1 3 (1,2)와 (1,3) 병합 MERGE 1 3 1 4 (1,3)과 (1,4) 병합 위 명령어를 실행하면 아래와 같은 상태가 됩니다. 병합한 셀은 ""category"" 값을 가지게 되며 (1,2), (1,3), (1,4) 중 어느 위치를 선택하더라도 접근할 수 있습니다. 아래는 UPDATE 명령어를 실행하여 셀의 값을 변경하는 예시입니다. commands 효과 UPDATE korean hansik ""korean""을 ""hansik""으로 변경 UPDATE 1 3 group (1,3) 위치의 셀 값을 ""group""으로 변경 위 명령어를 실행하면 아래와 같은 상태가 됩니다. 아래는 UNMERGE 명령어를 실행하여 셀의 병합을 해제하는 예시입니다. commands 효과 UNMERGE 1 4 셀 병합 해제 후 원래 값은 (1,4)가 가짐 위 명령어를 실행하면 아래와 같은 상태가 됩니다. 실행할 명령어들이 담긴 1차원 문자열 배열 commands가 매개변수로 주어집니다. commands의 명령어들을 순서대로 실행하였을 때, ""PRINT r c"" 명령어에 대한 실행결과를 순서대로 1차원 문자열 배열에 담아 return 하도록 solution 함수를 완성해주세요. 제한사항 1 ≤ commands의 길이 ≤ 1,000 commands의 각 원소는 아래 5가지 형태 중 하나입니다. ""UPDATE r c value"" r, c는 선택할 셀의 위치를 나타내며, 1~50 사이의 정수입니다. value는 셀에 입력할 내용을 나타내며, 알파벳 소문자와 숫자로 구성된 길이 1~10 사이인 문자열입니다. ""UPDATE value1 value2"" value1은 선택할 셀의 값, value2는 셀에 입력할 내용을 나타내며, 알파벳 소문자와 숫자로 구성된 길이 1~10 사이인 문자열입니다. ""MERGE r1 c1 r2 c2"" r1, c1, r2, c2는 선택할 셀의 위치를 나타내며, 1~50 사이의 정수입니다. ""UNMERGE r c"" r, c는 선택할 셀의 위치를 나타내며, 1~50 사이의 정수입니다. ""PRINT r c"" r, c는 선택할 셀의 위치를 나타내며, 1~50 사이의 정수입니다. commands는 1개 이상의 ""PRINT r c"" 명령어를 포함하고 있습니다. 입출력 예 commands result [""UPDATE 1 1 menu"", ""UPDATE 1 2 category"", ""UPDATE 2 1 bibimbap"", ""UPDATE 2 2 korean"", ""UPDATE 2 3 rice"", ""UPDATE 3 1 ramyeon"", ""UPDATE 3 2 korean"", ""UPDATE 3 3 noodle"", ""UPDATE 3 4 instant"", ""UPDATE 4 1 pasta"", ""UPDATE 4 2 italian"", ""UPDATE 4 3 noodle"", ""MERGE 1 2 1 3"", ""MERGE 1 3 1 4"", ""UPDATE korean hansik"", ""UPDATE 1 3 group"", ""UNMERGE 1 4"", ""PRINT 1 3"", ""PRINT 1 4""] [""EMPTY"", ""group""] [""UPDATE 1 1 a"", ""UPDATE 1 2 b"", ""UPDATE 2 1 c"", ""UPDATE 2 2 d"", ""MERGE 1 1 1 2"", ""MERGE 2 2 2 1"", ""MERGE 2 1 1 1"", ""PRINT 1 1"", ""UNMERGE 2 2"", ""PRINT 1 1""] [""d"", ""EMPTY""] 입출력 예 설명",normal,Array
48,"n x m 격자 미로가 주어집니다. 당신은 미로의 (x, y)에서 출발해 (r, c)로 이동해서 탈출해야 합니다. 단, 미로를 탈출하는 조건이 세 가지 있습니다. 격자의 바깥으로는 나갈 수 없습니다. (x, y)에서 (r, c)까지 이동하는 거리가 총 k여야 합니다. 이때, (x, y)와 (r, c)격자를 포함해, 같은 격자를 두 번 이상 방문해도 됩니다. 미로에서 탈출한 경로를 문자열로 나타냈을 때, 문자열이 사전 순으로 가장 빠른 경로로 탈출해야 합니다. 이동 경로는 다음과 같이 문자열로 바꿀 수 있습니다. l: 왼쪽으로 한 칸 이동 r: 오른쪽으로 한 칸 이동 u: 위쪽으로 한 칸 이동 d: 아래쪽으로 한 칸 이동 예를 들어, 왼쪽으로 한 칸, 위로 한 칸, 왼쪽으로 한 칸 움직였다면, 문자열 ""lul""로 나타낼 수 있습니다. 미로에서는 인접한 상, 하, 좌, 우 격자로 한 칸씩 이동할 수 있습니다. 예를 들어 다음과 같이 3 x 4 격자가 있다고 가정해 보겠습니다. .... ..S. E... 미로의 좌측 상단은 (1, 1)이고 우측 하단은 (3, 4)입니다. .은 빈 공간, S는 출발 지점, E는 탈출 지점입니다. 탈출까지 이동해야 하는 거리 k가 5라면 다음과 같은 경로로 탈출할 수 있습니다. lldud ulldd rdlll dllrl dllud ... 이때 dllrl보다 사전 순으로 빠른 경로로 탈출할 수는 없습니다. 격자의 크기를 뜻하는 정수 n, m, 출발 위치를 뜻하는 정수 x, y, 탈출 지점을 뜻하는 정수 r, c, 탈출까지 이동해야 하는 거리를 뜻하는 정수 k가 매개변수로 주어집니다. 이때, 미로를 탈출하기 위한 경로를 return 하도록 solution 함수를 완성해주세요. 단, 위 조건대로 미로를 탈출할 수 없는 경우 ""impossible""을 return 해야 합니다. 제한사항 2 ≤ n (= 미로의 세로 길이) ≤ 50 2 ≤ m (= 미로의 가로 길이) ≤ 50 1 ≤ x ≤ n 1 ≤ y ≤ m 1 ≤ r ≤ n 1 ≤ c ≤ m (x, y) ≠ (r, c) 1 ≤ k ≤ 2,500 입출력 예 n m x y r c k result 3 4 2 3 3 1 5 ""dllrl"" 2 2 1 1 2 2 2 ""dr"" 3 3 1 2 3 3 4 ""impossible"" 입출력 예 설명",normal,String
49,"춘식이는 트리의 1번 노드에 숫자 1, 2, 3 중 하나씩을 계속해서 떨어트려 트리의 리프 노드1에 숫자를 쌓는 게임을 하려고 합니다. 아래 그림은 게임의 예시를 나타냅니다. 트리의 모든 간선은 부모 노드가 자식 노드를 가리키는 단방향 간선입니다. 모든 부모 노드는 자식 노드와 연결된 간선 중 하나를 길로 설정합니다. 실선 화살표는 길인 간선입니다. 점선 화살표는 길이 아닌 간선입니다. 모든 부모 노드는 자신의 자식 노드 중 가장 번호가 작은 노드를 가리키는 간선을 초기 길로 설정합니다. [게임의 규칙]은 아래와 같습니다. 1번 노드(루트 노드)에 숫자 1, 2, 3 중 하나를 떨어트립니다. 숫자는 길인 간선을 따라 리프 노드까지 떨어집니다. 숫자가 리프 노드에 도착하면, 숫자가 지나간 각 노드는 현재 길로 연결된 자식 노드 다음으로 번호가 큰 자식 노드를 가리키는 간선을 새로운 길로 설정하고 기존의 길은 끊습니다. 만약 현재 길로 연결된 노드의 번호가 가장 크면, 번호가 가장 작은 노드를 가리키는 간선을 길로 설정합니다. 노드의 간선이 하나라면 계속 하나의 간선을 길로 설정합니다. 원하는 만큼 계속해서 루트 노드에 숫자를 떨어트릴 수 있습니다. 단, 앞서 떨어트린 숫자가 리프 노드까지 떨어진 후에 새로운 숫자를 떨어트려야 합니다. [게임의 목표]는 각각의 리프 노드에 쌓인 숫자의 합을 target에서 가리키는 값과 같게 만드는 것입니다. 예를 들어, target이 [0, 0, 0, 3, 0, 0, 5, 1, 2, 3]일 경우 아래 표와 같은 의미를 가집니다. 노드 번호 노드에 쌓인 숫자의 합 1 0 2 0 3 0 4 3 5 0 6 0 7 5 8 1 9 2 10 3 target대로 리프 노드에 쌓인 숫자의 합을 맞추기 위해서는 [2, 1, 2, 2, 1, 3, 3]순으로 숫자를 떨어트리면 됩니다. 아래 두 그림은 순서대로 1, 2번째 숫자 [2, 1]을 떨어트린 뒤의 길 상황을 나타냅니다. 숫자 2는 떨어지면서 1번 노드와 2번 노드를 지나갔습니다. 1번 노드는 3번 노드를 가리키는 간선을 길로 설정합니다. 2번 노드는 5번 노드를 가리키는 간선을 길로 설정합니다. 숫자 1은 떨어지면서 1번 노드, 3번 노드, 6번 노드를 지나갔습니다. 1번 노드는 3번 노드보다 번호가 큰 노드를 가리키는 간선이 없으므로 다시 2번 노드를 가리키는 간선을 길로 설정합니다. 3번 노드는 간선이 하나이므로 계속해서 6번 노드를 가리키는 간선을 길로 설정합니다. 6번 노드는 9번 노드를 가리키는 간선을 길로 설정합니다. 아래 두 그림은 순서대로 3, 4번째 숫자 [2, 2]를 떨어트린 뒤의 길 상황을 나타냅니다. 아래 세 그림은 순서대로 5, 6, 7번째 숫자 [1, 3, 3]을 떨어트린 뒤의 길 상황을 나타냅니다. 각 리프 노드에 쌓인 숫자를 모두 더해 배열로 나타내면 target과 같습니다. 트리의 각 노드들의 연결 관계를 담은 2차원 정수 배열 edges, 각 노드별로 만들어야 하는 숫자의 합을 담은 1차원 정수 배열 target이 매개변수로 주어집니다. 이때, target 대로 리프 노드에 쌓인 숫자의 합을 맞추기 위해 숫자를 떨어트리는 모든 경우 중 가장 적은 숫자를 사용하며 그중 사전 순으로 가장 빠른 경우를 1차원 정수 배열에 담아 return 하도록 solution 함수를 완성해주세요. 만약, target대로 숫자의 합을 만들 수 없는 경우 [-1]을 return 해주세요. 제한사항 1 ≤ edges의 길이 ≤ 100 edges[i]는 [부모 노드 번호, 자식 노드 번호] 형태로, 단방향으로 연결된 두 노드를 나타냅니다. 1 ≤ 노드 번호 ≤ edges의 길이 + 1 동일한 간선에 대한 정보가 중복해서 주어지지 않습니다. 항상 하나의 트리 형태로 입력이 주어지며, 잘못된 데이터가 주어지는 경우는 없습니다. 1번 노드는 항상 루트 노드입니다. target의 길이 = edges의 길이 + 1 target[i]는 i + 1번 노드에 쌓인 숫자의 합으로 만들어야 하는 수를 나타냅니다. 0 ≤ 리프 노드의 target값 ≤ 100 리프 노드를 제외한 노드의 target값 = 0 target의 원소의 합은 1 이상입니다.",hard,Array
50,"마법의 세계에 사는 민수는 아주 높은 탑에 살고 있습니다. 탑이 너무 높아서 걸어 다니기 힘든 민수는 마법의 엘리베이터를 만들었습니다. 마법의 엘리베이터의 버튼은 특별합니다. 마법의 엘리베이터에는 -1, +1, -10, +10, -100, +100 등과 같이 절댓값이 10c (c ≥ 0 인 정수) 형태인 정수들이 적힌 버튼이 있습니다. 마법의 엘리베이터의 버튼을 누르면 현재 층 수에 버튼에 적혀 있는 값을 더한 층으로 이동하게 됩니다. 단, 엘리베이터가 위치해 있는 층과 버튼의 값을 더한 결과가 0보다 작으면 엘리베이터는 움직이지 않습니다. 민수의 세계에서는 0층이 가장 아래층이며 엘리베이터는 현재 민수가 있는 층에 있습니다. 마법의 엘리베이터를 움직이기 위해서 버튼 한 번당 마법의 돌 한 개를 사용하게 됩니다.예를 들어, 16층에 있는 민수가 0층으로 가려면 -1이 적힌 버튼을 6번, -10이 적힌 버튼을 1번 눌러 마법의 돌 7개를 소모하여 0층으로 갈 수 있습니다. 하지만, +1이 적힌 버튼을 4번, -10이 적힌 버튼 2번을 누르면 마법의 돌 6개를 소모하여 0층으로 갈 수 있습니다. 마법의 돌을 아끼기 위해 민수는 항상 최소한의 버튼을 눌러서 이동하려고 합니다. 민수가 어떤 층에서 엘리베이터를 타고 0층으로 내려가는데 필요한 마법의 돌의 최소 개수를 알고 싶습니다. 민수와 마법의 엘리베이터가 있는 층을 나타내는 정수 storey 가 주어졌을 때, 0층으로 가기 위해 필요한 마법의 돌의 최소값을 return 하도록 solution 함수를 완성하세요. 제한사항 1 ≤ storey ≤ 100,000,000 입출력 예 storey result 16 6 2554 16 입출력 예 설명",normal,Math
51,"수학에서 칸토어 집합은 0과 1 사이의 실수로 이루어진 집합으로, [0, 1]부터 시작하여 각 구간을 3등분하여 가운데 구간을 반복적으로 제외하는 방식으로 만들어집니다. 남아는 칸토어 집합을 조금 변형하여 유사 칸토어 비트열을 만들었습니다. 유사 칸토어 비트열은 다음과 같이 정의됩니다. 0 번째 유사 칸토어 비트열은 ""1"" 입니다. n(1 ≤ n) 번째 유사 칸토어 비트열은 n - 1 번째 유사 칸토어 비트열에서의 1을 11011로 치환하고 0을 00000로 치환하여 만듭니다. 남아는 n 번째 유사 칸토어 비트열에서 특정 구간 내의 1의 개수가 몇 개인지 궁금해졌습니다. n과 1의 개수가 몇 개인지 알고 싶은 구간을 나타내는 l, r이 주어졌을 때 그 구간 내의 1의 개수를 return 하도록 solution 함수를 완성해주세요. 제한사항 1 ≤ n ≤ 20 1 ≤ l, r ≤ 5n l ≤ r < l + 10,000,000 l과 r은 비트열에서의 인덱스(1-base)이며 폐구간 [l, r]을 나타냅니다. 입출력 예 n l r result 2 4 17 8",normal,Array
52,"완호가 관리하는 어떤 데이터베이스의 한 테이블은 모두 정수 타입인 컬럼들로 이루어져 있습니다. 테이블은 2차원 행렬로 표현할 수 있으며 열은 컬럼을 나타내고, 행은 튜플을 나타냅니다. 첫 번째 컬럼은 기본키로서 모든 튜플에 대해 그 값이 중복되지 않도록 보장됩니다. 완호는 이 테이블에 대한 해시 함수를 다음과 같이 정의하였습니다. 해시 함수는 col, row_begin, row_end을 입력으로 받습니다. 테이블의 튜플을 col번째 컬럼의 값을 기준으로 오름차순 정렬을 하되, 만약 그 값이 동일하면 기본키인 첫 번째 컬럼의 값을 기준으로 내림차순 정렬합니다. 정렬된 데이터에서 S_i를 i 번째 행의 튜플에 대해 각 컬럼의 값을 i 로 나눈 나머지들의 합으로 정의합니다. row_begin ≤ i ≤ row_end 인 모든 S_i를 누적하여 bitwise XOR 한 값을 해시 값으로서 반환합니다. 테이블의 데이터 data와 해시 함수에 대한 입력 col, row_begin, row_end이 주어졌을 때 테이블의 해시 값을 return 하도록 solution 함수를 완성해주세요. 제한 사항 1 ≤ data의 길이 ≤ 2,500 1 ≤ data의 원소의 길이 ≤ 500 1 ≤ data[i][j] ≤ 1,000,000 data[i][j]는 i + 1 번째 튜플의 j + 1 번째 컬럼의 값을 의미합니다. 1 ≤ col ≤ data의 원소의 길이 1 ≤ row_begin ≤ row_end ≤ data의 길이 입출력 예 data col row_begin row_end result [[2,2,6],[1,5,10],[4,2,9],[3,8,3]] 2 2 3 4 입출력 예 설명 정해진 방법에 따라 튜플을 정렬하면 {4, 2, 9}, {2, 2, 6}, {1, 5, 10}, {3, 8, 3} 이 됩니다. S_2 = (2 mod 2) + (2 mod 2) + (6 mod 2) = 0 입니다. S_3 = (1 mod 3) + (5 mod 3) + (10 mod 3) = 4 입니다. 따라서 해시 값은 S_2 XOR S_ 3 = 4 입니다.",normal,Hash Table
53,"다음은 어느 한 서점에서 판매중인 도서들의 도서 정보(BOOK), 저자 정보(AUTHOR) 테이블입니다. BOOK 테이블은 각 도서의 정보를 담은 테이블로 아래와 같은 구조로 되어있습니다. Column name Type Nullable Description BOOK_ID INTEGER FALSE 도서 ID CATEGORY VARCHAR(N) FALSE 카테고리 (경제, 인문, 소설, 생활, 기술) AUTHOR_ID INTEGER FALSE 저자 ID PRICE INTEGER FALSE 판매가 (원) PUBLISHED_DATE DATE FALSE 출판일 AUTHOR 테이블은 도서의 저자의 정보를 담은 테이블로 아래와 같은 구조로 되어있습니다. Column name Type Nullable Description AUTHOR_ID INTEGER FALSE 저자 ID AUTHOR_NAME VARCHAR(N) FALSE 저자명 BOOK_SALES 테이블은 각 도서의 날짜 별 판매량 정보를 담은 테이블로 아래와 같은 구조로 되어있습니다. Column name Type Nullable Description BOOK_ID INTEGER FALSE 도서 ID SALES_DATE DATE FALSE 판매일 SALES INTEGER FALSE 판매량 문제 2022년 1월의 도서 판매 데이터를 기준으로 저자 별, 카테고리 별 매출액(TOTAL_SALES = 판매량 * 판매가) 을 구하여, 저자 ID(AUTHOR_ID), 저자명(AUTHOR_NAME), 카테고리(CATEGORY), 매출액(SALES) 리스트를 출력하는 SQL문을 작성해주세요. 결과는 저자 ID를 오름차순으로, 저자 ID가 같다면 카테고리를 내림차순 정렬해주세요. 예시 예를 들어 BOOK 테이블과 AUTHOR 테이블, BOOK_SALES 테이블이 다음과 같다면 BOOK_ID CATEGORY AUTHOR_ID PRICE PUBLISHED_DATE 1 인문 1 10000 2020-01-01 2 경제 1 9000 2021-02-05 3 경제 2 9000 2021-03-11 AUTHOR_ID AUTHOR_NAME 1 홍길동 2 김영호 BOOK_ID SALES_DATE SALES 1 2022-01-01 2 2 2022-01-02 3 1 2022-01-05 1 2 2022-01-20 5 2 2022-01-21 6 3 2022-01-22 2 2 2022-02-11 3 2022년 1월의 도서 별 총 매출액은 도서 ID 가 1 인 도서가 총 3권 * 10,000원 = 30,000원, 도서 ID 가 2 인 도서가 총 14권 * 9,000 = 126,000원 이고, 도서 ID 가 3 인 도서가 총 2권 * 9,000 = 18,000원 입니다. 저자 별 카테고리 별로 매출액을 집계하면 결과는 다음과 같습니다. AUTHOR_ID AUTHOR_NAME CATEGORY TOTAL_SALES 1 홍길동 인문 30000 1 홍길동 경제 126000 2 김영호 경제 18000 그리고 저자 ID, 카테고리 순으로 내림차순 정렬하면 다음과 같이 나와야 합니다. AUTHOR_ID AUTHOR_NAME CATEGORY TOTAL_SALES 1 홍길동 인문 30000 1 홍길동 경제 126000 2 김영호 경제 18000",hard,database
54,"다음은 어느 한 서점에서 판매중인 도서들의 도서 정보(BOOK), 판매 정보(BOOK_SALES) 테이블입니다. BOOK 테이블은 각 도서의 정보를 담은 테이블로 아래와 같은 구조로 되어있습니다. Column name Type Nullable Description BOOK_ID INTEGER FALSE 도서 ID CATEGORY VARCHAR(N) FALSE 카테고리 (경제, 인문, 소설, 생활, 기술) AUTHOR_ID INTEGER FALSE 저자 ID PRICE INTEGER FALSE 판매가 (원) PUBLISHED_DATE DATE FALSE 출판일 BOOK_SALES 테이블은 각 도서의 날짜 별 판매량 정보를 담은 테이블로 아래와 같은 구조로 되어있습니다. Column name Type Nullable Description BOOK_ID INTEGER FALSE 도서 ID SALES_DATE DATE FALSE 판매일 SALES INTEGER FALSE 판매량 문제 2022년 1월의 카테고리 별 도서 판매량을 합산하고, 카테고리(CATEGORY), 총 판매량(TOTAL_SALES) 리스트를 출력하는 SQL문을 작성해주세요. 결과는 카테고리명을 기준으로 오름차순 정렬해주세요. 예시 예를 들어 BOOK 테이블과 BOOK_SALES 테이블이 다음과 같다면 BOOK_ID CATEGORY AUTHOR_ID PRICE PUBLISHED_DATE 1 인문 1 10000 2020-01-01 2 경제 1 9000 2021-02-05 3 경제 2 9000 2021-03-11 BOOK_ID SALES_DATE SALES 1 2022-01-01 2 2 2022-01-02 3 1 2022-01-05 1 2 2022-01-20 5 2 2022-01-21 6 3 2022-01-22 2 2 2022-02-11 3 2022년 1월의 도서 별 총 판매량은 도서 ID 가 1 인 도서가 총 3권, 도서 ID 가 2 인 도서가 총 14권 이고, 도서 ID 가 3 인 도서가 총 2권 입니다. 카테고리 별로 판매량을 집계한 결과는 다음과 같습니다. CATEGORY TOTAL_SALES 인문 3 경제 16 카테고리명을 오름차순으로 정렬하면 다음과 같이 나와야 합니다. CATEGORY TOTAL_SALES 경제 16 인문 3",normal,database
55,"다음은 어느 한 서점에서 판매중인 도서들의 도서 정보(BOOK), 저자 정보(AUTHOR) 테이블입니다. BOOK 테이블은 각 도서의 정보를 담은 테이블로 아래와 같은 구조로 되어있습니다. Column name Type Nullable Description BOOK_ID INTEGER FALSE 도서 ID CATEGORY VARCHAR(N) FALSE 카테고리 (경제, 인문, 소설, 생활, 기술) AUTHOR_ID INTEGER FALSE 저자 ID PRICE INTEGER FALSE 판매가 (원) PUBLISHED_DATE DATE FALSE 출판일 AUTHOR 테이블은 도서의 저자의 정보를 담은 테이블로 아래와 같은 구조로 되어있습니다. Column name Type Nullable Description AUTHOR_ID INTEGER FALSE 저자 ID AUTHOR_NAME VARCHAR(N) FALSE 저자명 문제 '경제' 카테고리에 속하는 도서들의 도서 ID(BOOK_ID), 저자명(AUTHOR_NAME), 출판일(PUBLISHED_DATE) 리스트를 출력하는 SQL문을 작성해주세요. 결과는 출판일을 기준으로 오름차순 정렬해주세요. 예시 예를 들어 BOOK 테이블과 AUTHOR 테이블이 다음과 같다면 BOOK_ID CATEGORY AUTHOR_ID PRICE PUBLISHED_DATE 1 인문 1 10000 2020-01-01 2 경제 1 9000 2021-04-11 3 경제 2 11000 2021-02-05 AUTHOR_ID AUTHOR_NAME 1 홍길동 2 김영호 '경제' 카테고리에 속하는 도서는 도서 ID가 2, 3인 도서이고, 출판일을 기준으로 오름차순으로 정렬하면 다음과 같은 결과가 나와야 합니다. BOOK_ID AUTHOR_NAME PUBLISHED_DATE 3 김영호 2021-02-05 2 홍길동 2021-04-11 주의사항 PUBLISHED_DATE의 데이트 포맷이 예시와 동일해야 정답처리 됩니다.",normal,database
56,"준호는 요즘 디펜스 게임에 푹 빠져 있습니다. 디펜스 게임은 준호가 보유한 병사 n명으로 연속되는 적의 공격을 순서대로 막는 게임입니다. 디펜스 게임은 다음과 같은 규칙으로 진행됩니다. 준호는 처음에 병사 n명을 가지고 있습니다. 매 라운드마다 enemy[i]마리의 적이 등장합니다. 남은 병사 중 enemy[i]명 만큼 소모하여 enemy[i]마리의 적을 막을 수 있습니다. 예를 들어 남은 병사가 7명이고, 적의 수가 2마리인 경우, 현재 라운드를 막으면 7 - 2 = 5명의 병사가 남습니다. 남은 병사의 수보다 현재 라운드의 적의 수가 더 많으면 게임이 종료됩니다. 게임에는 무적권이라는 스킬이 있으며, 무적권을 사용하면 병사의 소모없이 한 라운드의 공격을 막을 수 있습니다. 무적권은 최대 k번 사용할 수 있습니다. 준호는 무적권을 적절한 시기에 사용하여 최대한 많은 라운드를 진행하고 싶습니다. 준호가 처음 가지고 있는 병사의 수 n, 사용 가능한 무적권의 횟수 k, 매 라운드마다 공격해오는 적의 수가 순서대로 담긴 정수 배열 enemy가 매개변수로 주어집니다. 준호가 몇 라운드까지 막을 수 있는지 return 하도록 solution 함수를 완성해주세요. 제한사항 1 ≤ n ≤ 1,000,000,000 1 ≤ k ≤ 500,000 1 ≤ enemy의 길이 ≤ 1,000,000 1 ≤ enemy[i] ≤ 1,000,000 enemy[i]에는 i + 1 라운드에서 공격해오는 적의 수가 담겨있습니다. 모든 라운드를 막을 수 있는 경우에는 enemy[i]의 길이를 return 해주세요. 입출력 예 n k enemy result 7 3 [4, 2, 4, 5, 3, 3, 1] 5 2 4 [3, 3, 3, 3] 4 입출력 예 설명",normal,Array
57,"좌표평면을 좋아하는 진수는 x축과 y축이 직교하는 2차원 좌표평면에 점을 찍으면서 놀고 있습니다. 진수는 두 양의 정수 k, d가 주어질 때 다음과 같이 점을 찍으려 합니다. 원점(0, 0)으로부터 x축 방향으로 a*k(a = 0, 1, 2, 3 ...), y축 방향으로 b*k(b = 0, 1, 2, 3 ...)만큼 떨어진 위치에 점을 찍습니다. 원점과 거리가 d를 넘는 위치에는 점을 찍지 않습니다. 예를 들어, k가 2, d가 4인 경우에는 (0, 0), (0, 2), (0, 4), (2, 0), (2, 2), (4, 0) 위치에 점을 찍어 총 6개의 점을 찍습니다. 정수 k와 원점과의 거리를 나타내는 정수 d가 주어졌을 때, 점이 총 몇 개 찍히는지 return 하는 solution 함수를 완성하세요. 제한사항 1 ≤ k ≤ 1,000,000 1 ≤ d ≤ 1,000,000 입출력 예 k d result 2 4 6 1 5 26 입출력 예 설명",normal,Math
58,"은비는 길을 걷다가 관광 명소인 쌍둥이 빌딩 숲을 보게 되었습니다. 쌍둥이 빌딩 숲은 일렬로 빌딩들이 줄지어 서있는 곳입니다. 쌍둥이 빌딩 숲에는 높이가 1부터 n까지 각각 2 채씩 총 2n채의 빌딩이 존재하기 때문에 그러한 이름이 붙게 되었으며, 같은 높이를 가지는 빌딩 사이에는 그보다 높은 빌딩이 존재하지 않습니다. 은비는 쌍둥이 빌딩 숲을 한쪽 측면에서(열 방향으로) 바라보고 있습니다. 이때 count 채의 빌딩이 구분되어 보였습니다. 은비의 세계는 안타깝게도 원근감이 존재하지 않지만, 다행히 서로 다른 높이를 가지는 빌딩들은 각각 고유한 색깔을 가지고 있어 어떤 빌딩이 다른 빌딩에 의해 전체가 가려지지 않는다면 볼 수 있습니다. 예를 들어 은비가 바라본 방향에서 가까운 빌딩부터 차례로 높이가 1,1,3,2,2,3 순이라면 높이가 2인 빌딩은 가려져서 보이지 않고, 높이가 1인 빌딩과 높이가 3인 빌딩만 구분되어 보입니다. n과 count가 주어졌을 때, 빌딩들이 배치될 수 있는 방법의 수를 return 하도록 solution 함수를 완성해주세요. 제한 사항 1 ≤ n ≤ 100 1 ≤ count ≤ n 같은 높이의 빌딩은 같은 색이므로 서로 구분하지 않습니다. 결과는 매우 클 수 있으므로 1,000,000,007 로 나눈 나머지를 return합니다. 입출력 예 n count result 3 1 8 3 2 6 3 3 1 입출력 예 설명",hard,Math
59,"경화는 과수원에서 귤을 수확했습니다. 경화는 수확한 귤 중 'k'개를 골라 상자 하나에 담아 판매하려고 합니다. 그런데 수확한 귤의 크기가 일정하지 않아 보기에 좋지 않다고 생각한 경화는 귤을 크기별로 분류했을 때 서로 다른 종류의 수를 최소화하고 싶습니다. 예를 들어, 경화가 수확한 귤 8개의 크기가 [1, 3, 2, 5, 4, 5, 2, 3] 이라고 합시다. 경화가 귤 6개를 판매하고 싶다면, 크기가 1, 4인 귤을 제외한 여섯 개의 귤을 상자에 담으면, 귤의 크기의 종류가 2, 3, 5로 총 3가지가 되며 이때가 서로 다른 종류가 최소일 때입니다. 경화가 한 상자에 담으려는 귤의 개수 k와 귤의 크기를 담은 배열 tangerine이 매개변수로 주어집니다. 경화가 귤 k개를 고를 때 크기가 서로 다른 종류의 수의 최솟값을 return 하도록 solution 함수를 작성해주세요. 제한사항 1 ≤ k ≤ tangerine의 길이 ≤ 100,000 1 ≤ tangerine의 원소 ≤ 10,000,000 입출력 예 k tangerine result 6 [1, 3, 2, 5, 4, 5, 2, 3] 3 4 [1, 3, 2, 5, 4, 5, 2, 3] 2 2 [1, 1, 1, 1, 2, 2, 2, 3] 1 입출력 예 설명",normal,Array
60,"영우는 천하제일 암산대회를 앞두고 있습니다. 암산보다는 암기에 일가견이 있는 영우는 구구단을 확장하여 억억단을 만들고 외워버리기로 하였습니다. 억억단은 1억 x 1억 크기의 행렬입니다. 억억단을 외우던 영우는 친구 수연에게 퀴즈를 내달라고 부탁하였습니다. 수연은 평범하게 문제를 내봐야 영우가 너무 쉽게 맞히기 때문에 좀 어렵게 퀴즈를 내보려고 합니다. 적당한 수 e를 먼저 정하여 알려주고 e 이하의 임의의 수 s를 여러 개 얘기합니다. 영우는 각 s에 대해서 s보다 크거나 같고 e 보다 작거나 같은 수 중에서 억억단에서 가장 많이 등장한 수를 답해야 합니다. 만약 가장 많이 등장한 수가 여러 개라면 그 중 가장 작은 수를 답해야 합니다. 수연은 영우가 정답을 말하는지 확인하기 위해 당신에게 프로그램 제작을 의뢰하였습니다. e와 s의 목록 starts가 매개변수로 주어질 때 각 퀴즈의 답 목록을 return 하도록 solution 함수를 완성해주세요. 제한사항 1 ≤ e ≤ 5,000,000 1 ≤ starts의 길이 ≤ min {e,100,000} 1 ≤ starts의 원소 ≤ e starts에는 중복되는 원소가 존재하지 않습니다. 입출력 예 e starts result 8 [1,3,7] [6,6,8] 입출력 예 설명 억억단에서 1 ~ 8이 등장하는 횟수는 다음과 같습니다. 1번 등장 : 1 2번 등장 : 2, 3, 5, 7 3번 등장 : 4 4번 등장 : 6, 8 [1, 8] 범위에서는 6과 8이 각각 4번씩 등장하여 가장 많은데 6이 더 작은 수이므로 6이 정답입니다. [3, 8] 범위에서도 위와 같으므로 6이 정답입니다. [7, 8] 범위에서는 7은 2번, 8은 4번 등장하므로 8이 정답입니다.",normal,Math
61,"위와 같은 모양으로 배열된 숫자 자판이 있습니다. 숫자 타자 대회는 이 동일한 자판을 사용하여 숫자로만 이루어진 긴 문자열을 누가 가장 빠르게 타이핑하는지 겨루는 대회입니다. 대회에 참가하려는 민희는 두 엄지 손가락을 이용하여 타이핑을 합니다. 민희는 항상 왼손 엄지를 4 위에, 오른손 엄지를 6 위에 두고 타이핑을 시작합니다. 엄지 손가락을 움직여 다음 숫자를 누르는 데에는 일정 시간이 듭니다. 민희는 어떤 두 숫자를 연속으로 입력하는 시간 비용을 몇몇 가중치로 분류하였습니다. 이동하지 않고 제자리에서 다시 누르는 것은 가중치가 1입니다. 상하좌우로 인접한 숫자로 이동하여 누르는 것은 가중치가 2입니다. 대각선으로 인접한 숫자로 이동하여 누르는 것은 가중치가 3입니다. 같지 않고 인접하지 않은 숫자를 누를 때는 위 규칙에 따라 가중치 합이 최소가 되는 경로를 따릅니다. 예를 들어 1 위에 있던 손가락을 0 으로 이동하여 누르는 것은 2 + 2 + 3 = 7 만큼의 가중치를 갖습니다. 단, 숫자 자판은 버튼의 크기가 작기 때문에 같은 숫자 버튼 위에 동시에 두 엄지 손가락을 올려놓을 수 없습니다. 즉, 어떤 숫자를 눌러야 할 차례에 그 숫자 위에 올려져 있는 손가락이 있다면 반드시 그 손가락으로 눌러야 합니다. 숫자로 이루어진 문자열 numbers가 주어졌을 때 최소한의 시간으로 타이핑을 하는 경우의 가중치 합을 return 하도록 solution 함수를 완성해주세요. 제한사항 1 ≤ numbers의 길이 ≤ 100,000 numbers는 아라비아 숫자로만 이루어진 문자열입니다. 입출력 예 numbers result ""1756"" 10 ""5123"" 8 입출력 예 설명",normal,Array
62,"철수와 영희는 선생님으로부터 숫자가 하나씩 적힌 카드들을 절반씩 나눠서 가진 후, 다음 두 조건 중 하나를 만족하는 가장 큰 양의 정수 a의 값을 구하려고 합니다. 철수가 가진 카드들에 적힌 모든 숫자를 나눌 수 있고 영희가 가진 카드들에 적힌 모든 숫자들 중 하나도 나눌 수 없는 양의 정수 a 영희가 가진 카드들에 적힌 모든 숫자를 나눌 수 있고, 철수가 가진 카드들에 적힌 모든 숫자들 중 하나도 나눌 수 없는 양의 정수 a 예를 들어, 카드들에 10, 5, 20, 17이 적혀 있는 경우에 대해 생각해 봅시다. 만약, 철수가 [10, 17]이 적힌 카드를 갖고, 영희가 [5, 20]이 적힌 카드를 갖는다면 두 조건 중 하나를 만족하는 양의 정수 a는 존재하지 않습니다. 하지만, 철수가 [10, 20]이 적힌 카드를 갖고, 영희가 [5, 17]이 적힌 카드를 갖는다면, 철수가 가진 카드들의 숫자는 모두 10으로 나눌 수 있고, 영희가 가진 카드들의 숫자는 모두 10으로 나눌 수 없습니다. 따라서 철수와 영희는 각각 [10, 20]이 적힌 카드, [5, 17]이 적힌 카드로 나눠 가졌다면 조건에 해당하는 양의 정수 a는 10이 됩니다. 철수가 가진 카드에 적힌 숫자들을 나타내는 정수 배열 arrayA와 영희가 가진 카드에 적힌 숫자들을 나타내는 정수 배열 arrayB가 주어졌을 때, 주어진 조건을 만족하는 가장 큰 양의 정수 a를 return하도록 solution 함수를 완성해 주세요. 만약, 조건을 만족하는 a가 없다면, 0을 return 해 주세요. 제한사항 제한사항 1 ≤ arrayA의 길이 = arrayB의 길이 ≤ 500,000 1 ≤ arrayA의 원소, arrayB의 원소 ≤ 100,000,000 arrayA와 arrayB에는 중복된 원소가 있을 수 있습니다. 입출력 예 arrayA arrayB result [10, 17] [5, 20] 0 [10, 20] [5, 17] 10 [14, 35, 119] [18, 30, 102] 7 입출력 예 설명",normal,Array
63,"콜라츠 추측이란 로타르 콜라츠(Lothar Collatz)가 1937년에 제기한 추측으로 모든 자연수 k에 대해 다음 작업을 반복하면 항상 1로 만들 수 있다는 추측입니다. 1-1. 입력된 수가 짝수라면 2로 나눕니다. 1-2. 입력된 수가 홀수라면 3을 곱하고 1을 더합니다. 2.결과로 나온 수가 1보다 크다면 1번 작업을 반복합니다. 예를 들어 주어진 수가 5 라면 5 ⇒ 16 ⇒ 8 ⇒ 4 ⇒2 ⇒ 1 이되어 총 5번만에 1이 됩니다. 수가 커졌다 작아지기를 반복하는 모습이 비구름에서 빗방울이 오르락내리락하며 우박이 되는 모습과 비슷하다고 하여 우박수 또는 우박수열로 불리기도 합니다. 현재 이 추측이 참인지 거짓인지 증명되지 않았지만 약 1해까지의 수에서 반례가 없음이 밝혀져 있습니다. 은지는 우박수열을 좌표 평면 위에 꺾은선 그래프로 나타내보려고 합니다. 초항이 k인 우박수열이 있다면, x = 0일때 y = k이고 다음 우박수는 x = 1에 표시합니다. 이런 식으로 우박수가 1이 될 때까지 점들을 찍고 인접한 점들끼리 직선으로 연결하면 다음과 같이 꺾은선 그래프를 만들 수 있습니다. 은지는 이렇게 만든 꺾은선 그래프를 정적분 해보고 싶어졌습니다. x에 대한 어떤 범위 [a, b]가 주어진다면 이 범위에 대한 정적분 결과는 꺾은선 그래프와 x = a, x = b, y = 0 으로 둘러 쌓인 공간의 면적과 같습니다. 은지는 이것을 우박수열 정적분이라고 정의하였고 다양한 구간에 대해서 우박수열 정적분을 해보려고 합니다. 0 이상의 수 b에 대해 [a, -b]에 대한 정적분 결과는 x = a, x = n - b, y = 0 으로 둘러 쌓인 공간의 면적으로 정의하며, 이때 n은 k가 초항인 우박수열이 1이 될때 까지의 횟수를 의미합니다. 예를 들어, 5를 초항으로 하는 우박수열은 5 ⇒ 16 ⇒ 8 ⇒ 4 ⇒ 2 ⇒ 1 입니다. 이를 좌표 평면으로 옮기면 (0, 5), (1, 16), (2, 8), (3, 4), (4, 2), (5, 1) 에 점이 찍히고 점들을 연결하면 꺾은선 그래프가 나옵니다. 이를 [0,0] 구간에 대해 정적분 한다면 전체 구간에 대한 정적분이며, [1,-2] 구간에 대해 정적분 한다면 1 ≤ x ≤ 3인 구간에 대한 정적분입니다. 우박수의 초항 k와, 정적분을 구하는 구간들의 목록 ranges가 주어졌을 때 정적분의 결과 목록을 return 하도록 solution을 완성해주세요. 단, 주어진 구간의 시작점이 끝점보다 커서 유효하지 않은 구간이 주어질 수 있으며 이때의 정적분 결과는 -1로 정의합니다. 제한사항 2 ≤ k ≤ 10,000 1 ≤ ranges의 길이 ≤ 10,000 ranges의 원소는 [a, b] 형식이며 0 ≤ a < 200, -200 < b ≤ 0 입니다. 주어진 모든 입력에 대해 정적분의 결과는 227 을 넘지 않습니다. 본 문제는 정답에 실수형이 포함되는 문제입니다. 입출력 예의 소수 부분 .0이 코드 실행 버튼 클릭 후 나타나는 결괏값, 기댓값 표시와 다를 수 있습니다. 입출력 예 k ranges result 5 [[0,0],[0,-1],[2,-3],[3,-3]] [33.0,31.5,0.0,-1.0] 3 [[0,0], [1,-2], [3,-3]] [47.0,36.0,12.0] 입출력 예 설명",normal,Math
64,"인천 앞바다에는 1부터 n까지 서로 다른 번호가 매겨진 등대 n개가 존재합니다. 등대와 등대 사이를 오가는 뱃길이 n-1개 존재하여, 어느 등대에서 출발해도 다른 모든 등대까지 이동할 수 있습니다. 등대 관리자 윤성이는 전력을 아끼기 위하여, 이 중 몇 개의 등대만 켜 두려고 합니다. 하지만 등대를 아무렇게나 꺼버리면, 뱃길을 오가는 배들이 위험할 수 있습니다. 한 뱃길의 양쪽 끝 등대 중 적어도 하나는 켜져 있도록 등대를 켜 두어야 합니다. 예를 들어, 아래 그림과 같이 등대 8개와 7개의 뱃길들이 있다고 합시다. 이 경우 1번 등대와 5번 등대 두 개만 켜 두어도 모든 뱃길은 양쪽 끝 등대 중 하나가 켜져 있으므로, 배들은 안전하게 운항할 수 있습니다. 등대의 개수 n과 각 뱃길이 연결된 등대의 번호를 담은 이차원 배열 lighthouse가 매개변수로 주어집니다. 윤성이가 켜 두어야 하는 등대 개수의 최솟값을 return 하도록 solution 함수를 작성해주세요. 제한사항 2 ≤ n ≤ 100,000 lighthouse의 길이 = n – 1 lighthouse 배열의 각 행 [a, b]는 a번 등대와 b번 등대가 뱃길로 연결되어 있다는 의미입니다. 1 ≤ a ≠ b ≤ n 모든 등대는 서로 다른 등대로 이동할 수 있는 뱃길이 존재하도록 입력이 주어집니다. 입출력 예 n lighthouse result 8 [[1, 2], [1, 3], [1, 4], [1, 5], [5, 6], [5, 7], [5, 8]] 2 10 [[4, 1], [5, 1], [5, 6], [7, 6], [1, 2], [1, 3], [6, 8], [2, 9], [9, 10]] 3 입출력 예 설명",normal,Array
65,"다음은 아이스크림 가게의 상반기 주문 정보를 담은 FIRST_HALF 테이블과 7월의 아이스크림 주문 정보를 담은 JULY 테이블입니다. FIRST_HALF 테이블 구조는 다음과 같으며, SHIPMENT_ID, FLAVOR, TOTAL_ORDER는 각각 아이스크림 공장에서 아이스크림 가게까지의 출하 번호, 아이스크림 맛, 상반기 아이스크림 총주문량을 나타냅니다. FIRST_HALF 테이블의 기본 키는 FLAVOR입니다. FIRST_HALF테이블의 SHIPMENT_ID는 JULY테이블의 SHIPMENT_ID의 외래 키입니다. NAME TYPE NULLABLE SHIPMENT_ID INT(N) FALSE FLAVOR VARCHAR(N) FALSE TOTAL_ORDER INT(N) FALSE JULY 테이블 구조는 다음과 같으며, SHIPMENT_ID, FLAVOR, TOTAL_ORDER 은 각각 아이스크림 공장에서 아이스크림 가게까지의 출하 번호, 아이스크림 맛, 7월 아이스크림 총주문량을 나타냅니다. JULY 테이블의 기본 키는 SHIPMENT_ID입니다. JULY테이블의 FLAVOR는 FIRST_HALF 테이블의 FLAVOR의 외래 키입니다. 7월에는 아이스크림 주문량이 많아 같은 아이스크림에 대하여 서로 다른 두 공장에서 아이스크림 가게로 출하를 진행하는 경우가 있습니다. 이 경우 같은 맛의 아이스크림이라도 다른 출하 번호를 갖게 됩니다. NAME TYPE NULLABLE SHIPMENT_ID INT(N) FALSE FLAVOR VARCHAR(N) FALSE TOTAL_ORDER INT(N) FALSE 문제 7월 아이스크림 총 주문량과 상반기의 아이스크림 총 주문량을 더한 값이 큰 순서대로 상위 3개의 맛을 조회하는 SQL 문을 작성해주세요. 예시 예를 들어 FIRST_HALF 테이블이 다음과 같고 SHIPMENT_ID FLAVOR TOTAL_ORDER 101 chocolate 3200 102 vanilla 2800 103 mint_chocolate 1700 104 caramel 2600 105 white_chocolate 3100 106 peach 2450 107 watermelon 2150 108 mango 2900 109 strawberry 3100 110 melon 3150 111 orange 2900 112 pineapple 2900 JULY테이블이 다음과 같다면 SHIPMENT_ID FLAVOR TOTAL_ORDER 101 chocolate 520 102 vanilla 560 103 mint_chocolate 400 104 caramel 460 105 white_chocolate 350 106 peach 500 107 watermelon 780 108 mango 790 109 strawberry 520 110 melon 400 111 orange 250 112 pineapple 200 208 mango 110 209 strawberry 220 7월 아이스크림 총주문량과 상반기의 아이스크림 총 주문량을 더한 값이 큰 순서대로 상위 3개의 맛을 조회하면 strawberry(520 + 220 + 3,100 = 3,840), mango(790 + 110 + 2,900 = 3,800), chocolate(520 + 3,200 = 3,720) 순입니다. 따라서 SQL 문을 실행하면 다음과 같이 나와야 합니다. FLAVOR strawberry mango chocolate",hard,database
66,"다음은 아이스크림 가게의 상반기 주문 정보를 담은 FIRST_HALF 테이블과 아이스크림 성분에 대한 정보를 담은 ICECREAM_INFO 테이블입니다. FIRST_HALF 테이블 구조는 다음과 같으며, SHIPMENT_ID, FLAVOR, TOTAL_ORDER 는 각각 아이스크림 공장에서 아이스크림 가게까지의 출하 번호, 아이스크림 맛, 상반기 아이스크림 총주문량을 나타냅니다. FIRST_HALF 테이블의 기본 키는 FLAVOR입니다. NAME TYPE NULLABLE SHIPMENT_ID INT(N) FALSE FLAVOR VARCHAR(N) FALSE TOTAL_ORDER INT(N) FALSE ICECREAM_INFO 테이블 구조는 다음과 같으며, FLAVOR, INGREDITENT_TYPE 은 각각 아이스크림 맛, 아이스크림의 성분 타입을 나타냅니다. INGREDIENT_TYPE에는 아이스크림의 주 성분이 설탕이면 sugar_based라고 입력되고, 아이스크림의 주 성분이 과일이면 fruit_based라고 입력됩니다. ICECREAM_INFO의 기본 키는 FLAVOR입니다. ICECREAM_INFO테이블의 FLAVOR는 FIRST_HALF 테이블의 FLAVOR의 외래 키입니다. NAME TYPE NULLABLE FLAVOR VARCHAR(N) FALSE INGREDIENT_TYPE VARCHAR(N) FALSE 문제 상반기 동안 각 아이스크림 성분 타입과 성분 타입에 대한 아이스크림의 총주문량을 총주문량이 작은 순서대로 조회하는 SQL 문을 작성해주세요. 이때 총주문량을 나타내는 컬럼명은 TOTAL_ORDER로 지정해주세요. 예시 예를 들어 FIRST_HALF 테이블이 다음과 같고 SHIPMENT_ID FLAVOR TOTAL_ORDER 101 chocolate 3200 102 vanilla 2800 103 mint_chocolate 1700 104 caramel 2600 105 white_chocolate 3100 106 peach 2450 107 watermelon 2150 108 mango 2900 109 strawberry 3100 110 melon 3150 111 orange 2900 112 pineapple 2900 ICECREAM_INFO 테이블이 다음과 같다면 FLAVOR INGREDIENT_TYPE chocolate sugar_based vanilla sugar_based mint_chocolate sugar_based caramel sugar_based white_chocolate sugar_based peach fruit_based watermelon fruit_based mango fruit_based strawberry fruit_based melon fruit_based orange fruit_based pineapple fruit_based 상반기에 아이스크림의 주 성분이 설탕인 아이스크림들에 대한 총주문량을 구하면 3,200 + 2,800 + 1,700 + 2,600 + 3,100 = 13,400입니다. 아이스크림의 주 성분이 과일인 아이스크림들에 대한 총주문량을 구하면 3,100 + 2,450 + 2,150 + 2,900 + 3,150 + 2,900 + 2,900 = 19,550입니다. 따라서 총주문량이 작은 순서대로 조회하는 SQL 문을 실행하면 다음과 같이 나와야 합니다. INGREDIENT_TYPE TOTAL_ORDER sugar_based 13400 fruit_based 19550",normal,database
67,"강철부대의 각 부대원이 여러 지역에 뿔뿔이 흩어져 특수 임무를 수행 중입니다. 지도에서 강철부대가 위치한 지역을 포함한 각 지역은 유일한 번호로 구분되며, 두 지역 간의 길을 통과하는 데 걸리는 시간은 모두 1로 동일합니다. 임무를 수행한 각 부대원은 지도 정보를 이용하여 최단시간에 부대로 복귀하고자 합니다. 다만 적군의 방해로 인해, 임무의 시작 때와 다르게 되돌아오는 경로가 없어져 복귀가 불가능한 부대원도 있을 수 있습니다. 강철부대가 위치한 지역을 포함한 총지역의 수 n, 두 지역을 왕복할 수 있는 길 정보를 담은 2차원 정수 배열 roads, 각 부대원이 위치한 서로 다른 지역들을 나타내는 정수 배열 sources, 강철부대의 지역 destination이 주어졌을 때, 주어진 sources의 원소 순서대로 강철부대로 복귀할 수 있는 최단시간을 담은 배열을 return하는 solution 함수를 완성해주세요. 복귀가 불가능한 경우 해당 부대원의 최단시간은 -1입니다. 제한사항 3 ≤ n ≤ 100,000 각 지역은 정수 1부터 n까지의 번호로 구분됩니다. 2 ≤ roads의 길이 ≤ 500,000 roads의 원소의 길이 = 2 roads의 원소는 [a, b] 형태로 두 지역 a, b가 서로 왕복할 수 있음을 의미합니다.(1 ≤ a, b ≤ n, a ≠ b) 동일한 정보가 중복해서 주어지지 않습니다. 동일한 [a, b]가 중복해서 주어지지 않습니다. [a, b]가 있다면 [b, a]는 주어지지 않습니다. 1 ≤ sources의 길이 ≤ 500 1 ≤ sources[i] ≤ n 1 ≤ destination ≤ n 입출력 예 n roads sources destination result 3 [[1, 2], [2, 3]] [2, 3] 1 [1, 2] 5 [[1, 2], [1, 4], [2, 4], [2, 5], [4, 5]] [1, 3, 5] 5 [2, -1, 0] 입출력 예 설명",normal,Array
68,"철수는 롤케이크를 두 조각으로 잘라서 동생과 한 조각씩 나눠 먹으려고 합니다. 이 롤케이크에는 여러가지 토핑들이 일렬로 올려져 있습니다. 철수와 동생은 롤케이크를 공평하게 나눠먹으려 하는데, 그들은 롤케이크의 크기보다 롤케이크 위에 올려진 토핑들의 종류에 더 관심이 많습니다. 그래서 잘린 조각들의 크기와 올려진 토핑의 개수에 상관없이 각 조각에 동일한 가짓수의 토핑이 올라가면 공평하게 롤케이크가 나누어진 것으로 생각합니다. 예를 들어, 롤케이크에 4가지 종류의 토핑이 올려져 있다고 합시다. 토핑들을 1, 2, 3, 4와 같이 번호로 표시했을 때, 케이크 위에 토핑들이 [1, 2, 1, 3, 1, 4, 1, 2] 순서로 올려져 있습니다. 만약 세 번째 토핑(1)과 네 번째 토핑(3) 사이를 자르면 롤케이크의 토핑은 [1, 2, 1], [3, 1, 4, 1, 2]로 나뉘게 됩니다. 철수가 [1, 2, 1]이 놓인 조각을, 동생이 [3, 1, 4, 1, 2]가 놓인 조각을 먹게 되면 철수는 두 가지 토핑(1, 2)을 맛볼 수 있지만, 동생은 네 가지 토핑(1, 2, 3, 4)을 맛볼 수 있으므로, 이는 공평하게 나누어진 것이 아닙니다. 만약 롤케이크의 네 번째 토핑(3)과 다섯 번째 토핑(1) 사이를 자르면 [1, 2, 1, 3], [1, 4, 1, 2]로 나뉘게 됩니다. 이 경우 철수는 세 가지 토핑(1, 2, 3)을, 동생도 세 가지 토핑(1, 2, 4)을 맛볼 수 있으므로, 이는 공평하게 나누어진 것입니다. 공평하게 롤케이크를 자르는 방법은 여러가지 일 수 있습니다. 위의 롤케이크를 [1, 2, 1, 3, 1], [4, 1, 2]으로 잘라도 공평하게 나뉩니다. 어떤 경우에는 롤케이크를 공평하게 나누지 못할 수도 있습니다. 롤케이크에 올려진 토핑들의 번호를 저장한 정수 배열 topping이 매개변수로 주어질 때, 롤케이크를 공평하게 자르는 방법의 수를 return 하도록 solution 함수를 완성해주세요. 제한사항 1 ≤ topping의 길이 ≤ 1,000,000 1 ≤ topping의 원소 ≤ 10,000 입출력 예 topping result [1, 2, 1, 3, 1, 4, 1, 2] 2 [1, 2, 3, 1, 4] 0 입출력 예 설명",normal,Array
69,"다음은 환자 정보를 담은 PATIENT 테이블과 의사 정보를 담은 DOCTOR 테이블, 그리고 진료 예약목록을 담은 APPOINTMENT에 대한 테이블입니다. PATIENT 테이블은 다음과 같으며 PT_NO, PT_NAME, GEND_CD, AGE, TLNO는 각각 환자번호, 환자이름, 성별코드, 나이, 전화번호를 의미합니다. Column name Type Nullable PT_NO VARCHAR(N) FALSE PT_NAME VARCHAR(N) FALSE GEND_CD VARCHAR(N) FALSE AGE INTEGER FALSE TLNO VARCHAR(N) TRUE DOCTOR 테이블은 다음과 같으며 DR_NAME, DR_ID, LCNS_NO, HIRE_YMD, MCDP_CD, TLNO는 각각 의사이름, 의사ID, 면허번호, 고용일자, 진료과코드, 전화번호를 나타냅니다. Column name Type Nullable DR_NAME VARCHAR(N) FALSE DR_ID VARCHAR(N) FALSE LCNS_NO VARCHAR(N) FALSE HIRE_YMD DATE FALSE MCDP_CD VARCHAR(N) TRUE TLNO VARCHAR(N) TRUE APPOINTMENT 테이블은 다음과 같으며 APNT_YMD, APNT_NO, PT_NO, MCDP_CD, MDDR_ID, APNT_CNCL_YN, APNT_CNCL_YMD는 각각 진료 예약일시, 진료예약번호, 환자번호, 진료과코드, 의사ID, 예약취소여부, 예약취소날짜를 나타냅니다. Column name Type Nullable APNT_YMD TIMESTAMP FALSE APNT_NO INTEGER FALSE PT_NO VARCHAR(N) FALSE MCDP_CD VARCHAR(N) FALSE MDDR_ID VARCHAR(N) FALSE APNT_CNCL_YN VARCHAR(N) TRUE APNT_CNCL_YMD DATE TRUE 문제 PATIENT, DOCTOR 그리고 APPOINTMENT 테이블에서 2022년 4월 13일 취소되지 않은 흉부외과(CS) 진료 예약 내역을 조회하는 SQL문을 작성해주세요. 진료예약번호, 환자이름, 환자번호, 진료과코드, 의사이름, 진료예약일시 항목이 출력되도록 작성해주세요. 결과는 진료예약일시를 기준으로 오름차순 정렬해주세요. 예시 PATIENT 테이블이 다음과 같고, PT_NO PT_NAME GEND_CD AGE TLNO PT22000019 바라 W 10 01079068799 PT22000043 오스왈드 M 68 01031294124 PT22000052 제니 W 60 NULL PT22000071 몬몬 M 31 01076489209 PT22000097 슈가 M 19 NULL DOCTOR 테이블이 다음과 같고, DR_NAME DR_ID LCNS_NO HIRE_YMD MCDP_CD TLNO 루피 DR20090029 LC00010001 2009-03-01 CS 01085482011 니모 DR20200012 LC00911162 2020-03-01 CS 01089483921 핑크퐁 DR20140011 LC00082201 2014-03-01 NP 01098428957 젤라비 DR20160031 LC00340327 2016-11-01 OB 01023981922 토리 DR20190129 LC00099911 2019-03-01 NS 01058390758 APPOINTMENT 테이블이 다음과 같을 때, APNT_YMD APNT_NO PT_NO MCDP_CD MDDR_ID APNT_CNCL_YN APNT_CNCL_YMD 2022-04-13 12:30:00.000000 42 PT22000071 CS DR20090029 N NULL 2022-04-13 15:30:00.000000 43 PT22000019 CS DR20200012 N NULL 2022-04-13 09:00:00.000000 46 PT22000043 CS DR20090029 N NULL 2022-07-09 11:00:00.000000 74 PT22000042 NP DR20100011 N NULL 2022-12-13 12:30:00.000000 110 PT22000097 NP DR20160011 Y 2022-12-03 SQL을 실행하면 다음과 같이 출력되어야 합니다. APNT_NO PT_NAME PT_NO MCDP_CD DR_NAME APNT_YMD 46 오스왈드 PT22000043 CS 루피 2022-04-13 09:00:00.000000 42 몬몬 PT22000071 CS 루피 2022-04-13 12:30:00.000000 43 바라 PT22000019 CS 니모 2022-04-13 15:30:00.000000",hard,database
70,"다음은 종합병원의 진료 예약정보를 담은 APPOINTMENT 테이블 입니다. APPOINTMENT 테이블은 다음과 같으며 APNT_YMD, APNT_NO, PT_NO, MCDP_CD, MDDR_ID, APNT_CNCL_YN, APNT_CNCL_YMD는 각각 진료예약일시, 진료예약번호, 환자번호, 진료과코드, 의사ID, 예약취소여부, 예약취소날짜를 나타냅니다. Column name Type Nullable APNT_YMD TIMESTAMP FALSE APNT_NO NUMBER(5) FALSE PT_NO VARCHAR(10) FALSE MCDP_CD VARCHAR(6) FALSE MDDR_ID VARCHAR(10) FALSE APNT_CNCL_YN VARCHAR(1) TRUE APNT_CNCL_YMD DATE TRUE 문제 APPOINTMENT 테이블에서 2022년 5월에 예약한 환자 수를 진료과코드 별로 조회하는 SQL문을 작성해주세요. 이때, 컬럼명은 '진료과 코드', '5월예약건수'로 지정해주시고 결과는 진료과별 예약한 환자 수를 기준으로 오름차순 정렬하고, 예약한 환자 수가 같다면 진료과 코드를 기준으로 오름차순 정렬해주세요. 예시 APPOINTMENT 테이블이 다음과 같을 때 APNT_YMD APNT_NO PT_NO MCDP_CD MDDR_ID APNT_CNCL_YN APNT_CNCL_YMD 2022-04-14 09:30:00.000000 47 PT22000064 GS DR20170123 N NULL 2022-04-15 10:30:00.000000 48 PT22000065 OB DR20100231 N NULL 2022-05-15 17:30:00.000000 49 PT22000086 OB DR20100231 N NULL 2022-05-18 10:30:00.000000 52 PT22000019 GS DR20100039 N NULL 2022-05-19 12:00:00.000000 53 PT22000020 FM DR20010112 N NULL 2022-05-22 08:30:00.000000 54 PT22000021 GS DR20100039 N NULL 2022-05-04 10:30:00.000000 56 PT22000023 FM DR20090112 N NULL 2022-05-14 15:30:00.000000 57 PT22000074 CS DR20200012 N NULL 2022-05-24 15:30:00.000000 58 PT22000085 CS DR20200012 N NULL 2022-05-28 10:00:00.000000 60 PT22000092 OS DR20100031 N NULL SQL을 실행하면 다음과 같이 출력되어야 합니다. 진료과코드 5월예약건수 OB 1 OS 1 CS 2 FM 2 GS 2",normal,database
71,"영재는 택배상자를 트럭에 싣는 일을 합니다. 영재가 실어야 하는 택배상자는 크기가 모두 같으며 1번 상자부터 n번 상자까지 번호가 증가하는 순서대로 컨테이너 벨트에 일렬로 놓여 영재에게 전달됩니다. 컨테이너 벨트는 한 방향으로만 진행이 가능해서 벨트에 놓인 순서대로(1번 상자부터) 상자를 내릴 수 있습니다. 하지만 컨테이너 벨트에 놓인 순서대로 택배상자를 내려 바로 트럭에 싣게 되면 택배 기사님이 배달하는 순서와 택배상자가 실려 있는 순서가 맞지 않아 배달에 차질이 생깁니다. 따라서 택배 기사님이 미리 알려준 순서에 맞게 영재가 택배상자를 실어야 합니다. 만약 컨테이너 벨트의 맨 앞에 놓인 상자가 현재 트럭에 실어야 하는 순서가 아니라면 그 상자를 트럭에 실을 순서가 될 때까지 잠시 다른 곳에 보관해야 합니다. 하지만 고객의 물건을 함부로 땅에 둘 수 없어 보조 컨테이너 벨트를 추가로 설치하였습니다. 보조 컨테이너 벨트는 앞 뒤로 이동이 가능하지만 입구 외에 다른 면이 막혀 있어서 맨 앞의 상자만 뺄 수 있습니다(즉, 가장 마지막에 보조 컨테이너 벨트에 보관한 상자부터 꺼내게 됩니다). 보조 컨테이너 벨트를 이용해도 기사님이 원하는 순서대로 상자를 싣지 못 한다면, 더 이상 상자를 싣지 않습니다. 예를 들어, 영재가 5개의 상자를 실어야 하며, 택배 기사님이 알려준 순서가 기존의 컨테이너 벨트에 네 번째, 세 번째, 첫 번째, 두 번째, 다섯 번째 놓인 택배상자 순서인 경우, 영재는 우선 첫 번째, 두 번째, 세 번째 상자를 보조 컨테이너 벨트에 보관합니다. 그 후 네 번째 상자를 트럭에 싣고 보조 컨테이너 벨트에서 세 번째 상자 빼서 트럭에싣습니다. 다음으로 첫 번째 상자를 실어야 하지만 보조 컨테이너 벨트에서는 두 번째 상자를, 기존의 컨테이너 벨트에는 다섯 번째 상자를 꺼낼 수 있기 때문에 더이상의 상자는 실을 수 없습니다. 따라서 트럭에는 2개의 상자만 실리게 됩니다. 택배 기사님이 원하는 상자 순서를 나타내는 정수 배열 order가 주어졌을 때, 영재가 몇 개의 상자를 실을 수 있는지 return 하는 solution 함수를 완성하세요. 제한사항 1 ≤ order의 길이 ≤ 1,000,000 order는 1이상 order의 길이 이하의 모든 정수가 한번씩 등장합니다. order[i]는 기존의 컨테이너 벨트에 order[i]번째 상자를 i+1번째로 트럭에 실어야 함을 의미합니다. 입출력 예 order result [4, 3, 1, 2, 5] 2 [5, 4, 3, 2, 1] 5 입출력 예 설명",normal,Array
72,"한수는 직사각형 모양의 공간에 놓인 동전들을 뒤집는 놀이를 하고 있습니다. 모든 동전들은 앞과 뒤가 구분되어 있으며, 동전을 뒤집기 위해서는 같은 줄에 있는 모든 동전을 뒤집어야 합니다. 동전들의 초기 상태와 목표 상태가 주어졌을 때, 초기 상태에서 최소 몇 번의 동전을 뒤집어야 목표 상태가 되는지 알아봅시다. 예를 들어, 위 그림에서 맨 왼쪽이 초기 상태, 맨 오른쪽이 목표 상태인 경우에 대해 알아봅시다. 그림에서 검은색 원은 앞면인 동전, 흰색 원은 뒷면인 동전을 의미합니다. 초기 상태에서 2행과 4행의 돌들을 뒤집으면, 두 번째 그림이 됩니다. 그 후, 2열, 4열, 5열의 돌들을 순서대로 뒤집는 다면, 총 5번의 동전 뒤집기를 통해 목표 상태가 되며, 이 경우가 최소인 경우입니다. 직사각형 모양의 공간에 놓인 동전들의 초기 상태를 나타내는 2차원 정수 배열 beginning, 목표 상태를 나타내는 target이 주어졌을 때, 초기 상태에서 목표 상태로 만들기 위해 필요한 동전 뒤집기 횟수의 최솟값을 return 하는 solution 함수를 완성하세요. 단, 목표 상태를 만들지 못하는 경우에는 -1을 return 합니다. 제한사항 1 ≤ beginning의 길이 = target의 길이 ≤ 10 1 ≤ beginning[i]의 길이 = target[i]의 길이 ≤ 10 beginning[i][j]와 target[i][j]는 i + 1행 j + 1열의 동전의 상태를 나타내며, 0 또는 1의 값으로 주어집니다. 0은 동전의 앞면을, 1은 동전의 뒷면을 의미합니다. 입출력 예 beginning target result [[0, 1, 0, 0, 0], [1, 0, 1, 0, 1], [0, 1, 1, 1, 0], [1, 0, 1, 1, 0], [0, 1, 0, 1, 0]] [[0, 0, 0, 1, 1], [0, 0, 0, 0, 1], [0, 0, 1, 0, 1], [0, 0, 0, 1, 0], [0, 0, 0, 0, 1]] 5 [[0, 0, 0], [0, 0, 0], [0, 0, 0]] [[1, 0, 1], [0, 0, 0], [0, 0, 0]] -1 입출력 예 설명",normal,Array
73,"고고학자인 혜선은 오래전부터 성궤의 행방을 추적해왔습니다. 그동안 그의 연구는 주류 학자들로부터 인정받지 못했었지만, 혜선이는 포기하지 않고 조사를 계속했고 마침내 성궤의 행방을 알아내었습니다. 그러나 오래전 누군가로부터 봉인된 성궤는 특별한 잠금장치에 의해 보호되고 있었습니다. 잠금장치는 일종의 퍼즐과 연결되어 퍼즐을 해결하면 열리는 것으로 보입니다. 퍼즐은 시계들이 행렬을 이루는 구조물인데 하나의 시계에 시곗바늘은 하나씩만 있습니다. 각 시곗바늘은 시계방향으로만 돌릴 수 있고 한 번의 조작으로 90도씩 돌릴 수 있습니다. 시계들은 기계장치에 의해 연결되어 있어 어떤 시계의 시곗바늘을 돌리면 그 시계의 상하좌우로 인접한 시계들의 시곗바늘도 함께 돌아갑니다. 행렬의 모서리에 위치한 시계의 시곗바늘을 돌리는 경우에는 인접한 세 시계의 시곗바늘들이 함께 돌아가며, 꼭짓점에 위치한 시계의 시곗바늘을 돌리는 경우에는 인접한 두 시계의 시곗바늘들이 함께 돌아갑니다. 각 시계는 12시, 3시, 6시, 9시 방향 중의 한 방향을 가리키고 있습니다. 각 시계의 시곗바늘을 적절히 조작하여 모든 시곗바늘이 12시 방향을 가리키면 퍼즐이 해결되어 성궤를 봉인하고 있는 잠금장치가 열릴 것입니다. 노후화된 퍼즐 기계장치가 걱정되었던 혜선은 가능한 최소한의 조작으로 퍼즐을 해결하려고 합니다. 시곗바늘들의 행렬 clockHands가 매개변수로 주어질 때, 퍼즐을 해결하기 위한 최소한의 조작 횟수를 return 하도록 solution 함수를 완성해주세요. 제한사항 2 ≤ clockHands의 길이 ≤ 8 clockHands는 2차원 배열이며 행과 열의 크기가 동일합니다. 0 ≤ clockHands의 원소 ≤ 3 clockHands[i]의 원소들은 시곗바늘의 방향을 나타내며 0은 12시 방향, 1은 3시 방향, 2는 6시 방향, 3은 9시 방향을 나타냅니다. 해결 가능한 퍼즐만 주어집니다. 입출력 예 clockHands result [[0,3,3,0],[3,2,2,3],[0,3,2,0],[0,3,3,3]] 3 입출력 예 설명",normal,Array
74,"철호는 수열을 가지고 놀기 좋아합니다. 어느 날 철호는 어떤 자연수로 이루어진 원형 수열의 연속하는 부분 수열의 합으로 만들 수 있는 수가 모두 몇 가지인지 알아보고 싶어졌습니다. 원형 수열이란 일반적인 수열에서 처음과 끝이 연결된 형태의 수열을 말합니다. 예를 들어 수열 [7, 9, 1, 1, 4] 로 원형 수열을 만들면 다음과 같습니다. 원형 수열은 처음과 끝이 연결되어 끊기는 부분이 없기 때문에 연속하는 부분 수열도 일반적인 수열보다 많아집니다. 원형 수열의 모든 원소 elements가 순서대로 주어질 때, 원형 수열의 연속 부분 수열 합으로 만들 수 있는 수의 개수를 return 하도록 solution 함수를 완성해주세요. 제한사항 3 ≤ elements의 길이 ≤ 1,000 1 ≤ elements의 원소 ≤ 1,000 입출력 예 elements result [7,9,1,1,4] 18 입출력 예 설명",normal,Math
75,"다음은 어느 의류 쇼핑몰의 온라인 상품 판매 정보를 담은 ONLINE_SALE 테이블과 오프라인 상품 판매 정보를 담은 OFFLINE_SALE 테이블 입니다. ONLINE_SALE 테이블은 아래와 같은 구조로 되어있으며 ONLINE_SALE_ID, USER_ID, PRODUCT_ID, SALES_AMOUNT, SALES_DATE는 각각 온라인 상품 판매 ID, 회원 ID, 상품 ID, 판매량, 판매일을 나타냅니다. Column name Type Nullable ONLINE_SALE_ID INTEGER FALSE USER_ID INTEGER FALSE PRODUCT_ID INTEGER FALSE SALES_AMOUNT INTEGER FALSE SALES_DATE DATE FALSE 동일한 날짜, 회원 ID, 상품 ID 조합에 대해서는 하나의 판매 데이터만 존재합니다. OFFLINE_SALE 테이블은 아래와 같은 구조로 되어있으며 OFFLINE_SALE_ID, PRODUCT_ID, SALES_AMOUNT, SALES_DATE는 각각 오프라인 상품 판매 ID, 상품 ID, 판매량, 판매일을 나타냅니다. Column name Type Nullable OFFLINE_SALE_ID INTEGER FALSE PRODUCT_ID INTEGER FALSE SALES_AMOUNT INTEGER FALSE SALES_DATE DATE FALSE 동일한 날짜, 상품 ID 조합에 대해서는 하나의 판매 데이터만 존재합니다. 문제 ONLINE_SALE 테이블과 OFFLINE_SALE 테이블에서 2022년 3월의 오프라인/온라인 상품 판매 데이터의 판매 날짜, 상품ID, 유저ID, 판매량을 출력하는 SQL문을 작성해주세요. OFFLINE_SALE 테이블의 판매 데이터의 USER_ID 값은 NULL 로 표시해주세요. 결과는 판매일을 기준으로 오름차순 정렬해주시고 판매일이 같다면 상품 ID를 기준으로 오름차순, 상품ID까지 같다면 유저 ID를 기준으로 오름차순 정렬해주세요. 예시 예를 들어 ONLINE_SALE 테이블이 다음과 같고 ONLINE_SALE_ID USER_ID PRODUCT_ID SALES_AMOUNT SALES_DATE 1 1 3 2 2022-02-25 2 4 4 1 2022-03-01 4 2 2 2 2022-03-02 3 6 3 3 2022-03-02 5 5 5 1 2022-03-03 6 5 7 1 2022-04-06 OFFLINE_SALE 테이블이 다음과 같다면 OFFLINE_SALE_ID PRODUCT_ID SALES_AMOUNT SALES_DATE 1 1 2 2022-02-21 4 1 2 2022-03-01 3 3 3 2022-03-01 2 4 1 2022-03-01 5 2 1 2022-03-03 6 2 1 2022-04-01 각 테이블의 2022년 3월의 판매 데이터를 합쳐서, 정렬한 결과는 다음과 같아야 합니다. SALES_DATE PRODUCT_ID USER_ID SALES_AMOUNT 2022-03-01 1 NULL 2 2022-03-01 3 NULL 3 2022-03-01 4 NULL 1 2022-03-01 4 4 1 2022-03-02 2 2 2 2022-03-02 3 6 3 2022-03-03 2 NULL 1 2022-03-03 5 5 1",hard,database
76,"다음은 어느 의류 쇼핑몰의 온라인 상품 판매 정보를 담은 ONLINE_SALE 테이블 입니다. ONLINE_SALE 테이블은 아래와 같은 구조로 되어있으며 ONLINE_SALE_ID, USER_ID, PRODUCT_ID, SALES_AMOUNT, SALES_DATE는 각각 온라인 상품 판매 ID, 회원 ID, 상품 ID, 판매량, 판매일을 나타냅니다. Column name Type Nullable ONLINE_SALE_ID INTEGER FALSE USER_ID INTEGER FALSE PRODUCT_ID INTEGER FALSE SALES_AMOUNT INTEGER FALSE SALES_DATE DATE FALSE 동일한 날짜, 회원 ID, 상품 ID 조합에 대해서는 하나의 판매 데이터만 존재합니다. 문제 ONLINE_SALE 테이블에서 동일한 회원이 동일한 상품을 재구매한 데이터를 구하여, 재구매한 회원 ID와 재구매한 상품 ID를 출력하는 SQL문을 작성해주세요. 결과는 회원 ID를 기준으로 오름차순 정렬해주시고 회원 ID가 같다면 상품 ID를 기준으로 내림차순 정렬해주세요. 예시 예를 들어 ONLINE_SALE 테이블이 다음과 같다면 ONLINE_SALE_ID USER_ID PRODUCT_ID SALES_AMOUNT SALES_DATE 1 1 3 2 2022-02-25 2 1 4 1 2022-03-01 4 2 4 2 2022-03-12 3 1 3 3 2022-03-31 5 3 5 1 2022-04-03 6 2 4 1 2022-04-06 2 1 4 2 2022-05-11 USER_ID 가 1인 유저가 PRODUCT_ID 가 3, 4인 상품들을 재구매하고, USER_ID 가 2인 유저가 PRODUCT_ID 가 4인 상품을 재구매 하였으므로, 다음과 같이 결과가 나와야합니다. USER_ID PRODUCT_ID 1 4 1 3 2 4",normal,database
77,"다음은 어느 의류 쇼핑몰에 가입한 회원 정보를 담은 USER_INFO 테이블과 온라인 상품 판매 정보를 담은 ONLINE_SALE 테이블 입니다. USER_INFO 테이블은 아래와 같은 구조로 되어있으며 USER_ID, GENDER, AGE, JOINED는 각각 회원 ID, 성별, 나이, 가입일을 나타냅니다. Column name Type Nullable USER_ID INTEGER FALSE GENDER TINYINT(1) TRUE AGE INTEGER TRUE JOINED DATE FALSE GENDER 컬럼은 비어있거나 0 또는 1의 값을 가지며 0인 경우 남자를, 1인 경우는 여자를 나타냅니다. ONLINE_SALE 테이블은 아래와 같은 구조로 되어있으며 ONLINE_SALE_ID, USER_ID, PRODUCT_ID, SALES_AMOUNT, SALES_DATE는 각각 온라인 상품 판매 ID, 회원 ID, 상품 ID, 판매량, 판매일을 나타냅니다. Column name Type Nullable ONLINE_SALE_ID INTEGER FALSE USER_ID INTEGER FALSE PRODUCT_ID INTEGER FALSE SALES_AMOUNT INTEGER FALSE SALES_DATE DATE FALSE 동일한 날짜, 회원 ID, 상품 ID 조합에 대해서는 하나의 판매 데이터만 존재합니다. 문제 USER_INFO 테이블과 ONLINE_SALE 테이블에서 2021년에 가입한 전체 회원들 중 상품을 구매한 회원수와 상품을 구매한 회원의 비율(=2021년에 가입한 회원 중 상품을 구매한 회원수 / 2021년에 가입한 전체 회원 수)을 년, 월 별로 출력하는 SQL문을 작성해주세요. 상품을 구매한 회원의 비율은 소수점 두번째자리에서 반올림하고, 전체 결과는 년을 기준으로 오름차순 정렬해주시고 년이 같다면 월을 기준으로 오름차순 정렬해주세요. 예시 예를 들어 USER_INFO 테이블이 다음과 같고 USER_ID GENDER AGE JOINED 1 1 26 2021-06-01 2 NULL NULL 2021-06-25 3 0 NULL 2021-06-30 4 0 31 2021-07-03 5 1 25 2022-01-09 6 1 33 2022-02-14 ONLINE_SALE 이 다음과 같다면 ONLINE_SALE_ID USER_ID PRODUCT_ID SALES_AMOUNT SALES_DATE 1 1 54 1 2022-01-01 2 1 3 2 2022-01-25 3 4 34 1 2022-01-30 4 6 253 3 2022-02-03 5 2 31 2 2022-02-09 6 5 35 1 2022-02-14 7 5 57 1 2022-02-18 2021년에 가입한 회원은 USER_ID가 1, 2, 3, 4 인 회원들로 총 4명 입니다. ONLINE_SALE 테이블에서 해당 회원들에 대한 판매 데이터는 다음과 같습니다. ONLINE_SALE_ID USER_ID PRODUCT_ID SALES_AMOUNT SALES_DATE 1 1 54 1 2022-01-01 2 1 3 2 2022-01-25 3 4 34 1 2022-01-30 5 2 31 2 2022-02-09 그러므로 년, 월 별로 상품을 구매한 회원수와 상품을 구매한 회원의 비율을 구하고 결과를 정렬하면 다음과 같아야 합니다. YEAR MONTH PURCHASED_USERS PUCHASED_RATIO 2022 1 2 0.5 2022 2 1 0.3",hard,database
78,"다음은 어느 의류 쇼핑몰에서 판매중인 상품들의 상품 정보를 담은 PRODUCT 테이블과 오프라인 상품 판매 정보를 담은 OFFLINE_SALE 테이블 입니다. PRODUCT 테이블은 아래와 같은 구조로 PRODUCT_ID, PRODUCT_CODE, PRICE는 각각 상품 ID, 상품코드, 판매가를 나타냅니다. Column name Type Nullable PRODUCT_ID INTEGER FALSE PRODUCT_CODE VARCHAR(8) FALSE PRICE INTEGER FALSE 상품 별로 중복되지 않는 8자리 상품코드 값을 가지며, 앞 2자리는 카테고리 코드를 의미합니다. OFFLINE_SALE 테이블은 아래와 같은 구조로 되어있으며 OFFLINE_SALE_ID, PRODUCT_ID, SALES_AMOUNT, SALES_DATE는 각각 오프라인 상품 판매 ID, 상품 ID, 판매량, 판매일을 나타냅니다. Column name Type Nullable OFFLINE_SALE_ID INTEGER FALSE PRODUCT_ID INTEGER FALSE SALES_AMOUNT INTEGER FALSE SALES_DATE DATE FALSE 동일한 날짜, 상품 ID 조합에 대해서는 하나의 판매 데이터만 존재합니다. 문제 PRODUCT 테이블과 OFFLINE_SALE 테이블에서 상품코드 별 매출액(판매가 * 판매량) 합계를 출력하는 SQL문을 작성해주세요. 결과는 매출액을 기준으로 내림차순 정렬해주시고 매출액이 같다면 상품코드를 기준으로 오름차순 정렬해주세요. 예시 예를 들어 PRODUCT 테이블이 다음과 같고 PRODUCT_ID PRODUCT_CODE PRICE 1 A1000011 15000 2 A1000045 8000 3 C3000002 42000 OFFLINE_SALE 테이블이 다음과 같다면 OFFLINE_SALE_ID PRODUCT_ID SALES_AMOUNT SALES_DATE 1 1 2 2022-02-21 2 1 2 2022-03-02 3 3 3 2022-05-01 4 2 1 2022-05-24 5 1 2 2022-07-14 6 2 1 2022-09-22 각 상품 별 총 판매량과 판매가는 다음과 같습니다. PRODUCT_CODE 가 A1000011인 상품은 총 판매량이 6개, 판매가가 15,000원 PRODUCT_CODE 가 A1000045인 상품은 총 판매량이 2개, 판매가가 8,000원 PRODUCT_CODE 가 C3000002인 상품은 총 판매량이 3개, 판매가가 42,000원 그러므로 각 상품 별 매출액을 계산하고 정렬하면 결과가 다음과 같이 나와야 합니다. PRODUCT_CODE SALES C3000002 126000 A1000011 90000 A1000045 16000",normal,database
79,"다음은 어느 의류 쇼핑몰에 가입한 회원 정보를 담은 USER_INFO 테이블과 온라인 상품 판매 정보를 담은 ONLINE_SALE 테이블 입니다.USER_INFO 테이블은 아래와 같은 구조로 되어있으며 USER_ID, GENDER, AGE, JOINED는 각각 회원 ID, 성별, 나이, 가입일을 나타냅니다. Column name Type Nullable USER_ID INTEGER FALSE GENDER TINYINT(1) TRUE AGE INTEGER TRUE JOINED DATE FALSE GENDER 컬럼은 비어있거나 0 또는 1의 값을 가지며 0인 경우 남자를, 1인 경우는 여자를 나타냅니다. ONLINE_SALE 테이블은 아래와 같은 구조로 되어있으며, ONLINE_SALE_ID, USER_ID, PRODUCT_ID, SALES_AMOUNT, SALES_DATE는 각각 온라인 상품 판매 ID, 회원 ID, 상품 ID, 판매량, 판매일을 나타냅니다. Column name Type Nullable ONLINE_SALE_ID INTEGER FALSE USER_ID INTEGER FALSE PRODUCT_ID INTEGER FALSE SALES_AMOUNT INTEGER FALSE SALES_DATE DATE FALSE 동일한 날짜, 회원 ID, 상품 ID 조합에 대해서는 하나의 판매 데이터만 존재합니다. 문제 USER_INFO 테이블과 ONLINE_SALE 테이블에서 년, 월, 성별 별로 상품을 구매한 회원수를 집계하는 SQL문을 작성해주세요. 결과는 년, 월, 성별을 기준으로 오름차순 정렬해주세요. 이때, 성별 정보가 없는 경우 결과에서 제외해주세요. 예시 예를 들어 USER_INFO 테이블이 다음과 같고 USER_ID GENDER AGE JOINED 1 1 26 2021-06-01 2 NULL NULL 2021-06-25 3 0 NULL 2021-06-30 4 0 31 2021-07-03 5 1 25 2021-07-09 6 1 33 2021-07-14 ONLINE_SALE 테이블이 다음과 같다면 ONLINE_SALE_ID USER_ID PRODUCT_ID SALES_AMOUNT SALES_DATE 1 1 54 1 2022-01-01 2 1 3 2 2022-01-25 3 4 34 1 2022-01-30 4 6 253 3 2022-02-03 5 2 31 2 2022-02-09 6 5 35 1 2022-02-14 7 5 57 1 2022-02-18 2022년 1월에 상품을 구매한 회원은 USER_ID 가 1(GENDER=1), 4(GENDER=0)인 회원들이고, 2022년 2월에 상품을 구매한 회원은 USER_ID 가 2(GENDER=NULL), 5(GENDER=1), 6(GENDER=1)인 회원들 이므로, 년, 월, 성별 별로 상품을 구매한 회원수를 집계하고, 년, 월, 성별을 기준으로 오름차순 정렬하면 다음과 같은 결과가 나와야 합니다. YEAR MONTH GENDER USERS 2022 1 0 1 2022 1 1 1 2022 2 1 2",hard,database
80,"다음은 어느 의류 쇼핑몰에서 판매중인 상품들의 정보를 담은 PRODUCT 테이블입니다. PRODUCT 테이블은 아래와 같은 구조로 되어있으며, PRODUCT_ID, PRODUCT_CODE, PRICE는 각각 상품 ID, 상품코드, 판매가를 나타냅니다. Column name Type Nullable PRODUCT_ID INTEGER FALSE PRODUCT_CODE VARCHAR(8) FALSE PRICE INTEGER FALSE 상품 별로 중복되지 않는 8자리 상품코드 값을 가지며 앞 2자리는 카테고리 코드를 나타냅니다. 문제 PRODUCT 테이블에서 만원 단위의 가격대 별로 상품 개수를 출력하는 SQL 문을 작성해주세요. 이때 컬럼명은 각각 컬럼명은 PRICE_GROUP, PRODUCTS로 지정해주시고 가격대 정보는 각 구간의 최소금액(10,000원 이상 ~ 20,000 미만인 구간인 경우 10,000)으로 표시해주세요. 결과는 가격대를 기준으로 오름차순 정렬해주세요. 예시 예를 들어 PRODUCT 테이블이 다음과 같다면 PRODUCT_ID PRODUCT_CODE PRICE 1 A1000011 10000 2 A1000045 9000 3 C3000002 22000 4 C3000006 15000 5 C3000010 30000 6 K1000023 17000 만원 단위의 가격대 별로 상품을 나누면 가격대가 0원 ~ 1만원 미만인 상품은 PRODUCT_ID 가 2인 상품 1개, 가격대가 1만원 이상 ~ 2만원 미만인 상품들은 PRODUCT_ID 가 1, 4, 6인 상품 3개, 가격대가 2만원 이상 ~ 3만원 미만인 상품은 PRODUCT_ID 가 3인 상품 1개, 가격대가 3만원 이상 ~ 4만원 미만인 상품은 PRODUCT_ID 가 5인 상품 1개, 에 각각 해당하므로 다음과 같이 결과가 나와야 합니다. PRICE_GROUP PRODUCTS 0 1 10000 3 20000 1 30000 1",normal,database
81,"다음은 어느 의류 쇼핑몰에서 판매중인 상품들의 정보를 담은 PRODUCT 테이블입니다. PRODUCT 테이블은 아래와 같은 구조로 되어있으며, PRODUCT_ID, PRODUCT_CODE, PRICE는 각각 상품 ID, 상품코드, 판매가를 나타냅니다. Column name Type Nullable PRODUCT_ID INTEGER FALSE PRODUCT_CODE VARCHAR(8) FALSE PRICE INTEGER FALSE 상품 별로 중복되지 않는 8자리 상품코드 값을 가지며, 앞 2자리는 카테고리 코드를 의미합니다. 문제 PRODUCT 테이블에서 상품 카테고리 코드(PRODUCT_CODE 앞 2자리) 별 상품 개수를 출력하는 SQL문을 작성해주세요. 결과는 상품 카테고리 코드를 기준으로 오름차순 정렬해주세요. 예시 예를 들어 PRODUCT 테이블이 다음과 같다면 PRODUCT_ID PRODUCT_CODE PRICE 1 A1000011 10000 2 A1000045 9000 3 C3000002 22000 4 C3000006 15000 5 C3000010 30000 6 K1000023 17000 상품 카테고리 코드 별 상품은 아래와 같으므로, A1: PRODUCT_ID가 1, 2 인 상품 C3: PRODUCT_ID가 3, 4, 5 인 상품 K1: PRODUCT_ID가 6 인 상품 다음과 같은 결과가 나와야 합니다. CATEGORY PRODUCTS A1 2 C3 3 K1 1",normal,database
82,"혼자서도 잘 노는 범희는 어느 날 방구석에 있는 숫자 카드 더미를 보더니 혼자 할 수 있는 재미있는 게임을 생각해냈습니다. 숫자 카드 더미에는 카드가 총 100장 있으며, 각 카드에는 1부터 100까지 숫자가 하나씩 적혀있습니다. 2 이상 100 이하의 자연수를 하나 정해 그 수보다 작거나 같은 숫자 카드들을 준비하고, 준비한 카드의 수만큼 작은 상자를 준비하면 게임을 시작할 수 있으며 게임 방법은 다음과 같습니다. 준비된 상자에 카드를 한 장씩 넣고, 상자를 무작위로 섞어 일렬로 나열합니다. 상자가 일렬로 나열되면 상자가 나열된 순서에 따라 1번부터 순차적으로 증가하는 번호를 붙입니다. 그 다음 임의의 상자를 하나 선택하여 선택한 상자 안의 숫자 카드를 확인합니다. 다음으로 확인한 카드에 적힌 번호에 해당하는 상자를 열어 안에 담긴 카드에 적힌 숫자를 확인합니다. 마찬가지로 숫자에 해당하는 번호를 가진 상자를 계속해서 열어가며, 열어야 하는 상자가 이미 열려있을 때까지 반복합니다. 이렇게 연 상자들은 1번 상자 그룹입니다. 이제 1번 상자 그룹을 다른 상자들과 섞이지 않도록 따로 둡니다. 만약 1번 상자 그룹을 제외하고 남는 상자가 없으면 그대로 게임이 종료되며, 이때 획득하는 점수는 0점입니다. 그렇지 않다면 남은 상자 중 다시 임의의 상자 하나를 골라 같은 방식으로 이미 열려있는 상자를 만날 때까지 상자를 엽니다. 이렇게 연 상자들은 2번 상자 그룹입니다. 1번 상자 그룹에 속한 상자의 수와 2번 상자 그룹에 속한 상자의 수를 곱한 값이 게임의 점수입니다. 상자 안에 들어있는 카드 번호가 순서대로 담긴 배열 cards가 매개변수로 주어질 때, 범희가 이 게임에서 얻을 수 있는 최고 점수를 구해서 return 하도록 solution 함수를 완성해주세요. 제한사항 2 ≤ cards의 길이 ≤ 100 cards의 원소는 cards의 길이 이하인 임의의 자연수입니다. cards에는 중복되는 원소가 존재하지 않습니다. cards[i]는 i + 1번 상자에 담긴 카드에 적힌 숫자를 의미합니다. 입출력 예 cards result [8,6,3,7,2,5,1,4] 12",normal,Array
83,"프로그래머스 다트 협회에서는 매년마다 새로운 특수 룰으로 다트 대회를 개최합니다. 이번 대회의 룰은 ""카운트 다운""으로 ""제로원"" 룰의 변형 룰입니다. ""카운트 다운""은 게임이 시작되면 무작위로 점수가 정해지고, 다트를 던지면서 점수를 깎아서 정확히 0점으로 만드는 게임입니다. 단, 남은 점수보다 큰 점수로 득점하면 버스트가 되며 실격 합니다. 다음 그림은 다트 과녁입니다. 다트 과녁에는 1 부터 20 까지의 수가 하나씩 있고 각 수마다 ""싱글"", ""더블"", ""트리플"" 칸이 있습니다. ""싱글""을 맞히면 해당 수만큼 점수를 얻고 ""더블""을 맞히면 해당 수의 두 배만큼 점수를 얻고 ""트리플""을 맞히면 해당 수의 세 배만큼 점수를 얻습니다. 가운데에는 ""불""과 ""아우터 불""이 있는데 ""카운트 다운"" 게임에서는 구분 없이 50점을 얻습니다. 대회는 토너먼트로 진행되며 한 게임에는 두 선수가 참가하게 됩니다. 게임은 두 선수가 교대로 한 번씩 던지는 라운드 방식으로 진행됩니다. 가장 먼저 0점을 만든 선수가 승리하는데 만약 두 선수가 같은 라운드에 0점을 만들면 두 선수 중 ""싱글"" 또는 ""불""을 더 많이 던진 선수가 승리하며 그마저도 같다면 선공인 선수가 승리합니다. 다트 실력에 자신 있던 종호는 이 대회에 출전하기로 하였습니다. 최소한의 다트로 0점을 만드는 게 가장 중요하고, 그러한 방법이 여러가지가 있다면 ""싱글"" 또는 ""불""을 최대한 많이 던지는 방법을 선택해야 합니다. 목표 점수 target이 매개변수로 주어졌을 때 최선의 경우 던질 다트 수와 그 때의 ""싱글"" 또는 ""불""을 맞춘 횟수(합)를 순서대로 배열에 담아 return 하도록 solution 함수를 완성해 주세요. 제한사항 1 ≤ target ≤ 100,000 입출력 예 target result 21 [1,0] 58 [2,2] 입출력 예 설명",normal,Array
84,"XYZ 마트는 일정한 금액을 지불하면 10일 동안 회원 자격을 부여합니다. XYZ 마트에서는 회원을 대상으로 매일 한 가지 제품을 할인하는 행사를 합니다. 할인하는 제품은 하루에 하나씩만 구매할 수 있습니다. 알뜰한 정현이는 자신이 원하는 제품과 수량이 할인하는 날짜와 10일 연속으로 일치할 경우에 맞춰서 회원가입을 하려 합니다. 예를 들어, 정현이가 원하는 제품이 바나나 3개, 사과 2개, 쌀 2개, 돼지고기 2개, 냄비 1개이며, XYZ 마트에서 14일간 회원을 대상으로 할인하는 제품이 날짜 순서대로 치킨, 사과, 사과, 바나나, 쌀, 사과, 돼지고기, 바나나, 돼지고기, 쌀, 냄비, 바나나, 사과, 바나나인 경우에 대해 알아봅시다. 첫째 날부터 열흘 간에는 냄비가 할인하지 않기 때문에 첫째 날에는 회원가입을 하지 않습니다. 둘째 날부터 열흘 간에는 바나나를 원하는 만큼 할인구매할 수 없기 때문에 둘째 날에도 회원가입을 하지 않습니다. 셋째 날, 넷째 날, 다섯째 날부터 각각 열흘은 원하는 제품과 수량이 일치하기 때문에 셋 중 하루에 회원가입을 하려 합니다. 정현이가 원하는 제품을 나타내는 문자열 배열 want와 정현이가 원하는 제품의 수량을 나타내는 정수 배열 number, XYZ 마트에서 할인하는 제품을 나타내는 문자열 배열 discount가 주어졌을 때, 회원등록시 정현이가 원하는 제품을 모두 할인 받을 수 있는 회원등록 날짜의 총 일수를 return 하는 solution 함수를 완성하시오. 가능한 날이 없으면 0을 return 합니다. 제한사항 1 ≤ want의 길이 = number의 길이 ≤ 10 1 ≤ number의 원소 ≤ 10 number[i]는 want[i]의 수량을 의미하며, number의 원소의 합은 10입니다. 10 ≤ discount의 길이 ≤ 100,000 want와 discount의 원소들은 알파벳 소문자로 이루어진 문자열입니다. 1 ≤ want의 원소의 길이, discount의 원소의 길이 ≤ 12 입출력 예 want number discount result [""banana"", ""apple"", ""rice"", ""pork"", ""pot""] [3, 2, 2, 2, 1] [""chicken"", ""apple"", ""apple"", ""banana"", ""rice"", ""apple"", ""pork"", ""banana"", ""pork"", ""rice"", ""pot"", ""banana"", ""apple"", ""banana""] 3 [""apple""] [10] [""banana"", ""banana"", ""banana"", ""banana"", ""banana"", ""banana"", ""banana"", ""banana"", ""banana"", ""banana""] 0 입출력 예 설명",normal,Array
85,"다음은 고객의 정보를 담은 MEMBER_PROFILE테이블과 식당의 리뷰 정보를 담은 REST_REVIEW 테이블입니다. MEMBER_PROFILE 테이블은 다음과 같으며 MEMBER_ID, MEMBER_NAME, TLNO, GENDER, DATE_OF_BIRTH는 회원 ID, 회원 이름, 회원 연락처, 성별, 생년월일을 의미합니다. Column name Type Nullable MEMBER_ID VARCHAR(100) FALSE MEMBER_NAME VARCHAR(50) FALSE TLNO VARCHAR(50) TRUE GENDER VARCHAR(1) TRUE DATE_OF_BIRTH DATE TRUE REST_REVIEW 테이블은 다음과 같으며 REVIEW_ID, REST_ID, MEMBER_ID, REVIEW_SCORE, REVIEW_TEXT,REVIEW_DATE는 각각 리뷰 ID, 식당 ID, 회원 ID, 점수, 리뷰 텍스트, 리뷰 작성일을 의미합니다. Column name Type Nullable REVIEW_ID VARCHAR(10) FALSE REST_ID VARCHAR(10) TRUE MEMBER_ID VARCHAR(100) TRUE REVIEW_SCORE NUMBER TRUE REVIEW_TEXT VARCHAR(1000) TRUE REVIEW_DATE DATE TRUE 문제 MEMBER_PROFILE와 REST_REVIEW 테이블에서 리뷰를 가장 많이 작성한 회원의 리뷰들을 조회하는 SQL문을 작성해주세요. 회원 이름, 리뷰 텍스트, 리뷰 작성일이 출력되도록 작성해주시고, 결과는 리뷰 작성일을 기준으로 오름차순, 리뷰 작성일이 같다면 리뷰 텍스트를 기준으로 오름차순 정렬해주세요. 예시 MEMBER_PROFILE 테이블이 다음과 같고 MEMBER_ID MEMBER_NAME TLNO GENDER DATE_OF_BIRTH jiho92@naver.com 이지호 01076432111 W 1992-02-12 jiyoon22@hotmail.com 김지윤 01032324117 W 1992-02-22 jihoon93@hanmail.net 김지훈 01023258688 M 1993-02-23 seoyeons@naver.com 박서연 01076482209 W 1993-03-16 yelin1130@gmail.com 조예린 01017626711 W 1990-11-30 REST_REVIEW 테이블이 다음과 같을 때 REVIEW_ID REST_ID MEMBER_ID REVIEW_SCORE REVIEW_TEXT REVIEW_DATE R000000065 00028 soobin97@naver.com 5 부찌 국물에서 샤브샤브 맛이나고 깔끔 2022-04-12 R000000066 00039 yelin1130@gmail.com 5 김치찌개 최곱니다. 2022-02-12 R000000067 00028 yelin1130@gmail.com 5 햄이 많아서 좋아요 2022-02-22 R000000068 00035 ksyi0316@gmail.com 5 숙성회가 끝내줍니다. 2022-02-15 R000000069 00035 yoonsy95@naver.com 4 비린내가 전혀없어요. 2022-04-16 SQL을 실행하면 다음과 같이 출력되어야 합니다. MEMBER_NAME REVIEW_TEXT REVIEW_DATE 조예린 김치찌개 최곱니다. 2022-02-12 조예린 햄이 많아서 좋아요 2022-02-22 주의사항 REVIEW_DATE의 데이트 포맷이 예시와 동일해야 정답처리 됩니다.",hard,database
86,"다음은 식당의 정보를 담은 REST_INFO 테이블입니다. REST_INFO 테이블은 다음과 같으며 REST_ID, REST_NAME, FOOD_TYPE, VIEWS, FAVORITES, PARKING_LOT, ADDRESS, TEL은 식당 ID, 식당 이름, 음식 종류, 조회수, 즐겨찾기수, 주차장 유무, 주소, 전화번호를 의미합니다. Column name Type Nullable REST_ID VARCHAR(5) FALSE REST_NAME VARCHAR(50) FALSE FOOD_TYPE VARCHAR(20) TRUE VIEWS NUMBER TRUE FAVORITES NUMBER TRUE PARKING_LOT VARCHAR(1) TRUE ADDRESS VARCHAR(100) TRUE TEL VARCHAR(100) TRUE 문제 REST_INFO 테이블에서 음식종류별로 즐겨찾기수가 가장 많은 식당의 음식 종류, ID, 식당 이름, 즐겨찾기수를 조회하는 SQL문을 작성해주세요. 이때 결과는 음식 종류를 기준으로 내림차순 정렬해주세요. 예시 REST_INFO 테이블이 다음과 같을 때 REST_ID REST_NAME FOOD_TYPE VIEWS FAVORITES PARKING_LOT ADDRESS TEL 00001 은돼지식당 한식 1150345 734 N 서울특별시 중구 다산로 149 010-4484-8751 00002 하이가쯔네 일식 120034 112 N 서울시 중구 신당동 375-21 NULL 00003 따띠따띠뜨 양식 1234023 102 N 서울시 강남구 신사동 627-3 1F 02-6397-1023 00004 스시사카우스 일식 1522074 230 N 서울시 서울시 강남구 신사동 627-27 010-9394-2554 00005 코슌스 일식 15301 123 N 서울특별시 강남구 언주로153길 010-1315-8729 SQL을 실행하면 다음과 같이 출력되어야 합니다. FOOD_TYPE REST_ID REST_NAME FAVORITES 한식 00001 은돼지식당 734 일식 00004 스시사카우스 230 양식 00003 따띠따띠뜨 102",normal,database
87,"다음은 식당 리뷰 사이트의 회원 정보를 담은 MEMBER_PROFILE 테이블입니다. MEMBER_PROFILE 테이블은 다음과 같으며 MEMBER_ID, MEMBER_NAME, TLNO, GENDER, DATE_OF_BIRTH는 회원 ID, 회원 이름, 회원 연락처, 성별, 생년월일을 의미합니다. Column name Type Nullable MEMBER_ID VARCHAR(100) FALSE MEMBER_NAME VARCHAR(50) FALSE TLNO VARCHAR(50) TRUE GENDER VARCHAR(1) TRUE DATE_OF_BIRTH DATE TRUE 문제 MEMBER_PROFILE 테이블에서 생일이 3월인 여성 회원의 ID, 이름, 성별, 생년월일을 조회하는 SQL문을 작성해주세요. 이때 전화번호가 NULL인 경우는 출력대상에서 제외시켜 주시고, 결과는 회원ID를 기준으로 오름차순 정렬해주세요. 예시 MEMBER_PROFILE 테이블이 다음과 같을 때 MEMBER_ID MEMBER_NAME TLNO GENDER DATE_OF_BIRTH jiho92@naver.com 이지호 01076432111 W 1992-02-12 jiyoon22@hotmail.com 김지윤 01032324117 W 1992-02-22 jihoon93@hanmail.net 김지훈 01023258688 M 1993-02-23 seoyeons@naver.com 박서연 01076482209 W 1993-03-16 yoonsy94@gmail.com 윤서연 NULL W 1994-03-19 SQL을 실행하면 다음과 같이 출력되어야 합니다. MEMBER_ID MEMBER_NAME GENDER DATE_OF_BIRTH seoyeons@naver.com 박서연 W 1993-03-16 주의사항 DATE_OF_BIRTH의 데이트 포맷이 예시와 동일해야 정답처리 됩니다.",normal,database
88,"다음은 식당의 정보를 담은 REST_INFO 테이블과 식당의 리뷰 정보를 담은 REST_REVIEW 테이블입니다. REST_INFO 테이블은 다음과 같으며 REST_ID, REST_NAME, FOOD_TYPE, VIEWS, FAVORITES, PARKING_LOT, ADDRESS, TEL은 식당 ID, 식당 이름, 음식 종류, 조회수, 즐겨찾기수, 주차장 유무, 주소, 전화번호를 의미합니다. Column name Type Nullable REST_ID VARCHAR(5) FALSE REST_NAME VARCHAR(50) FALSE FOOD_TYPE VARCHAR(20) TRUE VIEWS NUMBER TRUE FAVORITES NUMBER TRUE PARKING_LOT VARCHAR(1) TRUE ADDRESS VARCHAR(100) TRUE TEL VARCHAR(100) TRUE REST_REVIEW 테이블은 다음과 같으며 REVIEW_ID, REST_ID, MEMBER_ID, REVIEW_SCORE, REVIEW_TEXT,REVIEW_DATE는 각각 리뷰 ID, 식당 ID, 회원 ID, 점수, 리뷰 텍스트, 리뷰 작성일을 의미합니다. Column name Type Nullable REVIEW_ID VARCHAR(10) FALSE REST_ID VARCHAR(10) TRUE MEMBER_ID VARCHAR(100) TRUE REVIEW_SCORE NUMBER TRUE REVIEW_TEXT VARCHAR(1000) TRUE REVIEW_DATE DATE TRUE 문제 REST_INFO와 REST_REVIEW 테이블에서 서울에 위치한 식당들의 식당 ID, 식당 이름, 음식 종류, 즐겨찾기수, 주소, 리뷰 평균 점수를 조회하는 SQL문을 작성해주세요. 이때 리뷰 평균점수는 소수점 세 번째 자리에서 반올림 해주시고 결과는 평균점수를 기준으로 내림차순 정렬해주시고, 평균점수가 같다면 즐겨찾기수를 기준으로 내림차순 정렬해주세요. 예시 REST_INFO 테이블이 다음과 같고 REST_ID REST_NAME FOOD_TYPE VIEWS FAVORITES PARKING_LOT ADDRESS TEL 00028 대우부대찌개 한식 52310 10 N 경기도 용인시 처인구 남사읍 처인성로 309 031-235-1235 00039 광주식당 한식 23001 20 N 경기도 부천시 산업로8번길 60 031-235-6423 00035 삼촌식당 일식 532123 80 N 서울특별시 강서구 가로공원로76가길 02-135-1266 REST_REVIEW 테이블이 다음과 같을 때 REVIEW_ID REST_ID MEMBER_ID REVIEW_SCORE REVIEW_TEXT REVIEW_DATE R000000065 00028 soobin97@naver.com 5 부찌 국물에서 샤브샤브 맛이나고 깔끔 2022-04-12 R000000066 00039 yelin1130@gmail.com 5 김치찌개 최곱니다. 2022-02-12 R000000067 00028 yelin1130@gmail.com 5 햄이 많아서 좋아요 2022-02-22 R000000068 00035 ksyi0316@gmail.com 5 숙성회가 끝내줍니다. 2022-02-15 R000000069 00035 yoonsy95@naver.com 4 비린내가 전혀없어요. 2022-04-16 SQL을 실행하면 다음과 같이 출력되어야 합니다. REST_ID REST_NAME FOOD_TYPE FAVORITES ADDRESS SCORE 00035 삼촌식당 일식 80 서울특별시 강서구 가로공원로76가길 4.50",hard,database
89,"다음은 식품의 정보를 담은 FOOD_PRODUCT 테이블과 식품의 주문 정보를 담은 FOOD_ORDER 테이블입니다. FOOD_PRODUCT 테이블은 다음과 같으며 PRODUCT_ID, PRODUCT_NAME, PRODUCT_CD, CATEGORY, PRICE는 식품 ID, 식품 이름, 식품코드, 식품분류, 식품 가격을 의미합니다. Column name Type Nullable PRODUCT_ID VARCHAR(10) FALSE PRODUCT_NAME VARCHAR(50) FALSE PRODUCT_CD VARCHAR(10) TRUE CATEGORY VARCHAR(10) TRUE PRICE NUMBER TRUE FOOD_ORDER 테이블은 다음과 같으며 ORDER_ID, PRODUCT_ID, AMOUNT, PRODUCE_DATE, IN_DATE, OUT_DATE, FACTORY_ID, WAREHOUSE_ID는 각각 주문 ID, 제품 ID, 주문량, 생산일자, 입고일자, 출고일자, 공장 ID, 창고 ID를 의미합니다. Column name Type Nullable ORDER_ID VARCHAR(10) FALSE PRODUCT_ID VARCHAR(5) FALSE AMOUNT NUMBER FALSE PRODUCE_DATE DATE TRUE IN_DATE DATE TRUE OUT_DATE DATE TRUE FACTORY_ID VARCHAR(10) FALSE WAREHOUSE_ID VARCHAR(10) FALSE 문제 FOOD_PRODUCT와 FOOD_ORDER 테이블에서 생산일자가 2022년 5월인 식품들의 식품 ID, 식품 이름, 총매출을 조회하는 SQL문을 작성해주세요. 이때 결과는 총매출을 기준으로 내림차순 정렬해주시고 총매출이 같다면 식품 ID를 기준으로 오름차순 정렬해주세요. 예시 FOOD_PRODUCT 테이블이 다음과 같고 PRODUCT_ID PRODUCT_NAME PRODUCT_CD CATEGORY PRICE P0011 맛있는콩기름 CD_OL00001 식용유 4880 P0012 맛있는올리브유 CD_OL00002 식용유 7200 P0013 맛있는포도씨유 CD_OL00003 식용유 5950 P0014 맛있는마조유 CD_OL00004 식용유 8950 P0015 맛있는화조유 CD_OL00005 식용유 8800 P0016 맛있는참기름 CD_OL00006 식용유 7100 P0017 맛있는들기름 CD_OL00007 식용유 7900 P0018 맛있는고추기름 CD_OL00008 식용유 6100 P0019 맛있는카놀라유 CD_OL00009 식용유 5100 P0020 맛있는산초유 CD_OL00010 식용유 6500 FOOD_ORDER 테이블이 다음과 같을 때 ORDER_ID PRODUCT_ID AMOUNT PRODUCE_DATE IN_DATE OUT_DATE FACTORY_ID WAREHOUSE_ID OD00000056 P0012 1000 2022-04-04 2022-04-21 2022-04-25 FT19980002 WH0032 OD00000057 P0014 2500 2022-04-14 2022-04-27 2022-05-01 FT19980002 WH0033 OD00000058 P0017 1200 2022-05-19 2022-05-28 2022-05-28 FT20070002 WH0033 OD00000059 P0017 1000 2022-05-24 2022-05-30 2022-05-30 FT20070002 WH0038 OD00000060 P0019 2000 2022-05-29 2022-06-08 2022-06-08 FT20070002 WH0035 SQL을 실행하면 다음과 같이 출력되어야 합니다. PRODUCT_ID PRODUCT_NAME TOTAL_SALES P0017 맛있는들기름 17380000 P0019 맛있는카놀라유 10200000",hard,database
90,"다음은 식품의 정보를 담은 FOOD_PRODUCT 테이블입니다. FOOD_PRODUCT 테이블은 다음과 같으며 PRODUCT_ID, PRODUCT_NAME, PRODUCT_CD, CATEGORY, PRICE는 식품 ID, 식품 이름, 식품코드, 식품분류, 식품 가격을 의미합니다. Column name Type Nullable PRODUCT_ID VARCHAR(10) FALSE PRODUCT_NAME VARCHAR(50) FALSE PRODUCT_CD VARCHAR(10) TRUE CATEGORY VARCHAR(10) TRUE PRICE NUMBER TRUE 문제 FOOD_PRODUCT 테이블에서 식품분류별로 가격이 제일 비싼 식품의 분류, 가격, 이름을 조회하는 SQL문을 작성해주세요. 이때 식품분류가 '과자', '국', '김치', '식용유'인 경우만 출력시켜 주시고 결과는 식품 가격을 기준으로 내림차순 정렬해주세요. 예시 FOOD_PRODUCT 테이블이 다음과 같을 때 PRODUCT_ID PRODUCT_NAME PRODUCT_CD CATEGORY PRICE P0018 맛있는고추기름 CD_OL00008 식용유 6100 P0019 맛있는카놀라유 CD_OL00009 식용유 5100 P0020 맛있는산초유 CD_OL00010 식용유 6500 P0021 맛있는케첩 CD_SC00001 소스 4500 P0022 맛있는마요네즈 CD_SC00002 소스 4700 P0039 맛있는황도 CD_CN00008 캔 4100 P0040 맛있는명이나물 CD_CN00009 캔 3500 P0041 맛있는보리차 CD_TE00010 차 3400 P0042 맛있는메밀차 CD_TE00001 차 3500 P0099 맛있는맛동산 CD_CK00002 과자 1800 SQL을 실행하면 다음과 같이 출력되어야 합니다. CATEGORY MAX_PRICE PRODUCT_NAME 식용유 6500 맛있는산초유 과자 1800 맛있는맛동산",hard,database
91,"다음은 식품의 정보를 담은 FOOD_PRODUCT 테이블입니다. FOOD_PRODUCT 테이블은 다음과 같으며 PRODUCT_ID, PRODUCT_NAME, PRODUCT_CD, CATEGORY, PRICE는 식품 ID, 식품 이름, 식품 코드, 식품분류, 식품 가격을 의미합니다. Column name Type Nullable PRODUCT_ID VARCHAR(10) FALSE PRODUCT_NAME VARCHAR(50) FALSE PRODUCT_CD VARCHAR(10) TRUE CATEGORY VARCHAR(10) TRUE PRICE NUMBER TRUE 문제 FOOD_PRODUCT 테이블에서 가격이 제일 비싼 식품의 식품 ID, 식품 이름, 식품 코드, 식품분류, 식품 가격을 조회하는 SQL문을 작성해주세요. 예시 FOOD_PRODUCT 테이블이 다음과 같을 때 PRODUCT_ID PRODUCT_NAME PRODUCT_CD CATEGORY PRICE P0018 맛있는고추기름 CD_OL00008 식용유 6100 P0019 맛있는카놀라유 CD_OL00009 식용유 5100 P0020 맛있는산초유 CD_OL00010 식용유 6500 P0021 맛있는케첩 CD_OL00001 소스 4500 P0022 맛있는마요네즈 CD_OL00002 소스 4700 SQL을 실행하면 다음과 같이 출력되어야 합니다. PRODUCT_ID PRODUCT_NAME PRODUCT_CD CATEGORY PRICE P0020 맛있는산초유 CD_OL00010 식용유 6500",normal,database
92,"다음은 식품공장의 주문정보를 담은 FOOD_ORDER 테이블입니다. FOOD_ORDER 테이블은 다음과 같으며 ORDER_ID, PRODUCT_ID, AMOUNT, PRODUCE_DATE, IN_DATE,OUT_DATE,FACTORY_ID, WAREHOUSE_ID는 각각 주문 ID, 제품 ID, 주문양, 생산일자, 입고일자, 출고일자, 공장 ID, 창고 ID를 의미합니다. Column name Type Nullable ORDER_ID VARCHAR(10) FALSE PRODUCT_ID VARCHAR(5) FALSE AMOUNT NUMBER FALSE PRODUCE_DATE DATE TRUE IN_DATE DATE TRUE OUT_DATE DATE TRUE FACTORY_ID VARCHAR(10) FALSE WAREHOUSE_ID VARCHAR(10) FALSE 문제 FOOD_ORDER 테이블에서 2022년 5월 1일을 기준으로 주문 ID, 제품 ID, 출고일자, 출고여부를 조회하는 SQL문을 작성해주세요. 출고여부는 2022년 5월 1일까지 출고완료로 이 후 날짜는 출고 대기로 미정이면 출고미정으로 출력해주시고, 결과는 주문 ID를 기준으로 오름차순 정렬해주세요. 예시 FOOD_ORDER 테이블이 다음과 같을 때 ORDER_ID PRODUCT_ID AMOUNT PRODUCE_DATE IN_DATE OUT_DATE FACTORY_ID WAREHOUSE_ID OD00000051 P0002 4000 2022-04-01 2022-04-21 2022-04-21 FT19970003 WH0005 OD00000052 P0003 2500 2022-04-10 2022-04-27 2022-04-27 FT19970003 WH0006 OD00000053 P0005 6200 2022-04-15 2022-04-30 2022-05-01 FT19940003 WH0003 OD00000054 P0006 1000 2022-04-21 2022-04-30 NULL FT19940003 WH0009 OD00000055 P0008 1500 2022-04-25 2022-05-11 2022-05-11 FT19980003 WH0009 SQL을 실행하면 다음과 같이 출력되어야 합니다. ORDER_ID PRODUCT_ID OUT_DATE 출고여부 OD00000051 P0002 2022-04-21 출고완료 OD00000052 P0003 2022-04-27 출고완료 OD00000053 P0005 2022-05-01 출고완료 OD00000054 P0006 출고미정 OD00000055 P0008 2022-05-11 출고대기",normal,database
93,"[본 문제는 정확성과 효율성 테스트 각각 점수가 있는 문제입니다.] 당신은 행렬에 적용할 수 있는 두 가지 연산을 만들었습니다. ShiftRow 모든 행이 아래쪽으로 한 칸씩 밀려납니다. 즉, 모든 행에 대해서 i번째 행은 i+1번째 행이 됩니다. (마지막 행은 1번째 행이 됩니다.) ShiftRow의 예 왼쪽 행렬이 초기 상태이고 오른쪽 행렬이 ShiftRow를 한 번 시행한 뒤의 행렬입니다. 1번째 행에 있던 [1,2,3]이 2번째 행으로, 2번째 행에 있던 [4,5,6]이 3번째 행으로, 3번째 행에 있던 [7,8,9]가 1번째 행이 된 것을 확인할 수 있습니다. Rotate 행렬의 바깥쪽에 있는 원소들을 시계 방향으로 한 칸 회전시킵니다. 행렬의 바깥쪽에 있는 원소들은 첫 행, 첫 열, 끝 행, 끝 열에 포함되는 원소들입니다. 한 칸 회전시킨다는 것은 이 원소들이 시계 방향으로 한 칸씩 밀려난다는 것을 의미합니다. 즉, 다음 4개의 연산이 동시에 시행됩니다. 첫 행에서 끝 열에 있는 원소를 제외한 첫 행의 모든 원소는 오른쪽으로 한 칸 이동합니다. 끝 열에서 끝 행에 있는 원소를 제외한 끝 열의 모든 원소는 아래쪽으로 한 칸 이동합니다. 끝 행에서 첫 열에 있는 원소를 제외한 끝 행의 모든 원소는 왼쪽으로 한 칸 이동합니다. 첫 열에서 첫 행에 있는 원소를 제외한 첫 열의 모든 원소는 위쪽으로 한 칸 이동합니다. Rotate의 예 왼쪽 행렬이 초기 상태이고 오른쪽 행렬이 Rotate를 한 번 시행한 뒤의 행렬입니다. 바깥쪽에 있는 값들이 시계 방향으로 한 칸씩 이동한 것을 확인할 수 있습니다. 당신은 행렬에 연산을 여러 번 시행하려고 합니다. 행렬의 초기 상태를 담고 있는 2차원 정수 배열 rc, 시행할 연산을 순서대로 담고 있는 문자열 배열 operations가 매개변수로 주어졌을 때, 연산을 차례대로 시행한 후의 행렬 상태를 return 하도록 solution 함수를 완성해주세요. 제한사항 2 ≤ rc의 행 길이(=행렬의 가로 길이) ≤ 50,000 rc의 모든 행의 길이는 동일합니다. 2 ≤ rc의 열 길이(=행렬의 세로 길이) ≤ 50,000 rc의 모든 열의 길이는 동일합니다. 4 ≤ rc의 행 길이 x rc의 열 길이 ≤ 100,000 rc[i][j] 는 i+1번째 행 j+1번째 열에 있는 원소를 나타냅니다. 1 ≤ rc[i][j] ≤ 1,000,000 1 ≤ operations의 길이 ≤ 100,000 operations의 원소는 ""ShiftRow"" 혹은 ""Rotate""입니다. 정확성 테스트 케이스 제한 사항 2 ≤ rc의 행 길이(=행렬의 가로 길이) ≤ 1,000 rc의 모든 행의 길이는 동일합니다. 2 ≤ rc의 열 길이(=행렬의 세로 길이) ≤ 1,000 rc의 모든 열의 길이는 동일합니다. 4 ≤ rc의 행 길이 x rc의 열 길이 ≤ 10,000 1 ≤ operations의 길이 ≤ 100 효율성 테스트 케이스 제한 사항 주어진 조건 외 추가 제한사항 없습니다. 입출력 예 rc operations result [[1, 2, 3], [4, 5, 6], [7, 8, 9]] [""Rotate"", ""ShiftRow""] [[8, 9, 6], [4, 1, 2], [7, 5, 3]] [[8, 6, 3], [3, 3, 7], [8, 4, 9]] [""Rotate"", ""ShiftRow"", ""ShiftRow""] [[8, 3, 3], [4, 9, 7], [3, 8, 6]] [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]] [""ShiftRow"", ""Rotate"", ""ShiftRow"", ""Rotate""] [[1, 6, 7 ,8], [5, 9, 10, 4], [2, 3, 12, 11]] 입출력 예 설명",hard,Array
94,"XX산은 n개의 지점으로 이루어져 있습니다. 각 지점은 1부터 n까지 번호가 붙어있으며, 출입구, 쉼터, 혹은 산봉우리입니다. 각 지점은 양방향 통행이 가능한 등산로로 연결되어 있으며, 서로 다른 지점을 이동할 때 이 등산로를 이용해야 합니다. 이때, 등산로별로 이동하는데 일정 시간이 소요됩니다. 등산코스는 방문할 지점 번호들을 순서대로 나열하여 표현할 수 있습니다. 예를 들어 1-2-3-2-1 으로 표현하는 등산코스는 1번지점에서 출발하여 2번, 3번, 2번, 1번 지점을 순서대로 방문한다는 뜻입니다. 등산코스를 따라 이동하는 중 쉼터 혹은 산봉우리를 방문할 때마다 휴식을 취할 수 있으며, 휴식 없이 이동해야 하는 시간 중 가장 긴 시간을 해당 등산코스의 intensity라고 부르기로 합니다. 당신은 XX산의 출입구 중 한 곳에서 출발하여 산봉우리 중 한 곳만 방문한 뒤 다시 원래의 출입구로 돌아오는 등산코스를 정하려고 합니다. 다시 말해, 등산코스에서 출입구는 처음과 끝에 한 번씩, 산봉우리는 한 번만 포함되어야 합니다. 당신은 이러한 규칙을 지키면서 intensity가 최소가 되도록 등산코스를 정하려고 합니다. 다음은 XX산의 지점과 등산로를 그림으로 표현한 예시입니다. 위 그림에서 원에 적힌 숫자는 지점의 번호를 나타내며, 1, 3번 지점에 출입구, 5번 지점에 산봉우리가 있습니다. 각 선분은 등산로를 나타내며, 각 선분에 적힌 수는 이동 시간을 나타냅니다. 예를 들어 1번 지점에서 2번 지점으로 이동할 때는 3시간이 소요됩니다. 위의 예시에서 1-2-5-4-3 과 같은 등산코스는 처음 출발한 원래의 출입구로 돌아오지 않기 때문에 잘못된 등산코스입니다. 또한 1-2-5-6-4-3-2-1 과 같은 등산코스는 코스의 처음과 끝 외에 3번 출입구를 방문하기 때문에 잘못된 등산코스입니다. 등산코스를 3-2-5-4-3 과 같이 정했을 때의 이동경로를 그림으로 나타내면 아래와 같습니다. 이때, 휴식 없이 이동해야 하는 시간 중 가장 긴 시간은 5시간입니다. 따라서 이 등산코스의 intensity는 5입니다. 등산코스를 1-2-4-5-6-4-2-1 과 같이 정했을 때의 이동경로를 그림으로 나타내면 아래와 같습니다. 이때, 휴식 없이 이동해야 하는 시간 중 가장 긴 시간은 3시간입니다. 따라서 이 등산코스의 intensity는 3이며, 이 보다 intensity가 낮은 등산코스는 없습니다. XX산의 지점 수 n, 각 등산로의 정보를 담은 2차원 정수 배열 paths, 출입구들의 번호가 담긴 정수 배열 gates, 산봉우리들의 번호가 담긴 정수 배열 summits가 매개변수로 주어집니다. 이때, intensity가 최소가 되는 등산코스에 포함된 산봉우리 번호와 intensity의 최솟값을 차례대로 정수 배열에 담아 return 하도록 solution 함수를 완성해주세요. intensity가 최소가 되는 등산코스가 여러 개라면 그중 산봉우리의 번호가 가장 낮은 등산코스를 선택합니다. 제한사항 2 ≤ n ≤ 50,000 n - 1 ≤ paths의 길이 ≤ 200,000 paths의 원소는 [i, j, w] 형태입니다. i번 지점과 j번 지점을 연결하는 등산로가 있다는 뜻입니다. w는 두 지점 사이를 이동하는 데 걸리는 시간입니다. 1 ≤ i < j ≤ n 1 ≤ w ≤ 10,000,000 서로 다른 두 지점을 직접 연결하는 등산로는 최대 1개입니다. 1 ≤ gates의 길이 ≤ n 1 ≤ gates의 원소 ≤ n gates의 원소는 해당 지점이 출입구임을 나타냅니다. 1 ≤ summits의 길이 ≤ n 1 ≤ summits의 원소 ≤ n summits의 원소는 해당 지점이 산봉우리임을 나타냅니다. 출입구이면서 동시에 산봉우리인 지점은 없습니다. gates와 summits에 등장하지 않은 지점은 모두 쉼터입니다. 임의의 두 지점 사이에 이동 가능한 경로가 항상 존재합니다. return 하는 배열은 [산봉우리의 번호, intensity의 최솟값] 순서여야 합니다. 입출력 예 n paths gates summits result 6 [[1, 2, 3], [2, 3, 5], [2, 4, 2], [2, 5, 4], [3, 4, 4], [4, 5, 3], [4, 6, 1], [5, 6, 1]] [1, 3] [5] [5, 3] 7 [[1, 4, 4], [1, 6, 1], [1, 7, 3], [2, 5, 2], [3, 7, 4], [5, 6, 6]] [1] [2, 3, 4] [3, 4] 7 [[1, 2, 5], [1, 4, 1], [2, 3, 1], [2, 6, 7], [4, 5, 1], [5, 6, 1], [6, 7, 1]] [3, 7] [1, 5] [5, 1] 5 [[1, 3, 10], [1, 4, 20], [2, 3, 4], [2, 4, 6], [3, 5, 20], [4, 5, 6]] [1, 2] [5] [5, 6] 입출력 예 설명",normal,Array
95,"[본 문제는 정확성과 효율성 테스트 각각 점수가 있는 문제입니다.] 당신은 코딩 테스트를 준비하기 위해 공부하려고 합니다. 코딩 테스트 문제를 풀기 위해서는 알고리즘에 대한 지식과 코드를 구현하는 능력이 필요합니다. 알고리즘에 대한 지식은 알고력, 코드를 구현하는 능력은 코딩력이라고 표현합니다. 알고력과 코딩력은 0 이상의 정수로 표현됩니다. 문제를 풀기 위해서는 문제가 요구하는 일정 이상의 알고력과 코딩력이 필요합니다. 예를 들어, 당신의 현재 알고력이 15, 코딩력이 10이라고 가정해보겠습니다. A라는 문제가 알고력 10, 코딩력 10을 요구한다면 A 문제를 풀 수 있습니다. B라는 문제가 알고력 10, 코딩력 20을 요구한다면 코딩력이 부족하기 때문에 B 문제를 풀 수 없습니다. 풀 수 없는 문제를 해결하기 위해서는 알고력과 코딩력을 높여야 합니다. 알고력과 코딩력을 높이기 위한 다음과 같은 방법들이 있습니다. 알고력을 높이기 위해 알고리즘 공부를 합니다. 알고력 1을 높이기 위해서 1의 시간이 필요합니다. 코딩력을 높이기 위해 코딩 공부를 합니다. 코딩력 1을 높이기 위해서 1의 시간이 필요합니다. 현재 풀 수 있는 문제 중 하나를 풀어 알고력과 코딩력을 높입니다. 각 문제마다 문제를 풀면 올라가는 알고력과 코딩력이 정해져 있습니다. 문제를 하나 푸는 데는 문제가 요구하는 시간이 필요하며 같은 문제를 여러 번 푸는 것이 가능합니다. 당신은 주어진 모든 문제들을 풀 수 있는 알고력과 코딩력을 얻는 최단시간을 구하려 합니다. 초기의 알고력과 코딩력을 담은 정수 alp와 cop, 문제의 정보를 담은 2차원 정수 배열 problems가 매개변수로 주어졌을 때, 모든 문제들을 풀 수 있는 알고력과 코딩력을 얻는 최단시간을 return 하도록 solution 함수를 작성해주세요. 모든 문제들을 1번 이상씩 풀 필요는 없습니다. 입출력 예 설명을 참고해주세요. 제한사항 초기의 알고력을 나타내는 alp와 초기의 코딩력을 나타내는 cop가 입력으로 주어집니다. 0 ≤ alp,cop ≤ 150 1 ≤ problems의 길이 ≤ 100 problems의 원소는 [alp_req, cop_req, alp_rwd, cop_rwd, cost]의 형태로 이루어져 있습니다. alp_req는 문제를 푸는데 필요한 알고력입니다. 0 ≤ alp_req ≤ 150 cop_req는 문제를 푸는데 필요한 코딩력입니다. 0 ≤ cop_req ≤ 150 alp_rwd는 문제를 풀었을 때 증가하는 알고력입니다. 0 ≤ alp_rwd ≤ 30 cop_rwd는 문제를 풀었을 때 증가하는 코딩력입니다. 0 ≤ cop_rwd ≤ 30 cost는 문제를 푸는데 드는 시간입니다. 1 ≤ cost ≤ 100 정확성 테스트 케이스 제한사항 0 ≤ alp,cop ≤ 20 1 ≤ problems의 길이 ≤ 6 0 ≤ alp_req,cop_req ≤ 20 0 ≤ alp_rwd,cop_rwd ≤ 5 1 ≤ cost ≤ 10 효율성 테스트 케이스 제한사항 주어진 조건 외 추가 제한사항 없습니다. 입출력 예 alp cop problems result 10 10 [[10,15,2,1,2],[20,20,3,3,4]] 15 0 0 [[0,0,2,1,2],[4,5,3,1,2],[4,11,4,0,2],[10,4,0,4,2]] 13 입출력 예 설명",normal,Array
96,"길이가 같은 두 개의 큐가 주어집니다. 하나의 큐를 골라 원소를 추출(pop)하고, 추출된 원소를 다른 큐에 집어넣는(insert) 작업을 통해 각 큐의 원소 합이 같도록 만들려고 합니다. 이때 필요한 작업의 최소 횟수를 구하고자 합니다. 한 번의 pop과 한 번의 insert를 합쳐서 작업을 1회 수행한 것으로 간주합니다. 큐는 먼저 집어넣은 원소가 먼저 나오는 구조입니다. 이 문제에서는 큐를 배열로 표현하며, 원소가 배열 앞쪽에 있을수록 먼저 집어넣은 원소임을 의미합니다. 즉, pop을 하면 배열의 첫 번째 원소가 추출되며, insert를 하면 배열의 끝에 원소가 추가됩니다. 예를 들어 큐 [1, 2, 3, 4]가 주어졌을 때, pop을 하면 맨 앞에 있는 원소 1이 추출되어 [2, 3, 4]가 되며, 이어서 5를 insert하면 [2, 3, 4, 5]가 됩니다. 다음은 두 큐를 나타내는 예시입니다. queue1 = [3, 2, 7, 2] queue2 = [4, 6, 5, 1] 두 큐에 담긴 모든 원소의 합은 30입니다. 따라서, 각 큐의 합을 15로 만들어야 합니다. 예를 들어, 다음과 같이 2가지 방법이 있습니다. queue2의 4, 6, 5를 순서대로 추출하여 queue1에 추가한 뒤, queue1의 3, 2, 7, 2를 순서대로 추출하여 queue2에 추가합니다. 그 결과 queue1은 [4, 6, 5], queue2는 [1, 3, 2, 7, 2]가 되며, 각 큐의 원소 합은 15로 같습니다. 이 방법은 작업을 7번 수행합니다. queue1에서 3을 추출하여 queue2에 추가합니다. 그리고 queue2에서 4를 추출하여 queue1에 추가합니다. 그 결과 queue1은 [2, 7, 2, 4], queue2는 [6, 5, 1, 3]가 되며, 각 큐의 원소 합은 15로 같습니다. 이 방법은 작업을 2번만 수행하며, 이보다 적은 횟수로 목표를 달성할 수 없습니다. 따라서 각 큐의 원소 합을 같게 만들기 위해 필요한 작업의 최소 횟수는 2입니다. 길이가 같은 두 개의 큐를 나타내는 정수 배열 queue1, queue2가 매개변수로 주어집니다. 각 큐의 원소 합을 같게 만들기 위해 필요한 작업의 최소 횟수를 return 하도록 solution 함수를 완성해주세요. 단, 어떤 방법으로도 각 큐의 원소 합을 같게 만들 수 없는 경우, -1을 return 해주세요. 제한사항 1 ≤ queue1의 길이 = queue2의 길이 ≤ 300,000 1 ≤ queue1의 원소, queue2의 원소 ≤ 109 주의: 언어에 따라 합 계산 과정 중 산술 오버플로우 발생 가능성이 있으므로 long type 고려가 필요합니다. 입출력 예 queue1 queue2 result [3, 2, 7, 2] [4, 6, 5, 1] 2 [1, 2, 1, 2] [1, 10, 1, 2] 7 [1, 1] [1, 5] -1 입출력 예 설명",normal,Array
97,"문제 설명 플레이어 A와 플레이어 B가 서로 게임을 합니다. 당신은 이 게임이 끝날 때까지 양 플레이어가 캐릭터를 몇 번 움직이게 될지 예측하려고 합니다. 각 플레이어는 자신의 캐릭터 하나를 보드 위에 올려놓고 게임을 시작합니다. 게임 보드는 1x1 크기 정사각 격자로 이루어져 있으며, 보드 안에는 발판이 있는 부분과 없는 부분이 있습니다. 발판이 있는 곳에만 캐릭터가 서있을 수 있으며, 처음 캐릭터를 올려놓는 곳은 항상 발판이 있는 곳입니다. 캐릭터는 발판이 있는 곳으로만 이동할 수 있으며, 보드 밖으로 이동할 수 없습니다. 밟고 있던 발판은 그 위에 있던 캐릭터가 다른 곳으로 이동하여 다른 발판을 밞음과 동시에 사라집니다. 양 플레이어는 번갈아가며 자기 차례에 자신의 캐릭터를 상하좌우로 인접한 4개의 칸 중에서 발판이 있는 칸으로 옮겨야 합니다. 다음과 같은 2가지 상황에서 패자와 승자가 정해지며, 게임이 종료됩니다. 움직일 차례인데 캐릭터의 상하좌우 주변 4칸이 모두 발판이 없거나 보드 밖이라서 이동할 수 없는 경우, 해당 차례 플레이어는 패배합니다. 두 캐릭터가 같은 발판 위에 있을 때, 상대 플레이어의 캐릭터가 다른 발판으로 이동하여 자신의 캐릭터가 서있던 발판이 사라지게 되면 패배합니다. 게임은 항상 플레이어 A가 먼저 시작합니다. 양 플레이어는 최적의 플레이를 합니다. 즉, 이길 수 있는 플레이어는 최대한 빨리 승리하도록 플레이하고, 질 수밖에 없는 플레이어는 최대한 오래 버티도록 플레이합니다. '이길 수 있는 플레이어'는 실수만 하지 않는다면 항상 이기는 플레이어를 의미하며, '질 수밖에 없는 플레이어'는 최선을 다해도 상대가 실수하지 않으면 항상 질 수밖에 없는 플레이어를 의미합니다. 최대한 오래 버틴다는 것은 양 플레이어가 캐릭터를 움직이는 횟수를 최대화한다는 것을 의미합니다. 아래 그림은 초기 보드의 상태와 각 플레이어의 위치를 나타내는 예시입니다. 위와 같은 경우, 플레이어 A는 실수만 하지 않는다면 항상 이길 수 있습니다. 따라서 플레이어 A는 이길 수 있는 플레이어이며, B는 질 수밖에 없는 플레이어입니다. 다음은 A와 B가 최적의 플레이를 하는 과정을 나타냅니다. 플레이어 A가 초기 위치 (1, 0)에서 (1, 1)로 이동합니다. 플레이어 A가 (0, 0)이나 (2, 0)으로 이동할 경우 승리를 보장할 수 없습니다. 따라서 무조건 이길 방법이 있는 (1, 1)로 이동합니다. 플레이어 B는 (1, 1)로 이동할 경우, 바로 다음 차례에 A가 위 또는 아래 방향으로 이동하면 발판이 없어져 패배하게 됩니다. 질 수밖에 없는 플레이어는 최대한 오래 버티도록 플레이하기 때문에 (1, 1)로 이동하지 않습니다. (1, 2)에서 위쪽 칸인 (0, 2)로 이동합니다. A가 (1, 1)에서 (0, 1)로 이동합니다. B에게는 남은 선택지가 (0, 1)밖에 없습니다. 따라서 (0, 2)에서 (0, 1)로 이동합니다. A가 (0, 1)에서 (0, 0)으로 이동합니다. 이동을 완료함과 동시에 B가 서있던 (0, 1)의 발판이 사라집니다. B가 패배합니다. 만약 과정 2에서 B가 아래쪽 칸인 (2, 2)로 이동하더라도 A는 (2, 1)로 이동하면 됩니다. 이후 B가 (2, 1)로 이동, 다음 차례에 A가 (2, 0)으로 이동하면 B가 패배합니다. 위 예시에서 양 플레이어가 최적의 플레이를 했을 경우, 캐릭터의 이동 횟수 합은 5입니다. 최적의 플레이를 하는 방법은 여러 가지일 수 있으나, 이동한 횟수는 모두 5로 같습니다. 게임 보드의 초기 상태를 나타내는 2차원 정수 배열 board와 플레이어 A의 캐릭터 초기 위치를 나타내는 정수 배열 aloc, 플레이어 B의 캐릭터 초기 위치를 나타내는 정수 배열 bloc이 매개변수로 주어집니다. 양 플레이어가 최적의 플레이를 했을 때, 두 캐릭터가 움직인 횟수의 합을 return 하도록 solution 함수를 완성해주세요. 제한사항 1 ≤ board의 세로 길이 ≤ 5 1 ≤ board의 가로 길이 ≤ 5 board의 원소는 0 또는 1입니다. 0은 발판이 없음을, 1은 발판이 있음을 나타냅니다. 게임 보드의 좌측 상단 좌표는 (0, 0), 우측 하단 좌표는 (board의 세로 길이 - 1, board의 가로 길이 - 1)입니다. aloc과 bloc은 각각 플레이어 A의 캐릭터와 플레이어 B의 캐릭터 초기 위치를 나타내는 좌표값이며 [r, c] 형태입니다. r은 몇 번째 행인지를 나타냅니다. 0 ≤ r < board의 세로 길이 c는 몇 번째 열인지를 나타냅니다. 0 ≤ c < board의 가로 길이 초기 보드의 aloc과 bloc 위치는 항상 발판이 있는 곳입니다. aloc과 bloc이 같을 수 있습니다. 상대 플레이어의 캐릭터가 있는 칸으로 이동할 수 있습니다. 입출력 예 board aloc bloc result [[1, 1, 1], [1, 1, 1], [1, 1, 1]] [1, 0] [1, 2] 5 [[1, 1, 1], [1, 0, 1], [1, 1, 1]] [1, 0] [1, 2] 4 [[1, 1, 1, 1, 1]] [0, 0] [0, 4] 4 [[1]] [0, 0] [0, 0] 0 입출력 예 설명",normal,Array
98,"문제 설명 [본 문제는 정확성과 효율성 테스트 각각 점수가 있는 문제입니다.] N x M 크기의 행렬 모양의 게임 맵이 있습니다. 이 맵에는 내구도를 가진 건물이 각 칸마다 하나씩 있습니다. 적은 이 건물들을 공격하여 파괴하려고 합니다. 건물은 적의 공격을 받으면 내구도가 감소하고 내구도가 0이하가 되면 파괴됩니다. 반대로, 아군은 회복 스킬을 사용하여 건물들의 내구도를 높이려고 합니다. 적의 공격과 아군의 회복 스킬은 항상 직사각형 모양입니다. 예를 들어, 아래 사진은 크기가 4 x 5인 맵에 내구도가 5인 건물들이 있는 상태입니다. 첫 번째로 적이 맵의 (0,0)부터 (3,4)까지 공격하여 4만큼 건물의 내구도를 낮추면 아래와 같은 상태가 됩니다. 두 번째로 적이 맵의 (2,0)부터 (2,3)까지 공격하여 2만큼 건물의 내구도를 낮추면 아래와 같이 4개의 건물이 파괴되는 상태가 됩니다. 세 번째로 아군이 맵의 (1,0)부터 (3,1)까지 회복하여 2만큼 건물의 내구도를 높이면 아래와 같이 2개의 건물이 파괴되었다가 복구되고 2개의 건물만 파괴되어있는 상태가 됩니다. 마지막으로 적이 맵의 (0,1)부터 (3,3)까지 공격하여 1만큼 건물의 내구도를 낮추면 아래와 같이 8개의 건물이 더 파괴되어 총 10개의 건물이 파괴된 상태가 됩니다. (내구도가 0 이하가 된 이미 파괴된 건물도, 공격을 받으면 계속해서 내구도가 하락하는 것에 유의해주세요.) 최종적으로 총 10개의 건물이 파괴되지 않았습니다. 건물의 내구도를 나타내는 2차원 정수 배열 board와 적의 공격 혹은 아군의 회복 스킬을 나타내는 2차원 정수 배열 skill이 매개변수로 주어집니다. 적의 공격 혹은 아군의 회복 스킬이 모두 끝난 뒤 파괴되지 않은 건물의 개수를 return하는 solution함수를 완성해 주세요. 제한사항 1 ≤ board의 행의 길이 (= N) ≤ 1,000 1 ≤ board의 열의 길이 (= M) ≤ 1,000 1 ≤ board의 원소 (각 건물의 내구도) ≤ 1,000 1 ≤ skill의 행의 길이 ≤ 250,000 skill의 열의 길이 = 6 skill의 각 행은 [type, r1, c1, r2, c2, degree]형태를 가지고 있습니다. type은 1 혹은 2입니다. type이 1일 경우는 적의 공격을 의미합니다. 건물의 내구도를 낮춥니다. type이 2일 경우는 아군의 회복 스킬을 의미합니다. 건물의 내구도를 높입니다. (r1, c1)부터 (r2, c2)까지 직사각형 모양의 범위 안에 있는 건물의 내구도를 degree 만큼 낮추거나 높인다는 뜻입니다. 0 ≤ r1 ≤ r2 < board의 행의 길이 0 ≤ c1 ≤ c2 < board의 열의 길이 1 ≤ degree ≤ 500 type이 1이면 degree만큼 건물의 내구도를 낮춥니다. type이 2이면 degree만큼 건물의 내구도를 높입니다. 건물은 파괴되었다가 회복 스킬을 받아 내구도가 1이상이 되면 파괴되지 않은 상태가 됩니다. 즉, 최종적으로 건물의 내구도가 1이상이면 파괴되지 않은 건물입니다. 정확성 테스트 케이스 제한 사항 1 ≤ board의 행의 길이 (= N) ≤ 100 1 ≤ board의 열의 길이 (= M) ≤ 100 1 ≤ board의 원소 (각 건물의 내구도) ≤ 100 1 ≤ skill의 행의 길이 ≤ 100 1 ≤ degree ≤ 100 효율성 테스트 케이스 제한 사항 주어진 조건 외 추가 제한사항 없습니다. 입출력 예 board skill result [[5,5,5,5,5],[5,5,5,5,5],[5,5,5,5,5],[5,5,5,5,5]] [[1,0,0,3,4,4],[1,2,0,2,3,2],[2,1,0,3,1,2],[1,0,1,3,3,1]] 10 [[1,2,3],[4,5,6],[7,8,9]] [[1,1,1,2,2,4],[1,0,0,1,1,2],[2,2,0,2,0,100]] 6 입출력 예 설명",normal,Array
99,"문제 설명 2진 트리 모양 초원의 각 노드에 늑대와 양이 한 마리씩 놓여 있습니다. 이 초원의 루트 노드에서 출발하여 각 노드를 돌아다니며 양을 모으려 합니다. 각 노드를 방문할 때 마다 해당 노드에 있던 양과 늑대가 당신을 따라오게 됩니다. 이때, 늑대는 양을 잡아먹을 기회를 노리고 있으며, 당신이 모은 양의 수보다 늑대의 수가 같거나 더 많아지면 바로 모든 양을 잡아먹어 버립니다. 당신은 중간에 양이 늑대에게 잡아먹히지 않도록 하면서 최대한 많은 수의 양을 모아서 다시 루트 노드로 돌아오려 합니다. 예를 들어, 위 그림의 경우(루트 노드에는 항상 양이 있습니다) 0번 노드(루트 노드)에서 출발하면 양을 한마리 모을 수 있습니다. 다음으로 1번 노드로 이동하면 당신이 모은 양은 두 마리가 됩니다. 이때, 바로 4번 노드로 이동하면 늑대 한 마리가 당신을 따라오게 됩니다. 아직은 양 2마리, 늑대 1마리로 양이 잡아먹히지 않지만, 이후에 갈 수 있는 아직 방문하지 않은 모든 노드(2, 3, 6, 8번)에는 늑대가 있습니다. 이어서 늑대가 있는 노드로 이동한다면(예를 들어 바로 6번 노드로 이동한다면) 양 2마리, 늑대 2마리가 되어 양이 모두 잡아먹힙니다. 여기서는 0번, 1번 노드를 방문하여 양을 2마리 모은 후, 8번 노드로 이동한 후(양 2마리 늑대 1마리) 이어서 7번, 9번 노드를 방문하면 양 4마리 늑대 1마리가 됩니다. 이제 4번, 6번 노드로 이동하면 양 4마리, 늑대 3마리가 되며, 이제 5번 노드로 이동할 수 있게 됩니다. 따라서 양을 최대 5마리 모을 수 있습니다. 각 노드에 있는 양 또는 늑대에 대한 정보가 담긴 배열 info, 2진 트리의 각 노드들의 연결 관계를 담은 2차원 배열 edges가 매개변수로 주어질 때, 문제에 제시된 조건에 따라 각 노드를 방문하면서 모을 수 있는 양은 최대 몇 마리인지 return 하도록 solution 함수를 완성해주세요. 제한사항 2 ≤ info의 길이 ≤ 17 info의 원소는 0 또는 1 입니다. info[i]는 i번 노드에 있는 양 또는 늑대를 나타냅니다. 0은 양, 1은 늑대를 의미합니다. info[0]의 값은 항상 0입니다. 즉, 0번 노드(루트 노드)에는 항상 양이 있습니다. edges의 세로(행) 길이 = info의 길이 - 1 edges의 가로(열) 길이 = 2 edges의 각 행은 [부모 노드 번호, 자식 노드 번호] 형태로, 서로 연결된 두 노드를 나타냅니다. 동일한 간선에 대한 정보가 중복해서 주어지지 않습니다. 항상 하나의 이진 트리 형태로 입력이 주어지며, 잘못된 데이터가 주어지는 경우는 없습니다. 0번 노드는 항상 루트 노드입니다. 입출력 예 info edges result [0,0,1,1,1,0,1,0,1,0,1,1] [[0,1],[1,2],[1,4],[0,8],[8,7],[9,10],[9,11],[4,3],[6,5],[4,6],[8,9]] 5 [0,1,0,1,1,0,1,0,0,1,0] [[0,1],[0,2],[1,3],[1,4],[2,5],[2,6],[3,7],[4,8],[6,9],[9,10]] 5 입출력 예 설명",normal,Array
100,"문제 설명 카카오배 양궁대회가 열렸습니다. 라이언은 저번 카카오배 양궁대회 우승자이고 이번 대회에도 결승전까지 올라왔습니다. 결승전 상대는 어피치입니다. 카카오배 양궁대회 운영위원회는 한 선수의 연속 우승보다는 다양한 선수들이 양궁대회에서 우승하기를 원합니다. 따라서, 양궁대회 운영위원회는 결승전 규칙을 전 대회 우승자인 라이언에게 불리하게 다음과 같이 정했습니다. 어피치가 화살 n발을 다 쏜 후에 라이언이 화살 n발을 쏩니다. 점수를 계산합니다. 과녁판은 아래 사진처럼 생겼으며 가장 작은 원의 과녁 점수는 10점이고 가장 큰 원의 바깥쪽은 과녁 점수가 0점입니다. 만약, k(k는 1~10사이의 자연수)점을 어피치가 a발을 맞혔고 라이언이 b발을 맞혔을 경우 더 많은 화살을 k점에 맞힌 선수가 k 점을 가져갑니다. 단, a = b일 경우는 어피치가 k점을 가져갑니다. k점을 여러 발 맞혀도 k점 보다 많은 점수를 가져가는 게 아니고 k점만 가져가는 것을 유의하세요. 또한 a = b = 0 인 경우, 즉, 라이언과 어피치 모두 k점에 단 하나의 화살도 맞히지 못한 경우는 어느 누구도 k점을 가져가지 않습니다. 예를 들어, 어피치가 10점을 2발 맞혔고 라이언도 10점을 2발 맞혔을 경우 어피치가 10점을 가져갑니다. 다른 예로, 어피치가 10점을 0발 맞혔고 라이언이 10점을 2발 맞혔을 경우 라이언이 10점을 가져갑니다. 모든 과녁 점수에 대하여 각 선수의 최종 점수를 계산합니다. 최종 점수가 더 높은 선수를 우승자로 결정합니다. 단, 최종 점수가 같을 경우 어피치를 우승자로 결정합니다. 현재 상황은 어피치가 화살 n발을 다 쏜 후이고 라이언이 화살을 쏠 차례입니다. 라이언은 어피치를 가장 큰 점수 차이로 이기기 위해서 n발의 화살을 어떤 과녁 점수에 맞혀야 하는지를 구하려고 합니다. 화살의 개수를 담은 자연수 n, 어피치가 맞힌 과녁 점수의 개수를 10점부터 0점까지 순서대로 담은 정수 배열 info가 매개변수로 주어집니다. 이때, 라이언이 가장 큰 점수 차이로 우승하기 위해 n발의 화살을 어떤 과녁 점수에 맞혀야 하는지를 10점부터 0점까지 순서대로 정수 배열에 담아 return 하도록 solution 함수를 완성해 주세요. 만약, 라이언이 우승할 수 없는 경우(무조건 지거나 비기는 경우)는 [-1]을 return 해주세요. 제한사항 1 ≤ n ≤ 10 info의 길이 = 11 0 ≤ info의 원소 ≤ n info의 원소 총합 = n info의 i번째 원소는 과녁의 10 - i 점을 맞힌 화살 개수입니다. ( i는 0~10 사이의 정수입니다.) 라이언이 우승할 방법이 있는 경우, return 할 정수 배열의 길이는 11입니다. 0 ≤ return할 정수 배열의 원소 ≤ n return할 정수 배열의 원소 총합 = n (꼭 n발을 다 쏴야 합니다.) return할 정수 배열의 i번째 원소는 과녁의 10 - i 점을 맞힌 화살 개수입니다. ( i는 0~10 사이의 정수입니다.) 라이언이 가장 큰 점수 차이로 우승할 수 있는 방법이 여러 가지 일 경우, 가장 낮은 점수를 더 많이 맞힌 경우를 return 해주세요. 가장 낮은 점수를 맞힌 개수가 같을 경우 계속해서 그다음으로 낮은 점수를 더 많이 맞힌 경우를 return 해주세요. 예를 들어, [2,3,1,0,0,0,0,1,3,0,0]과 [2,1,0,2,0,0,0,2,3,0,0]를 비교하면 [2,1,0,2,0,0,0,2,3,0,0]를 return 해야 합니다. 다른 예로, [0,0,2,3,4,1,0,0,0,0,0]과 [9,0,0,0,0,0,0,0,1,0,0]를 비교하면[9,0,0,0,0,0,0,0,1,0,0]를 return 해야 합니다. 라이언이 우승할 방법이 없는 경우, return 할 정수 배열의 길이는 1입니다. 라이언이 어떻게 화살을 쏘든 라이언의 점수가 어피치의 점수보다 낮거나 같으면 [-1]을 return 해야 합니다. 입출력 예 n info result 5 [2,1,1,1,0,0,0,0,0,0,0] [0,2,2,0,1,0,0,0,0,0,0] 1 [1,0,0,0,0,0,0,0,0,0,0] [-1] 9 [0,0,1,2,0,1,1,1,1,1,1] [1,1,2,0,1,2,2,0,0,0,0] 10 [0,0,0,0,0,0,0,0,3,4,3] [1,1,1,1,1,1,1,1,0,0,2] 입출력 예 설명",normal,Array
101,"문제 설명 주차장의 요금표와 차량이 들어오고(입차) 나간(출차) 기록이 주어졌을 때, 차량별로 주차 요금을 계산하려고 합니다. 아래는 하나의 예시를 나타냅니다. 요금표 기본 시간(분) 기본 요금(원) 단위 시간(분) 단위 요금(원) 180 5000 10 600 입/출차 기록 시각(시:분) 차량 번호 내역 05:34 5961 입차 06:00 0000 입차 06:34 0000 출차 07:59 5961 출차 07:59 0148 입차 18:59 0000 입차 19:09 0148 출차 22:59 5961 입차 23:00 5961 출차 자동차별 주차 요금 차량 번호 누적 주차 시간(분) 주차 요금(원) 0000 34 + 300 = 334 5000 + ⌈(334 - 180) / 10⌉ x 600 = 14600 0148 670 5000 +⌈(670 - 180) / 10⌉x 600 = 34400 5961 145 + 1 = 146 5000 어떤 차량이 입차된 후에 출차된 내역이 없다면, 23:59에 출차된 것으로 간주합니다. 0000번 차량은 18:59에 입차된 이후, 출차된 내역이 없습니다. 따라서, 23:59에 출차된 것으로 간주합니다. 00:00부터 23:59까지의 입/출차 내역을 바탕으로 차량별 누적 주차 시간을 계산하여 요금을 일괄로 정산합니다. 누적 주차 시간이 기본 시간이하라면, 기본 요금을 청구합니다. 누적 주차 시간이 기본 시간을 초과하면, 기본 요금에 더해서, 초과한 시간에 대해서 단위 시간 마다 단위 요금을 청구합니다. 초과한 시간이 단위 시간으로 나누어 떨어지지 않으면, 올림합니다. ⌈a⌉ : a보다 작지 않은 최소의 정수를 의미합니다. 즉, 올림을 의미합니다. 주차 요금을 나타내는 정수 배열 fees, 자동차의 입/출차 내역을 나타내는 문자열 배열 records가 매개변수로 주어집니다. 차량 번호가 작은 자동차부터 청구할 주차 요금을 차례대로 정수 배열에 담아서 return 하도록 solution 함수를 완성해주세요. 제한사항 fees의 길이 = 4 fees[0] = 기본 시간(분) 1 ≤ fees[0] ≤ 1,439 fees[1] = 기본 요금(원) 0 ≤ fees[1] ≤ 100,000 fees[2] = 단위 시간(분) 1 ≤ fees[2] ≤ 1,439 fees[3] = 단위 요금(원) 1 ≤ fees[3] ≤ 10,000 1 ≤ records의 길이 ≤ 1,000 records의 각 원소는 ""시각 차량번호 내역"" 형식의 문자열입니다. 시각, 차량번호, 내역은 하나의 공백으로 구분되어 있습니다. 시각은 차량이 입차되거나 출차된 시각을 나타내며, HH:MM 형식의 길이 5인 문자열입니다. HH:MM은 00:00부터 23:59까지 주어집니다. 잘못된 시각(""25:22"", ""09:65"" 등)은 입력으로 주어지지 않습니다. 차량번호는 자동차를 구분하기 위한, `0'~'9'로 구성된 길이 4인 문자열입니다. 내역은 길이 2 또는 3인 문자열로, IN 또는 OUT입니다. IN은 입차를, OUT은 출차를 의미합니다. records의 원소들은 시각을 기준으로 오름차순으로 정렬되어 주어집니다. records는 하루 동안의 입/출차된 기록만 담고 있으며, 입차된 차량이 다음날 출차되는 경우는 입력으로 주어지지 않습니다. 같은 시각에, 같은 차량번호의 내역이 2번 이상 나타내지 않습니다. 마지막 시각(23:59)에 입차되는 경우는 입력으로 주어지지 않습니다. 아래의 예를 포함하여, 잘못된 입력은 주어지지 않습니다. 주차장에 없는 차량이 출차되는 경우 주차장에 이미 있는 차량(차량번호가 같은 차량)이 다시 입차되는 경우 입출력 예 fees records result [180, 5000, 10, 600] [""05:34 5961 IN"", ""06:00 0000 IN"", ""06:34 0000 OUT"", ""07:59 5961 OUT"", ""07:59 0148 IN"", ""18:59 0000 IN"", ""19:09 0148 OUT"", ""22:59 5961 IN"", ""23:00 5961 OUT""] [14600, 34400, 5000] [120, 0, 60, 591] [""16:00 3961 IN"",""16:00 0202 IN"",""18:00 3961 OUT"",""18:00 0202 OUT"",""23:58 3961 IN""] [0, 591] [1, 461, 1, 10] [""00:00 1234 IN""] [14841] 입출력 예 설명",normal,Array
102,"문제 설명 양의 정수 n이 주어집니다. 이 숫자를 k진수로 바꿨을 때, 변환된 수 안에 아래 조건에 맞는 소수(Prime number)가 몇 개인지 알아보려 합니다. 0P0처럼 소수 양쪽에 0이 있는 경우 P0처럼 소수 오른쪽에만 0이 있고 왼쪽에는 아무것도 없는 경우 0P처럼 소수 왼쪽에만 0이 있고 오른쪽에는 아무것도 없는 경우 P처럼 소수 양쪽에 아무것도 없는 경우 단, P는 각 자릿수에 0을 포함하지 않는 소수입니다. 예를 들어, 101은 P가 될 수 없습니다. 예를 들어, 437674을 3진수로 바꾸면 211020101011입니다. 여기서 찾을 수 있는 조건에 맞는 소수는 왼쪽부터 순서대로 211, 2, 11이 있으며, 총 3개입니다. (211, 2, 11을 k진법으로 보았을 때가 아닌, 10진법으로 보았을 때 소수여야 한다는 점에 주의합니다.) 211은 P0 형태에서 찾을 수 있으며, 2는 0P0에서, 11은 0P에서 찾을 수 있습니다. 정수 n과 k가 매개변수로 주어집니다. n을 k진수로 바꿨을 때, 변환된 수 안에서 찾을 수 있는 위 조건에 맞는 소수의 개수를 return 하도록 solution 함수를 완성해 주세요. 제한사항 1 ≤ n ≤ 1,000,000 3 ≤ k ≤ 10 입출력 예 n k result 437674 3 3 110011 10 2 입출력 예 설명",normal,Math
103,"XX게임에는 피로도 시스템(0 이상의 정수로 표현합니다)이 있으며, 일정 피로도를 사용해서 던전을 탐험할 수 있습니다. 이때, 각 던전마다 탐험을 시작하기 위해 필요한 ""최소 필요 피로도""와 던전 탐험을 마쳤을 때 소모되는 ""소모 피로도""가 있습니다. ""최소 필요 피로도""는 해당 던전을 탐험하기 위해 가지고 있어야 하는 최소한의 피로도를 나타내며, ""소모 피로도""는 던전을 탐험한 후 소모되는 피로도를 나타냅니다. 예를 들어 ""최소 필요 피로도""가 80, ""소모 피로도""가 20인 던전을 탐험하기 위해서는 유저의 현재 남은 피로도는 80 이상 이어야 하며, 던전을 탐험한 후에는 피로도 20이 소모됩니다. 이 게임에는 하루에 한 번씩 탐험할 수 있는 던전이 여러개 있는데, 한 유저가 오늘 이 던전들을 최대한 많이 탐험하려 합니다. 유저의 현재 피로도 k와 각 던전별 ""최소 필요 피로도"", ""소모 피로도""가 담긴 2차원 배열 dungeons 가 매개변수로 주어질 때, 유저가 탐험할수 있는 최대 던전 수를 return 하도록 solution 함수를 완성해주세요. 제한사항 k는 1 이상 5,000 이하인 자연수입니다. dungeons의 세로(행) 길이(즉, 던전의 개수)는 1 이상 8 이하입니다. dungeons의 가로(열) 길이는 2 입니다. dungeons의 각 행은 각 던전의 [""최소 필요 피로도"", ""소모 피로도""] 입니다. ""최소 필요 피로도""는 항상 ""소모 피로도""보다 크거나 같습니다. ""최소 필요 피로도""와 ""소모 피로도""는 1 이상 1,000 이하인 자연수입니다. 서로 다른 던전의 [""최소 필요 피로도"", ""소모 피로도""]가 서로 같을 수 있습니다. 입출력 예 k dungeons result 80 [[80,20],[50,40],[30,10]] 3 입출력 예 설명 현재 피로도는 80입니다. 만약, 첫 번째 → 두 번째 → 세 번째 던전 순서로 탐험한다면 현재 피로도는 80이며, 첫 번째 던전을 돌기위해 필요한 ""최소 필요 피로도"" 또한 80이므로, 첫 번째 던전을 탐험할 수 있습니다. 첫 번째 던전의 ""소모 피로도""는 20이므로, 던전을 탐험한 후 남은 피로도는 60입니다. 남은 피로도는 60이며, 두 번째 던전을 돌기위해 필요한 ""최소 필요 피로도""는 50이므로, 두 번째 던전을 탐험할 수 있습니다. 두 번째 던전의 ""소모 피로도""는 40이므로, 던전을 탐험한 후 남은 피로도는 20입니다. 남은 피로도는 20이며, 세 번째 던전을 돌기위해 필요한 ""최소 필요 피로도""는 30입니다. 따라서 세 번째 던전은 탐험할 수 없습니다. 만약, 첫 번째 → 세 번째 → 두 번째 던전 순서로 탐험한다면 현재 피로도는 80이며, 첫 번째 던전을 돌기위해 필요한 ""최소 필요 피로도"" 또한 80이므로, 첫 번째 던전을 탐험할 수 있습니다. 첫 번째 던전의 ""소모 피로도""는 20이므로, 던전을 탐험한 후 남은 피로도는 60입니다. 남은 피로도는 60이며, 세 번째 던전을 돌기위해 필요한 ""최소 필요 피로도""는 30이므로, 세 번째 던전을 탐험할 수 있습니다. 세 번째 던전의 ""소모 피로도""는 10이므로, 던전을 탐험한 후 남은 피로도는 50입니다. 남은 피로도는 50이며, 두 번째 던전을 돌기위해 필요한 ""최소 필요 피로도""는 50이므로, 두 번째 던전을 탐험할 수 있습니다. 두 번째 던전의 ""소모 피로도""는 40이므로, 던전을 탐험한 후 남은 피로도는 10입니다. 따라서 이 경우 세 던전을 모두 탐험할 수 있으며, 유저가 탐험할 수 있는 최대 던전 수는 3입니다.",normal,Array
104,"다음과 같은 다각형 모양 지형에서 캐릭터가 아이템을 줍기 위해 이동하려 합니다. 지형은 각 변이 x축, y축과 평행한 직사각형이 겹쳐진 형태로 표현하며, 캐릭터는 이 다각형의 둘레(굵은 선)를 따라서 이동합니다. 만약 직사각형을 겹친 후 다음과 같이 중앙에 빈 공간이 생기는 경우, 다각형의 가장 바깥쪽 테두리가 캐릭터의 이동 경로가 됩니다. 단, 서로 다른 두 직사각형의 x축 좌표 또는 y축 좌표가 같은 경우는 없습니다. 즉, 위 그림처럼 서로 다른 두 직사각형이 꼭짓점에서 만나거나, 변이 겹치는 경우 등은 없습니다. 다음 그림과 같이 지형이 2개 이상으로 분리된 경우도 없습니다. 한 직사각형이 다른 직사각형 안에 완전히 포함되는 경우 또한 없습니다. 지형을 나타내는 직사각형이 담긴 2차원 배열 rectangle, 초기 캐릭터의 위치 characterX, characterY, 아이템의 위치 itemX, itemY가 solution 함수의 매개변수로 주어질 때, 캐릭터가 아이템을 줍기 위해 이동해야 하는 가장 짧은 거리를 return 하도록 solution 함수를 완성해주세요. 제한사항 rectangle의 세로(행) 길이는 1 이상 4 이하입니다. rectangle의 원소는 각 직사각형의 [좌측 하단 x, 좌측 하단 y, 우측 상단 x, 우측 상단 y] 좌표 형태입니다. 직사각형을 나타내는 모든 좌표값은 1 이상 50 이하인 자연수입니다. 서로 다른 두 직사각형의 x축 좌표, 혹은 y축 좌표가 같은 경우는 없습니다. 문제에 주어진 조건에 맞는 직사각형만 입력으로 주어집니다. charcterX, charcterY는 1 이상 50 이하인 자연수입니다. 지형을 나타내는 다각형 테두리 위의 한 점이 주어집니다. itemX, itemY는 1 이상 50 이하인 자연수입니다. 지형을 나타내는 다각형 테두리 위의 한 점이 주어집니다. 캐릭터와 아이템의 처음 위치가 같은 경우는 없습니다. 전체 배점의 50%는 직사각형이 1개인 경우입니다. 전체 배점의 25%는 직사각형이 2개인 경우입니다. 전체 배점의 25%는 직사각형이 3개 또는 4개인 경우입니다. 입출력 예 rectangle characterX characterY itemX itemY result [[1,1,7,4],[3,2,5,5],[4,3,6,9],[2,6,8,8]] 1 3 7 8 17 [[1,1,8,4],[2,2,4,9],[3,6,9,8],[6,3,7,7]] 9 7 6 1 11 [[1,1,5,7]] 1 1 4 7 9 [[2,1,7,5],[6,4,10,10]] 3 1 7 10 15 [[2,2,5,5],[1,3,6,4],[3,1,4,6]] 1 4 6 3 10 입출력 예 설명",normal,Array
105,"길이가 n인 배열 a가 주어집니다. 당신은 여기에 q개의 쿼리를 순차적으로 날려 n개의 0으로 이루어진 배열을 a로 만들고자 합니다. query(l, r, x)는 다음 수도코드와 같은 역할을 합니다. (0 ≤ l ≤ r < n, 1 ≤ x ≤ 105 ) for i = l, l+1, ..., r: a[i] := max(a[i], x) q개의 쿼리를 통해 a를 만드는 방법은 여러 가지가 있을 수 있습니다. 예를 들어 a = [1,2], q = 2라면 다음 4가지 방법으로 a를 만들 수 있습니다. query(0, 0, 1), query(1, 1, 2) query(1, 1, 2), query(0, 0, 1) query(0, 1, 1), query(1, 1, 2) query(1, 1, 2), query(0, 1, 1) 정수 q와 정수 배열 a가 매개변수로 주어집니다. q개의 쿼리를 통해 a를 만드는 방법의 가짓수를 998,244,353으로 나눈 나머지를 return 하도록 solution 함수를 완성해주세요. 제한사항 1 ≤ q ≤ 50 1 ≤ a의 길이 ≤ 50 1 ≤ a의 모든 원소 ≤ 105 입출력 예 q a result 2 [1,2] 4 3 [3] 19 5 [1,4,4] 157740 50 [1,6,5,2,4] 61953538 입출력 예 설명",hard,Array
106,"n행 m열의 격자가 있습니다. 격자의 각 행은 0, 1, ..., n-1번의 번호, 그리고 각 열은 0, 1, ..., m-1번의 번호가 순서대로 매겨져 있습니다. 당신은 이 격자에 공을 하나 두고, 그 공에 다음과 같은 쿼리들을 날리고자 합니다. 열 번호가 감소하는 방향으로 dx칸 이동하는 쿼리 (query(0, dx)) 열 번호가 증가하는 방향으로 dx칸 이동하는 쿼리 (query(1, dx)) 행 번호가 감소하는 방향으로 dx칸 이동하는 쿼리 (query(2, dx)) 행 번호가 증가하는 방향으로 dx칸 이동하는 쿼리 (query(3, dx)) 단, 공은 격자 바깥으로 이동할 수 없으며, 목적지가 격자 바깥인 경우 공은 이동하다가 더 이상 이동할 수 없을 때 멈추게 됩니다. 예를 들어, 5행 × 4열 크기의 격자 내의 공이 3행 2열에 있을 때 query(3, 10) 쿼리를 받은 경우 공은 4행 2열에서 멈추게 됩니다. (격자의 크기가 5행 × 4열이므로, 0~4번 행과 0~3번 열로 격자가 구성되기 때문입니다.) 격자의 행의 개수 n, 열의 개수 m, 정수 x와 y, 그리고 쿼리들의 목록을 나타내는 2차원 정수 배열 queries가 매개변수로 주어집니다. n × m개의 가능한 시작점에 대해서 해당 시작점에 공을 두고 queries 내의 쿼리들을 순서대로 시뮬레이션했을 때, x행 y열에 도착하는 시작점의 개수를 return 하도록 solution 함수를 완성해주세요. 제한사항 1 ≤ n ≤ 109 1 ≤ m ≤ 109 0 ≤ x < n 0 ≤ y < m 1 ≤ queries의 행의 개수 ≤ 200,000 queries의 각 행은 [command,dx] 두 정수로 이루어져 있습니다. 0 ≤ command ≤ 3 1 ≤ dx ≤ 109 이는 query(command, dx)를 의미합니다. 입출력 예 n m x y queries result 2 2 0 0 [[2,1],[0,1],[1,1],[0,1],[2,1]] 4 2 5 0 1 [[3,1],[2,2],[1,1],[2,3],[0,1],[2,1]] 2 입출력 예 설명",normal,Array
107,"정수 n, left, right가 주어집니다. 다음 과정을 거쳐서 1차원 배열을 만들고자 합니다. n행 n열 크기의 비어있는 2차원 배열을 만듭니다. i = 1, 2, 3, ..., n에 대해서, 다음 과정을 반복합니다. 1행 1열부터 i행 i열까지의 영역 내의 모든 빈 칸을 숫자 i로 채웁니다. 1행, 2행, ..., n행을 잘라내어 모두 이어붙인 새로운 1차원 배열을 만듭니다. 새로운 1차원 배열을 arr이라 할 때, arr[left], arr[left+1], ..., arr[right]만 남기고 나머지는 지웁니다. 정수 n, left, right가 매개변수로 주어집니다. 주어진 과정대로 만들어진 1차원 배열을 return 하도록 solution 함수를 완성해주세요. 제한사항 1 ≤ n ≤ 107 0 ≤ left ≤ right < n2 right - left < 105 입출력 예 n left right result 3 2 5 [3,2,2,3] 4 7 14 [4,3,3,3,4,4,4,4] 입출력 예 설명",normal,Array
108,"Ax + By + C = 0으로 표현할 수 있는 n개의 직선이 주어질 때, 이 직선의 교점 중 정수 좌표에 별을 그리려 합니다. 예를 들어, 다음과 같은 직선 5개를 2x - y + 4 = 0 -2x - y + 4 = 0 -y + 1 = 0 5x - 8y - 12 = 0 5x + 8y + 12 = 0 좌표 평면 위에 그리면 아래 그림과 같습니다. 이때, 모든 교점의 좌표는 (4, 1), (4, -4), (-4, -4), (-4, 1), (0, 4), (1.5, 1.0), (2.1, -0.19), (0, -1.5), (-2.1, -0.19), (-1.5, 1.0)입니다. 이 중 정수로만 표현되는 좌표는 (4, 1), (4, -4), (-4, -4), (-4, 1), (0, 4)입니다. 만약 정수로 표현되는 교점에 별을 그리면 다음과 같습니다. 위의 그림을 문자열로 나타낼 때, 별이 그려진 부분은 *, 빈 공간(격자선이 교차하는 지점)은 .으로 표현하면 다음과 같습니다. ""..........."" "".....*....."" ""..........."" ""..........."" "".*.......*."" ""..........."" ""..........."" ""..........."" ""..........."" "".*.......*."" ""..........."" 이때 격자판은 무한히 넓으니 모든 별을 포함하는 최소한의 크기만 나타내면 됩니다. 따라서 정답은 ""....*...."" ""........."" ""........."" ""*.......*"" ""........."" ""........."" ""........."" ""........."" ""*.......*"" 입니다. 직선 A, B, C에 대한 정보가 담긴 배열 line이 매개변수로 주어집니다. 이때 모든 별을 포함하는 최소 사각형을 return 하도록 solution 함수를 완성해주세요. 제한사항 line의 세로(행) 길이는 2 이상 1,000 이하인 자연수입니다. line의 가로(열) 길이는 3입니다. line의 각 원소는 [A, B, C] 형태입니다. A, B, C는 -100,000 이상 100,000 이하인 정수입니다. 무수히 많은 교점이 생기는 직선 쌍은 주어지지 않습니다. A = 0이면서 B = 0인 경우는 주어지지 않습니다. 정답은 1,000 * 1,000 크기 이내에서 표현됩니다. 별이 한 개 이상 그려지는 입력만 주어집니다. 입출력 예 line result [[2, -1, 4], [-2, -1, 4], [0, -1, 1], [5, -8, -12], [5, 8, 12]] [""....*...."", ""........."", ""........."", ""*.......*"", ""........."", ""........."", ""........."", ""........."", ""*.......*""] [[0, 1, -1], [1, 0, -1], [1, 0, 1]] [""*.*""] [[1, -1, 0], [2, -1, 0]] [""*""] [[1, -1, 0], [2, -1, 0], [4, -1, 0]] [""*""] 입출력 예 설명",normal,Array
109,"n개의 송전탑이 전선을 통해 하나의 트리 형태로 연결되어 있습니다. 당신은 이 전선들 중 하나를 끊어서 현재의 전력망 네트워크를 2개로 분할하려고 합니다. 이때, 두 전력망이 갖게 되는 송전탑의 개수를 최대한 비슷하게 맞추고자 합니다. 송전탑의 개수 n, 그리고 전선 정보 wires가 매개변수로 주어집니다. 전선들 중 하나를 끊어서 송전탑 개수가 가능한 비슷하도록 두 전력망으로 나누었을 때, 두 전력망이 가지고 있는 송전탑 개수의 차이(절대값)를 return 하도록 solution 함수를 완성해주세요. 제한사항 n은 2 이상 100 이하인 자연수입니다. wires는 길이가 n-1인 정수형 2차원 배열입니다. wires의 각 원소는 [v1, v2] 2개의 자연수로 이루어져 있으며, 이는 전력망의 v1번 송전탑과 v2번 송전탑이 전선으로 연결되어 있다는 것을 의미합니다. 1 ≤ v1 < v2 ≤ n 입니다. 전력망 네트워크가 하나의 트리 형태가 아닌 경우는 입력으로 주어지지 않습니다. 입출력 예 n wires result 9 [[1,3],[2,3],[3,4],[4,5],[4,6],[4,7],[7,8],[7,9]] 3 4 [[1,2],[2,3],[3,4]] 0 7 [[1,2],[2,7],[3,7],[3,4],[4,5],[6,7]] 1 입출력 예 설명",normal,Array
110,"당신에게 자연수로 이루어진 길이가 n인 배열 b가 주어집니다. 초기에는 모든 수들이 ""안티 세포"" 안에 들어있습니다. 일반적인 세포는 분열을 하지만, 이 안티 세포는 반대로 여러 안티 세포가 모여 합성을 합니다. 당신은 다음과 같은 과정을 통해 인접한 두 안티 세포를 합치거나 또는 그대로 두려고 합니다. i=0로 설정하고, 빈 배열 c를 하나 만듭니다. i가 n이라면 과정을 종료합니다. b[i]를 포함하는 안티 세포를 X, 그리고 X 바로 왼쪽에 있는 안티 세포를 Y라고 정의합니다. 만약 Y가 존재하고 X의 모든 숫자의 합과 Y의 모든 숫자의 합이 같다면, 당신은 이 두 안티 세포를 합치거나 합치지 않는 행동 중에서 하나를 선택할 수 있습니다. 만약 X와 Y를 합친다면, 둘을 합치고, c의 맨 뒤에 i를 추가한 뒤 다시 3번 과정으로 돌아갑니다. 만약 X와 Y를 합치지 않는다면(또는 Y가 존재하지 않는다면), i를 1 증가시키고 2번 과정으로 돌아갑니다. 예를 들어, 다음은 b = [1,1,1,1]일 때 위와 같은 과정을 거치는 것을 나타낸 것입니다. i 안티 세포 c 비고 0 (1)(1)(1)(1) [] 초기 상태입니다. 1 (1)(1)(1)(1) [] i=0 일 때는 Y가 존재하지 않으므로 i를 1 증가시켰습니다. 1 (1,1)(1)(1) [1] b[1]을 포함하는 안티 세포(X)와 그 왼쪽의 안티 세포(Y)를 합쳤습니다. 따라서 c에 i=1이 추가됩니다. 2 (1,1)(1)(1) [1] b[1]을 포함하는 안티 세포(X) 왼쪽의 안티 세포 Y가 존재하지 않으므로 i를 1 증가시켰습니다. 3 (1,1)(1)(1) [1] X의 모든 수의 합은 1이고, Y의 모든 수의 합은 2이므로, 둘은 합칠 수 없습니다. 따라서 i을 1 증가시켰습니다. 3 (1,1)(1,1) [1,3] b[3]을 포함하는 안티 세포(X)와 그 왼쪽의 안티 세포(Y)를 합쳤습니다. 따라서 c에 i=3이 추가됩니다. 4 (1,1)(1,1) [1,3] b[3]을 포함하는 안티 세포(X)와 그 왼쪽의 안티 세포(Y)를 합칠 수 있었지만 그러지 않았습니다. 따라서 i를 1 증가시켰습니다. 이 경우 c = [1,3]이 됩니다. 물론 이는 c를 만들 수 있는 하나의 경우일 뿐이며, 당신의 선택에 따라 [], [1], [3], [1,3], [2], [1,3,3]으로 c배열을 다양하게 만들 수 있습니다. 당신이 어떤 선택을 하더라도 유한한 횟수 안에 c 배열을 만들 수 있음은 증명될 수 있습니다. 당신은 b가 주어졌을 때 만들 수 있는 서로 다른 배열 c의 개수가 몇 개인지 알고 싶습니다. 정수로 이루어진 배열 a와 s가 매개변수로 주어집니다. a는 여러 개의 b 배열을 순서대로 이어 붙인 배열이며, s는 각 b 배열의 길이가 순서대로 담긴 배열입니다. 각 b 배열에 대해 문제의 답을 109 + 7로 나눈 나머지를 구하여 배열에 차례대로 담아 return 하도록 solution 함수를 완성해주세요. 예를 들어, a = [1,2,3,4,5,6,7,8,9], s = [2,3,4] 라면, 다음 3가지 b 배열에 대해서 답을 구해야 합니다. b = [1,2] (s[0] = 2 이므로, a의 첫 2개 원소가 b 배열을 이룹니다.) b = [3,4,5] (s[1] = 3 이므로, a의 그다음 3개 원소가 b 배열을 이룹니다.) b = [6,7,8,9] (s[2] = 4 이므로, a의 그다음 4개 원소가 b 배열을 이룹니다.) 제한사항 1 ≤ a의 길이 ≤ 200,000 1 ≤ a의 모든 수 ≤ 109 1 ≤ s의 길이 ≤ a의 길이 1 ≤ s의 모든 수 ≤ a의 길이 s의 모든 수의 합 = a의 길이 입출력 예 a s result [1,1,1,1,1,1,2,5,8,2,1,1,4,8,8,8,12,6,6] [4,3,1,5,6] [6,3,1,5,9] 입출력 예 설명",hard,Array
111,"어느 왕국에 하나 이상의 도시들이 있습니다. 왕국의 왕은 새 도시를 짓기로 결정하였습니다. 해당 도시를 짓기 위해서는 도시를 짓는 장소에 금 a kg과 은 b kg이 전달되어야 합니다. 각 도시에는 번호가 매겨져 있는데, i번 도시에는 금 g[i] kg, 은 s[i] kg, 그리고 트럭 한 대가 있습니다. i번 도시의 트럭은 오직 새 도시를 짓는 건설 장소와 i번 도시만을 왕복할 수 있으며, 편도로 이동하는 데 t[i] 시간이 걸리고, 최대 w[i] kg 광물을 운반할 수 있습니다. (광물은 금과 은입니다. 즉, 금과 은을 동시에 운반할 수 있습니다.) 모든 트럭은 같은 도로를 여러 번 왕복할 수 있으며 연료는 무한대라고 가정합니다. 정수 a, b와 정수 배열 g, s, w, t가 매개변수로 주어집니다. 주어진 정보를 바탕으로 각 도시의 트럭을 최적으로 운행했을 때, 새로운 도시를 건설하기 위해 금 a kg과 은 b kg을 전달할 수 있는 가장 빠른 시간을 구해 return 하도록 solution 함수를 완성해주세요. 제한사항 0 ≤ a, b ≤ 109 1 ≤ g의 길이 = s의 길이 = w의 길이 = t의 길이 = 도시 개수 ≤ 105 0 ≤ g[i], s[i] ≤ 109 1 ≤ w[i] ≤ 102 1 ≤ t[i] ≤ 105 a ≤ g의 모든 수의 합 b ≤ s의 모든 수의 합 입출력 예 a b g s w t result 10 10 [100] [100] [7] [10] 50 90 500 [70,70,0] [0,0,500] [100,100,2] [4,8,1] 499 입출력 예 설명",normal,Array
112,"각 칸마다 S, L, 또는 R가 써져 있는 격자가 있습니다. 당신은 이 격자에서 빛을 쏘고자 합니다. 이 격자의 각 칸에는 다음과 같은 특이한 성질이 있습니다. 빛이 ""S""가 써진 칸에 도달한 경우, 직진합니다. 빛이 ""L""이 써진 칸에 도달한 경우, 좌회전을 합니다. 빛이 ""R""이 써진 칸에 도달한 경우, 우회전을 합니다. 빛이 격자의 끝을 넘어갈 경우, 반대쪽 끝으로 다시 돌아옵니다. 예를 들어, 빛이 1행에서 행이 줄어드는 방향으로 이동할 경우, 같은 열의 반대쪽 끝 행으로 다시 돌아옵니다. 당신은 이 격자 내에서 빛이 이동할 수 있는 경로 사이클이 몇 개 있고, 각 사이클의 길이가 얼마인지 알고 싶습니다. 경로 사이클이란, 빛이 이동하는 순환 경로를 의미합니다. 예를 들어, 다음 그림은 격자 [""SL"",""LR""]에서 1행 1열에서 2행 1열 방향으로 빛을 쏠 경우, 해당 빛이 이동하는 경로 사이클을 표현한 것입니다. 이 격자에는 길이가 16인 사이클 1개가 있으며, 다른 사이클은 존재하지 않습니다. 격자의 정보를 나타내는 1차원 문자열 배열 grid가 매개변수로 주어집니다. 주어진 격자를 통해 만들어지는 빛의 경로 사이클의 모든 길이들을 배열에 담아 오름차순으로 정렬하여 return 하도록 solution 함수를 완성해주세요. 제한사항 1 ≤ grid의 길이 ≤ 500 1 ≤ grid의 각 문자열의 길이 ≤ 500 grid의 모든 문자열의 길이는 서로 같습니다. grid의 모든 문자열은 'L', 'R', 'S'로 이루어져 있습니다. 입출력 예 grid result [""SL"",""LR""] [16] [""S""] [1,1,1,1] [""R"",""R""] [4,4] 입출력 예 설명",normal,Array
113,"사전에 알파벳 모음 'A', 'E', 'I', 'O', 'U'만을 사용하여 만들 수 있는, 길이 5 이하의 모든 단어가 수록되어 있습니다. 사전에서 첫 번째 단어는 ""A""이고, 그다음은 ""AA""이며, 마지막 단어는 ""UUUUU""입니다. 단어 하나 word가 매개변수로 주어질 때, 이 단어가 사전에서 몇 번째 단어인지 return 하도록 solution 함수를 완성해주세요. 제한사항 word의 길이는 1 이상 5 이하입니다. word는 알파벳 대문자 'A', 'E', 'I', 'O', 'U'로만 이루어져 있습니다. 입출력 예 word result ""AAAAE"" 6 ""AAAE"" 10 ""I"" 1563 ""EIO"" 1189 입출력 예 설명",normal,Bit Manipulation
114,"테이블 위에 놓인 퍼즐 조각을 게임 보드의 빈 공간에 적절히 올려놓으려 합니다. 게임 보드와 테이블은 모두 각 칸이 1x1 크기인 정사각 격자 모양입니다. 이때, 다음 규칙에 따라 테이블 위에 놓인 퍼즐 조각을 게임 보드의 빈칸에 채우면 됩니다. 조각은 한 번에 하나씩 채워 넣습니다. 조각을 회전시킬 수 있습니다. 조각을 뒤집을 수는 없습니다. 게임 보드에 새로 채워 넣은 퍼즐 조각과 인접한 칸이 비어있으면 안 됩니다. 다음은 퍼즐 조각을 채우는 예시입니다. 위 그림에서 왼쪽은 현재 게임 보드의 상태를, 오른쪽은 테이블 위에 놓인 퍼즐 조각들을 나타냅니다. 테이블 위에 놓인 퍼즐 조각들 또한 마찬가지로 [상,하,좌,우]로 인접해 붙어있는 경우는 없으며, 흰 칸은 퍼즐이 놓이지 않은 빈 공간을 나타냅니다. 모든 퍼즐 조각은 격자 칸에 딱 맞게 놓여있으며, 격자 칸을 벗어나거나, 걸쳐 있는 등 잘못 놓인 경우는 없습니다. 이때, 아래 그림과 같이 3,4,5번 조각을 격자 칸에 놓으면 규칙에 어긋나므로 불가능한 경우입니다. 3번 조각을 놓고 4번 조각을 놓기 전에 위쪽으로 인접한 칸에 빈칸이 생깁니다. 5번 조각의 양 옆으로 인접한 칸에 빈칸이 생깁니다. 다음은 규칙에 맞게 최대한 많은 조각을 게임 보드에 채워 넣은 모습입니다. 최대한 많은 조각을 채워 넣으면 총 14칸을 채울 수 있습니다. 현재 게임 보드의 상태 game_board, 테이블 위에 놓인 퍼즐 조각의 상태 table이 매개변수로 주어집니다. 규칙에 맞게 최대한 많은 퍼즐 조각을 채워 넣을 경우, 총 몇 칸을 채울 수 있는지 return 하도록 solution 함수를 완성해주세요. 제한사항 3 ≤ game_board의 행 길이 ≤ 50 game_board의 각 열 길이 = game_board의 행 길이 즉, 게임 보드는 정사각 격자 모양입니다. game_board의 모든 원소는 0 또는 1입니다. 0은 빈칸, 1은 이미 채워진 칸을 나타냅니다. 퍼즐 조각이 놓일 빈칸은 1 x 1 크기 정사각형이 최소 1개에서 최대 6개까지 연결된 형태로만 주어집니다. table의 행 길이 = game_board의 행 길이 table의 각 열 길이 = table의 행 길이 즉, 테이블은 game_board와 같은 크기의 정사각 격자 모양입니다. table의 모든 원소는 0 또는 1입니다. 0은 빈칸, 1은 조각이 놓인 칸을 나타냅니다. 퍼즐 조각은 1 x 1 크기 정사각형이 최소 1개에서 최대 6개까지 연결된 형태로만 주어집니다. game_board에는 반드시 하나 이상의 빈칸이 있습니다. table에는 반드시 하나 이상의 블록이 놓여 있습니다. 입출력 예 game_board table result [[1,1,0,0,1,0],[0,0,1,0,1,0],[0,1,1,0,0,1],[1,1,0,1,1,1],[1,0,0,0,1,0],[0,1,1,1,0,0]] [[1,0,0,1,1,0],[1,0,1,0,1,0],[0,1,1,0,1,1],[0,0,1,0,0,0],[1,1,0,1,1,0],[0,1,0,0,0,0]] 14 [[0,0,0],[1,1,0],[1,1,1]] [[1,1,1],[1,0,0],[0,0,0]] 0 입출력 예 설명",normal,Math
115,"[본 문제는 정확성과 효율성 테스트 각각 점수가 있는 문제입니다.] 카카오 인턴을 선발하는 코딩 테스트 시험장이 하나의 이진 트리1 형태로 연결되어 있습니다. 아래 그림은 12개의 시험장이 연결된 예시입니다. 하나의 노드는 하나의 시험장을 나타냅니다. 검은 바탕의 흰 숫자는 해당 시험장의 고유 번호(ID)를 나타냅니다. 2-1. 시험장이 n개 있다면, 시험장의 고유 번호는 0부터 n-1까지 부여됩니다. 노드 안의 빨간 숫자는, 해당 시험장의 응시자 수를 나타냅니다. 3-1. 위의 그림에서, 9번 시험장에는 10명, 4번 시험장에는 8명, 6번 시험장에는 20명의 응시자가 시험을 볼 예정입니다. 노드 사이의 간선은 해당 시험장이 연결되어 있음을 의미합니다. 4-1. 위의 그림에서, 9번 시험장은 7번 시험장과, 7번 시험장은 6번 시험장과 연결되어 있습니다. 코딩 테스트를 총괄하는 무지는 안정적인 시험을 위해, 시험장에서 오는 트래픽을 k개의 그룹으로 나누어 각 그룹별 서버로 분산시키기로 하였습니다. 시험장 사이를 연결한 간선들 중 k-1개를 끊어서 시험장을 k 개의 그룹으로 나눌 계획입니다. 이때, 그룹별 최대 트래픽을 최소화하기 위하여 가장 큰 그룹의 인원을 최소화시켜야 합니다. 위의 그림에서 7번과 6번 시험장을 잇는 간선을 끊고, 9번과 7번 시험장을 잇는 간선을 끊는다면, 전체 시험장은 3개의 그룹으로 나누어집니다. 주황색 노드로 표시된 A그룹의 인원은 35명(10+8+5+6+1+1+4) 보라색 노드로 표시된 B그룹의 인원은 37명(7+30) 녹색 노드로 표시된 C그룹의 인원은 40명(20+8+12) 즉, 인원이 가장 많은 그룹은 40명입니다. 다른 어떤 방법으로 시험장을 3개의 그룹으로 나눈다고 해도, 인원이 가장 많은 그룹의 인원이 40명 미만이 되도록 나눌 수는 없습니다. 나눌 그룹의 수를 나타내는 정수 k, 각 시험장의 응시자 수를 나타내는 1차원 정수 배열 num, 시험장의 연결 상태를 나타내는 2차원 정수 배열 links가 매개변수로 주어집니다. 인원이 가장 많은 그룹의 인원이 최소화되도록 k개의 그룹으로 나누었을 때, 최소화된 최대 그룹의 인원을 return 하도록 solution 함수를 완성해주세요. 제한사항 1 ≤ k ≤ 10,000 k ≤ num의 길이 ≤ 10,000 num[i]에는 i번 시험장의 응시자 수가 담겨있습니다. 1 ≤ num의 원소 ≤ 10,000 links의 길이 = num의 길이 links의 i번째 행은 i번 노드(시험장)의 [왼쪽 자식 노드 번호, 오른쪽 자식 노드 번호]입니다. 해당 위치에 자식 노드가 없는 경우 -1이 담겨있습니다. 잘못된 노드 번호나, 하나의 이진 트리 구조가 아닌 입력은 주어지지 않습니다. 정확성 테스트 케이스 제한 사항 1 ≤ k ≤ 20 k ≤ num의 길이 ≤ 20 효율성 테스트 케이스 제한 사항 주어진 조건 외 추가 제한사항 없습니다. 입출력 예 k num links result 3 [12, 30, 1, 8, 8, 6, 20, 7, 5, 10, 4, 1] [[-1, -1], [-1, -1], [-1, -1], [-1, -1], [8, 5], [2, 10], [3, 0], [6, 1], [11, -1], [7, 4], [-1, -1], [-1, -1]] 40 1 [6, 9, 7, 5] [[-1, -1], [-1, -1], [-1, 0], [2, 1]] 27 2 [6, 9, 7, 5] [[-1, -1], [-1, -1], [-1, 0], [2, 1]] 14 4 [6, 9, 7, 5] [[-1, -1], [-1, -1], [-1, 0], [2, 1]] 9 입출력 예 설명",hard,Array
116,"신규 게임 ‘카카오 미로 탈출’이 출시되어, 라이언이 베타테스터로 참가했습니다. 위 예시 그림은 카카오 미로 탈출의 초기 상태를 나타냅니다. 1번부터 3번까지 번호가 붙어있는 3개의 방이 있고, 방과 방 사이를 연결하는 길에는 이동하는데 걸리는 시간이 표시되어 있습니다. 길은 화살표가 가리키는 방향으로만 이동할 수 있습니다. 미로에는 함정이 존재하며, 함정으로 이동하면, 이동한 함정과 연결된 모든 화살표의 방향이 바뀝니다. 출발지점인 1번 방에서 탈출이 가능한 3번 방까지 이동해야 합니다. 탈출하는데 걸리는 최소 시간을 구하려고 합니다. 그림의 원은 방을 나타내며 원 안의 숫자는 방 번호를 나타냅니다. 방이 n개일 때, 방 번호는 1부터 n까지 사용됩니다. 화살표에 표시된 숫자는 방과 방 사이를 이동할 때 걸리는 시간을 나타냅니다. 화살표가 가리키고 있는 방향으로만 이동이 가능합니다. 즉, 위 그림에서 2번 방에서 1번 방으로는 이동할 수 없습니다. 그림에 표시된 빨간색 방인 2번 방은 함정입니다. 함정 방으로 이동하는 순간, 이동한 함정 방과 연결되어있는 모든 길의 방향이 반대가 됩니다. 위 그림 1번 방에서 2번 방으로 이동하는 순간 1에서 2로 이동할 수 있던 길은 2에서 1로 이동할 수 있는 길로 바뀌고, 3에서 2로 이동할 수 있던 길은 2에서 3으로 이동할 수 있는 길로 바뀝니다. 똑같은 함정 방을 두 번째 방문하게 되면 원래 방향의 길로 돌아옵니다. 즉, 여러 번 방문하여 계속 길의 방향을 반대로 뒤집을 수 있습니다. 미로를 탈출하는데 필요한 최단 시간은 다음과 같습니다. 1→2: 2번 방으로 이동합니다. 이동 시간은 2입니다. 함정 발동: 2번 방과 연결된 모든 길의 방향이 반대가 됩니다. 2→3: 3번 방으로 이동합니다. 이동 시간은 3입니다. 탈출에 성공했습니다. 총 이동시간은 5입니다. 방의 개수를 나타내는 정수 n, 출발 방의 번호 start, 도착 방의 번호 end, 통로와 이동시간을 나타내는 2차원 정수 배열 roads, 함정 방의 번호를 담은 정수 배열 traps이 매개변수로 주어질 때, 미로를 탈출하는데 필요한 최단 시간을 return 하도록 solution 함수를 완성해주세요. 제한사항 2 ≤ n ≤ 1,000 1 ≤ start ≤ n 1 ≤ end ≤ n 1 ≤ roads의 행 길이 ≤ 3,000 roads의 행은 [P, Q, S]로 이루어져 있습니다. P에서 Q로 갈 수 있는 길이 있으며, 길을 따라 이동하는데 S만큼 시간이 걸립니다. 1 ≤ P ≤ n 1 ≤ Q ≤ n P ≠ Q 1 ≤ S ≤ 3,000 서로 다른 두 방 사이에 직접 연결된 길이 여러 개 존재할 수도 있습니다. 0 ≤ traps의 길이 ≤ 10 1 ≤ traps의 원소 ≤ n 시작 방과 도착 방은 함정이 아닙니다. 항상 미로를 탈출할 수 있는 경우만 주어집니다. 입출력 예 n start end roads traps result 3 1 3 [[1, 2, 2], [3, 2, 3]] [2] 5 4 1 4 [[1, 2, 1], [3, 2, 1], [2, 4, 1]] [2, 3] 4 입출력 예 설명",hard,Array
117,"[본 문제는 정확성과 효율성 테스트 각각 점수가 있는 문제입니다.] 업무용 소프트웨어를 개발하는 니니즈웍스의 인턴인 앙몬드는 명령어 기반으로 표의 행을 선택, 삭제, 복구하는 프로그램을 작성하는 과제를 맡았습니다. 세부 요구 사항은 다음과 같습니다 위 그림에서 파란색으로 칠해진 칸은 현재 선택된 행을 나타냅니다. 단, 한 번에 한 행만 선택할 수 있으며, 표의 범위(0행 ~ 마지막 행)를 벗어날 수 없습니다. 이때, 다음과 같은 명령어를 이용하여 표를 편집합니다. ""U X"": 현재 선택된 행에서 X칸 위에 있는 행을 선택합니다. ""D X"": 현재 선택된 행에서 X칸 아래에 있는 행을 선택합니다. ""C"" : 현재 선택된 행을 삭제한 후, 바로 아래 행을 선택합니다. 단, 삭제된 행이 가장 마지막 행인 경우 바로 윗 행을 선택합니다. ""Z"" : 가장 최근에 삭제된 행을 원래대로 복구합니다. 단, 현재 선택된 행은 바뀌지 않습니다. 예를 들어 위 표에서 ""D 2""를 수행할 경우 아래 그림의 왼쪽처럼 4행이 선택되며, ""C""를 수행하면 선택된 행을 삭제하고, 바로 아래 행이었던 ""네오""가 적힌 행을 선택합니다(4행이 삭제되면서 아래 있던 행들이 하나씩 밀려 올라오고, 수정된 표에서 다시 4행을 선택하는 것과 동일합니다). 다음으로 ""U 3""을 수행한 다음 ""C""를 수행한 후의 표 상태는 아래 그림과 같습니다. 다음으로 ""D 4""를 수행한 다음 ""C""를 수행한 후의 표 상태는 아래 그림과 같습니다. 5행이 표의 마지막 행 이므로, 이 경우 바로 윗 행을 선택하는 점에 주의합니다. 다음으로 ""U 2""를 수행하면 현재 선택된 행은 2행이 됩니다. 위 상태에서 ""Z""를 수행할 경우 가장 최근에 제거된 ""라이언""이 적힌 행이 원래대로 복구됩니다. 다시한번 ""Z""를 수행하면 그 다음으로 최근에 제거된 ""콘""이 적힌 행이 원래대로 복구됩니다. 이때, 현재 선택된 행은 바뀌지 않는 점에 주의하세요. 이때, 최종 표의 상태와 처음 주어진 표의 상태를 비교하여 삭제되지 않은 행은 ""O"", 삭제된 행은 ""X""로 표시하면 다음과 같습니다. 처음 표의 행 개수를 나타내는 정수 n, 처음에 선택된 행의 위치를 나타내는 정수 k, 수행한 명령어들이 담긴 문자열 배열 cmd가 매개변수로 주어질 때, 모든 명령어를 수행한 후 표의 상태와 처음 주어진 표의 상태를 비교하여 삭제되지 않은 행은 O, 삭제된 행은 X로 표시하여 문자열 형태로 return 하도록 solution 함수를 완성해주세요. 제한사항 5 ≤ n ≤ 1,000,000 0 ≤ k < n 1 ≤ cmd의 원소 개수 ≤ 200,000 cmd의 각 원소는 ""U X"", ""D X"", ""C"", ""Z"" 중 하나입니다. X는 1 이상 300,000 이하인 자연수이며 0으로 시작하지 않습니다. X가 나타내는 자연수에 ',' 는 주어지지 않습니다. 예를 들어 123,456의 경우 123456으로 주어집니다. cmd에 등장하는 모든 X들의 값을 합친 결과가 1,000,000 이하인 경우만 입력으로 주어집니다. 표의 모든 행을 제거하여, 행이 하나도 남지 않는 경우는 입력으로 주어지지 않습니다. 본문에서 각 행이 제거되고 복구되는 과정을 보다 자연스럽게 보이기 위해 ""이름"" 열을 사용하였으나, ""이름""열의 내용이 실제 문제를 푸는 과정에 필요하지는 않습니다. ""이름""열에는 서로 다른 이름들이 중복없이 채워져 있다고 가정하고 문제를 해결해 주세요. 표의 범위를 벗어나는 이동은 입력으로 주어지지 않습니다. 원래대로 복구할 행이 없을 때(즉, 삭제된 행이 없을 때) ""Z""가 명령어로 주어지는 경우는 없습니다. 정답은 표의 0행부터 n - 1행까지에 해당되는 O, X를 순서대로 이어붙인 문자열 형태로 return 해주세요. 정확성 테스트 케이스 제한 사항 5 ≤ n ≤ 1,000 1 ≤ cmd의 원소 개수 ≤ 1,000 효율성 테스트 케이스 제한 사항 주어진 조건 외 추가 제한사항 없습니다. 입출력 예 n k cmd result 8 2 [""D 2"",""C"",""U 3"",""C"",""D 4"",""C"",""U 2"",""Z"",""Z""] ""OOOOXOOO"" 8 2 [""D 2"",""C"",""U 3"",""C"",""D 4"",""C"",""U 2"",""Z"",""Z"",""U 1"",""C""] ""OOXOXOOO"" 입출력 예 설명",normal,Array
118,"개발자를 희망하는 죠르디가 카카오에 면접을 보러 왔습니다. 코로나 바이러스 감염 예방을 위해 응시자들은 거리를 둬서 대기를 해야하는데 개발 직군 면접인 만큼 아래와 같은 규칙으로 대기실에 거리를 두고 앉도록 안내하고 있습니다. 대기실은 5개이며, 각 대기실은 5x5 크기입니다. 거리두기를 위하여 응시자들 끼리는 맨해튼 거리1가 2 이하로 앉지 말아 주세요. 단 응시자가 앉아있는 자리 사이가 파티션으로 막혀 있을 경우에는 허용합니다. 예를 들어, 위 그림처럼 자리 사이에 파티션이 존재한다면 맨해튼 거리가 2여도 거리두기를 지킨 것입니다. 위 그림처럼 파티션을 사이에 두고 앉은 경우도 거리두기를 지킨 것입니다. 위 그림처럼 자리 사이가 맨해튼 거리 2이고 사이에 빈 테이블이 있는 경우는 거리두기를 지키지 않은 것입니다. 응시자가 앉아있는 자리(P)를 의미합니다. 빈 테이블(O)을 의미합니다. 파티션(X)을 의미합니다. 5개의 대기실을 본 죠르디는 각 대기실에서 응시자들이 거리두기를 잘 기키고 있는지 알고 싶어졌습니다. 자리에 앉아있는 응시자들의 정보와 대기실 구조를 대기실별로 담은 2차원 문자열 배열 places가 매개변수로 주어집니다. 각 대기실별로 거리두기를 지키고 있으면 1을, 한 명이라도 지키지 않고 있으면 0을 배열에 담아 return 하도록 solution 함수를 완성해 주세요. 제한사항 places의 행 길이(대기실 개수) = 5 places의 각 행은 하나의 대기실 구조를 나타냅니다. places의 열 길이(대기실 세로 길이) = 5 places의 원소는 P,O,X로 이루어진 문자열입니다. places 원소의 길이(대기실 가로 길이) = 5 P는 응시자가 앉아있는 자리를 의미합니다. O는 빈 테이블을 의미합니다. X는 파티션을 의미합니다. 입력으로 주어지는 5개 대기실의 크기는 모두 5x5 입니다. return 값 형식 1차원 정수 배열에 5개의 원소를 담아서 return 합니다. places에 담겨 있는 5개 대기실의 순서대로, 거리두기 준수 여부를 차례대로 배열에 담습니다. 각 대기실 별로 모든 응시자가 거리두기를 지키고 있으면 1을, 한 명이라도 지키지 않고 있으면 0을 담습니다. 입출력 예 places result [[""POOOP"", ""OXXOX"", ""OPXPX"", ""OOXOX"", ""POXXP""], [""POOPX"", ""OXPXP"", ""PXXXO"", ""OXXXO"", ""OOOPP""], [""PXOPX"", ""OXOXP"", ""OXPOX"", ""OXXOP"", ""PXPOX""], [""OOOXX"", ""XOOOX"", ""OOOXX"", ""OXOOX"", ""OOOOO""], [""PXPXP"", ""XPXPX"", ""PXPXP"", ""XPXPX"", ""PXPXP""]] [1, 0, 1, 1, 1] 입출력 예 설명",normal,Array
119,"1부터 n까지 번호가 하나씩 붙은 n개의 노드를 갖는 트리가 주어집니다. 각 노드에는 값이 하나씩 들어 있으며, 이 트리의 루트 노드는 1번 노드입니다. 당신은 이 트리에 대해 다음과 같은 쿼리 두 종류를 처리하면 됩니다. 1번 쿼리: 정수 u가 주어집니다. u번 노드의 서브 트리의 모든 노드의 값의 합을 구해야 합니다. 2번 쿼리: 정수 u, w가 주어집니다. u번 노드의 값을 삭제한 뒤, u번 노드의 부모 노드의 값을 u번 노드로 복사합니다., u번 노드의 부모 노드에 대해 같은 작업을 반복하며 루트노드까지 거슬러 올라갑니다. 마지막으로 루트 노드의 값을 w로 바꿉니다. 트리의 노드 초기값이 담긴 정수 배열 values, 트리의 연결 상태가 담긴 2차원 정수 배열 edges, 쿼리들이 담긴 2차원 정수 배열 queries가 주어집니다. 쿼리들을 순서대로 처리할 때, 각 1번 쿼리에 대한 답을 수행 순서대로 배열에 담아 return 하도록 solution 함수를 완성해주세요. 제한사항 1 ≤ values의 길이 ≤ 100,000 values의 길이는 트리의 노드 개수를 의미합니다. values[i]는 i+1번 노드의 초기 값을 의미합니다. edges의 길이 = values의 길이 - 1 edges의 각 행은 [v1, v2] 2개의 정수로 이루어져 있으며, 이는 v1번 노드와 v2번 노드가 연결되어 있음을 의미합니다. 주어진 그래프는 항상 1번 노드가 루트인 트리 형태입니다. 1 ≤ queries의 길이 ≤ 100,000 queries의 각 행은 단일 쿼리를 의미하며, [u, w] 2개의 정수로 이루어져 있습니다. 1 ≤ u ≤ values의 길이 -1 ≤ w ≤ 109 w가 -1일 경우, 이 쿼리는 1번 쿼리이며, 그렇지 않을 경우 이 쿼리는 2번 쿼리입니다. 입출력 예 values edges queries result [1,10,100,1000,10000] [[1,2],[1,3],[2,4],[2,5]] [[1,-1],[2,-1],[3,-1],[4,-1],[5,-1],[4,1000],[1,-1],[2,-1],[3,-1],[4,-1],[5,-1],[2,1],[1,-1],[2,-1],[3,-1],[4,-1],[5,-1]] [11111,11010,100,1000,10000,11111,10011,100,10,10000,11111,11010,100,10,10000] 입출력 예 설명",hard,Array
120,"0과 1로 이루어진 어떤 문자열 x에 대해서, 당신은 다음과 같은 행동을 통해 x를 최대한 사전 순으로 앞에 오도록 만들고자 합니다. x에 있는 ""110""을 뽑아서, 임의의 위치에 다시 삽입합니다. 예를 들어, x = ""11100"" 일 때, 여기서 중앙에 있는 ""110""을 뽑으면 x = ""10"" 이 됩니다. 뽑았던 ""110""을 x의 맨 앞에 다시 삽입하면 x = ""11010"" 이 됩니다. 변형시킬 문자열 x가 여러 개 들어있는 문자열 배열 s가 주어졌을 때, 각 문자열에 대해서 위의 행동으로 변형해서 만들 수 있는 문자열 중 사전 순으로 가장 앞에 오는 문자열을 배열에 담아 return 하도록 solution 함수를 완성해주세요. 제한사항 1 ≤ s의 길이 ≤ 1,000,000 1 ≤ s의 각 원소 길이 ≤ 1,000,000 1 ≤ s의 모든 원소의 길이의 합 ≤ 1,000,000 입출력 예 s result [""1110"",""100111100"",""0111111010""] [""1101"",""100110110"",""0110110111""] 입출력 예 설명",normal,Array
121,"양의 정수 x에 대한 함수 f(x)를 다음과 같이 정의합니다. x보다 크고 x와 비트가 1~2개 다른 수들 중에서 제일 작은 수 예를 들어, f(2) = 3 입니다. 다음 표와 같이 2보다 큰 수들 중에서 비트가 다른 지점이 2개 이하이면서 제일 작은 수가 3이기 때문입니다. 수 비트 다른 비트의 개수 2 000...0010 3 000...0011 1 f(7) = 11 입니다. 다음 표와 같이 7보다 큰 수들 중에서 비트가 다른 지점이 2개 이하이면서 제일 작은 수가 11이기 때문입니다. 수 비트 다른 비트의 개수 7 000...0111 8 000...1000 4 9 000...1001 3 10 000...1010 3 11 000...1011 2 정수들이 담긴 배열 numbers가 매개변수로 주어집니다. numbers의 모든 수들에 대하여 각 수의 f 값을 배열에 차례대로 담아 return 하도록 solution 함수를 완성해주세요. 제한사항 1 ≤ numbers의 길이 ≤ 100,000 0 ≤ numbers의 모든 수 ≤ 1015 입출력 예 numbers result [2,7] [3,11] 입출력 예 설명",normal,Array
122,"PLACES 테이블은 공간 임대 서비스에 등록된 공간의 정보를 담은 테이블입니다. PLACES 테이블의 구조는 다음과 같으며 ID, NAME, HOST_ID는 각각 공간의 아이디, 이름, 공간을 소유한 유저의 아이디를 나타냅니다. ID는 기본키입니다. NAME TYPE ID INT NAME VARCHAR HOST_ID INT 문제 이 서비스에서는 공간을 둘 이상 등록한 사람을 ""헤비 유저""라고 부릅니다. 헤비 유저가 등록한 공간의 정보를 아이디 순으로 조회하는 SQL문을 작성해주세요. 예시 예를 들어, PLACES 테이블이 다음과 같다면 ID NAME HOST_ID 4431977 BOUTIQUE STAYS - Somerset Terrace, Pet Friendly 760849 5194998 BOUTIQUE STAYS - Elwood Beaches 3, Pet Friendly 760849 16045624 Urban Jungle in the Heart of Melbourne 30900122 17810814 Stylish Bayside Retreat with a Luscious Garden 760849 22740286 FREE PARKING - The Velvet Lux in Melbourne CBD 30900122 22868779 ★ Fresh Fitzroy Pad with City Views! ★ 21058208 760849번 유저는 공간을 3개 등록했으므로 이 유저는 헤비유저입니다. 30900122번 유저는 공간을 2개 등록했으므로 이 유저는 헤비유저입니다. 21058208번 유저는 공간을 1개 등록했으므로 이 유저는 헤비유저가 아닙니다. 따라서 SQL 문을 실행하면 다음과 같이 나와야 합니다. ID NAME HOST_ID 4431977 BOUTIQUE STAYS - Somerset Terrace, Pet Friendly 760849 5194998 BOUTIQUE STAYS - Elwood Beaches 3, Pet Friendly 760849 16045624 Urban Jungle in the Heart of Melbourne 30900122 17810814 Stylish Bayside Retreat with a Luscious Garden 760849 22740286 FREE PARKING - The Velvet Lux in Melbourne CBD 30900122",normal,database
123,"민호는 다단계 조직을 이용하여 칫솔을 판매하고 있습니다. 판매원이 칫솔을 판매하면 그 이익이 피라미드 조직을 타고 조금씩 분배되는 형태의 판매망입니다. 어느정도 판매가 이루어진 후, 조직을 운영하던 민호는 조직 내 누가 얼마만큼의 이득을 가져갔는지가 궁금해졌습니다. 예를 들어, 민호가 운영하고 있는 다단계 칫솔 판매 조직이 아래 그림과 같다고 합시다. 민호는 center이며, 파란색 네모는 여덟 명의 판매원을 표시한 것입니다. 각각은 자신을 조직에 참여시킨 추천인에 연결되어 피라미드 식의 구조를 이루고 있습니다. 조직의 이익 분배 규칙은 간단합니다. 모든 판매원은 칫솔의 판매에 의하여 발생하는 이익에서 10% 를 계산하여 자신을 조직에 참여시킨 추천인에게 배분하고 나머지는 자신이 가집니다. 모든 판매원은 자신이 칫솔 판매에서 발생한 이익 뿐만 아니라, 자신이 조직에 추천하여 가입시킨 판매원에게서 발생하는 이익의 10% 까지 자신에 이익이 됩니다. 자신에게 발생하는 이익 또한 마찬가지의 규칙으로 자신의 추천인에게 분배됩니다. 단, 10% 를 계산할 때에는 원 단위에서 절사하며, 10%를 계산한 금액이 1 원 미만인 경우에는 이득을 분배하지 않고 자신이 모두 가집니다. 예를 들어, 아래와 같은 판매 기록이 있다고 가정하겠습니다. 칫솔의 판매에서 발생하는 이익은 개당 100 원으로 정해져 있습니다. 판매원 판매 수량 이익금 young 12 1,200 원 john 4 400 원 tod 2 200 원 emily 5 500 원 mary 10 1,000 원 판매원 young 에 의하여 1,200 원의 이익이 발생했습니다. young 은 이 중 10% 에 해당하는 120 원을, 자신을 조직에 참여시킨 추천인인 edward 에게 배분하고 자신은 나머지인 1,080 원을 가집니다. edward 는 young 에게서 받은 120 원 중 10% 인 12 원을 mary 에게 배분하고 자신은 나머지인 108 원을 가집니다. 12 원을 edward 로부터 받은 mary 는 10% 인 1 원을 센터에 (즉, 민호에게) 배분하고 자신은 나머지인 11 원을 가집니다. 이 상태를 그림으로 나타내면 아래와 같습니다. 그 후, 판매원 john 에 의하여 400 원의 이익이 발생합니다. john 은 10% 인 40 원을 센터에 배분하고 자신이 나머지인 360 원을 가집니다. 이 상태를 그림으로 나타내면 아래와 같습니다. 또 그 후에는 판매원 tod 에 의하여 200 원 이익이 발생하는데, tod 자신이 180 원을, 추천인인 jaimie 가 그 중 10% 인 20 원을 받아서 18 원을 가지고, jaimie 의 추천인인 mary 는 2 원을 받지만 이것의 10% 는 원 단위에서 절사하면 배분할 금액이 없기 때문에 mary 는 2 원을 모두 가집니다. 이 상태를 그림으로 나타내면 아래와 같습니다. 그 다음으로 emily 가 칫솔 판매를 통하여 얻은 이익 500 원은 마찬가지의 규칙에 따라 emily 에게 450 원, mary 에게 45 원, 그리고 센터에 5 원으로 분배됩니다. 이 상태를 그림으로 나타내면 아래와 같습니다. 마지막으로, 판매원 mary 는 1,000 원의 이익을 달성하고, 이 중 10% 인 100 원을 센터에 배분한 후 그 나머지인 900 원을 자신이 가집니다. 이 상태를 그림으로 나타내면 아래와 같습니다. 위와 같이 하여 모든 조직 구성원들의 이익 달성 현황 집계가 끝났습니다. 지금까지 얻은 이익을 모두 합한 결과를 그림으로 나타내면 아래와 같습니다. 이 결과가 민호가 파악하고자 하는 이익 배분 현황입니다. 각 판매원의 이름을 담은 배열 enroll, 각 판매원을 다단계 조직에 참여시킨 다른 판매원의 이름을 담은 배열 referral, 판매량 집계 데이터의 판매원 이름을 나열한 배열 seller, 판매량 집계 데이터의 판매 수량을 나열한 배열 amount가 매개변수로 주어질 때, 각 판매원이 득한 이익금을 나열한 배열을 return 하도록 solution 함수를 완성해주세요. 판매원에게 배분된 이익금의 총합을 계산하여(정수형으로), 입력으로 주어진 enroll에 이름이 포함된 순서에 따라 나열하면 됩니다. 제한사항 enroll의 길이는 1 이상 10,000 이하입니다. enroll에 민호의 이름은 없습니다. 따라서 enroll의 길이는 민호를 제외한 조직 구성원의 총 수입니다. referral의 길이는 enroll의 길이와 같습니다. referral 내에서 i 번째에 있는 이름은 배열 enroll 내에서 i 번째에 있는 판매원을 조직에 참여시킨 사람의 이름입니다. 어느 누구의 추천도 없이 조직에 참여한 사람에 대해서는 referral 배열 내에 추천인의 이름이 기입되지 않고 “-“ 가 기입됩니다. 위 예제에서는 john 과 mary 가 이러한 예에 해당합니다. enroll 에 등장하는 이름은 조직에 참여한 순서에 따릅니다. 즉, 어느 판매원의 이름이 enroll 의 i 번째에 등장한다면, 이 판매원을 조직에 참여시킨 사람의 이름, 즉 referral 의 i 번째 원소는 이미 배열 enroll 의 j 번째 (j < i) 에 등장했음이 보장됩니다. seller의 길이는 1 이상 100,000 이하입니다. seller 내의 i 번째에 있는 이름은 i 번째 판매 집계 데이터가 어느 판매원에 의한 것인지를 나타냅니다. seller 에는 같은 이름이 중복해서 들어있을 수 있습니다. amount의 길이는 seller의 길이와 같습니다. amount 내의 i 번째에 있는 수는 i 번째 판매 집계 데이터의 판매량을 나타냅니다. 판매량의 범위, 즉 amount 의 원소들의 범위는 1 이상 100 이하인 자연수입니다. 칫솔 한 개를 판매하여 얻어지는 이익은 100 원으로 정해져 있습니다. 모든 조직 구성원들의 이름은 10 글자 이내의 영문 알파벳 소문자들로만 이루어져 있습니다. 입출력 예 enroll referral seller amount result [""john"", ""mary"", ""edward"", ""sam"", ""emily"", ""jaimie"", ""tod"", ""young""] [""-"", ""-"", ""mary"", ""edward"", ""mary"", ""mary"", ""jaimie"", ""edward""] [""young"", ""john"", ""tod"", ""emily"", ""mary""] [12, 4, 2, 5, 10] [360, 958, 108, 0, 450, 18, 180, 1080] [""john"", ""mary"", ""edward"", ""sam"", ""emily"", ""jaimie"", ""tod"", ""young""] [""-"", ""-"", ""mary"", ""edward"", ""mary"", ""mary"", ""jaimie"", ""edward""] [""sam"", ""emily"", ""jaimie"", ""edward""] [2, 3, 5, 4] [0, 110, 378, 180, 270, 450, 0, 0] 입출력 예 설명",normal,Array
124,"rows x columns 크기인 행렬이 있습니다. 행렬에는 1부터 rows x columns까지의 숫자가 한 줄씩 순서대로 적혀있습니다. 이 행렬에서 직사각형 모양의 범위를 여러 번 선택해, 테두리 부분에 있는 숫자들을 시계방향으로 회전시키려 합니다. 각 회전은 (x1, y1, x2, y2)인 정수 4개로 표현하며, 그 의미는 다음과 같습니다. x1 행 y1 열부터 x2 행 y2 열까지의 영역에 해당하는 직사각형에서 테두리에 있는 숫자들을 한 칸씩 시계방향으로 회전합니다. 다음은 6 x 6 크기 행렬의 예시입니다. 이 행렬에 (2, 2, 5, 4) 회전을 적용하면, 아래 그림과 같이 2행 2열부터 5행 4열까지 영역의 테두리가 시계방향으로 회전합니다. 이때, 중앙의 15와 21이 있는 영역은 회전하지 않는 것을 주의하세요. 행렬의 세로 길이(행 개수) rows, 가로 길이(열 개수) columns, 그리고 회전들의 목록 queries가 주어질 때, 각 회전들을 배열에 적용한 뒤, 그 회전에 의해 위치가 바뀐 숫자들 중 가장 작은 숫자들을 순서대로 배열에 담아 return 하도록 solution 함수를 완성해주세요. 제한사항 rows는 2 이상 100 이하인 자연수입니다. columns는 2 이상 100 이하인 자연수입니다. 처음에 행렬에는 가로 방향으로 숫자가 1부터 하나씩 증가하면서 적혀있습니다. 즉, 아무 회전도 하지 않았을 때, i 행 j 열에 있는 숫자는 ((i-1) x columns + j)입니다. queries의 행의 개수(회전의 개수)는 1 이상 10,000 이하입니다. queries의 각 행은 4개의 정수 [x1, y1, x2, y2]입니다. x1 행 y1 열부터 x2 행 y2 열까지 영역의 테두리를 시계방향으로 회전한다는 뜻입니다. 1 ≤ x1 < x2 ≤ rows, 1 ≤ y1 < y2 ≤ columns입니다. 모든 회전은 순서대로 이루어집니다. 예를 들어, 두 번째 회전에 대한 답은 첫 번째 회전을 실행한 다음, 그 상태에서 두 번째 회전을 실행했을 때 이동한 숫자 중 최솟값을 구하면 됩니다. 입출력 예시 rows columns queries result 6 6 [[2,2,5,4],[3,3,6,6],[5,1,6,3]] [8, 10, 25] 3 3 [[1,1,2,2],[1,2,2,3],[2,1,3,2],[2,2,3,3]] [1, 1, 5, 3] 100 97 [[1,1,100,97]] [1] 입출력 예 설명",normal,Array
125,"당신은 어떤 RPG 게임의 주인공입니다. 게임에는 n개의 도시(0번, 1번, ..., n-1번)와 m개의 도시 간 도로, 그리고 상수값 z가 있습니다. 각 도로는 일방통행이며, 도로마다 다른 가중치값 w (이 w는 z보다 항상 작습니다)를 가지고 있습니다. 당신은 게임 도중 매 턴당 다음 행동 중 하나를 취할 수 있습니다. 현재 있는 도시에서 연결된 도로를 따라 다른 도시로 이동합니다. 해당 도로의 가중치값을 w라고 할 때, w원을 얻습니다. 현재 있는 도시에서 움직이지 않고 z원을 얻습니다. 원하는 아무 도시로 순간 이동합니다. 이때 얻는 돈은 없습니다. 여기서 주의해야 할 점은, 같은 도로를 몇 번을 사용하든 그 도로를 사용할 때마다 얻는 금액은 동일하다는 것입니다. 이때, 당신에게 q개의 쿼리가 주어집니다. 각 쿼리는 단일 숫자 c로 이루어져 있으며, 당신은 이 게임을 0번 도시에서 0원을 가진 상태에서 시작했을 때, 정확히 c원을 얻는 것이 가능한지, 가능하다면 최소 몇 턴만에 c원을 얻을 수 있는지를 판별해야 합니다. 도시의 숫자 n, 게임의 상수값 z, 도시 간 도로의 정보 roads, 그리고 쿼리들로 이루어진 배열 queries가 매개변수로 주어집니다. 주어진 정보들을 활용하여 각 쿼리의 답(불가능한 경우 -1)을 배열에 담아 return 하도록 solution 함수를 완성해주세요. 제한사항 n은 2 이상 3,000 이하입니다. z는 2 이상 50 이하입니다. roads의 길이는 1 이상 3,000 이하입니다. roads의 각 행은 [u, v, w] 3개의 정수로 이루어져 있으며, 이는 u번 도시부터 v번 도시까지 도로가 연결되어 있고, 해당 도로를 따라 이동했을 때 w원을 얻을 수 있음을 의미합니다. 0 ≤ u, v < n 입니다. 1 ≤ w < z 입니다. u와 v는 서로 다른 수입니다. u번 도시에서 v번 도시로 가는 도로는 최대 하나뿐입니다. queries의 길이는 1 이상 100,000 이하입니다. queries의 모든 숫자는 0 이상 1018 이하입니다. 입출력 예 n z roads queries result 5 5 [[1,2,3],[0,3,2]] [0,1,2,3,4,5,6] [0,-1,1,2,3,1,4] 입출력 예 설명",hard,Array
126,"각 점에 가중치가 부여된 트리가 주어집니다. 당신은 다음 연산을 통하여, 이 트리의 모든 점들의 가중치를 0으로 만들고자 합니다. 임의의 연결된 두 점을 골라서 한쪽은 1 증가시키고, 다른 한쪽은 1 감소시킵니다. 하지만, 모든 트리가 위의 행동을 통하여 모든 점들의 가중치를 0으로 만들 수 있는 것은 아닙니다. 당신은 주어진 트리에 대해서 해당 사항이 가능한지 판별하고, 만약 가능하다면 최소한의 행동을 통하여 모든 점들의 가중치를 0으로 만들고자 합니다. 트리의 각 점의 가중치를 의미하는 1차원 정수 배열 a와 트리의 간선 정보를 의미하는 edges가 매개변수로 주어집니다. 주어진 행동을 통해 트리의 모든 점들의 가중치를 0으로 만드는 것이 불가능하다면 -1을, 가능하다면 최소 몇 번만에 가능한지를 찾아 return 하도록 solution 함수를 완성해주세요. (만약 처음부터 트리의 모든 정점의 가중치가 0이라면, 0을 return 해야 합니다.) 제한사항 a의 길이는 2 이상 300,000 이하입니다. a의 모든 수는 각각 -1,000,000 이상 1,000,000 이하입니다. a[i]는 i번 정점의 가중치를 의미합니다. edges의 행의 개수는 (a의 길이 - 1)입니다. edges의 각 행은 [u, v] 2개의 정수로 이루어져 있으며, 이는 u번 정점과 v번 정점이 간선으로 연결되어 있음을 의미합니다. edges가 나타내는 그래프는 항상 트리로 주어집니다. 입출력 예 a edges result [-5,0,2,1,2] [[0,1],[3,4],[2,3],[0,3]] 9 [0,1,0] [[0,1],[1,2]] -1 입출력 예 설명",normal,Array
127,"다음 규칙을 지키는 문자열을 올바른 괄호 문자열이라고 정의합니다. (), [], {} 는 모두 올바른 괄호 문자열입니다. 만약 A가 올바른 괄호 문자열이라면, (A), [A], {A} 도 올바른 괄호 문자열입니다. 예를 들어, [] 가 올바른 괄호 문자열이므로, ([]) 도 올바른 괄호 문자열입니다. 만약 A, B가 올바른 괄호 문자열이라면, AB 도 올바른 괄호 문자열입니다. 예를 들어, {} 와 ([]) 가 올바른 괄호 문자열이므로, {}([]) 도 올바른 괄호 문자열입니다. 대괄호, 중괄호, 그리고 소괄호로 이루어진 문자열 s가 매개변수로 주어집니다. 이 s를 왼쪽으로 x (0 ≤ x < (s의 길이)) 칸만큼 회전시켰을 때 s가 올바른 괄호 문자열이 되게 하는 x의 개수를 return 하도록 solution 함수를 완성해주세요. 제한사항 s의 길이는 1 이상 1,000 이하입니다. 입출력 예 s result ""[](){}"" 3 ""}]()[{"" 2 ""[)(]"" 0 ""}}}"" 0 입출력 예 설명",normal,String
128,"유통전문회사 카카오상사의 오너인 제이지는 새로운 사업 아이템을 구상하기 위해 전문경영인(CEO)인 프로도에게 회사의 경영을 부탁하였습니다. ""카카오상사""는 직원들을 여러 개의 팀 단위로 조직을 구성하고 있으며 아래 그림은 CEO를 포함하여 10명의 직원과 4개의 팀으로 구성되어 있는 회사 조직도를 보여주고 있습니다. 그림의 조직도는 다음과 같이 설명할 수 있습니다. 그림의 각 원들은 각각의 직원 1명을 표시하고 있으며, CEO를 포함하여 총 10명의 직원을 표시하고 있습니다. 원 안에 적힌 두 개의 숫자는 직원의 정보를 담고 있습니다. 왼쪽 숫자는 직원번호이며 직원을 식별할 수 있도록 1번부터 순서대로 발급되는 일련번호이며, 오른쪽 숫자는 해당 직원의 하루평균 매출액을 나타냅니다. 위 그림에서 1번 직원은 14원을, 9번 직원은 28원의 하루평균 매출액을 기록하고 있습니다. CEO를 포함하여 모든 직원은 팀장 또는 팀원이라는 직위를 가지고 있으며 그림에서는 팀장과 팀원의 관계를 화살표로 표시하고 있습니다. 화살표가 시작되는 쪽의 직원은 팀장, 화살표를 받는 쪽의 직원은 팀원을 의미합니다. 3-1. 직원번호 1번은 회사의 CEO로 고정되어 있으며, CEO는 항상 팀장이고 팀원일 수 없어 화살표를 받는 쪽이 될 수 없습니다. 3-2. 반면에 CEO를 제외한 나머지 모든 직원들은 다른 누군가로부터 정확히 1개의 화살표를 받게 됩니다. 3-3. 한 직원은 최대 2개의 팀에 소속될 수 있습니다. 만약 어떤 직원이 두 개의 팀에 소속되어 있다면, 반드시 하나의 팀에서는 팀장, 나머지 팀에서는 팀원이어야 합니다. 팀장을 겸임하거나, 두 개의 팀에서 팀원이 될 수는 없습니다. 예를들어 10번 직원은 D팀의 팀장이면서 동시에 5번 직원이 팀장으로 있는 C팀에 속한 팀원입니다. 3-4. 5번, 9번, 10번 직원은 받는 쪽의 화살표와 시작하는 화살표가 모두 있으므로 팀장인 동시에 팀원입니다. 3-5. 2번, 3번, 4번, 6번, 7번, 8번 직원은 시작하는 화살표가 없고 받는 쪽의 화살표만 있으므로 팀장이 아니며 오직 팀원입니다. 3-6. 1번 직원인 CEO는 받는 쪽의 화살표가 없고 시작하는 화살표만 있으며 항상 팀원이 아닌 팀장입니다. 3-7. 그림의 조직도에는 A, B, C, D 총 4개의 팀이 존재하며, 각각 1번, 9번, 5번, 10번 직원이 팀장 직위를 담당하게 됩니다. ""제이지""는 자신이 구상한 새로운 사업 아이템에 대해 직원들에게 설명하고자 하루 일정으로 워크숍을 계획하고 있습니다. 단, 모든 직원을 참석시킬 수 없어 아래와 같은 기준으로 워크숍에 참석할 직원들을 선발하려고 합니다. 워크숍에서 교육받은 내용은 전 직원들에게 공유되어야 하므로 모든 팀은 최소 1명 이상의 직원을 워크숍에 참석시켜야 합니다. 워크숍 기간 동안, 회사의 매출 손실을 최소화하는 것이 중요하므로 워크숍에 참석하는 직원들의 하루평균 매출액의 합이 최소가 되어야 합니다. 위 그림의 조직도에서 회색으로 색칠된 1번, 7번, 10번 직원을 워크숍에 참석시키면 모든 팀에서 최소 한 명 이상의 직원을 참석시킨 것이 되며, 해당 직원들의 하루평균 매출액의 합은 44(14+13+17)원 입니다. 10번 직원은 C팀과 D팀 모두에 속해 있으므로, 두 팀에서 모두 참석한 것으로 인정됩니다. [문제] 직원들의 하루평균 매출액 값을 담은 배열 sales, 직원들의 팀장-팀원의 관계를 나타내는 2차원 배열 links가 매개변수로 주어집니다. 이때, 모든 팀에서 최소 한 명 이상 워크숍에 참석하면서, 참석하는 직원들의 하루평균 매출액의 합을 최소로 하려고 합니다. 그렇게 최소화된 매출액의 합을 구해서 return 하도록 solution 함수를 완성해 주세요. [제한사항] sales 배열의 크기는 2 이상 300,000 이하입니다. sales 배열의 크기는 CEO를 포함한 전체 직원 수와 같습니다. sales 배열은 각 직원들의 하루평균 매출액을 담고 있으며, 1번 직원부터 직원번호 순서대로 주어집니다. sales 배열의 각 원소의 값은 0 이상 10,000 이하인 정수입니다. links 배열의 크기는 sales 배열의 크기 - 1 입니다. 즉, 전체 직원 수보다 1이 작습니다. links 배열의 각 원소는 [a, b] 형식입니다. a는 팀장의 직원번호, b는 a팀장이 관리하는 팀원의 직원번호이며, a와 b는 서로 다른 자연수입니다. 1 ≤ a ≤ sales 배열의 크기 입니다. 2 ≤ b ≤ sales 배열의 크기 입니다. 직원번호 1은 CEO로 정해져 있고 CEO는 항상 팀장으므로 b ≠ 1 입니다. links 배열로 만들어지는 조직도는 하나의 트리 구조 형태입니다. 정답으로 return 되는 값은 231 - 1 이하인 자연수임이 보장됩니다. [입출력 예] sales links result [14, 17, 15, 18, 19, 14, 13, 16, 28, 17] [[10, 8], [1, 9], [9, 7], [5, 4], [1, 5], [5, 10], [10, 6], [1, 3], [10, 2]] 44 [5, 6, 5, 3, 4] [[2,3], [1,4], [2,5], [1,2]] 6 [5, 6, 5, 1, 4] [[2,3], [1,4], [2,5], [1,2]] 5 [10, 10, 1, 1] [[3,2], [4,3], [1,4]] 2 입출력 예에 대한 설명",hard,Array
129,"게임 개발자인 베로니는 개발 연습을 위해 다음과 같은 간단한 카드 짝맞추기 보드 게임을 개발해 보려고 합니다. 게임이 시작되면 화면에는 카드 16장이 뒷면을 위로하여 4 x 4 크기의 격자 형태로 표시되어 있습니다. 각 카드의 앞면에는 카카오프렌즈 캐릭터 그림이 그려져 있으며, 8가지의 캐릭터 그림이 그려진 카드가 각기 2장씩 화면에 무작위로 배치되어 있습니다. 유저가 카드를 2장 선택하여 앞면으로 뒤집었을 때 같은 그림이 그려진 카드면 해당 카드는 게임 화면에서 사라지며, 같은 그림이 아니라면 원래 상태로 뒷면이 보이도록 뒤집힙니다. 이와 같은 방법으로 모든 카드를 화면에서 사라지게 하면 게임이 종료됩니다. 게임에서 카드를 선택하는 방법은 다음과 같습니다. 카드는 커서를 이용해서 선택할 수 있습니다. 커서는 4 x 4 화면에서 유저가 선택한 현재 위치를 표시하는 ""굵고 빨간 테두리 상자""를 의미합니다. 커서는 [Ctrl] 키와 방향키에 의해 이동되며 키 조작법은 다음과 같습니다. 방향키 ←, ↑, ↓, → 중 하나를 누르면, 커서가 누른 키 방향으로 1칸 이동합니다. [Ctrl] 키를 누른 상태에서 방향키 ←, ↑, ↓, → 중 하나를 누르면, 누른 키 방향에 있는 가장 가까운 카드로 한번에 이동합니다. 만약, 해당 방향에 카드가 하나도 없다면 그 방향의 가장 마지막 칸으로 이동합니다. 만약, 누른 키 방향으로 이동 가능한 카드 또는 빈 공간이 없어 이동할 수 없다면 커서는 움직이지 않습니다. 커서가 위치한 카드를 뒤집기 위해서는 [Enter] 키를 입력합니다. [Enter] 키를 입력해서 카드를 뒤집었을 때 앞면이 보이는 카드가 1장 뿐이라면 그림을 맞출 수 없으므로 두번째 카드를 뒤집을 때 까지 앞면을 유지합니다. 앞면이 보이는 카드가 2장이 된 경우, 두개의 카드에 그려진 그림이 같으면 해당 카드들이 화면에서 사라지며, 그림이 다르다면 두 카드 모두 뒷면이 보이도록 다시 뒤집힙니다. ""베로니""는 게임 진행 중 카드의 짝을 맞춰 몇 장 제거된 상태에서 카드 앞면의 그림을 알고 있다면, 남은 카드를 모두 제거하는데 필요한 키 조작 횟수의 최솟값을 구해 보려고 합니다. 키 조작 횟수는 방향키와 [Enter] 키를 누르는 동작을 각각 조작 횟수 1로 계산하며, [Ctrl] 키와 방향키를 함께 누르는 동작 또한 조작 횟수 1로 계산합니다. 다음은 카드가 몇 장 제거된 상태의 게임 화면에서 커서를 이동하는 예시입니다. 아래 그림에서 빈 칸은 이미 카드가 제거되어 없어진 칸을 의미하며, 그림이 그려진 칸은 카드 앞 면에 그려진 그림을 나타냅니다. 예시에서 커서는 두번째 행, 첫번째 열 위치에서 시작하였습니다. [Enter] 입력, ↓ 이동, [Ctrl]+→ 이동, [Enter] 입력 = 키 조작 4회 [Ctrl]+↑ 이동, [Enter] 입력, [Ctrl]+← 이동, [Ctrl]+↓ 이동, [Enter] 입력 = 키 조작 5회 [Ctrl]+→ 이동, [Enter] 입력, [Ctrl]+↑ 이동, [Ctrl]+← 이동, [Enter] 입력 = 키 조작 5회 위와 같은 방법으로 커서를 이동하여 카드를 선택하고 그림을 맞추어 카드를 모두 제거하기 위해서는 총 14번(방향 이동 8번, [Enter] 키 입력 6번)의 키 조작 횟수가 필요합니다. [문제] 현재 카드가 놓인 상태를 나타내는 2차원 배열 board와 커서의 처음 위치 r, c가 매개변수로 주어질 때, 모든 카드를 제거하기 위한 키 조작 횟수의 최솟값을 return 하도록 solution 함수를 완성해 주세요. [제한사항] board는 4 x 4 크기의 2차원 배열입니다. board 배열의 각 원소는 0 이상 6 이하인 자연수입니다. 0은 카드가 제거된 빈 칸을 나타냅니다. 1 부터 6까지의 자연수는 2개씩 들어있으며 같은 숫자는 같은 그림의 카드를 의미합니다. 뒤집을 카드가 없는 경우(board의 모든 원소가 0인 경우)는 입력으로 주어지지 않습니다. r은 커서의 최초 세로(행) 위치를 의미합니다. c는 커서의 최초 가로(열) 위치를 의미합니다. r과 c는 0 이상 3 이하인 정수입니다. 게임 화면의 좌측 상단이 (0, 0), 우측 하단이 (3, 3) 입니다. [입출력 예] board r c result [[1,0,0,3],[2,0,0,0],[0,0,0,2],[3,0,1,0]] 1 0 14 [[3,0,0,2],[0,0,1,0],[0,1,0,0],[2,0,0,3]] 0 1 16 입출력 예에 대한 설명",normal,Array
130,"카카오TV에서 유명한 크리에이터로 활동 중인 죠르디는 환경 단체로부터 자신의 가장 인기있는 동영상에 지구온난화의 심각성을 알리기 위한 공익광고를 넣어 달라는 요청을 받았습니다. 평소에 환경 문제에 관심을 가지고 있던 ""죠르디""는 요청을 받아들였고 광고효과를 높이기 위해 시청자들이 가장 많이 보는 구간에 공익광고를 넣으려고 합니다. ""죠르디""는 시청자들이 해당 동영상의 어떤 구간을 재생했는 지 알 수 있는 재생구간 기록을 구했고, 해당 기록을 바탕으로 공익광고가 삽입될 최적의 위치를 고를 수 있었습니다. 참고로 광고는 재생 중인 동영상의 오른쪽 아래에서 원래 영상과 동시에 재생되는 PIP(Picture in Picture) 형태로 제공됩니다. 다음은 ""죠르디""가 공익광고가 삽입될 최적의 위치를 고르는 과정을 그림으로 설명한 것입니다. 그림의 파란색 선은 광고를 검토 중인 ""죠르디"" 동영상의 전체 재생 구간을 나타냅니다. 위 그림에서, ""죠르디"" 동영상의 총 재생시간은 02시간 03분 55초 입니다. 그림의 검은색 선들은 각 시청자들이 ""죠르디""의 동영상을 재생한 구간의 위치를 표시하고 있습니다. 검은색 선의 가운데 숫자는 각 재생 기록을 구분하는 ID를 나타냅니다. 검은색 선에 표기된 왼쪽 끝 숫자와 오른쪽 끝 숫자는 시청자들이 재생한 동영상 구간의 시작 시각과 종료 시각을 나타냅니다. 위 그림에서, 3번 재생 기록은 00시 25분 50초 부터 00시 48분 29초 까지 총 00시간 22분 39초 동안 죠르디의 동영상을 재생했습니다. 1 위 그림에서, 1번 재생 기록은 01시 20분 15초 부터 01시 45분 14초 까지 총 00시간 24분 59초 동안 죠르디의 동영상을 재생했습니다. 그림의 빨간색 선은 ""죠르디""가 선택한 최적의 공익광고 위치를 나타냅니다. 만약 공익광고의 재생시간이 00시간 14분 15초라면, 위의 그림처럼 01시 30분 59초 부터 01시 45분 14초 까지 공익광고를 삽입하는 것이 가장 좋습니다. 이 구간을 시청한 시청자들의 누적 재생시간이 가장 크기 때문입니다. 01시 30분 59초 부터 01시 45분 14초 까지의 누적 재생시간은 다음과 같이 계산됩니다. 01시 30분 59초 부터 01시 37분 44초 까지 : 4번, 1번 재생 기록이 두차례 있으므로 재생시간의 합은 00시간 06분 45초 X 2 = 00시간 13분 30초 01시 37분 44초 부터 01시 45분 14초 까지 : 4번, 1번, 5번 재생 기록이 세차례 있으므로 재생시간의 합은 00시간 07분 30초 X 3 = 00시간 22분 30초 따라서, 이 구간 시청자들의 누적 재생시간은 00시간 13분 30초 + 00시간 22분 30초 = 00시간 36분 00초입니다. [문제] ""죠르디""의 동영상 재생시간 길이 play_time, 공익광고의 재생시간 길이 adv_time, 시청자들이 해당 동영상을 재생했던 구간 정보 logs가 매개변수로 주어질 때, 시청자들의 누적 재생시간이 가장 많이 나오는 곳에 공익광고를 삽입하려고 합니다. 이때, 공익광고가 들어갈 시작 시각을 구해서 return 하도록 solution 함수를 완성해주세요. 만약, 시청자들의 누적 재생시간이 가장 많은 곳이 여러 곳이라면, 그 중에서 가장 빠른 시작 시각을 return 하도록 합니다. [제한사항] play_time, adv_time은 길이 8로 고정된 문자열입니다. play_time, adv_time은 HH:MM:SS 형식이며, 00:00:01 이상 99:59:59 이하입니다. 즉, 동영상 재생시간과 공익광고 재생시간은 00시간 00분 01초 이상 99시간 59분 59초 이하입니다. 공익광고 재생시간은 동영상 재생시간보다 짧거나 같게 주어집니다. logs는 크기가 1 이상 300,000 이하인 문자열 배열입니다. logs 배열의 각 원소는 시청자의 재생 구간을 나타냅니다. logs 배열의 각 원소는 길이가 17로 고정된 문자열입니다. logs 배열의 각 원소는 H1:M1:S1-H2:M2:S2 형식입니다. H1:M1:S1은 동영상이 시작된 시각, H2:M2:S2는 동영상이 종료된 시각을 나타냅니다. H1:M1:S1는 H2:M2:S2보다 1초 이상 이전 시각으로 주어집니다. H1:M1:S1와 H2:M2:S2는 play_time 이내의 시각입니다. 시간을 나타내는 HH, H1, H2의 범위는 00~99, 분을 나타내는 MM, M1, M2의 범위는 00~59, 초를 나타내는 SS, S1, S2의 범위는 00~59까지 사용됩니다. 잘못된 시각은 입력으로 주어지지 않습니다. (예: 04:60:24, 11:12:78, 123:12:45 등) return 값의 형식 공익광고를 삽입할 시각을 HH:MM:SS 형식의 8자리 문자열로 반환합니다. [입출력 예] play_time adv_time logs result ""02:03:55"" ""00:14:15"" [""01:20:15-01:45:14"", ""00:40:31-01:00:00"", ""00:25:50-00:48:29"", ""01:30:59-01:53:29"", ""01:37:44-02:02:30""] ""01:30:59"" ""99:59:59"" ""25:00:00"" [""69:59:59-89:59:59"", ""01:00:00-21:00:00"", ""79:59:59-99:59:59"", ""11:00:00-31:00:00""] ""01:00:00"" ""50:00:00"" ""50:00:00"" [""15:36:51-38:21:49"", ""10:14:18-15:36:51"", ""38:21:49-42:51:45""] ""00:00:00"" 입출력 예에 대한 설명",normal,Array
131,"[본 문제는 정확성과 효율성 테스트 각각 점수가 있는 문제입니다.] 밤늦게 귀가할 때 안전을 위해 항상 택시를 이용하던 무지는 최근 야근이 잦아져 택시를 더 많이 이용하게 되어 택시비를 아낄 수 있는 방법을 고민하고 있습니다. ""무지""는 자신이 택시를 이용할 때 동료인 어피치 역시 자신과 비슷한 방향으로 가는 택시를 종종 이용하는 것을 알게 되었습니다. ""무지""는 ""어피치""와 귀가 방향이 비슷하여 택시 합승을 적절히 이용하면 택시요금을 얼마나 아낄 수 있을 지 계산해 보고 ""어피치""에게 합승을 제안해 보려고 합니다. 위 예시 그림은 택시가 이동 가능한 반경에 있는 6개 지점 사이의 이동 가능한 택시노선과 예상요금을 보여주고 있습니다. 그림에서 A와 B 두 사람은 출발지점인 4번 지점에서 출발해서 택시를 타고 귀가하려고 합니다. A의 집은 6번 지점에 있으며 B의 집은 2번 지점에 있고 두 사람이 모두 귀가하는 데 소요되는 예상 최저 택시요금이 얼마인 지 계산하려고 합니다. 그림의 원은 지점을 나타내며 원 안의 숫자는 지점 번호를 나타냅니다. 지점이 n개일 때, 지점 번호는 1부터 n까지 사용됩니다. 지점 간에 택시가 이동할 수 있는 경로를 간선이라 하며, 간선에 표시된 숫자는 두 지점 사이의 예상 택시요금을 나타냅니다. 간선은 편의 상 직선으로 표시되어 있습니다. 위 그림 예시에서, 4번 지점에서 1번 지점으로(4→1) 가거나, 1번 지점에서 4번 지점으로(1→4) 갈 때 예상 택시요금은 10원으로 동일하며 이동 방향에 따라 달라지지 않습니다. 예상되는 최저 택시요금은 다음과 같이 계산됩니다. 4→1→5 : A, B가 합승하여 택시를 이용합니다. 예상 택시요금은 10 + 24 = 34원 입니다. 5→6 : A가 혼자 택시를 이용합니다. 예상 택시요금은 2원 입니다. 5→3→2 : B가 혼자 택시를 이용합니다. 예상 택시요금은 24 + 22 = 46원 입니다. A, B 모두 귀가 완료까지 예상되는 최저 택시요금은 34 + 2 + 46 = 82원 입니다. [문제] 지점의 개수 n, 출발지점을 나타내는 s, A의 도착지점을 나타내는 a, B의 도착지점을 나타내는 b, 지점 사이의 예상 택시요금을 나타내는 fares가 매개변수로 주어집니다. 이때, A, B 두 사람이 s에서 출발해서 각각의 도착 지점까지 택시를 타고 간다고 가정할 때, 최저 예상 택시요금을 계산해서 return 하도록 solution 함수를 완성해 주세요. 만약, 아예 합승을 하지 않고 각자 이동하는 경우의 예상 택시요금이 더 낮다면, 합승을 하지 않아도 됩니다. [제한사항] 지점갯수 n은 3 이상 200 이하인 자연수입니다. 지점 s, a, b는 1 이상 n 이하인 자연수이며, 각기 서로 다른 값입니다. 즉, 출발지점, A의 도착지점, B의 도착지점은 서로 겹치지 않습니다. fares는 2차원 정수 배열입니다. fares 배열의 크기는 2 이상 n x (n-1) / 2 이하입니다. 예를들어, n = 6이라면 fares 배열의 크기는 2 이상 15 이하입니다. (6 x 5 / 2 = 15) fares 배열의 각 행은 [c, d, f] 형태입니다. c지점과 d지점 사이의 예상 택시요금이 f원이라는 뜻입니다. 지점 c, d는 1 이상 n 이하인 자연수이며, 각기 서로 다른 값입니다. 요금 f는 1 이상 100,000 이하인 자연수입니다. fares 배열에 두 지점 간 예상 택시요금은 1개만 주어집니다. 즉, [c, d, f]가 있다면 [d, c, f]는 주어지지 않습니다. 출발지점 s에서 도착지점 a와 b로 가는 경로가 존재하는 경우만 입력으로 주어집니다. [입출력 예] n s a b fares result 6 4 6 2 [[4, 1, 10], [3, 5, 24], [5, 6, 2], [3, 1, 41], [5, 1, 24], [4, 6, 50], [2, 4, 66], [2, 3, 22], [1, 6, 25]] 82 7 3 4 1 [[5, 7, 9], [4, 6, 4], [3, 6, 1], [3, 2, 3], [2, 1, 6]] 14 6 4 5 6 [[2,6,6], [6,3,7], [4,6,7], [6,5,11], [2,5,12], [5,3,20], [2,4,8], [4,3,9]] 18 입출력 예에 대한 설명",normal,Array
132,"[본 문제는 정확성과 효율성 테스트 각각 점수가 있는 문제입니다.] 카카오는 하반기 경력 개발자 공개채용을 진행 중에 있으며 현재 지원서 접수와 코딩테스트가 종료되었습니다. 이번 채용에서 지원자는 지원서 작성 시 아래와 같이 4가지 항목을 반드시 선택하도록 하였습니다. 코딩테스트 참여 개발언어 항목에 cpp, java, python 중 하나를 선택해야 합니다. 지원 직군 항목에 backend와 frontend 중 하나를 선택해야 합니다. 지원 경력구분 항목에 junior와 senior 중 하나를 선택해야 합니다. 선호하는 소울푸드로 chicken과 pizza 중 하나를 선택해야 합니다. 인재영입팀에 근무하고 있는 니니즈는 코딩테스트 결과를 분석하여 채용에 참여한 개발팀들에 제공하기 위해 지원자들의 지원 조건을 선택하면 해당 조건에 맞는 지원자가 몇 명인 지 쉽게 알 수 있는 도구를 만들고 있습니다. 예를 들어, 개발팀에서 궁금해하는 문의사항은 다음과 같은 형태가 될 수 있습니다. 코딩테스트에 java로 참여했으며, backend 직군을 선택했고, junior 경력이면서, 소울푸드로 pizza를 선택한 사람 중 코딩테스트 점수를 50점 이상 받은 지원자는 몇 명인가? 물론 이 외에도 각 개발팀의 상황에 따라 아래와 같이 다양한 형태의 문의가 있을 수 있습니다. 코딩테스트에 python으로 참여했으며, frontend 직군을 선택했고, senior 경력이면서, 소울푸드로 chicken을 선택한 사람 중 코딩테스트 점수를 100점 이상 받은 사람은 모두 몇 명인가? 코딩테스트에 cpp로 참여했으며, senior 경력이면서, 소울푸드로 pizza를 선택한 사람 중 코딩테스트 점수를 100점 이상 받은 사람은 모두 몇 명인가? backend 직군을 선택했고, senior 경력이면서 코딩테스트 점수를 200점 이상 받은 사람은 모두 몇 명인가? 소울푸드로 chicken을 선택한 사람 중 코딩테스트 점수를 250점 이상 받은 사람은 모두 몇 명인가? 코딩테스트 점수를 150점 이상 받은 사람은 모두 몇 명인가? 즉, 개발팀에서 궁금해하는 내용은 다음과 같은 형태를 갖습니다. * [조건]을 만족하는 사람 중 코딩테스트 점수를 X점 이상 받은 사람은 모두 몇 명인가? [문제] 지원자가 지원서에 입력한 4가지의 정보와 획득한 코딩테스트 점수를 하나의 문자열로 구성한 값의 배열 info, 개발팀이 궁금해하는 문의조건이 문자열 형태로 담긴 배열 query가 매개변수로 주어질 때, 각 문의조건에 해당하는 사람들의 숫자를 순서대로 배열에 담아 return 하도록 solution 함수를 완성해 주세요. [제한사항] info 배열의 크기는 1 이상 50,000 이하입니다. info 배열 각 원소의 값은 지원자가 지원서에 입력한 4가지 값과 코딩테스트 점수를 합친 ""개발언어 직군 경력 소울푸드 점수"" 형식입니다. 개발언어는 cpp, java, python 중 하나입니다. 직군은 backend, frontend 중 하나입니다. 경력은 junior, senior 중 하나입니다. 소울푸드는 chicken, pizza 중 하나입니다. 점수는 코딩테스트 점수를 의미하며, 1 이상 100,000 이하인 자연수입니다. 각 단어는 공백문자(스페이스 바) 하나로 구분되어 있습니다. query 배열의 크기는 1 이상 100,000 이하입니다. query의 각 문자열은 ""[조건] X"" 형식입니다. [조건]은 ""개발언어 and 직군 and 경력 and 소울푸드"" 형식의 문자열입니다. 언어는 cpp, java, python, - 중 하나입니다. 직군은 backend, frontend, - 중 하나입니다. 경력은 junior, senior, - 중 하나입니다. 소울푸드는 chicken, pizza, - 중 하나입니다. '-' 표시는 해당 조건을 고려하지 않겠다는 의미입니다. X는 코딩테스트 점수를 의미하며 조건을 만족하는 사람 중 X점 이상 받은 사람은 모두 몇 명인 지를 의미합니다. 각 단어는 공백문자(스페이스 바) 하나로 구분되어 있습니다. 예를 들면, ""cpp and - and senior and pizza 500""은 ""cpp로 코딩테스트를 봤으며, 경력은 senior 이면서 소울푸드로 pizza를 선택한 지원자 중 코딩테스트 점수를 500점 이상 받은 사람은 모두 몇 명인가?""를 의미합니다. [입출력 예] info query result [""java backend junior pizza 150"",""python frontend senior chicken 210"",""python frontend senior chicken 150"",""cpp backend senior pizza 260"",""java backend junior chicken 80"",""python backend senior chicken 50""] [""java and backend and junior and pizza 100"",""python and frontend and senior and chicken 200"",""cpp and - and senior and pizza 250"",""- and backend and senior and - 150"",""- and - and - and chicken 100"",""- and - and - and - 150""] [1,1,1,1,2,4] 입출력 예에 대한 설명 지원자 정보를 표로 나타내면 다음과 같습니다. 언어 직군 경력 소울 푸드 점수 java backend junior pizza 150 python frontend senior chicken 210 python frontend senior chicken 150 cpp backend senior pizza 260 java backend junior chicken 80 python backend senior chicken 50 ""java and backend and junior and pizza 100"" : java로 코딩테스트를 봤으며, backend 직군을 선택했고 junior 경력이면서 소울푸드로 pizza를 선택한 지원자 중 코딩테스트 점수를 100점 이상 받은 지원자는 1명 입니다. ""python and frontend and senior and chicken 200"" : python으로 코딩테스트를 봤으며, frontend 직군을 선택했고, senior 경력이면서 소울 푸드로 chicken을 선택한 지원자 중 코딩테스트 점수를 200점 이상 받은 지원자는 1명 입니다. ""cpp and - and senior and pizza 250"" : cpp로 코딩테스트를 봤으며, senior 경력이면서 소울푸드로 pizza를 선택한 지원자 중 코딩테스트 점수를 250점 이상 받은 지원자는 1명 입니다. ""- and backend and senior and - 150"" : backend 직군을 선택했고, senior 경력인 지원자 중 코딩테스트 점수를 150점 이상 받은 지원자는 1명 입니다. ""- and - and - and chicken 100"" : 소울푸드로 chicken을 선택한 지원자 중 코딩테스트 점수를 100점 이상을 받은 지원자는 2명 입니다. ""- and - and - and - 150"" : 코딩테스트 점수를 150점 이상 받은 지원자는 4명 입니다.",normal,Array
133,"레스토랑을 운영하던 스카피는 코로나19로 인한 불경기를 극복하고자 메뉴를 새로 구성하려고 고민하고 있습니다. 기존에는 단품으로만 제공하던 메뉴를 조합해서 코스요리 형태로 재구성해서 새로운 메뉴를 제공하기로 결정했습니다. 어떤 단품메뉴들을 조합해서 코스요리 메뉴로 구성하면 좋을 지 고민하던 ""스카피""는 이전에 각 손님들이 주문할 때 가장 많이 함께 주문한 단품메뉴들을 코스요리 메뉴로 구성하기로 했습니다. 단, 코스요리 메뉴는 최소 2가지 이상의 단품메뉴로 구성하려고 합니다. 또한, 최소 2명 이상의 손님으로부터 주문된 단품메뉴 조합에 대해서만 코스요리 메뉴 후보에 포함하기로 했습니다. 예를 들어, 손님 6명이 주문한 단품메뉴들의 조합이 다음과 같다면, (각 손님은 단품메뉴를 2개 이상 주문해야 하며, 각 단품메뉴는 A ~ Z의 알파벳 대문자로 표기합니다.) 손님 번호 주문한 단품메뉴 조합 1번 손님 A, B, C, F, G 2번 손님 A, C 3번 손님 C, D, E 4번 손님 A, C, D, E 5번 손님 B, C, F, G 6번 손님 A, C, D, E, H 가장 많이 함께 주문된 단품메뉴 조합에 따라 ""스카피""가 만들게 될 코스요리 메뉴 구성 후보는 다음과 같습니다. 코스 종류 메뉴 구성 설명 요리 2개 코스 A, C 1번, 2번, 4번, 6번 손님으로부터 총 4번 주문됐습니다. 요리 3개 코스 C, D, E 3번, 4번, 6번 손님으로부터 총 3번 주문됐습니다. 요리 4개 코스 B, C, F, G 1번, 5번 손님으로부터 총 2번 주문됐습니다. 요리 4개 코스 A, C, D, E 4번, 6번 손님으로부터 총 2번 주문됐습니다. [문제] 각 손님들이 주문한 단품메뉴들이 문자열 형식으로 담긴 배열 orders, ""스카피""가 추가하고 싶어하는 코스요리를 구성하는 단품메뉴들의 갯수가 담긴 배열 course가 매개변수로 주어질 때, ""스카피""가 새로 추가하게 될 코스요리의 메뉴 구성을 문자열 형태로 배열에 담아 return 하도록 solution 함수를 완성해 주세요. [제한사항] orders 배열의 크기는 2 이상 20 이하입니다. orders 배열의 각 원소는 크기가 2 이상 10 이하인 문자열입니다. 각 문자열은 알파벳 대문자로만 이루어져 있습니다. 각 문자열에는 같은 알파벳이 중복해서 들어있지 않습니다. course 배열의 크기는 1 이상 10 이하입니다. course 배열의 각 원소는 2 이상 10 이하인 자연수가 오름차순으로 정렬되어 있습니다. course 배열에는 같은 값이 중복해서 들어있지 않습니다. 정답은 각 코스요리 메뉴의 구성을 문자열 형식으로 배열에 담아 사전 순으로 오름차순 정렬해서 return 해주세요. 배열의 각 원소에 저장된 문자열 또한 알파벳 오름차순으로 정렬되어야 합니다. 만약 가장 많이 함께 주문된 메뉴 구성이 여러 개라면, 모두 배열에 담아 return 하면 됩니다. orders와 course 매개변수는 return 하는 배열의 길이가 1 이상이 되도록 주어집니다. [입출력 예] orders course result [""ABCFG"", ""AC"", ""CDE"", ""ACDE"", ""BCFG"", ""ACDEH""] [2,3,4] [""AC"", ""ACDE"", ""BCFG"", ""CDE""] [""ABCDE"", ""AB"", ""CD"", ""ADE"", ""XYZ"", ""XYZ"", ""ACD""] [2,3,5] [""ACD"", ""AD"", ""ADE"", ""CD"", ""XYZ""] [""XYZ"", ""XWY"", ""WXA""] [2,3,4] [""WX"", ""XY""] 입출력 예에 대한 설명",normal,Array
134,"다음 조건을 만족하는 그래프 상의 경로(Path)를 가짜 해밀토니안 경로라고 정의합니다. 경로가 그래프 상의 모든 점을 최소 1번, 최대 2번 방문해야 합니다. 그래프의 형태에 따라, 해당 그래프가 가짜 해밀토니안 경로를 가질 수도 있고, 가지지 않을 수도 있습니다. 본 문제에서 주어지는 그래프는 항상 트리 형태이며, 다음은 트리에서 가짜 해밀토니안 경로를 나타내는 예시입니다. 이 트리는 가짜 해밀토니안 경로를 가지는 트리입니다. 그림의 경로가 트리 상의 모든 점을 최소 1번, 최대 2번 방문하는 가짜 해밀토니안 경로 중 하나입니다. 이 트리는 가짜 해밀토니안 경로를 가지지 않는 트리입니다. 트리 정보를 담고 있는 2차원 정수 배열 t가 매개변수로 주어집니다. 이 트리의 모든 부분 트리(Subtree) 중에서, 가짜 해밀토니안 경로를 갖고 있으면서 동시에 점의 개수가 제일 많은 트리의 크기를 찾아 그 트리의 점의 개수를 return 하도록 solution 함수를 완성해주세요. 이때, 점의 개수가 3 이상(제한사항을 참고해주세요)인 임의의 트리는 항상 가짜 해밀토니안 경로를 가지는 부분 트리를 가지므로, 이 문제에서 답은 항상 존재합니다. 제한사항 t의 행의 개수는 2 이상 200,000 미만입니다. 트리의 점(Vertex)의 개수는 (t의 행의 개수 + 1) 입니다. 즉, 트리의 점의 개수는 3 이상 200,000 이하입니다. 각 행은 [v1, v2] 2개의 정수로 이루어져 있습니다. 이는 v1번 점과 v2번 점이 서로 연결되어 있다는 것을 의미합니다. v1, v2는 각각 0 이상 (t의 행의 개수) 이하입니다. v1과 v2는 서로 다른 수입니다. t는 항상 트리 형태로만 주어집니다. 입출력 예 t result [[5,1],[2,5],[3,5],[3,6],[2,4],[4,0]] 7 [[2,5],[2,0],[3,2],[4,2],[2,1]] 4",hard,Array
135,"다음과 같은 것들을 정의합니다. 어떤 수열 x의 부분 수열(Subsequence)이란, x의 몇몇 원소들을 제거하거나 그러지 않고 남은 원소들이 원래 순서를 유지하여 얻을 수 있는 새로운 수열을 말합니다. 예를 들어, [1,3]은 [1,2,3,4,5]의 부분수열입니다. 원래 수열에서 2, 4, 5를 제거해서 얻을 수 있기 때문입니다. 다음과 같은 조건을 모두 만족하는 수열 x를 스타 수열이라고 정의합니다. x의 길이가 2 이상의 짝수입니다. (빈 수열은 허용되지 않습니다.) x의 길이를 2n이라 할 때, 다음과 같은 n개의 집합 {x[0], x[1]}, {x[2], x[3]}, ..., {x[2n-2], x[2n-1]} 의 교집합의 원소의 개수가 1 이상입니다. x[0] != x[1], x[2] != x[3], ..., x[2n-2] != x[2n-1] 입니다. 예를 들어, [1,2,1,3,4,1,1,3]은 스타 수열입니다. {1,2}, {1,3}, {4,1}, {1,3} 의 교집합은 {1} 이고, 각 집합 내의 숫자들이 서로 다르기 때문입니다. 1차원 정수 배열 a가 매개변수로 주어집니다. a의 모든 부분 수열 중에서 가장 길이가 긴 스타 수열의 길이를 return 하도록 solution 함수를 완성해주세요. 이때, a의 모든 부분 수열 중에서 스타 수열이 없다면, 0을 return 해주세요. 제한사항 a의 길이는 1 이상 500,000 이하입니다. a의 모든 수는 0 이상 (a의 길이) 미만입니다. 입출력 예 a result [0] 0 [5,2,3,3,5,3] 4 [0,3,3,0,7,2,0,2,2,0] 8 입출력 예 설명",normal,Array
136,"0과 1로 이루어진 어떤 문자열 x에 대한 이진 변환을 다음과 같이 정의합니다. x의 모든 0을 제거합니다. x의 길이를 c라고 하면, x를 ""c를 2진법으로 표현한 문자열""로 바꿉니다. 예를 들어, x = ""0111010""이라면, x에 이진 변환을 가하면 x = ""0111010"" -> ""1111"" -> ""100"" 이 됩니다. 0과 1로 이루어진 문자열 s가 매개변수로 주어집니다. s가 ""1""이 될 때까지 계속해서 s에 이진 변환을 가했을 때, 이진 변환의 횟수와 변환 과정에서 제거된 모든 0의 개수를 각각 배열에 담아 return 하도록 solution 함수를 완성해주세요. 제한사항 s의 길이는 1 이상 150,000 이하입니다. s에는 '1'이 최소 하나 이상 포함되어 있습니다. 입출력 예 s result ""110010101001"" [3,8] ""01110"" [3,3] ""1111111"" [4,1] 입출력 예 설명",normal,Array
137,"어떤 문자열 x의 ""아름다움""을 다음과 같이 정의합니다. 만약 x의 모든 글자가 전부 같다면, 0입니다. 그렇지 않다면, 서로 다른 글자가 위치해 있는 두 인덱스 i, j를 골랐을 때의 j-i 값들 중 최대값입니다. 예를 들어, 문자열 ""abbca""의 아름다움은 3입니다. 인덱스 1(b)과 4(a)를 고르거나, 또는 0(a)과 3(c)를 고를 때 최대값이기 때문입니다. 영어 소문자로 이루어진 문자열 s가 매개변수로 주어집니다. s의 모든 부분문자열의 아름다움의 합을 return 하도록 solution 함수를 완성해주세요. 제한 사항 s의 길이는 1 이상 300,000 이하입니다. 입출력 예 s result ""baby"" 9 ""oo"" 0 입출력 예 설명",hard,Array
138,"n개의 점으로 이루어진 트리가 있습니다. 이때, 트리 상에서 다음과 같은 것들을 정의합니다. 어떤 두 점 사이의 거리는, 두 점을 잇는 경로 상 간선의 개수로 정의합니다. 임의의 3개의 점 a, b, c에 대한 함수 f(a, b, c)의 값을 a와 b 사이의 거리, b와 c 사이의 거리, c와 a 사이의 거리, 3개 값의 중간값으로 정의합니다. 트리의 정점의 개수 n과 트리의 간선을 나타내는 2차원 정수 배열 edges가 매개변수로 주어집니다. 주어진 트리에서 임의의 3개의 점을 뽑아 만들 수 있는 모든 f값 중에서, 제일 큰 값을 구해 return 하도록 solution 함수를 완성해주세요. 제한 사항 n은 3 이상 250,000 이하입니다. edges의 행의 개수는 n-1 입니다. edges의 각 행은 [v1, v2] 2개의 정수로 이루어져 있으며, 이는 v1번 정점과 v2번 정점 사이에 간선이 있음을 의미합니다. v1, v2는 각각 1 이상 n 이하입니다. v1, v2는 다른 수입니다. 입력으로 주어지는 그래프는 항상 트리입니다. 입출력 예 n edges result 4 [[1,2],[2,3],[3,4]] 2 5 [[1,5],[2,5],[3,5],[4,5]] 2 입출력 예 설명",hard,Array
139,"0과 1로 이루어진 2n x 2n 크기의 2차원 정수 배열 arr이 있습니다. 당신은 이 arr을 쿼드 트리와 같은 방식으로 압축하고자 합니다. 구체적인 방식은 다음과 같습니다. 당신이 압축하고자 하는 특정 영역을 S라고 정의합니다. 만약 S 내부에 있는 모든 수가 같은 값이라면, S를 해당 수 하나로 압축시킵니다. 그렇지 않다면, S를 정확히 4개의 균일한 정사각형 영역(입출력 예를 참고해주시기 바랍니다.)으로 쪼갠 뒤, 각 정사각형 영역에 대해 같은 방식의 압축을 시도합니다. arr이 매개변수로 주어집니다. 위와 같은 방식으로 arr을 압축했을 때, 배열에 최종적으로 남는 0의 개수와 1의 개수를 배열에 담아서 return 하도록 solution 함수를 완성해주세요. 제한사항 arr의 행의 개수는 1 이상 1024 이하이며, 2의 거듭 제곱수 형태를 하고 있습니다. 즉, arr의 행의 개수는 1, 2, 4, 8, ..., 1024 중 하나입니다. arr의 각 행의 길이는 arr의 행의 개수와 같습니다. 즉, arr은 정사각형 배열입니다. arr의 각 행에 있는 모든 값은 0 또는 1 입니다. 입출력 예 arr result [[1,1,0,0],[1,0,0,0],[1,0,0,1],[1,1,1,1]] [4,9] [[1,1,1,1,1,1,1,1],[0,1,1,1,1,1,1,1],[0,0,0,0,1,1,1,1],[0,1,0,0,1,1,1,1],[0,0,0,0,0,0,1,1],[0,0,0,0,0,0,0,1],[0,0,0,0,1,0,0,1],[0,0,0,0,1,1,1,1]] [10,15] 입출력 예 설명",normal,Array
140,"모든 수가 0 또는 1로 이루어진 2차원 배열 a가 주어집니다. 다음 조건을 모두 만족하는 2차원 배열 b의 경우의 수를 (107 + 19)로 나눈 나머지를 return 하도록 solution 함수를 완성해주세요. b의 모든 원소는 0 아니면 1입니다. a의 행/열의 개수와 b의 행/열의 개수가 같습니다. (= a와 b의 크기가 같습니다.) i = 1, 2, ..., (a의 열의 개수)에 대해서 a의 i번째 열과 b의 i번째 열에 들어 있는 1의 개수가 같습니다. b의 각 행에 들어 있는 1의 개수가 짝수입니다. (0도 짝수입니다.) 제한 사항 a의 행의 개수는 1 이상 300 이하입니다. a의 각 행의 길이는 1 이상 300 이하로 모두 동일합니다. 입출력 예 a result [[0,1,0],[1,1,1],[1,1,0],[0,1,1]] 6 [[1,0,0],[1,0,0]] 0 [[1,0,0,1,1],[0,0,0,0,0],[1,1,0,0,0],[0,0,0,0,1]] 72 입출력 예 설명",hard,Array
141,"일렬로 나열된 n개의 풍선이 있습니다. 모든 풍선에는 서로 다른 숫자가 써져 있습니다. 당신은 다음 과정을 반복하면서 풍선들을 단 1개만 남을 때까지 계속 터트리려고 합니다. 임의의 인접한 두 풍선을 고른 뒤, 두 풍선 중 하나를 터트립니다. 터진 풍선으로 인해 풍선들 사이에 빈 공간이 생겼다면, 빈 공간이 없도록 풍선들을 중앙으로 밀착시킵니다. 여기서 조건이 있습니다. 인접한 두 풍선 중에서 번호가 더 작은 풍선을 터트리는 행위는 최대 1번만 할 수 있습니다. 즉, 어떤 시점에서 인접한 두 풍선 중 번호가 더 작은 풍선을 터트렸다면, 그 이후에는 인접한 두 풍선을 고른 뒤 번호가 더 큰 풍선만을 터트릴 수 있습니다. 당신은 어떤 풍선이 최후까지 남을 수 있는지 알아보고 싶습니다. 위에 서술된 조건대로 풍선을 터트리다 보면, 어떤 풍선은 최후까지 남을 수도 있지만, 어떤 풍선은 무슨 수를 쓰더라도 마지막까지 남기는 것이 불가능할 수도 있습니다. 일렬로 나열된 풍선들의 번호가 담긴 배열 a가 주어집니다. 위에 서술된 규칙대로 풍선들을 1개만 남을 때까지 터트렸을 때 최후까지 남기는 것이 가능한 풍선들의 개수를 return 하도록 solution 함수를 완성해주세요. 제한 사항 a의 길이는 1 이상 1,000,000 이하입니다. a[i]는 i+1 번째 풍선에 써진 숫자를 의미합니다. a의 모든 수는 -1,000,000,000 이상 1,000,000,000 이하인 정수입니다. a의 모든 수는 서로 다릅니다. 입출력 예 a result [9,-1,-5] 3 [-16,27,65,-2,58,-92,-71,-68,-61,-33] 6 입출력 예 설명",normal,Array
142,"정수 n이 매개변수로 주어집니다. 다음 그림과 같이 밑변의 길이와 높이가 n인 삼각형에서 맨 위 꼭짓점부터 반시계 방향으로 달팽이 채우기를 진행한 후, 첫 행부터 마지막 행까지 모두 순서대로 합친 새로운 배열을 return 하도록 solution 함수를 완성해주세요. 제한사항 n은 1 이상 1,000 이하입니다. 입출력 예 n result 4 [1,2,9,3,10,8,4,5,6,7] 5 [1,2,12,3,13,11,4,14,15,10,5,6,7,8,9] 6 [1,2,15,3,16,14,4,17,21,13,5,18,19,20,12,6,7,8,9,10,11] 입출력 예 설명",normal,Array
143,"[본 문제는 정확성과 효율성 테스트 각각 점수가 있는 문제입니다.] 오지 탐험가인 프로도는 탐험 도중 n개의 방으로 이루어진 지하 동굴을 탐험하게 되었습니다. 모든 방에는 0부터 n - 1 까지 번호가 붙어있고, 이 동굴에 들어갈 수 있는 유일한 입구는 0번 방과 연결되어 있습니다. 각 방들은 양방향으로 통행이 가능한 통로로 서로 연결되어 있는데, 서로 다른 두 방을 직접 연결하는 통로는 오직 하나입니다. 임의의 서로 다른 두 방 사이의 최단경로는 딱 한 가지만 있으며, 또한 임의의 두 방 사이에 이동이 불가능한 경우는 없습니다. 탐험에 앞서 이 지하 동굴의 지도를 손에 넣은 프로도는 다음과 같이 탐험 계획을 세웠습니다. 모든 방을 적어도 한 번은 방문해야 합니다. 특정 방은 방문하기 전에 반드시 먼저 방문할 방이 정해져 있습니다. 2-1. 이는 A번 방은 방문하기 전에 반드시 B번 방을 먼저 방문해야 한다는 의미입니다. 2-2. 어떤 방을 방문하기 위해 반드시 먼저 방문해야 하는 방은 없거나 또는 1개 입니다. 2-3. 서로 다른 두 개 이상의 방에 대해 먼저 방문해야 하는 방이 같은 경우는 없습니다. 2-4. 어떤 방이 먼저 방문해야 하는 방이면서 동시에 나중에 방문해야 되는 방인 경우는 없습니다. 위 계획 중 2-2, 2-3, 2-4는 순서를 지켜 방문해야 하는 두 방의 쌍이 A → B(A를 먼저 방문하고 B를 방문함) 형태로 유일함을 의미합니다. 즉, 프로도는 아래와 같은 형태로 방문순서가 잡히지 않도록 방문 계획을 세웠습니다. A → B, A → C (방문순서 배열 order = [...,[A,B],...,[A,C],...]) 형태로 A를 방문 후에 방문해야 할 방이 B와 C로 두 개 또는 그 이상인 경우 X → A, Z → A (방문순서 배열 order = [...,[X,A],...,[Z,A],...]) 형태로 A를 방문하기 전에 방문해야 할 방이 X와 Z로 두 개 또는 그 이상 인 경우 A → B → C (방문순서 배열 order = [...,[A,B],...,[B,C],...) 형태로 B처럼 A 방문 후이면서 동시에 C 방문 전인 경우 그리고 먼저 방문해야 할 방과 나중에 방문할 방을 반드시 연속해서 방문해야 할 필요는 없어 A방을 방문한 후 다른 방을 방문한 후 B방을 방문해도 좋습니다. 방 개수 n, 동굴의 각 통로들이 연결하는 두 방의 번호가 담긴 2차원 배열 path, 프로도가 정한 방문 순서가 담긴 2차원 배열 order가 매개변수로 주어질 때, 프로도가 규칙에 맞게 모든 방을 탐험할 수 있을 지 return 하도록 solution 함수를 완성해주세요. [제한사항] n은 2 이상 200,000 이하입니다. path 배열의 세로(행) 길이는 n - 1 입니다. path 배열의 원소는 [방 번호 A, 방 번호 B] 형태입니다. 두 방 A, B사이를 연결하는 통로를 나타냅니다. 통로가 연결하는 두 방 번호가 순서없이 들어있음에 주의하세요. order 배열의 세로(행) 길이는 1 이상 (n / 2) 이하입니다. order 배열의 원소는 [방 번호 A, 방 번호 B] 형태입니다. A번 방을 먼저 방문한 후 B번 방을 방문해야 함을 나타냅니다. 입출력 예 n path order result 9 [[0,1],[0,3],[0,7],[8,1],[3,6],[1,2],[4,7],[7,5]] [[8,5],[6,7],[4,1]] true 9 [[8,1],[0,1],[1,2],[0,7],[4,7],[0,3],[7,5],[3,6]] [[4,1],[5,2]] true 9 [[0,1],[0,3],[0,7],[8,1],[3,6],[1,2],[4,7],[7,5]] [[4,1],[8,7],[6,5]] false 입출력 예에 대한 설명",hard,Array
144,"건설회사의 설계사인 죠르디는 고객사로부터 자동차 경주로 건설에 필요한 견적을 의뢰받았습니다. 제공된 경주로 설계 도면에 따르면 경주로 부지는 N x N 크기의 정사각형 격자 형태이며 각 격자는 1 x 1 크기입니다. 설계 도면에는 각 격자의 칸은 0 또는 1 로 채워져 있으며, 0은 칸이 비어 있음을 1은 해당 칸이 벽으로 채워져 있음을 나타냅니다. 경주로의 출발점은 (0, 0) 칸(좌측 상단)이며, 도착점은 (N-1, N-1) 칸(우측 하단)입니다. 죠르디는 출발점인 (0, 0) 칸에서 출발한 자동차가 도착점인 (N-1, N-1) 칸까지 무사히 도달할 수 있게 중간에 끊기지 않도록 경주로를 건설해야 합니다. 경주로는 상, 하, 좌, 우로 인접한 두 빈 칸을 연결하여 건설할 수 있으며, 벽이 있는 칸에는 경주로를 건설할 수 없습니다. 이때, 인접한 두 빈 칸을 상하 또는 좌우로 연결한 경주로를 직선 도로 라고 합니다. 또한 두 직선 도로가 서로 직각으로 만나는 지점을 코너 라고 부릅니다. 건설 비용을 계산해 보니 직선 도로 하나를 만들 때는 100원이 소요되며, 코너를 하나 만들 때는 500원이 추가로 듭니다. 죠르디는 견적서 작성을 위해 경주로를 건설하는 데 필요한 최소 비용을 계산해야 합니다. 예를 들어, 아래 그림은 직선 도로 6개와 코너 4개로 구성된 임의의 경주로 예시이며, 건설 비용은 6 x 100 + 4 x 500 = 2600원 입니다. 또 다른 예로, 아래 그림은 직선 도로 4개와 코너 1개로 구성된 경주로이며, 건설 비용은 4 x 100 + 1 x 500 = 900원 입니다. 도면의 상태(0은 비어 있음, 1은 벽)을 나타내는 2차원 배열 board가 매개변수로 주어질 때, 경주로를 건설하는데 필요한 최소 비용을 return 하도록 solution 함수를 완성해주세요. [제한사항] board는 2차원 정사각 배열로 배열의 크기는 3 이상 25 이하입니다. board 배열의 각 원소의 값은 0 또는 1 입니다. 도면의 가장 왼쪽 상단 좌표는 (0, 0)이며, 가장 우측 하단 좌표는 (N-1, N-1) 입니다. 원소의 값 0은 칸이 비어 있어 도로 연결이 가능함을 1은 칸이 벽으로 채워져 있어 도로 연결이 불가능함을 나타냅니다. board는 항상 출발점에서 도착점까지 경주로를 건설할 수 있는 형태로 주어집니다. 출발점과 도착점 칸의 원소의 값은 항상 0으로 주어집니다. 입출력 예 board result [[0,0,0],[0,0,0],[0,0,0]] 900 [[0,0,0,0,0,0,0,1],[0,0,0,0,0,0,0,0],[0,0,0,0,0,1,0,0],[0,0,0,0,1,0,0,0],[0,0,0,1,0,0,0,1],[0,0,1,0,0,0,1,0],[0,1,0,0,0,1,0,0],[1,0,0,0,0,0,0,0]] 3800 [[0,0,1,0],[0,0,0,0],[0,1,0,1],[1,0,0,0]] 2100 [[0,0,0,0,0,0],[0,1,1,1,1,0],[0,0,1,0,0,0],[1,0,0,1,0,1],[0,1,0,0,0,1],[0,0,0,0,0,0]] 3200 입출력 예에 대한 설명",normal,Array
145,"[본 문제는 정확성과 효율성 테스트 각각 점수가 있는 문제입니다.] 개발자 출신으로 세계 최고의 갑부가 된 어피치는 스트레스를 받을 때면 이를 풀기 위해 오프라인 매장에 쇼핑을 하러 가곤 합니다. 어피치는 쇼핑을 할 때면 매장 진열대의 특정 범위의 물건들을 모두 싹쓸이 구매하는 습관이 있습니다. 어느 날 스트레스를 풀기 위해 보석 매장에 쇼핑을 하러 간 어피치는 이전처럼 진열대의 특정 범위의 보석을 모두 구매하되 특별히 아래 목적을 달성하고 싶었습니다. 진열된 모든 종류의 보석을 적어도 1개 이상 포함하는 가장 짧은 구간을 찾아서 구매 예를 들어 아래 진열대는 4종류의 보석(RUBY, DIA, EMERALD, SAPPHIRE) 8개가 진열된 예시입니다. 진열대 번호 1 2 3 4 5 6 7 8 보석 이름 DIA RUBY RUBY DIA DIA EMERALD SAPPHIRE DIA 진열대의 3번부터 7번까지 5개의 보석을 구매하면 모든 종류의 보석을 적어도 하나 이상씩 포함하게 됩니다. 진열대의 3, 4, 6, 7번의 보석만 구매하는 것은 중간에 특정 구간(5번)이 빠지게 되므로 어피치의 쇼핑 습관에 맞지 않습니다. 진열대 번호 순서대로 보석들의 이름이 저장된 배열 gems가 매개변수로 주어집니다. 이때 모든 보석을 하나 이상 포함하는 가장 짧은 구간을 찾아서 return 하도록 solution 함수를 완성해주세요. 가장 짧은 구간의 시작 진열대 번호와 끝 진열대 번호를 차례대로 배열에 담아서 return 하도록 하며, 만약 가장 짧은 구간이 여러 개라면 시작 진열대 번호가 가장 작은 구간을 return 합니다. [제한사항] gems 배열의 크기는 1 이상 100,000 이하입니다. gems 배열의 각 원소는 진열대에 나열된 보석을 나타냅니다. gems 배열에는 1번 진열대부터 진열대 번호 순서대로 보석이름이 차례대로 저장되어 있습니다. gems 배열의 각 원소는 길이가 1 이상 10 이하인 알파벳 대문자로만 구성된 문자열입니다. 입출력 예 gems result [""DIA"", ""RUBY"", ""RUBY"", ""DIA"", ""DIA"", ""EMERALD"", ""SAPPHIRE"", ""DIA""] [3, 7] [""AA"", ""AB"", ""AC"", ""AA"", ""AC""] [1, 3] [""XYZ"", ""XYZ"", ""XYZ""] [1, 1] [""ZZZ"", ""YYY"", ""NNNN"", ""YYY"", ""BBB""] [1, 5] 입출력 예에 대한 설명",normal,Array
146,"IT 벤처 회사를 운영하고 있는 라이언은 매년 사내 해커톤 대회를 개최하여 우승자에게 상금을 지급하고 있습니다. 이번 대회에서는 우승자에게 지급되는 상금을 이전 대회와는 다르게 다음과 같은 방식으로 결정하려고 합니다. 해커톤 대회에 참가하는 모든 참가자들에게는 숫자들과 3가지의 연산문자(+, -, *) 만으로 이루어진 연산 수식이 전달되며, 참가자의 미션은 전달받은 수식에 포함된 연산자의 우선순위를 자유롭게 재정의하여 만들 수 있는 가장 큰 숫자를 제출하는 것입니다. 단, 연산자의 우선순위를 새로 정의할 때, 같은 순위의 연산자는 없어야 합니다. 즉, + > - > * 또는 - > * > + 등과 같이 연산자 우선순위를 정의할 수 있으나 +,* > - 또는 * > +,-처럼 2개 이상의 연산자가 동일한 순위를 가지도록 연산자 우선순위를 정의할 수는 없습니다. 수식에 포함된 연산자가 2개라면 정의할 수 있는 연산자 우선순위 조합은 2! = 2가지이며, 연산자가 3개라면 3! = 6가지 조합이 가능합니다. 만약 계산된 결과가 음수라면 해당 숫자의 절댓값으로 변환하여 제출하며 제출한 숫자가 가장 큰 참가자를 우승자로 선정하며, 우승자가 제출한 숫자를 우승상금으로 지급하게 됩니다. 예를 들어, 참가자 중 네오가 아래와 같은 수식을 전달받았다고 가정합니다. ""100-200*300-500+20"" 일반적으로 수학 및 전산학에서 약속된 연산자 우선순위에 따르면 더하기와 빼기는 서로 동등하며 곱하기는 더하기, 빼기에 비해 우선순위가 높아 * > +,- 로 우선순위가 정의되어 있습니다. 대회 규칙에 따라 + > - > * 또는 - > * > + 등과 같이 연산자 우선순위를 정의할 수 있으나 +,* > - 또는 * > +,- 처럼 2개 이상의 연산자가 동일한 순위를 가지도록 연산자 우선순위를 정의할 수는 없습니다. 수식에 연산자가 3개 주어졌으므로 가능한 연산자 우선순위 조합은 3! = 6가지이며, 그 중 + > - > * 로 연산자 우선순위를 정한다면 결괏값은 22,000원이 됩니다. 반면에 * > + > - 로 연산자 우선순위를 정한다면 수식의 결괏값은 -60,420 이지만, 규칙에 따라 우승 시 상금은 절댓값인 60,420원이 됩니다. 참가자에게 주어진 연산 수식이 담긴 문자열 expression이 매개변수로 주어질 때, 우승 시 받을 수 있는 가장 큰 상금 금액을 return 하도록 solution 함수를 완성해주세요. [제한사항] expression은 길이가 3 이상 100 이하인 문자열입니다. expression은 공백문자, 괄호문자 없이 오로지 숫자와 3가지의 연산자(+, -, *) 만으로 이루어진 올바른 중위표기법(연산의 두 대상 사이에 연산기호를 사용하는 방식)으로 표현된 연산식입니다. 잘못된 연산식은 입력으로 주어지지 않습니다. 즉, ""402+-561*""처럼 잘못된 수식은 올바른 중위표기법이 아니므로 주어지지 않습니다. expression의 피연산자(operand)는 0 이상 999 이하의 숫자입니다. 즉, ""100-2145*458+12""처럼 999를 초과하는 피연산자가 포함된 수식은 입력으로 주어지지 않습니다. ""-56+100""처럼 피연산자가 음수인 수식도 입력으로 주어지지 않습니다. expression은 적어도 1개 이상의 연산자를 포함하고 있습니다. 연산자 우선순위를 어떻게 적용하더라도, expression의 중간 계산값과 최종 결괏값은 절댓값이 263 - 1 이하가 되도록 입력이 주어집니다. 같은 연산자끼리는 앞에 있는 것의 우선순위가 더 높습니다. 입출력 예 expression result ""100-200*300-500+20"" 60420 ""50*6-3*2"" 300 입출력 예에 대한 설명",normal,String
147,"셀수있는 수량의 순서있는 열거 또는 어떤 순서를 따르는 요소들의 모음을 튜플(tuple)이라고 합니다. n개의 요소를 가진 튜플을 n-튜플(n-tuple)이라고 하며, 다음과 같이 표현할 수 있습니다. (a1, a2, a3, ..., an) 튜플은 다음과 같은 성질을 가지고 있습니다. 중복된 원소가 있을 수 있습니다. ex : (2, 3, 1, 2) 원소에 정해진 순서가 있으며, 원소의 순서가 다르면 서로 다른 튜플입니다. ex : (1, 2, 3) ≠ (1, 3, 2) 튜플의 원소 개수는 유한합니다. 원소의 개수가 n개이고, 중복되는 원소가 없는 튜플 (a1, a2, a3, ..., an)이 주어질 때(단, a1, a2, ..., an은 자연수), 이는 다음과 같이 집합 기호 '{', '}'를 이용해 표현할 수 있습니다. {{a1}, {a1, a2}, {a1, a2, a3}, {a1, a2, a3, a4}, ... {a1, a2, a3, a4, ..., an}} 예를 들어 튜플이 (2, 1, 3, 4)인 경우 이는 {{2}, {2, 1}, {2, 1, 3}, {2, 1, 3, 4}} 와 같이 표현할 수 있습니다. 이때, 집합은 원소의 순서가 바뀌어도 상관없으므로 {{2}, {2, 1}, {2, 1, 3}, {2, 1, 3, 4}} {{2, 1, 3, 4}, {2}, {2, 1, 3}, {2, 1}} {{1, 2, 3}, {2, 1}, {1, 2, 4, 3}, {2}} 는 모두 같은 튜플 (2, 1, 3, 4)를 나타냅니다. 특정 튜플을 표현하는 집합이 담긴 문자열 s가 매개변수로 주어질 때, s가 표현하는 튜플을 배열에 담아 return 하도록 solution 함수를 완성해주세요. [제한사항] s의 길이는 5 이상 1,000,000 이하입니다. s는 숫자와 '{', '}', ',' 로만 이루어져 있습니다. 숫자가 0으로 시작하는 경우는 없습니다. s는 항상 중복되는 원소가 없는 튜플을 올바르게 표현하고 있습니다. s가 표현하는 튜플의 원소는 1 이상 100,000 이하인 자연수입니다. return 하는 배열의 길이가 1 이상 500 이하인 경우만 입력으로 주어집니다. [입출력 예] s result ""{{2},{2,1},{2,1,3},{2,1,3,4}}"" [2, 1, 3, 4] ""{{1,2,3},{2,1},{1,2,4,3},{2}}"" [2, 1, 3, 4] ""{{20,111},{111}}"" [111, 20] ""{{123}}"" [123] ""{{4,2,3},{3},{2,3,4,1},{2,3}}"" [3, 2, 4, 1] 입출력 예에 대한 설명",normal,Array
148,"개발팀 내에서 이벤트 개발을 담당하고 있는 ""무지""는 최근 진행된 카카오이모티콘 이벤트에 비정상적인 방법으로 당첨을 시도한 응모자들을 발견하였습니다. 이런 응모자들을 따로 모아 불량 사용자라는 이름으로 목록을 만들어서 당첨 처리 시 제외하도록 이벤트 당첨자 담당자인 ""프로도"" 에게 전달하려고 합니다. 이 때 개인정보 보호을 위해 사용자 아이디 중 일부 문자를 '*' 문자로 가려서 전달했습니다. 가리고자 하는 문자 하나에 '*' 문자 하나를 사용하였고 아이디 당 최소 하나 이상의 '*' 문자를 사용하였습니다. ""무지""와 ""프로도""는 불량 사용자 목록에 매핑된 응모자 아이디를 제재 아이디 라고 부르기로 하였습니다. 예를 들어, 이벤트에 응모한 전체 사용자 아이디 목록이 다음과 같다면 응모자 아이디 frodo fradi crodo abc123 frodoc 다음과 같이 불량 사용자 아이디 목록이 전달된 경우, 불량 사용자 fr*d* abc1** 불량 사용자에 매핑되어 당첨에서 제외되어야 야 할 제재 아이디 목록은 다음과 같이 두 가지 경우가 있을 수 있습니다. 제재 아이디 frodo abc123 제재 아이디 fradi abc123 이벤트 응모자 아이디 목록이 담긴 배열 user_id와 불량 사용자 아이디 목록이 담긴 배열 banned_id가 매개변수로 주어질 때, 당첨에서 제외되어야 할 제재 아이디 목록은 몇가지 경우의 수가 가능한 지 return 하도록 solution 함수를 완성해주세요. [제한사항] user_id 배열의 크기는 1 이상 8 이하입니다. user_id 배열 각 원소들의 값은 길이가 1 이상 8 이하인 문자열입니다. 응모한 사용자 아이디들은 서로 중복되지 않습니다. 응모한 사용자 아이디는 알파벳 소문자와 숫자로만으로 구성되어 있습니다. banned_id 배열의 크기는 1 이상 user_id 배열의 크기 이하입니다. banned_id 배열 각 원소들의 값은 길이가 1 이상 8 이하인 문자열입니다. 불량 사용자 아이디는 알파벳 소문자와 숫자, 가리기 위한 문자 '*' 로만 이루어져 있습니다. 불량 사용자 아이디는 '*' 문자를 하나 이상 포함하고 있습니다. 불량 사용자 아이디 하나는 응모자 아이디 중 하나에 해당하고 같은 응모자 아이디가 중복해서 제재 아이디 목록에 들어가는 경우는 없습니다. 제재 아이디 목록들을 구했을 때 아이디들이 나열된 순서와 관계없이 아이디 목록의 내용이 동일하다면 같은 것으로 처리하여 하나로 세면 됩니다. [입출력 예] user_id banned_id result [""frodo"", ""fradi"", ""crodo"", ""abc123"", ""frodoc""] [""fr*d*"", ""abc1**""] 2 [""frodo"", ""fradi"", ""crodo"", ""abc123"", ""frodoc""] [""*rodo"", ""*rodo"", ""******""] 2 [""frodo"", ""fradi"", ""crodo"", ""abc123"", ""frodoc""] [""fr*d*"", ""*rodo"", ""******"", ""******""] 3 입출력 예에 대한 설명",normal,Array
149,"[본 문제는 정확성과 효율성 테스트 각각 점수가 있는 문제입니다.] ""스노우타운""에서 호텔을 운영하고 있는 ""스카피""는 호텔에 투숙하려는 고객들에게 방을 배정하려 합니다. 호텔에는 방이 총 k개 있으며, 각각의 방은 1번부터 k번까지 번호로 구분하고 있습니다. 처음에는 모든 방이 비어 있으며 ""스카피""는 다음과 같은 규칙에 따라 고객에게 방을 배정하려고 합니다. 한 번에 한 명씩 신청한 순서대로 방을 배정합니다. 고객은 투숙하기 원하는 방 번호를 제출합니다. 고객이 원하는 방이 비어 있다면 즉시 배정합니다. 고객이 원하는 방이 이미 배정되어 있으면 원하는 방보다 번호가 크면서 비어있는 방 중 가장 번호가 작은 방을 배정합니다. 예를 들어, 방이 총 10개이고, 고객들이 원하는 방 번호가 순서대로 [1, 3, 4, 1, 3, 1] 일 경우 다음과 같이 방을 배정받게 됩니다. 원하는 방 번호 배정된 방 번호 1 1 3 3 4 4 1 2 3 5 1 6 전체 방 개수 k와 고객들이 원하는 방 번호가 순서대로 들어있는 배열 room_number가 매개변수로 주어질 때, 각 고객에게 배정되는 방 번호를 순서대로 배열에 담아 return 하도록 solution 함수를 완성해주세요. [제한사항] k는 1 이상 1012 이하인 자연수입니다. room_number 배열의 크기는 1 이상 200,000 이하입니다. room_number 배열 각 원소들의 값은 1 이상 k 이하인 자연수입니다. room_number 배열은 모든 고객이 방을 배정받을 수 있는 경우만 입력으로 주어집니다. 예를 들어, k = 5, room_number = [5, 5] 와 같은 경우는 방을 배정받지 못하는 고객이 발생하므로 이런 경우는 입력으로 주어지지 않습니다. [입출력 예] k room_number result 10 [1,3,4,1,3,1] [1,3,4,2,5,6] 입출력 예에 대한 설명",hard,Array
150,"[본 문제는 정확성과 효율성 테스트 각각 점수가 있는 문제입니다.] 카카오 초등학교의 ""니니즈 친구들""이 ""라이언"" 선생님과 함께 가을 소풍을 가는 중에 징검다리가 있는 개울을 만나서 건너편으로 건너려고 합니다. ""라이언"" 선생님은 ""니니즈 친구들""이 무사히 징검다리를 건널 수 있도록 다음과 같이 규칙을 만들었습니다. 징검다리는 일렬로 놓여 있고 각 징검다리의 디딤돌에는 모두 숫자가 적혀 있으며 디딤돌의 숫자는 한 번 밟을 때마다 1씩 줄어듭니다. 디딤돌의 숫자가 0이 되면 더 이상 밟을 수 없으며 이때는 그 다음 디딤돌로 한번에 여러 칸을 건너 뛸 수 있습니다. 단, 다음으로 밟을 수 있는 디딤돌이 여러 개인 경우 무조건 가장 가까운 디딤돌로만 건너뛸 수 있습니다. ""니니즈 친구들""은 개울의 왼쪽에 있으며, 개울의 오른쪽 건너편에 도착해야 징검다리를 건넌 것으로 인정합니다. ""니니즈 친구들""은 한 번에 한 명씩 징검다리를 건너야 하며, 한 친구가 징검다리를 모두 건넌 후에 그 다음 친구가 건너기 시작합니다. 디딤돌에 적힌 숫자가 순서대로 담긴 배열 stones와 한 번에 건너뛸 수 있는 디딤돌의 최대 칸수 k가 매개변수로 주어질 때, 최대 몇 명까지 징검다리를 건널 수 있는지 return 하도록 solution 함수를 완성해주세요. [제한사항] 징검다리를 건너야 하는 니니즈 친구들의 수는 무제한 이라고 간주합니다. stones 배열의 크기는 1 이상 200,000 이하입니다. stones 배열 각 원소들의 값은 1 이상 200,000,000 이하인 자연수입니다. k는 1 이상 stones의 길이 이하인 자연수입니다. [입출력 예] stones k result [2, 4, 5, 3, 2, 1, 4, 2, 5, 1] 3 3 입출력 예에 대한 설명",normal,Array
151,"CART_PRODUCTS 테이블은 장바구니에 담긴 상품 정보를 담은 테이블입니다. CART_PRODUCTS 테이블의 구조는 다음과 같으며, ID, CART_ID, NAME, PRICE는 각각 테이블의 아이디, 장바구니의 아이디, 상품 종류, 가격을 나타냅니다. NAME TYPE ID INT CART_ID INT NAME VARCHAR PRICE INT 데이터 분석 팀에서는 우유(Milk)와 요거트(Yogurt)를 동시에 구입한 장바구니가 있는지 알아보려 합니다. 우유와 요거트를 동시에 구입한 장바구니의 아이디를 조회하는 SQL 문을 작성해주세요. 이때 결과는 장바구니의 아이디 순으로 나와야 합니다. 예시 예를 들어 CART_PRODUCTS 테이블이 다음과 같다면 CART_PRODUCTS 테이블 ID CART_ID NAME PRICE 1630 83 Cereal 3980 1631 83 Multipurpose Supply 3900 5491 286 Yogurt 2980 5504 286 Milk 1880 8435 448 Milk 1880 8437 448 Yogurt 2980 8438 448 Tea 11000 20236 1034 Yogurt 2980 20237 1034 Butter 4890 83번 장바구니에는 Milk와 Yogurt가 모두 없습니다. 286번 장바구니에는 Milk와 Yogurt가 모두 있습니다. 448번 장바구니에는 Milk와 Yogurt가 모두 있습니다. 1034번 장바구니에는 Milk는 없고 Yogurt만 있습니다. 따라서 SQL 문을 실행하면 다음과 같이 나와야 합니다. CART_ID 286 448",hard,database
152,"N x N 크기인 정사각 격자 형태의 지형이 있습니다. 각 격자 칸은 1 x 1 크기이며, 숫자가 하나씩 적혀있습니다. 격자 칸에 적힌 숫자는 그 칸의 높이를 나타냅니다. 이 지형의 아무 칸에서나 출발해 모든 칸을 방문하는 탐험을 떠나려 합니다. 칸을 이동할 때는 상, 하, 좌, 우로 한 칸씩 이동할 수 있는데, 현재 칸과 이동하려는 칸의 높이 차가 height 이하여야 합니다. 높이 차가 height 보다 많이 나는 경우에는 사다리를 설치해서 이동할 수 있습니다. 이때, 사다리를 설치하는데 두 격자 칸의 높이차만큼 비용이 듭니다. 따라서, 최대한 적은 비용이 들도록 사다리를 설치해서 모든 칸으로 이동 가능하도록 해야 합니다. 설치할 수 있는 사다리 개수에 제한은 없으며, 설치한 사다리는 철거하지 않습니다. 각 격자칸의 높이가 담긴 2차원 배열 land와 이동 가능한 최대 높이차 height가 매개변수로 주어질 때, 모든 칸을 방문하기 위해 필요한 사다리 설치 비용의 최솟값을 return 하도록 solution 함수를 완성해주세요. 제한사항 land는 N x N크기인 2차원 배열입니다. land의 최소 크기는 4 x 4, 최대 크기는 300 x 300입니다. land의 원소는 각 격자 칸의 높이를 나타냅니다. 격자 칸의 높이는 1 이상 10,000 이하인 자연수입니다. height는 1 이상 10,000 이하인 자연수입니다. 입출력 예 land height result [[1, 4, 8, 10], [5, 5, 5, 5], [10, 10, 10, 10], [10, 10, 10, 20]] 3 15 [[10, 11, 10, 11], [2, 21, 20, 10], [1, 20, 21, 11], [2, 1, 2, 1]] 1 18 입출력 예 설명",hard,Array
153,"가로 길이가 Wcm, 세로 길이가 Hcm인 직사각형 종이가 있습니다. 종이에는 가로, 세로 방향과 평행하게 격자 형태로 선이 그어져 있으며, 모든 격자칸은 1cm x 1cm 크기입니다. 이 종이를 격자 선을 따라 1cm × 1cm의 정사각형으로 잘라 사용할 예정이었는데, 누군가가 이 종이를 대각선 꼭지점 2개를 잇는 방향으로 잘라 놓았습니다. 그러므로 현재 직사각형 종이는 크기가 같은 직각삼각형 2개로 나누어진 상태입니다. 새로운 종이를 구할 수 없는 상태이기 때문에, 이 종이에서 원래 종이의 가로, 세로 방향과 평행하게 1cm × 1cm로 잘라 사용할 수 있는 만큼만 사용하기로 하였습니다. 가로의 길이 W와 세로의 길이 H가 주어질 때, 사용할 수 있는 정사각형의 개수를 구하는 solution 함수를 완성해 주세요. 제한사항 W, H : 1억 이하의 자연수 입출력 예 W H result 8 12 80 입출력 예 설명",normal,Math
154,"로봇개발자 ""무지""는 한 달 앞으로 다가온 ""카카오배 로봇경진대회""에 출품할 로봇을 준비하고 있습니다. 준비 중인 로봇은 2 x 1 크기의 로봇으로 ""무지""는 ""0""과 ""1""로 이루어진 N x N 크기의 지도에서 2 x 1 크기인 로봇을 움직여 (N, N) 위치까지 이동 할 수 있도록 프로그래밍을 하려고 합니다. 로봇이 이동하는 지도는 가장 왼쪽, 상단의 좌표를 (1, 1)로 하며 지도 내에 표시된 숫자 ""0""은 빈칸을 ""1""은 벽을 나타냅니다. 로봇은 벽이 있는 칸 또는 지도 밖으로는 이동할 수 없습니다. 로봇은 처음에 아래 그림과 같이 좌표 (1, 1) 위치에서 가로방향으로 놓여있는 상태로 시작하며, 앞뒤 구분없이 움직일 수 있습니다. 로봇이 움직일 때는 현재 놓여있는 상태를 유지하면서 이동합니다. 예를 들어, 위 그림에서 오른쪽으로 한 칸 이동한다면 (1, 2), (1, 3) 두 칸을 차지하게 되며, 아래로 이동한다면 (2, 1), (2, 2) 두 칸을 차지하게 됩니다. 로봇이 차지하는 두 칸 중 어느 한 칸이라도 (N, N) 위치에 도착하면 됩니다. 로봇은 다음과 같이 조건에 따라 회전이 가능합니다. 위 그림과 같이 로봇은 90도씩 회전할 수 있습니다. 단, 로봇이 차지하는 두 칸 중, 어느 칸이든 축이 될 수 있지만, 회전하는 방향(축이 되는 칸으로부터 대각선 방향에 있는 칸)에는 벽이 없어야 합니다. 로봇이 한 칸 이동하거나 90도 회전하는 데는 걸리는 시간은 정확히 1초 입니다. ""0""과 ""1""로 이루어진 지도인 board가 주어질 때, 로봇이 (N, N) 위치까지 이동하는데 필요한 최소 시간을 return 하도록 solution 함수를 완성해주세요. 제한사항 board의 한 변의 길이는 5 이상 100 이하입니다. board의 원소는 0 또는 1입니다. 로봇이 처음에 놓여 있는 칸 (1, 1), (1, 2)는 항상 0으로 주어집니다. 로봇이 항상 목적지에 도착할 수 있는 경우만 입력으로 주어집니다. 입출력 예 board result [[0, 0, 0, 1, 1],[0, 0, 0, 1, 0],[0, 1, 0, 1, 1],[1, 1, 0, 0, 1],[0, 0, 0, 0, 0]] 7 입출력 예에 대한 설명 문제에 주어진 예시와 같습니다. 로봇이 오른쪽으로 한 칸 이동 후, (1, 3) 칸을 축으로 반시계 방향으로 90도 회전합니다. 다시, 아래쪽으로 3칸 이동하면 로봇은 (4, 3), (5, 3) 두 칸을 차지하게 됩니다. 이제 (5, 3)을 축으로 시계 방향으로 90도 회전 후, 오른쪽으로 한 칸 이동하면 (N, N)에 도착합니다. 따라서 목적지에 도달하기까지 최소 7초가 걸립니다.",normal,Math
155,"레스토랑을 운영하고 있는 ""스카피""는 레스토랑 내부가 너무 낡아 친구들과 함께 직접 리모델링 하기로 했습니다. 레스토랑이 있는 곳은 스노우타운으로 매우 추운 지역이어서 내부 공사를 하는 도중에 주기적으로 외벽의 상태를 점검해야 할 필요가 있습니다. 레스토랑의 구조는 완전히 동그란 모양이고 외벽의 총 둘레는 n미터이며, 외벽의 몇몇 지점은 추위가 심할 경우 손상될 수도 있는 취약한 지점들이 있습니다. 따라서 내부 공사 도중에도 외벽의 취약 지점들이 손상되지 않았는 지, 주기적으로 친구들을 보내서 점검을 하기로 했습니다. 다만, 빠른 공사 진행을 위해 점검 시간을 1시간으로 제한했습니다. 친구들이 1시간 동안 이동할 수 있는 거리는 제각각이기 때문에, 최소한의 친구들을 투입해 취약 지점을 점검하고 나머지 친구들은 내부 공사를 돕도록 하려고 합니다. 편의 상 레스토랑의 정북 방향 지점을 0으로 나타내며, 취약 지점의 위치는 정북 방향 지점으로부터 시계 방향으로 떨어진 거리로 나타냅니다. 또, 친구들은 출발 지점부터 시계, 혹은 반시계 방향으로 외벽을 따라서만 이동합니다. 외벽의 길이 n, 취약 지점의 위치가 담긴 배열 weak, 각 친구가 1시간 동안 이동할 수 있는 거리가 담긴 배열 dist가 매개변수로 주어질 때, 취약 지점을 점검하기 위해 보내야 하는 친구 수의 최소값을 return 하도록 solution 함수를 완성해주세요. 제한사항 n은 1 이상 200 이하인 자연수입니다. weak의 길이는 1 이상 15 이하입니다. 서로 다른 두 취약점의 위치가 같은 경우는 주어지지 않습니다. 취약 지점의 위치는 오름차순으로 정렬되어 주어집니다. weak의 원소는 0 이상 n - 1 이하인 정수입니다. dist의 길이는 1 이상 8 이하입니다. dist의 원소는 1 이상 100 이하인 자연수입니다. 친구들을 모두 투입해도 취약 지점을 전부 점검할 수 없는 경우에는 -1을 return 해주세요. 입출력 예 n weak dist result 12 [1, 5, 6, 10] [1, 2, 3, 4] 2 12 [1, 3, 4, 9, 10] [3, 5, 7] 1 입출력 예에 대한 설명",normal,Array
156,"빙하가 깨지면서 스노우타운에 떠내려 온 ""죠르디""는 인생 2막을 위해 주택 건축사업에 뛰어들기로 결심하였습니다. ""죠르디""는 기둥과 보를 이용하여 벽면 구조물을 자동으로 세우는 로봇을 개발할 계획인데, 그에 앞서 로봇의 동작을 시뮬레이션 할 수 있는 프로그램을 만들고 있습니다. 프로그램은 2차원 가상 벽면에 기둥과 보를 이용한 구조물을 설치할 수 있는데, 기둥과 보는 길이가 1인 선분으로 표현되며 다음과 같은 규칙을 가지고 있습니다. 기둥은 바닥 위에 있거나 보의 한쪽 끝 부분 위에 있거나, 또는 다른 기둥 위에 있어야 합니다. 보는 한쪽 끝 부분이 기둥 위에 있거나, 또는 양쪽 끝 부분이 다른 보와 동시에 연결되어 있어야 합니다. 단, 바닥은 벽면의 맨 아래 지면을 말합니다. 2차원 벽면은 n x n 크기 정사각 격자 형태이며, 각 격자는 1 x 1 크기입니다. 맨 처음 벽면은 비어있는 상태입니다. 기둥과 보는 격자선의 교차점에 걸치지 않고, 격자 칸의 각 변에 정확히 일치하도록 설치할 수 있습니다. 다음은 기둥과 보를 설치해 구조물을 만든 예시입니다. 예를 들어, 위 그림은 다음 순서에 따라 구조물을 만들었습니다. (1, 0)에서 위쪽으로 기둥을 하나 설치 후, (1, 1)에서 오른쪽으로 보를 하나 만듭니다. (2, 1)에서 위쪽으로 기둥을 하나 설치 후, (2, 2)에서 오른쪽으로 보를 하나 만듭니다. (5, 0)에서 위쪽으로 기둥을 하나 설치 후, (5, 1)에서 위쪽으로 기둥을 하나 더 설치합니다. (4, 2)에서 오른쪽으로 보를 설치 후, (3, 2)에서 오른쪽으로 보를 설치합니다. 만약 (4, 2)에서 오른쪽으로 보를 먼저 설치하지 않고, (3, 2)에서 오른쪽으로 보를 설치하려 한다면 2번 규칙에 맞지 않으므로 설치가 되지 않습니다. 기둥과 보를 삭제하는 기능도 있는데 기둥과 보를 삭제한 후에 남은 기둥과 보들 또한 위 규칙을 만족해야 합니다. 만약, 작업을 수행한 결과가 조건을 만족하지 않는다면 해당 작업은 무시됩니다. 벽면의 크기 n, 기둥과 보를 설치하거나 삭제하는 작업이 순서대로 담긴 2차원 배열 build_frame이 매개변수로 주어질 때, 모든 명령어를 수행한 후 구조물의 상태를 return 하도록 solution 함수를 완성해주세요. 제한사항 n은 5 이상 100 이하인 자연수입니다. build_frame의 세로(행) 길이는 1 이상 1,000 이하입니다. build_frame의 가로(열) 길이는 4입니다. build_frame의 원소는 [x, y, a, b]형태입니다. x, y는 기둥, 보를 설치 또는 삭제할 교차점의 좌표이며, [가로 좌표, 세로 좌표] 형태입니다. a는 설치 또는 삭제할 구조물의 종류를 나타내며, 0은 기둥, 1은 보를 나타냅니다. b는 구조물을 설치할 지, 혹은 삭제할 지를 나타내며 0은 삭제, 1은 설치를 나타냅니다. 벽면을 벗어나게 기둥, 보를 설치하는 경우는 없습니다. 바닥에 보를 설치 하는 경우는 없습니다. 구조물은 교차점 좌표를 기준으로 보는 오른쪽, 기둥은 위쪽 방향으로 설치 또는 삭제합니다. 구조물이 겹치도록 설치하는 경우와, 없는 구조물을 삭제하는 경우는 입력으로 주어지지 않습니다. 최종 구조물의 상태는 아래 규칙에 맞춰 return 해주세요. return 하는 배열은 가로(열) 길이가 3인 2차원 배열로, 각 구조물의 좌표를 담고있어야 합니다. return 하는 배열의 원소는 [x, y, a] 형식입니다. x, y는 기둥, 보의 교차점 좌표이며, [가로 좌표, 세로 좌표] 형태입니다. 기둥, 보는 교차점 좌표를 기준으로 오른쪽, 또는 위쪽 방향으로 설치되어 있음을 나타냅니다. a는 구조물의 종류를 나타내며, 0은 기둥, 1은 보를 나타냅니다. return 하는 배열은 x좌표 기준으로 오름차순 정렬하며, x좌표가 같을 경우 y좌표 기준으로 오름차순 정렬해주세요. x, y좌표가 모두 같은 경우 기둥이 보보다 앞에 오면 됩니다. 입출력 예 n build_frame result 5 [[1,0,0,1],[1,1,1,1],[2,1,0,1],[2,2,1,1],[5,0,0,1],[5,1,0,1],[4,2,1,1],[3,2,1,1]] [[1,0,0],[1,1,1],[2,1,0],[2,2,1],[3,2,1],[4,2,1],[5,0,0],[5,1,0]] 5 [[0,0,0,1],[2,0,0,1],[4,0,0,1],[0,1,1,1],[1,1,1,1],[2,1,1,1],[3,1,1,1],[2,0,0,0],[1,1,1,0],[2,2,0,1]] [[0,0,0],[0,1,1],[1,1,1],[2,1,1],[3,1,1],[4,0,0]] 입출력 예에 대한 설명",normal,Array
157,"[본 문제는 정확성과 효율성 테스트 각각 점수가 있는 문제입니다.] 친구들로부터 천재 프로그래머로 불리는 ""프로도""는 음악을 하는 친구로부터 자신이 좋아하는 노래 가사에 사용된 단어들 중에 특정 키워드가 몇 개 포함되어 있는지 궁금하니 프로그램으로 개발해 달라는 제안을 받았습니다. 그 제안 사항 중, 키워드는 와일드카드 문자중 하나인 '?'가 포함된 패턴 형태의 문자열을 뜻합니다. 와일드카드 문자인 '?'는 글자 하나를 의미하며, 어떤 문자에도 매치된다고 가정합니다. 예를 들어 ""fro??""는 ""frodo"", ""front"", ""frost"" 등에 매치되지만 ""frame"", ""frozen""에는 매치되지 않습니다. 가사에 사용된 모든 단어들이 담긴 배열 words와 찾고자 하는 키워드가 담긴 배열 queries가 주어질 때, 각 키워드 별로 매치된 단어가 몇 개인지 순서대로 배열에 담아 반환하도록 solution 함수를 완성해 주세요. 가사 단어 제한사항 words의 길이(가사 단어의 개수)는 2 이상 100,000 이하입니다. 각 가사 단어의 길이는 1 이상 10,000 이하로 빈 문자열인 경우는 없습니다. 전체 가사 단어 길이의 합은 2 이상 1,000,000 이하입니다. 가사에 동일 단어가 여러 번 나올 경우 중복을 제거하고 words에는 하나로만 제공됩니다. 각 가사 단어는 오직 알파벳 소문자로만 구성되어 있으며, 특수문자나 숫자는 포함하지 않는 것으로 가정합니다. 검색 키워드 제한사항 queries의 길이(검색 키워드 개수)는 2 이상 100,000 이하입니다. 각 검색 키워드의 길이는 1 이상 10,000 이하로 빈 문자열인 경우는 없습니다. 전체 검색 키워드 길이의 합은 2 이상 1,000,000 이하입니다. 검색 키워드는 중복될 수도 있습니다. 각 검색 키워드는 오직 알파벳 소문자와 와일드카드 문자인 '?' 로만 구성되어 있으며, 특수문자나 숫자는 포함하지 않는 것으로 가정합니다. 검색 키워드는 와일드카드 문자인 '?'가 하나 이상 포함돼 있으며, '?'는 각 검색 키워드의 접두사 아니면 접미사 중 하나로만 주어집니다. 예를 들어 ""??odo"", ""fro??"", ""?????""는 가능한 키워드입니다. 반면에 ""frodo""('?'가 없음), ""fr?do""('?'가 중간에 있음), ""?ro??""('?'가 양쪽에 있음)는 불가능한 키워드입니다. 입출력 예 words queries result [""frodo"", ""front"", ""frost"", ""frozen"", ""frame"", ""kakao""] [""fro??"", ""????o"", ""fr???"", ""fro???"", ""pro?""] [3, 2, 4, 1, 0] 입출력 예에 대한 설명 ""fro??""는 ""frodo"", ""front"", ""frost""에 매치되므로 3입니다. ""????o""는 ""frodo"", ""kakao""에 매치되므로 2입니다. ""fr???""는 ""frodo"", ""front"", ""frost"", ""frame""에 매치되므로 4입니다. ""fro???""는 ""frozen""에 매치되므로 1입니다. ""pro?""는 매치되는 가사 단어가 없으므로 0 입니다.",hard,Array
158,"고고학자인 ""튜브""는 고대 유적지에서 보물과 유적이 가득할 것으로 추정되는 비밀의 문을 발견하였습니다. 그런데 문을 열려고 살펴보니 특이한 형태의 자물쇠로 잠겨 있었고 문 앞에는 특이한 형태의 열쇠와 함께 자물쇠를 푸는 방법에 대해 다음과 같이 설명해 주는 종이가 발견되었습니다. 잠겨있는 자물쇠는 격자 한 칸의 크기가 1 x 1인 N x N 크기의 정사각 격자 형태이고 특이한 모양의 열쇠는 M x M 크기인 정사각 격자 형태로 되어 있습니다. 자물쇠에는 홈이 파여 있고 열쇠 또한 홈과 돌기 부분이 있습니다. 열쇠는 회전과 이동이 가능하며 열쇠의 돌기 부분을 자물쇠의 홈 부분에 딱 맞게 채우면 자물쇠가 열리게 되는 구조입니다. 자물쇠 영역을 벗어난 부분에 있는 열쇠의 홈과 돌기는 자물쇠를 여는 데 영향을 주지 않지만, 자물쇠 영역 내에서는 열쇠의 돌기 부분과 자물쇠의 홈 부분이 정확히 일치해야 하며 열쇠의 돌기와 자물쇠의 돌기가 만나서는 안됩니다. 또한 자물쇠의 모든 홈을 채워 비어있는 곳이 없어야 자물쇠를 열 수 있습니다. 열쇠를 나타내는 2차원 배열 key와 자물쇠를 나타내는 2차원 배열 lock이 매개변수로 주어질 때, 열쇠로 자물쇠를 열수 있으면 true를, 열 수 없으면 false를 return 하도록 solution 함수를 완성해주세요. 제한사항 key는 M x M(3 ≤ M ≤ 20, M은 자연수)크기 2차원 배열입니다. lock은 N x N(3 ≤ N ≤ 20, N은 자연수)크기 2차원 배열입니다. M은 항상 N 이하입니다. key와 lock의 원소는 0 또는 1로 이루어져 있습니다. 0은 홈 부분, 1은 돌기 부분을 나타냅니다. 입출력 예 key lock result [[0, 0, 0], [1, 0, 0], [0, 1, 1]] [[1, 1, 1], [1, 1, 0], [1, 0, 1]] true 입출력 예에 대한 설명 key를 시계 방향으로 90도 회전하고, 오른쪽으로 한 칸, 아래로 한 칸 이동하면 lock의 홈 부분을 정확히 모두 채울 수 있습니다.",normal,Array
159,"카카오에 신입 개발자로 입사한 ""콘""은 선배 개발자로부터 개발역량 강화를 위해 다른 개발자가 작성한 소스 코드를 분석하여 문제점을 발견하고 수정하라는 업무 과제를 받았습니다. 소스를 컴파일하여 로그를 보니 대부분 소스 코드 내 작성된 괄호가 개수는 맞지만 짝이 맞지 않은 형태로 작성되어 오류가 나는 것을 알게 되었습니다. 수정해야 할 소스 파일이 너무 많아서 고민하던 ""콘""은 소스 코드에 작성된 모든 괄호를 뽑아서 올바른 순서대로 배치된 괄호 문자열을 알려주는 프로그램을 다음과 같이 개발하려고 합니다. 용어의 정의 '(' 와 ')' 로만 이루어진 문자열이 있을 경우, '(' 의 개수와 ')' 의 개수가 같다면 이를 균형잡힌 괄호 문자열이라고 부릅니다. 그리고 여기에 '('와 ')'의 괄호의 짝도 모두 맞을 경우에는 이를 올바른 괄호 문자열이라고 부릅니다. 예를 들어, ""(()))(""와 같은 문자열은 ""균형잡힌 괄호 문자열"" 이지만 ""올바른 괄호 문자열""은 아닙니다. 반면에 ""(())()""와 같은 문자열은 ""균형잡힌 괄호 문자열"" 이면서 동시에 ""올바른 괄호 문자열"" 입니다. '(' 와 ')' 로만 이루어진 문자열 w가 ""균형잡힌 괄호 문자열"" 이라면 다음과 같은 과정을 통해 ""올바른 괄호 문자열""로 변환할 수 있습니다. 1. 입력이 빈 문자열인 경우, 빈 문자열을 반환합니다. 2. 문자열 w를 두 ""균형잡힌 괄호 문자열"" u, v로 분리합니다. 단, u는 ""균형잡힌 괄호 문자열""로 더 이상 분리할 수 없어야 하며, v는 빈 문자열이 될 수 있습니다. 3. 문자열 u가 ""올바른 괄호 문자열"" 이라면 문자열 v에 대해 1단계부터 다시 수행합니다. 3-1. 수행한 결과 문자열을 u에 이어 붙인 후 반환합니다. 4. 문자열 u가 ""올바른 괄호 문자열""이 아니라면 아래 과정을 수행합니다. 4-1. 빈 문자열에 첫 번째 문자로 '('를 붙입니다. 4-2. 문자열 v에 대해 1단계부터 재귀적으로 수행한 결과 문자열을 이어 붙입니다. 4-3. ')'를 다시 붙입니다. 4-4. u의 첫 번째와 마지막 문자를 제거하고, 나머지 문자열의 괄호 방향을 뒤집어서 뒤에 붙입니다. 4-5. 생성된 문자열을 반환합니다. ""균형잡힌 괄호 문자열"" p가 매개변수로 주어질 때, 주어진 알고리즘을 수행해 ""올바른 괄호 문자열""로 변환한 결과를 return 하도록 solution 함수를 완성해 주세요. 매개변수 설명 p는 '(' 와 ')' 로만 이루어진 문자열이며 길이는 2 이상 1,000 이하인 짝수입니다. 문자열 p를 이루는 '(' 와 ')' 의 개수는 항상 같습니다. 만약 p가 이미 ""올바른 괄호 문자열""이라면 그대로 return 하면 됩니다. 입출력 예 p result ""(()())()"" ""(()())()"" "")("" ""()"" ""()))((()"" ""()(())()"" 입출력 예에 대한 설명",normal,String
160,"데이터 처리 전문가가 되고 싶은 ""어피치""는 문자열을 압축하는 방법에 대해 공부를 하고 있습니다. 최근에 대량의 데이터 처리를 위한 간단한 비손실 압축 방법에 대해 공부를 하고 있는데, 문자열에서 같은 값이 연속해서 나타나는 것을 그 문자의 개수와 반복되는 값으로 표현하여 더 짧은 문자열로 줄여서 표현하는 알고리즘을 공부하고 있습니다. 간단한 예로 ""aabbaccc""의 경우 ""2a2ba3c""(문자가 반복되지 않아 한번만 나타난 경우 1은 생략함)와 같이 표현할 수 있는데, 이러한 방식은 반복되는 문자가 적은 경우 압축률이 낮다는 단점이 있습니다. 예를 들면, ""abcabcdede""와 같은 문자열은 전혀 압축되지 않습니다. ""어피치""는 이러한 단점을 해결하기 위해 문자열을 1개 이상의 단위로 잘라서 압축하여 더 짧은 문자열로 표현할 수 있는지 방법을 찾아보려고 합니다. 예를 들어, ""ababcdcdababcdcd""의 경우 문자를 1개 단위로 자르면 전혀 압축되지 않지만, 2개 단위로 잘라서 압축한다면 ""2ab2cd2ab2cd""로 표현할 수 있습니다. 다른 방법으로 8개 단위로 잘라서 압축한다면 ""2ababcdcd""로 표현할 수 있으며, 이때가 가장 짧게 압축하여 표현할 수 있는 방법입니다. 다른 예로, ""abcabcdede""와 같은 경우, 문자를 2개 단위로 잘라서 압축하면 ""abcabc2de""가 되지만, 3개 단위로 자른다면 ""2abcdede""가 되어 3개 단위가 가장 짧은 압축 방법이 됩니다. 이때 3개 단위로 자르고 마지막에 남는 문자열은 그대로 붙여주면 됩니다. 압축할 문자열 s가 매개변수로 주어질 때, 위에 설명한 방법으로 1개 이상 단위로 문자열을 잘라 압축하여 표현한 문자열 중 가장 짧은 것의 길이를 return 하도록 solution 함수를 완성해주세요. 제한사항 s의 길이는 1 이상 1,000 이하입니다. s는 알파벳 소문자로만 이루어져 있습니다. 입출력 예 s result ""aabbaccc"" 7 ""ababcdcdababcdcd"" 9 ""abcabcdede"" 8 ""abcabcabcabcdededededede"" 14 ""xababcdcdababcdcd"" 17 입출력 예에 대한 설명",normal,String
161,"ANIMAL_INS 테이블은 동물 보호소에 들어온 동물의 정보를 담은 테이블입니다. ANIMAL_INS 테이블 구조는 다음과 같으며, ANIMAL_ID, ANIMAL_TYPE, DATETIME, INTAKE_CONDITION, NAME, SEX_UPON_INTAKE는 각각 동물의 아이디, 생물 종, 보호 시작일, 보호 시작 시 상태, 이름, 성별 및 중성화 여부를 나타냅니다. NAME TYPE NULLABLE ANIMAL_ID VARCHAR(N) FALSE ANIMAL_TYPE VARCHAR(N) FALSE DATETIME DATETIME FALSE INTAKE_CONDITION VARCHAR(N) FALSE NAME VARCHAR(N) TRUE SEX_UPON_INTAKE VARCHAR(N) FALSE ANIMAL_INS 테이블에 등록된 모든 레코드에 대해, 각 동물의 아이디와 이름, 들어온 날짜1를 조회하는 SQL문을 작성해주세요. 이때 결과는 아이디 순으로 조회해야 합니다. 예시 예를 들어, ANIMAL_INS 테이블이 다음과 같다면 ANIMAL_INS ANIMAL_ID ANIMAL_TYPE DATETIME INTAKE_CONDITION NAME SEX_UPON_INTAKE A349996 Cat 2018-01-22 14:32:00 Normal Sugar Neutered Male A350276 Cat 2017-08-13 13:50:00 Normal Jewel Spayed Female A350375 Cat 2017-03-06 15:01:00 Normal Meo Neutered Male A352555 Dog 2014-08-08 04:20:00 Normal Harley Spayed Female A352713 Cat 2017-04-13 16:29:00 Normal Gia Spayed Female SQL문을 실행하면 다음과 같이 나와야 합니다. ANIMAL_ID NAME 날짜 A349996 Sugar 2018-01-22 A350276 Jewel 2017-08-13 A350375 Meo 2017-03-06 A352555 Harley 2014-08-08 A352713 Gia 2017-04-13 본 문제는 Kaggle의 ""Austin Animal Center Shelter Intakes and Outcomes""에서 제공하는 데이터를 사용하였으며 ODbL의 적용을 받습니다. 시각(시-분-초)을 제외한 날짜(년-월-일)만 보여주세요. ↩",normal,database
162,"ANIMAL_OUTS 테이블은 동물 보호소에서 입양 보낸 동물의 정보를 담은 테이블입니다. ANIMAL_OUTS 테이블 구조는 다음과 같으며, ANIMAL_ID, ANIMAL_TYPE, DATETIME, NAME, SEX_UPON_OUTCOME는 각각 동물의 아이디, 생물 종, 입양일, 이름, 성별 및 중성화 여부를 나타냅니다. NAME TYPE NULLABLE ANIMAL_ID VARCHAR(N) FALSE ANIMAL_TYPE VARCHAR(N) FALSE DATETIME DATETIME FALSE NAME VARCHAR(N) TRUE SEX_UPON_OUTCOME VARCHAR(N) FALSE 보호소에서는 몇 시에 입양이 가장 활발하게 일어나는지 알아보려 합니다. 0시부터 23시까지, 각 시간대별로 입양이 몇 건이나 발생했는지 조회하는 SQL문을 작성해주세요. 이때 결과는 시간대 순으로 정렬해야 합니다. 예시 SQL문을 실행하면 다음과 같이 나와야 합니다. HOUR COUNT 0 0 1 0 2 0 3 0 4 0 5 0 6 0 7 3 8 1 9 1 10 2 11 13 12 10 13 14 14 9 15 7 16 10 17 12 18 16 19 2 20 0 21 0 22 0 23 0 본 문제는 Kaggle의 ""Austin Animal Center Shelter Intakes and Outcomes""에서 제공하는 데이터를 사용하였으며 ODbL의 적용을 받습니다.",hard,database
163,"ANIMAL_OUTS 테이블은 동물 보호소에서 입양 보낸 동물의 정보를 담은 테이블입니다. ANIMAL_OUTS 테이블 구조는 다음과 같으며, ANIMAL_ID, ANIMAL_TYPE, DATETIME, NAME, SEX_UPON_OUTCOME는 각각 동물의 아이디, 생물 종, 입양일, 이름, 성별 및 중성화 여부를 나타냅니다. NAME TYPE NULLABLE ANIMAL_ID VARCHAR(N) FALSE ANIMAL_TYPE VARCHAR(N) FALSE DATETIME DATETIME FALSE NAME VARCHAR(N) TRUE SEX_UPON_OUTCOME VARCHAR(N) FALSE 보호소에서는 몇 시에 입양이 가장 활발하게 일어나는지 알아보려 합니다. 09:00부터 19:59까지, 각 시간대별로 입양이 몇 건이나 발생했는지 조회하는 SQL문을 작성해주세요. 이때 결과는 시간대 순으로 정렬해야 합니다. 예시 SQL문을 실행하면 다음과 같이 나와야 합니다. HOUR COUNT 9 1 10 2 11 13 12 10 13 14 14 9 15 7 16 10 17 12 18 16 19 2 본 문제는 Kaggle의 ""Austin Animal Center Shelter Intakes and Outcomes""에서 제공하는 데이터를 사용하였으며 ODbL의 적용을 받습니다.",normal,database
164,"ANIMAL_INS 테이블은 동물 보호소에 들어온 동물의 정보를 담은 테이블입니다. ANIMAL_INS 테이블 구조는 다음과 같으며, ANIMAL_ID, ANIMAL_TYPE, DATETIME, INTAKE_CONDITION, NAME, SEX_UPON_INTAKE는 각각 동물의 아이디, 생물 종, 보호 시작일, 보호 시작 시 상태, 이름, 성별 및 중성화 여부를 나타냅니다. NAME TYPE NULLABLE ANIMAL_ID VARCHAR(N) FALSE ANIMAL_TYPE VARCHAR(N) FALSE DATETIME DATETIME FALSE INTAKE_CONDITION VARCHAR(N) FALSE NAME VARCHAR(N) TRUE SEX_UPON_INTAKE VARCHAR(N) FALSE ANIMAL_OUTS 테이블은 동물 보호소에서 입양 보낸 동물의 정보를 담은 테이블입니다. ANIMAL_OUTS 테이블 구조는 다음과 같으며, ANIMAL_ID, ANIMAL_TYPE, DATETIME, NAME, SEX_UPON_OUTCOME는 각각 동물의 아이디, 생물 종, 입양일, 이름, 성별 및 중성화 여부를 나타냅니다. ANIMAL_OUTS 테이블의 ANIMAL_ID는 ANIMAL_INS의 ANIMAL_ID의 외래 키입니다. NAME TYPE NULLABLE ANIMAL_ID VARCHAR(N) FALSE ANIMAL_TYPE VARCHAR(N) FALSE DATETIME DATETIME FALSE NAME VARCHAR(N) TRUE SEX_UPON_OUTCOME VARCHAR(N) FALSE 입양을 간 동물 중, 보호 기간이 가장 길었던 동물 두 마리의 아이디와 이름을 조회하는 SQL문을 작성해주세요. 이때 결과는 보호 기간이 긴 순으로 조회해야 합니다. 예시 예를 들어, ANIMAL_INS 테이블과 ANIMAL_OUTS 테이블이 다음과 같다면 ANIMAL_INS ANIMAL_ID ANIMAL_TYPE DATETIME INTAKE_CONDITION NAME SEX_UPON_INTAKE A354597 Cat 2014-05-02 12:16:00 Normal Ariel Spayed Female A362707 Dog 2016-01-27 12:27:00 Sick Girly Girl Spayed Female A370507 Cat 2014-10-27 14:43:00 Normal Emily Spayed Female A414513 Dog 2016-06-07 09:17:00 Normal Rocky Neutered Male ANIMAL_OUTS ANIMAL_ID ANIMAL_TYPE DATETIME NAME SEX_UPON_OUTCOME A354597 Cat 2014-06-03 12:30:00 Ariel Spayed Female A362707 Dog 2017-01-10 10:44:00 Girly Girl Spayed Female A370507 Cat 2015-08-15 09:24:00 Emily Spayed Female SQL문을 실행하면 다음과 같이 나와야 합니다. ANIMAL_ID NAME A362707 Girly Girl A370507 Emily ※ 입양을 간 동물이 2마리 이상인 경우만 입력으로 주어집니다. 본 문제는 Kaggle의 ""Austin Animal Center Shelter Intakes and Outcomes""에서 제공하는 데이터를 사용하였으며 ODbL의 적용을 받습니다.",normal,database
165,"ANIMAL_INS 테이블은 동물 보호소에 들어온 동물의 정보를 담은 테이블입니다. ANIMAL_INS 테이블 구조는 다음과 같으며, ANIMAL_ID, ANIMAL_TYPE, DATETIME, INTAKE_CONDITION, NAME, SEX_UPON_INTAKE는 각각 동물의 아이디, 생물 종, 보호 시작일, 보호 시작 시 상태, 이름, 성별 및 중성화 여부를 나타냅니다. NAME TYPE NULLABLE ANIMAL_ID VARCHAR(N) FALSE ANIMAL_TYPE VARCHAR(N) FALSE DATETIME DATETIME FALSE INTAKE_CONDITION VARCHAR(N) FALSE NAME VARCHAR(N) TRUE SEX_UPON_INTAKE VARCHAR(N) FALSE 입양 게시판에 동물 정보를 게시하려 합니다. 동물의 생물 종, 이름, 성별 및 중성화 여부를 아이디 순으로 조회하는 SQL문을 작성해주세요. 이때 프로그래밍을 모르는 사람들은 NULL이라는 기호를 모르기 때문에, 이름이 없는 동물의 이름은 ""No name""으로 표시해 주세요. 예시 예를 들어 ANIMAL_INS 테이블이 다음과 같다면 ANIMAL_ID ANIMAL_TYPE DATETIME INTAKE_CONDITION NAME SEX_UPON_INTAKE A350276 Cat 2017-08-13 13:50:00 Normal Jewel Spayed Female A350375 Cat 2017-03-06 15:01:00 Normal Meo Neutered Male A368930 Dog 2014-06-08 13:20:00 Normal NULL Spayed Female 마지막 줄의 개는 이름이 없기 때문에, 이 개의 이름은 ""No name""으로 표시합니다. 따라서 SQL문을 실행하면 다음과 같이 나와야 합니다. ANIMAL_TYPE NAME SEX_UPON_INTAKE Cat Jewel Spayed Female Cat Meo Neutered Male Dog No name Spayed Female ※ 컬럼 이름은 일치하지 않아도 됩니다. 본 문제는 Kaggle의 ""Austin Animal Center Shelter Intakes and Outcomes""에서 제공하는 데이터를 사용하였으며 ODbL의 적용을 받습니다.",normal,database
166,"ANIMAL_INS 테이블은 동물 보호소에 들어온 동물의 정보를 담은 테이블입니다. ANIMAL_INS 테이블 구조는 다음과 같으며, ANIMAL_ID, ANIMAL_TYPE, DATETIME, INTAKE_CONDITION, NAME, SEX_UPON_INTAKE는 각각 동물의 아이디, 생물 종, 보호 시작일, 보호 시작 시 상태, 이름, 성별 및 중성화 여부를 나타냅니다. NAME TYPE NULLABLE ANIMAL_ID VARCHAR(N) FALSE ANIMAL_TYPE VARCHAR(N) FALSE DATETIME DATETIME FALSE INTAKE_CONDITION VARCHAR(N) FALSE NAME VARCHAR(N) TRUE SEX_UPON_INTAKE VARCHAR(N) FALSE 보호소의 동물이 중성화되었는지 아닌지 파악하려 합니다. 중성화된 동물은 SEX_UPON_INTAKE 컬럼에 'Neutered' 또는 'Spayed'라는 단어가 들어있습니다. 동물의 아이디와 이름, 중성화 여부를 아이디 순으로 조회하는 SQL문을 작성해주세요. 이때 중성화가 되어있다면 'O', 아니라면 'X'라고 표시해주세요. 예시 예를 들어 ANIMAL_INS 테이블이 다음과 같다면 ANIMAL_ID ANIMAL_TYPE DATETIME INTAKE_CONDITION NAME SEX_UPON_INTAKE A355753 Dog 2015-09-10 13:14:00 Normal Elijah Neutered Male A373219 Cat 2014-07-29 11:43:00 Normal Ella Spayed Female A382192 Dog 2015-03-13 13:14:00 Normal Maxwell 2 Intact Male 중성화한 동물: Elijah, Ella 중성화하지 않은 동물: Maxwell 2 따라서 SQL문을 실행하면 다음과 같이 나와야 합니다. ANIMAL_ID NAME 중성화 A355753 Elijah O A373219 Ella O A382192 Maxwell 2 X ※ 컬럼 이름은 일치하지 않아도 됩니다. 본 문제는 Kaggle의 ""Austin Animal Center Shelter Intakes and Outcomes""에서 제공하는 데이터를 사용하였으며 ODbL의 적용을 받습니다.",normal,database
167,"ANIMAL_INS 테이블은 동물 보호소에 들어온 동물의 정보를 담은 테이블입니다. ANIMAL_INS 테이블 구조는 다음과 같으며, ANIMAL_ID, ANIMAL_TYPE, DATETIME, INTAKE_CONDITION, NAME, SEX_UPON_INTAKE는 각각 동물의 아이디, 생물 종, 보호 시작일, 보호 시작 시 상태, 이름, 성별 및 중성화 여부를 나타냅니다. NAME TYPE NULLABLE ANIMAL_ID VARCHAR(N) FALSE ANIMAL_TYPE VARCHAR(N) FALSE DATETIME DATETIME FALSE INTAKE_CONDITION VARCHAR(N) FALSE NAME VARCHAR(N) TRUE SEX_UPON_INTAKE VARCHAR(N) FALSE 동물 보호소에 들어온 동물의 이름은 몇 개인지 조회하는 SQL 문을 작성해주세요. 이때 이름이 NULL인 경우는 집계하지 않으며 중복되는 이름은 하나로 칩니다. 예시 예를 들어 ANIMAL_INS 테이블이 다음과 같다면 ANIMAL_ID ANIMAL_TYPE DATETIME INTAKE_CONDITION NAME SEX_UPON_INTAKE A562649 Dog 2014-03-20 18:06:00 Sick NULL Spayed Female A412626 Dog 2016-03-13 11:17:00 Normal *Sam Neutered Male A563492 Dog 2014-10-24 14:45:00 Normal *Sam Neutered Male A513956 Dog 2017-06-14 11:54:00 Normal *Sweetie Spayed Female 보호소에 들어온 동물의 이름은 NULL(없음), *Sam, *Sam, *Sweetie입니다. 이 중 NULL과 중복되는 이름을 고려하면, 보호소에 들어온 동물 이름의 수는 2입니다. 따라서 SQL문을 실행하면 다음과 같이 나와야 합니다. count 2 ※ 컬럼 이름(위 예제에서는 count)은 일치하지 않아도 됩니다. 본 문제는 Kaggle의 ""Austin Animal Center Shelter Intakes and Outcomes""에서 제공하는 데이터를 사용하였으며 ODbL의 적용을 받습니다.",normal,database
168,"ANIMAL_INS 테이블은 동물 보호소에 들어온 동물의 정보를 담은 테이블입니다. ANIMAL_INS 테이블 구조는 다음과 같으며, ANIMAL_ID, ANIMAL_TYPE, DATETIME, INTAKE_CONDITION, NAME, SEX_UPON_INTAKE는 각각 동물의 아이디, 생물 종, 보호 시작일, 보호 시작 시 상태, 이름, 성별 및 중성화 여부를 나타냅니다. NAME TYPE NULLABLE ANIMAL_ID VARCHAR(N) FALSE ANIMAL_TYPE VARCHAR(N) FALSE DATETIME DATETIME FALSE INTAKE_CONDITION VARCHAR(N) FALSE NAME VARCHAR(N) TRUE SEX_UPON_INTAKE VARCHAR(N) FALSE 동물 보호소에 동물이 몇 마리 들어왔는지 조회하는 SQL 문을 작성해주세요. 예시 예를 들어 ANIMAL_INS 테이블이 다음과 같다면 ANIMAL_ID ANIMAL_TYPE DATETIME INTAKE_CONDITION NAME SEX_UPON_INTAKE A399552 Dog 2013-10-14 15:38:00 Normal Jack Neutered Male A379998 Dog 2013-10-23 11:42:00 Normal Disciple Intact Male A370852 Dog 2013-11-03 15:04:00 Normal Katie Spayed Female A403564 Dog 2013-11-18 17:03:00 Normal Anna Spayed Female 동물 보호소에 들어온 동물은 4마리입니다. 따라서 SQL문을 실행하면 다음과 같이 나와야 합니다. count 4 ※ 컬럼 이름(위 예제에서는 count)은 일치하지 않아도 됩니다. 본 문제는 Kaggle의 ""Austin Animal Center Shelter Intakes and Outcomes""에서 제공하는 데이터를 사용하였으며 ODbL의 적용을 받습니다.",normal,database
169,"ANIMAL_INS 테이블은 동물 보호소에 들어온 동물의 정보를 담은 테이블입니다. ANIMAL_INS 테이블 구조는 다음과 같으며, ANIMAL_ID, ANIMAL_TYPE, DATETIME, INTAKE_CONDITION, NAME, SEX_UPON_INTAKE는 각각 동물의 아이디, 생물 종, 보호 시작일, 보호 시작 시 상태, 이름, 성별 및 중성화 여부를 나타냅니다. NAME TYPE NULLABLE ANIMAL_ID VARCHAR(N) FALSE ANIMAL_TYPE VARCHAR(N) FALSE DATETIME DATETIME FALSE INTAKE_CONDITION VARCHAR(N) FALSE NAME VARCHAR(N) TRUE SEX_UPON_INTAKE VARCHAR(N) FALSE 보호소에 돌아가신 할머니가 기르던 개를 찾는 사람이 찾아왔습니다. 이 사람이 말하길 할머니가 기르던 개는 이름에 'el'이 들어간다고 합니다. 동물 보호소에 들어온 동물 이름 중, 이름에 ""EL""이 들어가는 개의 아이디와 이름을 조회하는 SQL문을 작성해주세요. 이때 결과는 이름 순으로 조회해주세요. 단, 이름의 대소문자는 구분하지 않습니다. 예시 예를 들어 ANIMAL_INS 테이블이 다음과 같다면 ANIMAL_ID ANIMAL_TYPE DATETIME INTAKE_CONDITION NAME SEX_UPON_INTAKE A355753 Dog 2015-09-10 13:14:00 Normal Elijah Neutered Male A352872 Dog 2015-07-09 17:51:00 Aged Peanutbutter Neutered Male A353259 Dog 2016-05-08 12:57:00 Injured Bj Neutered Male A373219 Cat 2014-07-29 11:43:00 Normal Ella Spayed Female A382192 Dog 2015-03-13 13:14:00 Normal Maxwell 2 Intact Male 이름에 'el'이 들어가는 동물은 Elijah, Ella, Maxwell 2입니다. 이 중, 개는 Elijah, Maxwell 2입니다. 따라서 SQL문을 실행하면 다음과 같이 나와야 합니다. ANIMAL_ID NAME A355753 Elijah A382192 Maxwell 2 본 문제는 Kaggle의 ""Austin Animal Center Shelter Intakes and Outcomes""에서 제공하는 데이터를 사용하였으며 ODbL의 적용을 받습니다.",normal,database
170,"ANIMAL_INS 테이블은 동물 보호소에 들어온 동물의 정보를 담은 테이블입니다. ANIMAL_INS 테이블 구조는 다음과 같으며, ANIMAL_ID, ANIMAL_TYPE, DATETIME, INTAKE_CONDITION, NAME, SEX_UPON_INTAKE는 각각 동물의 아이디, 생물 종, 보호 시작일, 보호 시작 시 상태, 이름, 성별 및 중성화 여부를 나타냅니다. NAME TYPE NULLABLE ANIMAL_ID VARCHAR(N) FALSE ANIMAL_TYPE VARCHAR(N) FALSE DATETIME DATETIME FALSE INTAKE_CONDITION VARCHAR(N) FALSE NAME VARCHAR(N) TRUE SEX_UPON_INTAKE VARCHAR(N) FALSE 동물 보호소에 들어온 동물 중 이름이 Lucy, Ella, Pickle, Rogan, Sabrina, Mitty인 동물의 아이디와 이름, 성별 및 중성화 여부를 조회하는 SQL 문을 작성해주세요. 예시 이때 결과는 아이디 순으로 조회해주세요. 예를 들어 ANIMAL_INS 테이블이 다음과 같다면 ANIMAL_ID ANIMAL_TYPE DATETIME INTAKE_CONDITION NAME SEX_UPON_INTAKE A373219 Cat 2014-07-29 11:43:00 Normal Ella Spayed Female A377750 Dog 2017-10-25 17:17:00 Normal Lucy Spayed Female A353259 Dog 2016-05-08 12:57:00 Injured Bj Neutered Male A354540 Cat 2014-12-11 11:48:00 Normal Tux Neutered Male A354597 Cat 2014-05-02 12:16:00 Normal Ariel Spayed Female SQL문을 실행하면 다음과 같이 나와야 합니다. ANIMAL_ID NAME SEX_UPON_INTAKE A373219 Ella Spayed Female A377750 Lucy Spayed Female 본 문제는 Kaggle의 ""Austin Animal Center Shelter Intakes and Outcomes""에서 제공하는 데이터를 사용하였으며 ODbL의 적용을 받습니다.",normal,database
171,"ANIMAL_INS 테이블은 동물 보호소에 들어온 동물의 정보를 담은 테이블입니다. ANIMAL_INS 테이블 구조는 다음과 같으며, ANIMAL_ID, ANIMAL_TYPE, DATETIME, INTAKE_CONDITION, NAME, SEX_UPON_INTAKE는 각각 동물의 아이디, 생물 종, 보호 시작일, 보호 시작 시 상태, 이름, 성별 및 중성화 여부를 나타냅니다. NAME TYPE NULLABLE ANIMAL_ID VARCHAR(N) FALSE ANIMAL_TYPE VARCHAR(N) FALSE DATETIME DATETIME FALSE INTAKE_CONDITION VARCHAR(N) FALSE NAME VARCHAR(N) TRUE SEX_UPON_INTAKE VARCHAR(N) FALSE ANIMAL_OUTS 테이블은 동물 보호소에서 입양 보낸 동물의 정보를 담은 테이블입니다. ANIMAL_OUTS 테이블 구조는 다음과 같으며, ANIMAL_ID, ANIMAL_TYPE, DATETIME, NAME, SEX_UPON_OUTCOME는 각각 동물의 아이디, 생물 종, 입양일, 이름, 성별 및 중성화 여부를 나타냅니다. ANIMAL_OUTS 테이블의 ANIMAL_ID는 ANIMAL_INS의 ANIMAL_ID의 외래 키입니다. NAME TYPE NULLABLE ANIMAL_ID VARCHAR(N) FALSE ANIMAL_TYPE VARCHAR(N) FALSE DATETIME DATETIME FALSE NAME VARCHAR(N) TRUE SEX_UPON_OUTCOME VARCHAR(N) FALSE 보호소에서 중성화 수술을 거친 동물 정보를 알아보려 합니다. 보호소에 들어올 당시에는 중성화1되지 않았지만, 보호소를 나갈 당시에는 중성화된 동물의 아이디와 생물 종, 이름을 조회하는 아이디 순으로 조회하는 SQL 문을 작성해주세요. 예시 예를 들어, ANIMAL_INS 테이블과 ANIMAL_OUTS 테이블이 다음과 같다면 ANIMAL_INS ANIMAL_ID ANIMAL_TYPE DATETIME INTAKE_CONDITION NAME SEX_UPON_INTAKE A367438 Dog 2015-09-10 16:01:00 Normal Cookie Spayed Female A382192 Dog 2015-03-13 13:14:00 Normal Maxwell 2 Intact Male A405494 Dog 2014-05-16 14:17:00 Normal Kaila Spayed Female A410330 Dog 2016-09-11 14:09:00 Sick Chewy Intact Female ANIMAL_OUTS ANIMAL_ID ANIMAL_TYPE DATETIME NAME SEX_UPON_OUTCOME A367438 Dog 2015-09-12 13:30:00 Cookie Spayed Female A382192 Dog 2015-03-16 13:46:00 Maxwell 2 Neutered Male A405494 Dog 2014-05-20 11:44:00 Kaila Spayed Female A410330 Dog 2016-09-13 13:46:00 Chewy Spayed Female Cookie는 보호소에 들어올 당시에 이미 중성화되어있었습니다. Maxwell 2는 보호소에 들어온 후 중성화되었습니다. Kaila는 보호소에 들어올 당시에 이미 중성화되어있었습니다. Chewy는 보호소에 들어온 후 중성화되었습니다. 따라서 SQL문을 실행하면 다음과 같이 나와야 합니다. ANIMAL_ID ANIMAL_TYPE NAME A382192 Dog Maxwell 2 A410330 Dog Chewy 본 문제는 Kaggle의 ""Austin Animal Center Shelter Intakes and Outcomes""에서 제공하는 데이터를 사용하였으며 ODbL의 적용을 받습니다. 중성화를 거치지 않은 동물은 성별 및 중성화 여부에 Intact, 중성화를 거친 동물은 Spayed 또는 Neutered라고 표시되어있습니다. ↩",hard,database
172,"ANIMAL_INS 테이블은 동물 보호소에 들어온 동물의 정보를 담은 테이블입니다. ANIMAL_INS 테이블 구조는 다음과 같으며, ANIMAL_ID, ANIMAL_TYPE, DATETIME, INTAKE_CONDITION, NAME, SEX_UPON_INTAKE는 각각 동물의 아이디, 생물 종, 보호 시작일, 보호 시작 시 상태, 이름, 성별 및 중성화 여부를 나타냅니다. NAME TYPE NULLABLE ANIMAL_ID VARCHAR(N) FALSE ANIMAL_TYPE VARCHAR(N) FALSE DATETIME DATETIME FALSE INTAKE_CONDITION VARCHAR(N) FALSE NAME VARCHAR(N) TRUE SEX_UPON_INTAKE VARCHAR(N) FALSE ANIMAL_OUTS 테이블은 동물 보호소에서 입양 보낸 동물의 정보를 담은 테이블입니다. ANIMAL_OUTS 테이블 구조는 다음과 같으며, ANIMAL_ID, ANIMAL_TYPE, DATETIME, NAME, SEX_UPON_OUTCOME는 각각 동물의 아이디, 생물 종, 입양일, 이름, 성별 및 중성화 여부를 나타냅니다. ANIMAL_OUTS 테이블의 ANIMAL_ID는 ANIMAL_INS의 ANIMAL_ID의 외래 키입니다. NAME TYPE NULLABLE ANIMAL_ID VARCHAR(N) FALSE ANIMAL_TYPE VARCHAR(N) FALSE DATETIME DATETIME FALSE NAME VARCHAR(N) TRUE SEX_UPON_OUTCOME VARCHAR(N) FALSE 아직 입양을 못 간 동물 중, 가장 오래 보호소에 있었던 동물 3마리의 이름과 보호 시작일을 조회하는 SQL문을 작성해주세요. 이때 결과는 보호 시작일 순으로 조회해야 합니다. 예시 예를 들어, ANIMAL_INS 테이블과 ANIMAL_OUTS 테이블이 다음과 같다면 ANIMAL_INS ANIMAL_ID ANIMAL_TYPE DATETIME INTAKE_CONDITION NAME SEX_UPON_INTAKE A354597 Cat 2014-05-02 12:16:00 Normal Ariel Spayed Female A373687 Dog 2014-03-20 12:31:00 Normal Rosie Spayed Female A412697 Dog 2016-01-03 16:25:00 Normal Jackie Neutered Male A413789 Dog 2016-04-19 13:28:00 Normal Benji Spayed Female A414198 Dog 2015-01-29 15:01:00 Normal Shelly Spayed Female A368930 Dog 2014-06-08 13:20:00 Normal Spayed Female ANIMAL_OUTS ANIMAL_ID ANIMAL_TYPE DATETIME NAME SEX_UPON_OUTCOME A354597 Cat 2014-05-02 12:16:00 Ariel Spayed Female A373687 Dog 2014-03-20 12:31:00 Rosie Spayed Female A368930 Dog 2014-06-13 15:52:00 Spayed Female SQL문을 실행하면 다음과 같이 나와야 합니다. NAME DATETIME Shelly 2015-01-29 15:01:00 Jackie 2016-01-03 16:25:00 Benji 2016-04-19 13:28:00 ※ 입양을 가지 못한 동물이 3마리 이상인 경우만 입력으로 주어집니다. 본 문제는 Kaggle의 ""Austin Animal Center Shelter Intakes and Outcomes""에서 제공하는 데이터를 사용하였으며 ODbL의 적용을 받습니다.",normal,database
173,"ANIMAL_INS 테이블은 동물 보호소에 들어온 동물의 정보를 담은 테이블입니다. ANIMAL_INS 테이블 구조는 다음과 같으며, ANIMAL_ID, ANIMAL_TYPE, DATETIME, INTAKE_CONDITION, NAME, SEX_UPON_INTAKE는 각각 동물의 아이디, 생물 종, 보호 시작일, 보호 시작 시 상태, 이름, 성별 및 중성화 여부를 나타냅니다. NAME TYPE NULLABLE ANIMAL_ID VARCHAR(N) FALSE ANIMAL_TYPE VARCHAR(N) FALSE DATETIME DATETIME FALSE INTAKE_CONDITION VARCHAR(N) FALSE NAME VARCHAR(N) TRUE SEX_UPON_INTAKE VARCHAR(N) FALSE ANIMAL_OUTS 테이블은 동물 보호소에서 입양 보낸 동물의 정보를 담은 테이블입니다. ANIMAL_OUTS 테이블 구조는 다음과 같으며, ANIMAL_ID, ANIMAL_TYPE, DATETIME, NAME, SEX_UPON_OUTCOME는 각각 동물의 아이디, 생물 종, 입양일, 이름, 성별 및 중성화 여부를 나타냅니다. ANIMAL_OUTS 테이블의 ANIMAL_ID는 ANIMAL_INS의 ANIMAL_ID의 외래 키입니다. NAME TYPE NULLABLE ANIMAL_ID VARCHAR(N) FALSE ANIMAL_TYPE VARCHAR(N) FALSE DATETIME DATETIME FALSE NAME VARCHAR(N) TRUE SEX_UPON_OUTCOME VARCHAR(N) FALSE 관리자의 실수로 일부 동물의 입양일이 잘못 입력되었습니다. 보호 시작일보다 입양일이 더 빠른 동물의 아이디와 이름을 조회하는 SQL문을 작성해주세요. 이때 결과는 보호 시작일이 빠른 순으로 조회해야합니다. 예시 예를 들어, ANIMAL_INS 테이블과 ANIMAL_OUTS 테이블이 다음과 같다면 ANIMAL_INS ANIMAL_ID ANIMAL_TYPE DATETIME INTAKE_CONDITION NAME SEX_UPON_INTAKE A350276 Cat 2017-08-13 13:50:00 Normal Jewel Spayed Female A381217 Dog 2017-07-08 09:41:00 Sick Cherokee Neutered Male ANIMAL_OUTS ANIMAL_ID ANIMAL_TYPE DATETIME NAME SEX_UPON_OUTCOME A350276 Cat 2018-01-28 17:51:00 Jewel Spayed Female A381217 Dog 2017-06-09 18:51:00 Cherokee Neutered Male SQL문을 실행하면 다음과 같이 나와야 합니다. ANIMAL_ID NAME A381217 Cherokee 본 문제는 Kaggle의 ""Austin Animal Center Shelter Intakes and Outcomes""에서 제공하는 데이터를 사용하였으며 ODbL의 적용을 받습니다.",normal,database
174,"ANIMAL_INS 테이블은 동물 보호소에 들어온 동물의 정보를 담은 테이블입니다. ANIMAL_INS 테이블 구조는 다음과 같으며, ANIMAL_ID, ANIMAL_TYPE, DATETIME, INTAKE_CONDITION, NAME, SEX_UPON_INTAKE는 각각 동물의 아이디, 생물 종, 보호 시작일, 보호 시작 시 상태, 이름, 성별 및 중성화 여부를 나타냅니다. NAME TYPE NULLABLE ANIMAL_ID VARCHAR(N) FALSE ANIMAL_TYPE VARCHAR(N) FALSE DATETIME DATETIME FALSE INTAKE_CONDITION VARCHAR(N) FALSE NAME VARCHAR(N) TRUE SEX_UPON_INTAKE VARCHAR(N) FALSE ANIMAL_OUTS 테이블은 동물 보호소에서 입양 보낸 동물의 정보를 담은 테이블입니다. ANIMAL_OUTS 테이블 구조는 다음과 같으며, ANIMAL_ID, ANIMAL_TYPE, DATETIME, NAME, SEX_UPON_OUTCOME는 각각 동물의 아이디, 생물 종, 입양일, 이름, 성별 및 중성화 여부를 나타냅니다. ANIMAL_OUTS 테이블의 ANIMAL_ID는 ANIMAL_INS의 ANIMAL_ID의 외래 키입니다. NAME TYPE NULLABLE ANIMAL_ID VARCHAR(N) FALSE ANIMAL_TYPE VARCHAR(N) FALSE DATETIME DATETIME FALSE NAME VARCHAR(N) TRUE SEX_UPON_OUTCOME VARCHAR(N) FALSE 천재지변으로 인해 일부 데이터가 유실되었습니다. 입양을 간 기록은 있는데, 보호소에 들어온 기록이 없는 동물의 ID와 이름을 ID 순으로 조회하는 SQL문을 작성해주세요. 예시 예를 들어, ANIMAL_INS 테이블과 ANIMAL_OUTS 테이블이 다음과 같다면 ANIMAL_INS ANIMAL_ID ANIMAL_TYPE DATETIME INTAKE_CONDITION NAME SEX_UPON_INTAKE A352713 Cat 2017-04-13 16:29:00 Normal Gia Spayed Female A350375 Cat 2017-03-06 15:01:00 Normal Meo Neutered Male ANIMAL_OUTS ANIMAL_ID ANIMAL_TYPE DATETIME NAME SEX_UPON_OUTCOME A349733 Dog 2017-09-27 19:09:00 Allie Spayed Female A352713 Cat 2017-04-25 12:25:00 Gia Spayed Female A349990 Cat 2018-02-02 14:18:00 Spice Spayed Female ANIMAL_OUTS 테이블에서 Allie의 ID는 ANIMAL_INS에 없으므로, Allie의 데이터는 유실되었습니다. Gia의 ID는 ANIMAL_INS에 있으므로, Gia의 데이터는 유실되지 않았습니다. Spice의 ID는 ANIMAL_INS에 없으므로, Spice의 데이터는 유실되었습니다. 따라서 SQL문을 실행하면 다음과 같이 나와야 합니다. ANIMAL_ID NAME A349733 Allie A349990 Spice 본 문제는 Kaggle의 ""Austin Animal Center Shelter Intakes and Outcomes""에서 제공하는 데이터를 사용하였으며 ODbL의 적용을 받습니다.",normal,database
175,"ANIMAL_INS 테이블은 동물 보호소에 들어온 동물의 정보를 담은 테이블입니다. ANIMAL_INS 테이블 구조는 다음과 같으며, ANIMAL_ID, ANIMAL_TYPE, DATETIME, INTAKE_CONDITION, NAME, SEX_UPON_INTAKE는 각각 동물의 아이디, 생물 종, 보호 시작일, 보호 시작 시 상태, 이름, 성별 및 중성화 여부를 나타냅니다. NAME TYPE NULLABLE ANIMAL_ID VARCHAR(N) FALSE ANIMAL_TYPE VARCHAR(N) FALSE DATETIME DATETIME FALSE INTAKE_CONDITION VARCHAR(N) FALSE NAME VARCHAR(N) TRUE SEX_UPON_INTAKE VARCHAR(N) FALSE 동물 보호소에 들어온 동물 이름 중 두 번 이상 쓰인 이름과 해당 이름이 쓰인 횟수를 조회하는 SQL문을 작성해주세요. 이때 결과는 이름이 없는 동물은 집계에서 제외하며, 결과는 이름 순으로 조회해주세요. 예시 예를 들어 ANIMAL_INS 테이블이 다음과 같다면 ANIMAL_ID ANIMAL_TYPE DATETIME INTAKE_CONDITION NAME SEX_UPON_INTAKE A396810 Dog 2016-08-22 16:13:00 Injured Raven Spayed Female A377750 Dog 2017-10-25 17:17:00 Normal Lucy Spayed Female A355688 Dog 2014-01-26 13:48:00 Normal Shadow Neutered Male A399421 Dog 2015-08-25 14:08:00 Normal Lucy Spayed Female A400680 Dog 2017-06-17 13:29:00 Normal Lucy Spayed Female A410668 Cat 2015-11-19 13:41:00 Normal Raven Spayed Female Raven 이름은 2번 쓰였습니다. Lucy 이름은 3번 쓰였습니다 Shadow 이름은 1번 쓰였습니다. 따라서 SQL문을 실행하면 다음과 같이 나와야 합니다. NAME COUNT Lucy 3 Raven 2 본 문제는 Kaggle의 ""Austin Animal Center Shelter Intakes and Outcomes""에서 제공하는 데이터를 사용하였으며 ODbL의 적용을 받습니다.",normal,database
176,"ANIMAL_INS 테이블은 동물 보호소에 들어온 동물의 정보를 담은 테이블입니다. ANIMAL_INS 테이블 구조는 다음과 같으며, ANIMAL_ID, ANIMAL_TYPE, DATETIME, INTAKE_CONDITION, NAME, SEX_UPON_INTAKE는 각각 동물의 아이디, 생물 종, 보호 시작일, 보호 시작 시 상태, 이름, 성별 및 중성화 여부를 나타냅니다. NAME TYPE NULLABLE ANIMAL_ID VARCHAR(N) FALSE ANIMAL_TYPE VARCHAR(N) FALSE DATETIME DATETIME FALSE INTAKE_CONDITION VARCHAR(N) FALSE NAME VARCHAR(N) TRUE SEX_UPON_INTAKE VARCHAR(N) FALSE 동물 보호소에 들어온 동물 중 고양이와 개가 각각 몇 마리인지 조회하는 SQL문을 작성해주세요. 이때 고양이를 개보다 먼저 조회해주세요. 예시 예를 들어 ANIMAL_INS 테이블이 다음과 같다면 ANIMAL_ID ANIMAL_TYPE DATETIME INTAKE_CONDITION NAME SEX_UPON_INTAKE A373219 Cat 2014-07-29 11:43:00 Normal Ella Spayed Female A377750 Dog 2017-10-25 17:17:00 Normal Lucy Spayed Female A354540 Cat 2014-12-11 11:48:00 Normal Tux Neutered Male 고양이는 2마리, 개는 1마리 들어왔습니다. 따라서 SQL문을 실행하면 다음과 같이 나와야 합니다. ANIMAL_TYPE count Cat 2 Dog 1 본 문제는 Kaggle의 ""Austin Animal Center Shelter Intakes and Outcomes""에서 제공하는 데이터를 사용하였으며 ODbL의 적용을 받습니다.",normal,database
177,"ANIMAL_INS 테이블은 동물 보호소에 들어온 동물의 정보를 담은 테이블입니다. ANIMAL_INS 테이블 구조는 다음과 같으며, ANIMAL_ID, ANIMAL_TYPE, DATETIME, INTAKE_CONDITION, NAME, SEX_UPON_INTAKE는 각각 동물의 아이디, 생물 종, 보호 시작일, 보호 시작 시 상태, 이름, 성별 및 중성화 여부를 나타냅니다. NAME TYPE NULLABLE ANIMAL_ID VARCHAR(N) FALSE ANIMAL_TYPE VARCHAR(N) FALSE DATETIME DATETIME FALSE INTAKE_CONDITION VARCHAR(N) FALSE NAME VARCHAR(N) TRUE SEX_UPON_INTAKE VARCHAR(N) FALSE 동물 보호소에 가장 먼저 들어온 동물은 언제 들어왔는지 조회하는 SQL 문을 작성해주세요. 예시 예를 들어 ANIMAL_INS 테이블이 다음과 같다면 ANIMAL_ID ANIMAL_TYPE DATETIME INTAKE_CONDITION NAME SEX_UPON_INTAKE A399552 Dog 2013-10-14 15:38:00 Normal Jack Neutered Male A379998 Dog 2013-10-23 11:42:00 Normal Disciple Intact Male A370852 Dog 2013-11-03 15:04:00 Normal Katie Spayed Female A403564 Dog 2013-11-18 17:03:00 Normal Anna Spayed Female 가장 먼저 들어온 동물은 Jack이고, Jack은 2013-10-14 15:38:00에 들어왔습니다. 따라서 SQL문을 실행하면 다음과 같이 나와야 합니다. 시간 2013-10-14 15:38:00 ※ 컬럼 이름(위 예제에서는 ""시간"")은 일치하지 않아도 됩니다. 본 문제는 Kaggle의 ""Austin Animal Center Shelter Intakes and Outcomes""에서 제공하는 데이터를 사용하였으며 ODbL의 적용을 받습니다.",normal,database
178,"과자를 바구니 단위로 파는 가게가 있습니다. 이 가게는 1번부터 N번까지 차례로 번호가 붙은 바구니 N개가 일렬로 나열해 놨습니다. 철수는 두 아들에게 줄 과자를 사려합니다. 첫째 아들에게는 l번 바구니부터 m번 바구니까지, 둘째 아들에게는 m+1번 바구니부터 r번 바구니까지를 주려합니다. 단, 두 아들이 받을 과자 수는 같아야 합니다(1 <= l <= m, m+1 <= r <= N). 즉, A[i] 를 i번 바구니에 들어있는 과자 수라고 했을 때, A[l]+..+A[m] = A[m+1]+..+A[r] 를 만족해야 합니다. 각 바구니 안에 들은 과자 수가 차례로 들은 배열 cookie가 주어질 때, 조건에 맞게 과자를 살 경우 한 명의 아들에게 줄 수 있는 가장 많은 과자 수를 return 하는 solution 함수를 완성해주세요. (단, 조건에 맞게 과자를 구매할 수 없다면 0을 return 합니다) 제한사항 cookie의 길이는 1 이상 2,000 이하입니다. cookie의 각각의 원소는 1 이상 500 이하인 자연수입니다. 입출력 예 cookie result [1,1,2,3] 3 [1,2,4,5] 0 입출력 예 설명",hard,Array
179,"게임 캐릭터를 4가지 명령어를 통해 움직이려 합니다. 명령어는 다음과 같습니다. U: 위쪽으로 한 칸 가기 D: 아래쪽으로 한 칸 가기 R: 오른쪽으로 한 칸 가기 L: 왼쪽으로 한 칸 가기 캐릭터는 좌표평면의 (0, 0) 위치에서 시작합니다. 좌표평면의 경계는 왼쪽 위(-5, 5), 왼쪽 아래(-5, -5), 오른쪽 위(5, 5), 오른쪽 아래(5, -5)로 이루어져 있습니다. 예를 들어, ""ULURRDLLU""로 명령했다면 1번 명령어부터 7번 명령어까지 다음과 같이 움직입니다. 8번 명령어부터 9번 명령어까지 다음과 같이 움직입니다. 이때, 우리는 게임 캐릭터가 지나간 길 중 캐릭터가 처음 걸어본 길의 길이를 구하려고 합니다. 예를 들어 위의 예시에서 게임 캐릭터가 움직인 길이는 9이지만, 캐릭터가 처음 걸어본 길의 길이는 7이 됩니다. (8, 9번 명령어에서 움직인 길은 2, 3번 명령어에서 이미 거쳐 간 길입니다) 단, 좌표평면의 경계를 넘어가는 명령어는 무시합니다. 예를 들어, ""LULLLLLLU""로 명령했다면 1번 명령어부터 6번 명령어대로 움직인 후, 7, 8번 명령어는 무시합니다. 다시 9번 명령어대로 움직입니다. 이때 캐릭터가 처음 걸어본 길의 길이는 7이 됩니다. 명령어가 매개변수 dirs로 주어질 때, 게임 캐릭터가 처음 걸어본 길의 길이를 구하여 return 하는 solution 함수를 완성해 주세요. 제한사항 dirs는 string형으로 주어지며, 'U', 'D', 'R', 'L' 이외에 문자는 주어지지 않습니다. dirs의 길이는 500 이하의 자연수입니다. 입출력 예 dirs answer ""ULURRDLLU"" 7 ""LULLLLLLU"" 7 입출력 예 설명",normal,String
180,"선행 스킬이란 어떤 스킬을 배우기 전에 먼저 배워야 하는 스킬을 뜻합니다. 예를 들어 선행 스킬 순서가 스파크 → 라이트닝 볼트 → 썬더일때, 썬더를 배우려면 먼저 라이트닝 볼트를 배워야 하고, 라이트닝 볼트를 배우려면 먼저 스파크를 배워야 합니다. 위 순서에 없는 다른 스킬(힐링 등)은 순서에 상관없이 배울 수 있습니다. 따라서 스파크 → 힐링 → 라이트닝 볼트 → 썬더와 같은 스킬트리는 가능하지만, 썬더 → 스파크나 라이트닝 볼트 → 스파크 → 힐링 → 썬더와 같은 스킬트리는 불가능합니다. 선행 스킬 순서 skill과 유저들이 만든 스킬트리1를 담은 배열 skill_trees가 매개변수로 주어질 때, 가능한 스킬트리 개수를 return 하는 solution 함수를 작성해주세요. 제한 조건 스킬은 알파벳 대문자로 표기하며, 모든 문자열은 알파벳 대문자로만 이루어져 있습니다. 스킬 순서와 스킬트리는 문자열로 표기합니다. 예를 들어, C → B → D 라면 ""CBD""로 표기합니다 선행 스킬 순서 skill의 길이는 1 이상 26 이하이며, 스킬은 중복해 주어지지 않습니다. skill_trees는 길이 1 이상 20 이하인 배열입니다. skill_trees의 원소는 스킬을 나타내는 문자열입니다. skill_trees의 원소는 길이가 2 이상 26 이하인 문자열이며, 스킬이 중복해 주어지지 않습니다. 입출력 예 skill skill_trees return ""CBD"" [""BACDE"", ""CBADF"", ""AECB"", ""BDA""] 2 입출력 예 설명 ""BACDE"": B 스킬을 배우기 전에 C 스킬을 먼저 배워야 합니다. 불가능한 스킬트립니다. ""CBADF"": 가능한 스킬트리입니다. ""AECB"": 가능한 스킬트리입니다. ""BDA"": B 스킬을 배우기 전에 C 스킬을 먼저 배워야 합니다. 불가능한 스킬트리입니다. 스킬 트리: 유저가 스킬을 배울 순서 ↩",normal,Array
181,"n명의 권투선수가 권투 대회에 참여했고 각각 1번부터 n번까지 번호를 받았습니다. 권투 경기는 1대1 방식으로 진행이 되고, 만약 A 선수가 B 선수보다 실력이 좋다면 A 선수는 B 선수를 항상 이깁니다. 심판은 주어진 경기 결과를 가지고 선수들의 순위를 매기려 합니다. 하지만 몇몇 경기 결과를 분실하여 정확하게 순위를 매길 수 없습니다. 선수의 수 n, 경기 결과를 담은 2차원 배열 results가 매개변수로 주어질 때 정확하게 순위를 매길 수 있는 선수의 수를 return 하도록 solution 함수를 작성해주세요. 제한사항 선수의 수는 1명 이상 100명 이하입니다. 경기 결과는 1개 이상 4,500개 이하입니다. results 배열 각 행 [A, B]는 A 선수가 B 선수를 이겼다는 의미입니다. 모든 경기 결과에는 모순이 없습니다. 입출력 예 n results return 5 [[4, 3], [4, 2], [3, 2], [1, 2], [2, 5]] 2",normal,Array
182,"원점(0,0)에서 시작해서 아래처럼 숫자가 적힌 방향으로 이동하며 선을 긋습니다. ex) 1일때는 오른쪽 위로 이동 그림을 그릴 때, 사방이 막히면 방하나로 샙니다. 이동하는 방향이 담긴 배열 arrows가 매개변수로 주어질 때, 방의 갯수를 return 하도록 solution 함수를 작성하세요. 제한사항 배열 arrows의 크기는 1 이상 100,000 이하 입니다. arrows의 원소는 0 이상 7 이하 입니다. 방은 다른 방으로 둘러 싸여질 수 있습니다. 입출력 예 arrows return [6, 6, 6, 4, 4, 4, 2, 2, 2, 0, 0, 0, 1, 6, 5, 5, 3, 6, 0] 3",hard,Array
183,"n개의 노드가 있는 그래프가 있습니다. 각 노드는 1부터 n까지 번호가 적혀있습니다. 1번 노드에서 가장 멀리 떨어진 노드의 갯수를 구하려고 합니다. 가장 멀리 떨어진 노드란 최단경로로 이동했을 때 간선의 개수가 가장 많은 노드들을 의미합니다. 노드의 개수 n, 간선에 대한 정보가 담긴 2차원 배열 vertex가 매개변수로 주어질 때, 1번 노드로부터 가장 멀리 떨어진 노드가 몇 개인지를 return 하도록 solution 함수를 작성해주세요. 제한사항 노드의 개수 n은 2 이상 20,000 이하입니다. 간선은 양방향이며 총 1개 이상 50,000개 이하의 간선이 있습니다. vertex 배열 각 행 [a, b]는 a번 노드와 b번 노드 사이에 간선이 있다는 의미입니다. 입출력 예 n vertex return 6 [[3, 6], [4, 3], [3, 2], [1, 3], [1, 2], [2, 4], [5, 2]] 3",normal,Array
184,"n명이 입국심사를 위해 줄을 서서 기다리고 있습니다. 각 입국심사대에 있는 심사관마다 심사하는데 걸리는 시간은 다릅니다. 처음에 모든 심사대는 비어있습니다. 한 심사대에서는 동시에 한 명만 심사를 할 수 있습니다. 가장 앞에 서 있는 사람은 비어 있는 심사대로 가서 심사를 받을 수 있습니다. 하지만 더 빨리 끝나는 심사대가 있으면 기다렸다가 그곳으로 가서 심사를 받을 수도 있습니다. 모든 사람이 심사를 받는데 걸리는 시간을 최소로 하고 싶습니다. 입국심사를 기다리는 사람 수 n, 각 심사관이 한 명을 심사하는데 걸리는 시간이 담긴 배열 times가 매개변수로 주어질 때, 모든 사람이 심사를 받는데 걸리는 시간의 최솟값을 return 하도록 solution 함수를 작성해주세요. 제한사항 입국심사를 기다리는 사람은 1명 이상 1,000,000,000명 이하입니다. 각 심사관이 한 명을 심사하는데 걸리는 시간은 1분 이상 1,000,000,000분 이하입니다. 심사관은 1명 이상 100,000명 이하입니다. 입출력 예 n times return 6 [7, 10] 28 입출력 예 설명 가장 첫 두 사람은 바로 심사를 받으러 갑니다. 7분이 되었을 때, 첫 번째 심사대가 비고 3번째 사람이 심사를 받습니다. 10분이 되었을 때, 두 번째 심사대가 비고 4번째 사람이 심사를 받습니다. 14분이 되었을 때, 첫 번째 심사대가 비고 5번째 사람이 심사를 받습니다. 20분이 되었을 때, 두 번째 심사대가 비지만 6번째 사람이 그곳에서 심사를 받지 않고 1분을 더 기다린 후에 첫 번째 심사대에서 심사를 받으면 28분에 모든 사람의 심사가 끝납니다. 문제가 잘 안풀린다면😢 힌트가 필요한가요? [코딩테스트 연습 힌트 모음집]으로 오세요! → 클릭",normal,Array
185,"출발지점부터 distance만큼 떨어진 곳에 도착지점이 있습니다. 그리고 그사이에는 바위들이 놓여있습니다. 바위 중 몇 개를 제거하려고 합니다. 예를 들어, 도착지점이 25만큼 떨어져 있고, 바위가 [2, 14, 11, 21, 17] 지점에 놓여있을 때 바위 2개를 제거하면 출발지점, 도착지점, 바위 간의 거리가 아래와 같습니다. 제거한 바위의 위치 각 바위 사이의 거리 거리의 최솟값 [21, 17] [2, 9, 3, 11] 2 [2, 21] [11, 3, 3, 8] 3 [2, 11] [14, 3, 4, 4] 3 [11, 21] [2, 12, 3, 8] 2 [2, 14] [11, 6, 4, 4] 4 위에서 구한 거리의 최솟값 중에 가장 큰 값은 4입니다. 출발지점부터 도착지점까지의 거리 distance, 바위들이 있는 위치를 담은 배열 rocks, 제거할 바위의 수 n이 매개변수로 주어질 때, 바위를 n개 제거한 뒤 각 지점 사이의 거리의 최솟값 중에 가장 큰 값을 return 하도록 solution 함수를 작성해주세요. 제한사항 도착지점까지의 거리 distance는 1 이상 1,000,000,000 이하입니다. 바위는 1개 이상 50,000개 이하가 있습니다. n 은 1 이상 바위의 개수 이하입니다. 입출력 예 distance rocks n return 25 [2, 14, 11, 21, 17] 2 4 입출력 예 설명 문제에 나온 예와 같습니다. 출처",hard,Array
186,"n개의 음이 아닌 정수들이 있습니다. 이 정수들을 순서를 바꾸지 않고 적절히 더하거나 빼서 타겟 넘버를 만들려고 합니다. 예를 들어 [1, 1, 1, 1, 1]로 숫자 3을 만들려면 다음 다섯 방법을 쓸 수 있습니다. -1+1+1+1+1 = 3 +1-1+1+1+1 = 3 +1+1-1+1+1 = 3 +1+1+1-1+1 = 3 +1+1+1+1-1 = 3 사용할 수 있는 숫자가 담긴 배열 numbers, 타겟 넘버 target이 매개변수로 주어질 때 숫자를 적절히 더하고 빼서 타겟 넘버를 만드는 방법의 수를 return 하도록 solution 함수를 작성해주세요. 제한사항 주어지는 숫자의 개수는 2개 이상 20개 이하입니다. 각 숫자는 1 이상 50 이하인 자연수입니다. 타겟 넘버는 1 이상 1000 이하인 자연수입니다. 입출력 예 numbers target return [1, 1, 1, 1, 1] 3 5 [4, 1, 2, 1] 4 2 입출력 예 설명",normal,Array
187,"주어진 항공권을 모두 이용하여 여행경로를 짜려고 합니다. 항상 ""ICN"" 공항에서 출발합니다. 항공권 정보가 담긴 2차원 배열 tickets가 매개변수로 주어질 때, 방문하는 공항 경로를 배열에 담아 return 하도록 solution 함수를 작성해주세요. 제한사항 모든 공항은 알파벳 대문자 3글자로 이루어집니다. 주어진 공항 수는 3개 이상 10,000개 이하입니다. tickets의 각 행 [a, b]는 a 공항에서 b 공항으로 가는 항공권이 있다는 의미입니다. 주어진 항공권은 모두 사용해야 합니다. 만일 가능한 경로가 2개 이상일 경우 알파벳 순서가 앞서는 경로를 return 합니다. 모든 도시를 방문할 수 없는 경우는 주어지지 않습니다. 입출력 예 tickets return [[""ICN"", ""JFK""], [""HND"", ""IAD""], [""JFK"", ""HND""]] [""ICN"", ""JFK"", ""HND"", ""IAD""] [[""ICN"", ""SFO""], [""ICN"", ""ATL""], [""SFO"", ""ATL""], [""ATL"", ""ICN""], [""ATL"",""SFO""]] [""ICN"", ""ATL"", ""ICN"", ""SFO"", ""ATL"", ""SFO""]",normal,Array
188,"두 개의 단어 begin, target과 단어의 집합 words가 있습니다. 아래와 같은 규칙을 이용하여 begin에서 target으로 변환하는 가장 짧은 변환 과정을 찾으려고 합니다. 1. 한 번에 한 개의 알파벳만 바꿀 수 있습니다. 2. words에 있는 단어로만 변환할 수 있습니다. 예를 들어 begin이 ""hit"", target가 ""cog"", words가 [""hot"",""dot"",""dog"",""lot"",""log"",""cog""]라면 ""hit"" -> ""hot"" -> ""dot"" -> ""dog"" -> ""cog""와 같이 4단계를 거쳐 변환할 수 있습니다. 두 개의 단어 begin, target과 단어의 집합 words가 매개변수로 주어질 때, 최소 몇 단계의 과정을 거쳐 begin을 target으로 변환할 수 있는지 return 하도록 solution 함수를 작성해주세요. 제한사항 각 단어는 알파벳 소문자로만 이루어져 있습니다. 각 단어의 길이는 3 이상 10 이하이며 모든 단어의 길이는 같습니다. words에는 3개 이상 50개 이하의 단어가 있으며 중복되는 단어는 없습니다. begin과 target은 같지 않습니다. 변환할 수 없는 경우에는 0를 return 합니다. 입출력 예 begin target words return ""hit"" ""cog"" [""hot"", ""dot"", ""dog"", ""lot"", ""log"", ""cog""] 4 ""hit"" ""cog"" [""hot"", ""dot"", ""dog"", ""lot"", ""log""] 0",normal,Hash Table
189,"네트워크란 컴퓨터 상호 간에 정보를 교환할 수 있도록 연결된 형태를 의미합니다. 예를 들어, 컴퓨터 A와 컴퓨터 B가 직접적으로 연결되어있고, 컴퓨터 B와 컴퓨터 C가 직접적으로 연결되어 있을 때 컴퓨터 A와 컴퓨터 C도 간접적으로 연결되어 정보를 교환할 수 있습니다. 따라서 컴퓨터 A, B, C는 모두 같은 네트워크 상에 있다고 할 수 있습니다. 컴퓨터의 개수 n, 연결에 대한 정보가 담긴 2차원 배열 computers가 매개변수로 주어질 때, 네트워크의 개수를 return 하도록 solution 함수를 작성하시오. 제한사항 컴퓨터의 개수 n은 1 이상 200 이하인 자연수입니다. 각 컴퓨터는 0부터 n-1인 정수로 표현합니다. i번 컴퓨터와 j번 컴퓨터가 연결되어 있으면 computers[i][j]를 1로 표현합니다. computer[i][i]는 항상 1입니다. 입출력 예 n computers return 3 [[1, 1, 0], [1, 1, 0], [0, 0, 1]] 2 3 [[1, 1, 0], [1, 1, 1], [0, 1, 1]] 1",normal,Array
190,"위와 같은 삼각형의 꼭대기에서 바닥까지 이어지는 경로 중, 거쳐간 숫자의 합이 가장 큰 경우를 찾아보려고 합니다. 아래 칸으로 이동할 때는 대각선 방향으로 한 칸 오른쪽 또는 왼쪽으로만 이동 가능합니다. 예를 들어 3에서는 그 아래칸의 8 또는 1로만 이동이 가능합니다. 삼각형의 정보가 담긴 배열 triangle이 매개변수로 주어질 때, 거쳐간 숫자의 최댓값을 return 하도록 solution 함수를 완성하세요. 제한사항 삼각형의 높이는 1 이상 500 이하입니다. 삼각형을 이루고 있는 숫자는 0 이상 9,999 이하의 정수입니다. 입출력 예 triangle result [[7], [3, 8], [8, 1, 0], [2, 7, 4, 4], [4, 5, 2, 6, 5]] 30",normal,Array
191,"계속되는 폭우로 일부 지역이 물에 잠겼습니다. 물에 잠기지 않은 지역을 통해 학교를 가려고 합니다. 집에서 학교까지 가는 길은 m x n 크기의 격자모양으로 나타낼 수 있습니다. 아래 그림은 m = 4, n = 3 인 경우입니다. 가장 왼쪽 위, 즉 집이 있는 곳의 좌표는 (1, 1)로 나타내고 가장 오른쪽 아래, 즉 학교가 있는 곳의 좌표는 (m, n)으로 나타냅니다. 격자의 크기 m, n과 물이 잠긴 지역의 좌표를 담은 2차원 배열 puddles이 매개변수로 주어집니다. 오른쪽과 아래쪽으로만 움직여 집에서 학교까지 갈 수 있는 최단경로의 개수를 1,000,000,007로 나눈 나머지를 return 하도록 solution 함수를 작성해주세요. 제한사항 격자의 크기 m, n은 1 이상 100 이하인 자연수입니다. m과 n이 모두 1인 경우는 입력으로 주어지지 않습니다. 물에 잠긴 지역은 0개 이상 10개 이하입니다. 집과 학교가 물에 잠긴 경우는 입력으로 주어지지 않습니다. 입출력 예 m n puddles return 4 3 [[2, 2]] 4",normal,Array
192,"도둑이 어느 마을을 털 계획을 하고 있습니다. 이 마을의 모든 집들은 아래 그림과 같이 동그랗게 배치되어 있습니다. 각 집들은 서로 인접한 집들과 방범장치가 연결되어 있기 때문에 인접한 두 집을 털면 경보가 울립니다. 각 집에 있는 돈이 담긴 배열 money가 주어질 때, 도둑이 훔칠 수 있는 돈의 최댓값을 return 하도록 solution 함수를 작성하세요. 제한사항 이 마을에 있는 집은 3개 이상 1,000,000개 이하입니다. money 배열의 각 원소는 0 이상 1,000 이하인 정수입니다. 입출력 예 money return [1, 2, 3, 1] 4",hard,Array
193,"아래와 같이 5와 사칙연산만으로 12를 표현할 수 있습니다. 12 = 5 + 5 + (5 / 5) + (5 / 5) 12 = 55 / 5 + 5 / 5 12 = (55 + 5) / 5 5를 사용한 횟수는 각각 6,5,4 입니다. 그리고 이중 가장 작은 경우는 4입니다. 이처럼 숫자 N과 number가 주어질 때, N과 사칙연산만 사용해서 표현 할 수 있는 방법 중 N 사용횟수의 최솟값을 return 하도록 solution 함수를 작성하세요. 제한사항 N은 1 이상 9 이하입니다. number는 1 이상 32,000 이하입니다. 수식에는 괄호와 사칙연산만 가능하며 나누기 연산에서 나머지는 무시합니다. 최솟값이 8보다 크면 -1을 return 합니다. 입출력 예 N number return 5 12 4 2 11 3",normal,Math
194,"블록게임 프렌즈 블록이라는 신규 게임이 출시되었고, 어마어마한 상금이 걸린 이벤트 대회가 개최 되었다. 이 대회는 사람을 대신해서 플레이할 프로그램으로 참가해도 된다는 규정이 있어서, 게임 실력이 형편없는 프로도는 프로그램을 만들어서 참가하기로 결심하고 개발을 시작하였다. 프로도가 우승할 수 있도록 도와서 빠르고 정확한 프로그램을 작성해 보자. 게임규칙 아래 그림과 같이 1×1 크기의 블록을 이어 붙여 만든 3 종류의 블록을 회전해서 총 12가지 모양의 블록을 만들 수 있다. 1 x 1 크기의 정사각형으로 이루어진 N x N 크기의 보드 위에 이 블록들이 배치된 채로 게임이 시작된다. (보드 위에 놓인 블록은 회전할 수 없다). 모든 블록은 블록을 구성하는 사각형들이 정확히 보드 위의 사각형에 맞도록 놓여있으며, 선 위에 걸치거나 보드를 벗어나게 놓여있는 경우는 없다. 플레이어는 위쪽에서 1 x 1 크기의 검은 블록을 떨어뜨려 쌓을 수 있다. 검은 블록은 항상 맵의 한 칸에 꽉 차게 떨어뜨려야 하며, 줄에 걸치면 안된다. 이때, 검은 블록과 기존에 놓인 블록을 합해 속이 꽉 채워진 직사각형을 만들 수 있다면 그 블록을 없앨 수 있다. 예를 들어 검은 블록을 떨어뜨려 아래와 같이 만들 경우 주황색 블록을 없앨 수 있다. 빨간 블록을 가로막던 주황색 블록이 없어졌으므로 다음과 같이 빨간 블록도 없앨 수 있다. 그러나 다른 블록들은 검은 블록을 떨어뜨려 직사각형으로 만들 수 없기 때문에 없앨 수 없다. 따라서 위 예시에서 없앨 수 있는 블록은 최대 2개이다. 보드 위에 놓인 블록의 상태가 담긴 2차원 배열 board가 주어질 때, 검은 블록을 떨어뜨려 없앨 수 있는 블록 개수의 최댓값을 구하라. 제한사항 board는 블록의 상태가 들어있는 N x N 크기 2차원 배열이다. N은 4 이상 50 이하다. board의 각 행의 원소는 0 이상 200 이하의 자연수이다. 0 은 빈 칸을 나타낸다. board에 놓여있는 각 블록은 숫자를 이용해 표현한다. 잘못된 블록 모양이 주어지는 경우는 없다. 모양에 관계 없이 서로 다른 블록은 서로 다른 숫자로 표현된다. 예를 들어 문제에 주어진 예시의 경우 다음과 같이 주어진다. 입출력 예 board result [[0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,4,0,0,0],[0,0,0,0,0,4,4,0,0,0],[0,0,0,0,3,0,4,0,0,0],[0,0,0,2,3,0,0,0,5,5],[1,2,2,2,3,3,0,0,0,5],[1,1,1,0,0,0,0,0,0,5]] 2 입출력 예 설명",hard,Array
195,"매칭 점수 프렌즈 대학교 조교였던 제이지는 허드렛일만 시키는 네오 학과장님의 마수에서 벗어나, 카카오에 입사하게 되었다. 평소에 관심있어하던 검색에 마침 결원이 발생하여, 검색개발팀에 편입될 수 있었고, 대망의 첫 프로젝트를 맡게 되었다. 그 프로젝트는 검색어에 가장 잘 맞는 웹페이지를 보여주기 위해 아래와 같은 규칙으로 검색어에 대한 웹페이지의 매칭점수를 계산 하는 것이었다. 한 웹페이지에 대해서 기본점수, 외부 링크 수, 링크점수, 그리고 매칭점수를 구할 수 있다. 한 웹페이지의 기본점수는 해당 웹페이지의 텍스트 중, 검색어가 등장하는 횟수이다. (대소문자 무시) 한 웹페이지의 외부 링크 수는 해당 웹페이지에서 다른 외부 페이지로 연결된 링크의 개수이다. 한 웹페이지의 링크점수는 해당 웹페이지로 링크가 걸린 다른 웹페이지의 기본점수 ÷ 외부 링크 수의 총합이다. 한 웹페이지의 매칭점수는 기본점수와 링크점수의 합으로 계산한다. 예를 들어, 다음과 같이 A, B, C 세 개의 웹페이지가 있고, 검색어가 hi라고 하자. 이때 A 웹페이지의 매칭점수는 다음과 같이 계산할 수 있다. 기본 점수는 각 웹페이지에서 hi가 등장한 횟수이다. A,B,C 웹페이지의 기본점수는 각각 1점, 4점, 9점이다. 외부 링크수는 다른 웹페이지로 링크가 걸린 개수이다. A,B,C 웹페이지의 외부 링크 수는 각각 1점, 2점, 3점이다. A 웹페이지로 링크가 걸린 페이지는 B와 C가 있다. A 웹페이지의 링크점수는 B의 링크점수 2점(4 ÷ 2)과 C의 링크점수 3점(9 ÷ 3)을 더한 5점이 된다. 그러므로, A 웹페이지의 매칭점수는 기본점수 1점 + 링크점수 5점 = 6점이 된다. 검색어 word와 웹페이지의 HTML 목록인 pages가 주어졌을 때, 매칭점수가 가장 높은 웹페이지의 index를 구하라. 만약 그런 웹페이지가 여러 개라면 그중 번호가 가장 작은 것을 구하라. 제한사항 pages는 HTML 형식의 웹페이지가 문자열 형태로 들어있는 배열이고, 길이는 1 이상 20 이하이다. 한 웹페이지 문자열의 길이는 1 이상 1,500 이하이다. 웹페이지의 index는 pages 배열의 index와 같으며 0부터 시작한다. 한 웹페이지의 url은 HTML의 <head> 태그 내에 <meta> 태그의 값으로 주어진다. 예를들어, 아래와 같은 meta tag가 있으면 이 웹페이지의 url은 https://careers.kakao.com/index 이다. 한 웹페이지에서 모든 외부 링크는 의 형태를 가진다. 내에 다른 attribute가 주어지는 경우는 없으며 항상 href로 연결할 사이트의 url만 포함된다. 위의 경우에서 해당 웹페이지는 https://careers.kakao.com/index 로 외부링크를 가지고 있다고 볼 수 있다. 모든 url은 https:// 로만 시작한다. 검색어 word는 하나의 영어 단어로만 주어지며 알파벳 소문자와 대문자로만 이루어져 있다. word의 길이는 1 이상 12 이하이다. 검색어를 찾을 때, 대소문자 구분은 무시하고 찾는다. 예를들어 검색어가 blind일 때, HTML 내에 Blind라는 단어가 있거나, BLIND라는 단어가 있으면 두 경우 모두 해당된다. 검색어는 단어 단위로 비교하며, 단어와 완전히 일치하는 경우에만 기본 점수에 반영한다. 단어는 알파벳을 제외한 다른 모든 문자로 구분한다. 예를들어 검색어가 ""aba"" 일 때, ""abab abababa""는 단어 단위로 일치하는게 없으니, 기본 점수는 0점이 된다. 만약 검색어가 ""aba"" 라면, ""aba@aba aba""는 단어 단위로 세개가 일치하므로, 기본 점수는 3점이다. 결과를 돌려줄때, 동일한 매칭점수를 가진 웹페이지가 여러 개라면 그중 index 번호가 가장 작은 것를 리턴한다 즉, 웹페이지가 세개이고, 각각 매칭점수가 3,1,3 이라면 제일 적은 index 번호인 0을 리턴하면 된다.",normal,Array
196,"길 찾기 게임 전무로 승진한 라이언은 기분이 너무 좋아 프렌즈를 이끌고 특별 휴가를 가기로 했다. 내친김에 여행 계획까지 구상하던 라이언은 재미있는 게임을 생각해냈고 역시 전무로 승진할만한 인재라고 스스로에게 감탄했다. 라이언이 구상한(그리고 아마도 라이언만 즐거울만한) 게임은, 카카오 프렌즈를 두 팀으로 나누고, 각 팀이 같은 곳을 다른 순서로 방문하도록 해서 먼저 순회를 마친 팀이 승리하는 것이다. 그냥 지도를 주고 게임을 시작하면 재미가 덜해지므로, 라이언은 방문할 곳의 2차원 좌표 값을 구하고 각 장소를 이진트리의 노드가 되도록 구성한 후, 순회 방법을 힌트로 주어 각 팀이 스스로 경로를 찾도록 할 계획이다. 라이언은 아래와 같은 특별한 규칙으로 트리 노드들을 구성한다. 트리를 구성하는 모든 노드의 x, y 좌표 값은 정수이다. 모든 노드는 서로 다른 x값을 가진다. 같은 레벨(level)에 있는 노드는 같은 y 좌표를 가진다. 자식 노드의 y 값은 항상 부모 노드보다 작다. 임의의 노드 V의 왼쪽 서브 트리(left subtree)에 있는 모든 노드의 x값은 V의 x값보다 작다. 임의의 노드 V의 오른쪽 서브 트리(right subtree)에 있는 모든 노드의 x값은 V의 x값보다 크다. 아래 예시를 확인해보자. 라이언의 규칙에 맞게 이진트리의 노드만 좌표 평면에 그리면 다음과 같다. (이진트리의 각 노드에는 1부터 N까지 순서대로 번호가 붙어있다.) 이제, 노드를 잇는 간선(edge)을 모두 그리면 아래와 같은 모양이 된다. 위 이진트리에서 전위 순회(preorder), 후위 순회(postorder)를 한 결과는 다음과 같고, 이것은 각 팀이 방문해야 할 순서를 의미한다. 전위 순회 : 7, 4, 6, 9, 1, 8, 5, 2, 3 후위 순회 : 9, 6, 5, 8, 1, 4, 3, 2, 7 다행히 두 팀 모두 머리를 모아 분석한 끝에 라이언의 의도를 간신히 알아차렸다. 그러나 여전히 문제는 남아있다. 노드의 수가 예시처럼 적다면 쉽게 해결할 수 있겠지만, 예상대로 라이언은 그렇게 할 생각이 전혀 없었다. 이제 당신이 나설 때가 되었다. 곤경에 빠진 카카오 프렌즈를 위해 이진트리를 구성하는 노드들의 좌표가 담긴 배열 nodeinfo가 매개변수로 주어질 때, 노드들로 구성된 이진트리를 전위 순회, 후위 순회한 결과를 2차원 배열에 순서대로 담아 return 하도록 solution 함수를 완성하자. 제한사항 nodeinfo는 이진트리를 구성하는 각 노드의 좌표가 1번 노드부터 순서대로 들어있는 2차원 배열이다. nodeinfo의 길이는 1 이상 10,000 이하이다. nodeinfo[i] 는 i + 1번 노드의 좌표이며, [x축 좌표, y축 좌표] 순으로 들어있다. 모든 노드의 좌표 값은 0 이상 100,000 이하인 정수이다. 트리의 깊이가 1,000 이하인 경우만 입력으로 주어진다. 모든 노드의 좌표는 문제에 주어진 규칙을 따르며, 잘못된 노드 위치가 주어지는 경우는 없다. 입출력 예 nodeinfo result [[5,3],[11,5],[13,3],[3,5],[6,1],[1,3],[8,6],[7,2],[2,2]] [[7,4,6,9,1,8,5,2,3],[9,6,5,8,1,4,3,2,7]] 입출력 예 설명",normal,Array
197,"무지의 먹방 라이브 * 효율성 테스트에 부분 점수가 있는 문제입니다. 평소 식욕이 왕성한 무지는 자신의 재능을 뽐내고 싶어 졌고 고민 끝에 카카오 TV 라이브로 방송을 하기로 마음먹었다. 그냥 먹방을 하면 다른 방송과 차별성이 없기 때문에 무지는 아래와 같이 독특한 방식을 생각해냈다. 회전판에 먹어야 할 N 개의 음식이 있다. 각 음식에는 1부터 N 까지 번호가 붙어있으며, 각 음식을 섭취하는데 일정 시간이 소요된다. 무지는 다음과 같은 방법으로 음식을 섭취한다. 무지는 1번 음식부터 먹기 시작하며, 회전판은 번호가 증가하는 순서대로 음식을 무지 앞으로 가져다 놓는다. 마지막 번호의 음식을 섭취한 후에는 회전판에 의해 다시 1번 음식이 무지 앞으로 온다. 무지는 음식 하나를 1초 동안 섭취한 후 남은 음식은 그대로 두고, 다음 음식을 섭취한다. 다음 음식이란, 아직 남은 음식 중 다음으로 섭취해야 할 가장 가까운 번호의 음식을 말한다. 회전판이 다음 음식을 무지 앞으로 가져오는데 걸리는 시간은 없다고 가정한다. 무지가 먹방을 시작한 지 K 초 후에 네트워크 장애로 인해 방송이 잠시 중단되었다. 무지는 네트워크 정상화 후 다시 방송을 이어갈 때, 몇 번 음식부터 섭취해야 하는지를 알고자 한다. 각 음식을 모두 먹는데 필요한 시간이 담겨있는 배열 food_times, 네트워크 장애가 발생한 시간 K 초가 매개변수로 주어질 때 몇 번 음식부터 다시 섭취하면 되는지 return 하도록 solution 함수를 완성하라. 제한사항 food_times 는 각 음식을 모두 먹는데 필요한 시간이 음식의 번호 순서대로 들어있는 배열이다. k 는 방송이 중단된 시간을 나타낸다. 만약 더 섭취해야 할 음식이 없다면 -1을 반환하면 된다. 정확성 테스트 제한 사항 food_times 의 길이는 1 이상 2,000 이하이다. food_times 의 원소는 1 이상 1,000 이하의 자연수이다. k는 1 이상 2,000,000 이하의 자연수이다. 효율성 테스트 제한 사항 food_times 의 길이는 1 이상 200,000 이하이다. food_times 의 원소는 1 이상 100,000,000 이하의 자연수이다. k는 1 이상 2 x 10^13 이하의 자연수이다. 입출력 예 food_times k result [3, 1, 2] 5 1 입출력 예 설명",hard,Array
198,"후보키 프렌즈대학교 컴퓨터공학과 조교인 제이지는 네오 학과장님의 지시로, 학생들의 인적사항을 정리하는 업무를 담당하게 되었다. 그의 학부 시절 프로그래밍 경험을 되살려, 모든 인적사항을 데이터베이스에 넣기로 하였고, 이를 위해 정리를 하던 중에 후보키(Candidate Key)에 대한 고민이 필요하게 되었다. 후보키에 대한 내용이 잘 기억나지 않던 제이지는, 정확한 내용을 파악하기 위해 데이터베이스 관련 서적을 확인하여 아래와 같은 내용을 확인하였다. 관계 데이터베이스에서 릴레이션(Relation)의 튜플(Tuple)을 유일하게 식별할 수 있는 속성(Attribute) 또는 속성의 집합 중, 다음 두 성질을 만족하는 것을 후보 키(Candidate Key)라고 한다. 유일성(uniqueness) : 릴레이션에 있는 모든 튜플에 대해 유일하게 식별되어야 한다. 최소성(minimality) : 유일성을 가진 키를 구성하는 속성(Attribute) 중 하나라도 제외하는 경우 유일성이 깨지는 것을 의미한다. 즉, 릴레이션의 모든 튜플을 유일하게 식별하는 데 꼭 필요한 속성들로만 구성되어야 한다. 제이지를 위해, 아래와 같은 학생들의 인적사항이 주어졌을 때, 후보 키의 최대 개수를 구하라. 위의 예를 설명하면, 학생의 인적사항 릴레이션에서 모든 학생은 각자 유일한 ""학번""을 가지고 있다. 따라서 ""학번""은 릴레이션의 후보 키가 될 수 있다. 그다음 ""이름""에 대해서는 같은 이름(""apeach"")을 사용하는 학생이 있기 때문에, ""이름""은 후보 키가 될 수 없다. 그러나, 만약 [""이름"", ""전공""]을 함께 사용한다면 릴레이션의 모든 튜플을 유일하게 식별 가능하므로 후보 키가 될 수 있게 된다. 물론 [""이름"", ""전공"", ""학년""]을 함께 사용해도 릴레이션의 모든 튜플을 유일하게 식별할 수 있지만, 최소성을 만족하지 못하기 때문에 후보 키가 될 수 없다. 따라서, 위의 학생 인적사항의 후보키는 ""학번"", [""이름"", ""전공""] 두 개가 된다. 릴레이션을 나타내는 문자열 배열 relation이 매개변수로 주어질 때, 이 릴레이션에서 후보 키의 개수를 return 하도록 solution 함수를 완성하라. 제한사항 relation은 2차원 문자열 배열이다. relation의 컬럼(column)의 길이는 1 이상 8 이하이며, 각각의 컬럼은 릴레이션의 속성을 나타낸다. relation의 로우(row)의 길이는 1 이상 20 이하이며, 각각의 로우는 릴레이션의 튜플을 나타낸다. relation의 모든 문자열의 길이는 1 이상 8 이하이며, 알파벳 소문자와 숫자로만 이루어져 있다. relation의 모든 튜플은 유일하게 식별 가능하다.(즉, 중복되는 튜플은 없다.) 입출력 예 relation result [[""100"",""ryan"",""music"",""2""],[""200"",""apeach"",""math"",""2""],[""300"",""tube"",""computer"",""3""],[""400"",""con"",""computer"",""4""],[""500"",""muzi"",""music"",""3""],[""600"",""apeach"",""music"",""2""]] 2 입출력 예 설명",normal,Array
199,"오픈채팅방 카카오톡 오픈채팅방에서는 친구가 아닌 사람들과 대화를 할 수 있는데, 본래 닉네임이 아닌 가상의 닉네임을 사용하여 채팅방에 들어갈 수 있다. 신입사원인 김크루는 카카오톡 오픈 채팅방을 개설한 사람을 위해, 다양한 사람들이 들어오고, 나가는 것을 지켜볼 수 있는 관리자창을 만들기로 했다. 채팅방에 누군가 들어오면 다음 메시지가 출력된다. ""[닉네임]님이 들어왔습니다."" 채팅방에서 누군가 나가면 다음 메시지가 출력된다. ""[닉네임]님이 나갔습니다."" 채팅방에서 닉네임을 변경하는 방법은 다음과 같이 두 가지이다. 채팅방을 나간 후, 새로운 닉네임으로 다시 들어간다. 채팅방에서 닉네임을 변경한다. 닉네임을 변경할 때는 기존에 채팅방에 출력되어 있던 메시지의 닉네임도 전부 변경된다. 예를 들어, 채팅방에 ""Muzi""와 ""Prodo""라는 닉네임을 사용하는 사람이 순서대로 들어오면 채팅방에는 다음과 같이 메시지가 출력된다. ""Muzi님이 들어왔습니다."" ""Prodo님이 들어왔습니다."" 채팅방에 있던 사람이 나가면 채팅방에는 다음과 같이 메시지가 남는다. ""Muzi님이 들어왔습니다."" ""Prodo님이 들어왔습니다."" ""Muzi님이 나갔습니다."" Muzi가 나간후 다시 들어올 때, Prodo 라는 닉네임으로 들어올 경우 기존에 채팅방에 남아있던 Muzi도 Prodo로 다음과 같이 변경된다. ""Prodo님이 들어왔습니다."" ""Prodo님이 들어왔습니다."" ""Prodo님이 나갔습니다."" ""Prodo님이 들어왔습니다."" 채팅방은 중복 닉네임을 허용하기 때문에, 현재 채팅방에는 Prodo라는 닉네임을 사용하는 사람이 두 명이 있다. 이제, 채팅방에 두 번째로 들어왔던 Prodo가 Ryan으로 닉네임을 변경하면 채팅방 메시지는 다음과 같이 변경된다. ""Prodo님이 들어왔습니다."" ""Ryan님이 들어왔습니다."" ""Prodo님이 나갔습니다."" ""Prodo님이 들어왔습니다."" 채팅방에 들어오고 나가거나, 닉네임을 변경한 기록이 담긴 문자열 배열 record가 매개변수로 주어질 때, 모든 기록이 처리된 후, 최종적으로 방을 개설한 사람이 보게 되는 메시지를 문자열 배열 형태로 return 하도록 solution 함수를 완성하라. 제한사항 record는 다음과 같은 문자열이 담긴 배열이며, 길이는 1 이상 100,000 이하이다. 다음은 record에 담긴 문자열에 대한 설명이다. 모든 유저는 [유저 아이디]로 구분한다. [유저 아이디] 사용자가 [닉네임]으로 채팅방에 입장 - ""Enter [유저 아이디] [닉네임]"" (ex. ""Enter uid1234 Muzi"") [유저 아이디] 사용자가 채팅방에서 퇴장 - ""Leave [유저 아이디]"" (ex. ""Leave uid1234"") [유저 아이디] 사용자가 닉네임을 [닉네임]으로 변경 - ""Change [유저 아이디] [닉네임]"" (ex. ""Change uid1234 Muzi"") 첫 단어는 Enter, Leave, Change 중 하나이다. 각 단어는 공백으로 구분되어 있으며, 알파벳 대문자, 소문자, 숫자로만 이루어져있다. 유저 아이디와 닉네임은 알파벳 대문자, 소문자를 구별한다. 유저 아이디와 닉네임의 길이는 1 이상 10 이하이다. 채팅방에서 나간 유저가 닉네임을 변경하는 등 잘못 된 입력은 주어지지 않는다. 입출력 예 record result [""Enter uid1234 Muzi"", ""Enter uid4567 Prodo"",""Leave uid1234"",""Enter uid1234 Prodo"",""Change uid4567 Ryan""] [""Prodo님이 들어왔습니다."", ""Ryan님이 들어왔습니다."", ""Prodo님이 나갔습니다."", ""Prodo님이 들어왔습니다.""] 입출력 예 설명",normal,Array
200,"무인도에 갇힌 사람들을 구명보트를 이용하여 구출하려고 합니다. 구명보트는 작아서 한 번에 최대 2명씩 밖에 탈 수 없고, 무게 제한도 있습니다. 예를 들어, 사람들의 몸무게가 [70kg, 50kg, 80kg, 50kg]이고 구명보트의 무게 제한이 100kg이라면 2번째 사람과 4번째 사람은 같이 탈 수 있지만 1번째 사람과 3번째 사람의 무게의 합은 150kg이므로 구명보트의 무게 제한을 초과하여 같이 탈 수 없습니다. 구명보트를 최대한 적게 사용하여 모든 사람을 구출하려고 합니다. 사람들의 몸무게를 담은 배열 people과 구명보트의 무게 제한 limit가 매개변수로 주어질 때, 모든 사람을 구출하기 위해 필요한 구명보트 개수의 최솟값을 return 하도록 solution 함수를 작성해주세요. 제한사항 무인도에 갇힌 사람은 1명 이상 50,000명 이하입니다. 각 사람의 몸무게는 40kg 이상 240kg 이하입니다. 구명보트의 무게 제한은 40kg 이상 240kg 이하입니다. 구명보트의 무게 제한은 항상 사람들의 몸무게 중 최댓값보다 크게 주어지므로 사람들을 구출할 수 없는 경우는 없습니다. 입출력 예 people limit return [70, 50, 80, 50] 100 3 [70, 80, 50] 100 3 ※ 2023년 07월 31일 테스트 케이스가 추가되었습니다. 기존에 제출한 코드가 통과하지 못할 수 있습니다.",normal,Array
201,"고속도로를 이동하는 모든 차량이 고속도로를 이용하면서 단속용 카메라를 한 번은 만나도록 카메라를 설치하려고 합니다. 고속도로를 이동하는 차량의 경로 routes가 매개변수로 주어질 때, 모든 차량이 한 번은 단속용 카메라를 만나도록 하려면 최소 몇 대의 카메라를 설치해야 하는지를 return 하도록 solution 함수를 완성하세요. 제한사항 차량의 대수는 1대 이상 10,000대 이하입니다. routes에는 차량의 이동 경로가 포함되어 있으며 routes[i][0]에는 i번째 차량이 고속도로에 진입한 지점, routes[i][1]에는 i번째 차량이 고속도로에서 나간 지점이 적혀 있습니다. 차량의 진입/진출 지점에 카메라가 설치되어 있어도 카메라를 만난것으로 간주합니다. 차량의 진입 지점, 진출 지점은 -30,000 이상 30,000 이하입니다. 입출력 예 routes return [[-20,-15], [-14,-5], [-18,-13], [-5,-3]] 2 입출력 예 설명 -5 지점에 카메라를 설치하면 두 번째, 네 번째 차량이 카메라를 만납니다. -15 지점에 카메라를 설치하면 첫 번째, 세 번째 차량이 카메라를 만납니다.",normal,Math
202,"어떤 숫자에서 k개의 수를 제거했을 때 얻을 수 있는 가장 큰 숫자를 구하려 합니다. 예를 들어, 숫자 1924에서 수 두 개를 제거하면 [19, 12, 14, 92, 94, 24] 를 만들 수 있습니다. 이 중 가장 큰 숫자는 94 입니다. 문자열 형식으로 숫자 number와 제거할 수의 개수 k가 solution 함수의 매개변수로 주어집니다. number에서 k 개의 수를 제거했을 때 만들 수 있는 수 중 가장 큰 숫자를 문자열 형태로 return 하도록 solution 함수를 완성하세요. 제한 조건 number는 2자리 이상, 1,000,000자리 이하인 숫자입니다. k는 1 이상 number의 자릿수 미만인 자연수입니다. 입출력 예 number k return ""1924"" 2 ""94"" ""1231234"" 3 ""3234"" ""4177252841"" 4 ""775841""",normal,String
203,"n개의 섬 사이에 다리를 건설하는 비용(costs)이 주어질 때, 최소의 비용으로 모든 섬이 서로 통행 가능하도록 만들 때 필요한 최소 비용을 return 하도록 solution을 완성하세요. 다리를 여러 번 건너더라도, 도달할 수만 있으면 통행 가능하다고 봅니다. 예를 들어 A 섬과 B 섬 사이에 다리가 있고, B 섬과 C 섬 사이에 다리가 있으면 A 섬과 C 섬은 서로 통행 가능합니다. 제한사항 섬의 개수 n은 1 이상 100 이하입니다. costs의 길이는 ((n-1) * n) / 2이하입니다. 임의의 i에 대해, costs[i][0] 와 costs[i] [1]에는 다리가 연결되는 두 섬의 번호가 들어있고, costs[i] [2]에는 이 두 섬을 연결하는 다리를 건설할 때 드는 비용입니다. 같은 연결은 두 번 주어지지 않습니다. 또한 순서가 바뀌더라도 같은 연결로 봅니다. 즉 0과 1 사이를 연결하는 비용이 주어졌을 때, 1과 0의 비용이 주어지지 않습니다. 모든 섬 사이의 다리 건설 비용이 주어지지 않습니다. 이 경우, 두 섬 사이의 건설이 불가능한 것으로 봅니다. 연결할 수 없는 섬은 주어지지 않습니다. 입출력 예 n costs return 4 [[0,1,1],[0,2,2],[1,2,5],[1,3,1],[2,3,8]] 4 입출력 예 설명 costs를 그림으로 표현하면 다음과 같으며, 이때 초록색 경로로 연결하는 것이 가장 적은 비용으로 모두를 통행할 수 있도록 만드는 방법입니다.",normal,Math
204,"조이스틱으로 알파벳 이름을 완성하세요. 맨 처음엔 A로만 이루어져 있습니다. ex) 완성해야 하는 이름이 세 글자면 AAA, 네 글자면 AAAA 조이스틱을 각 방향으로 움직이면 아래와 같습니다. ▲ - 다음 알파벳 ▼ - 이전 알파벳 (A에서 아래쪽으로 이동하면 Z로) ◀ - 커서를 왼쪽으로 이동 (첫 번째 위치에서 왼쪽으로 이동하면 마지막 문자에 커서) ▶ - 커서를 오른쪽으로 이동 (마지막 위치에서 오른쪽으로 이동하면 첫 번째 문자에 커서) 예를 들어 아래의 방법으로 ""JAZ""를 만들 수 있습니다. - 첫 번째 위치에서 조이스틱을 위로 9번 조작하여 J를 완성합니다. - 조이스틱을 왼쪽으로 1번 조작하여 커서를 마지막 문자 위치로 이동시킵니다. - 마지막 위치에서 조이스틱을 아래로 1번 조작하여 Z를 완성합니다. 따라서 11번 이동시켜 ""JAZ""를 만들 수 있고, 이때가 최소 이동입니다. 만들고자 하는 이름 name이 매개변수로 주어질 때, 이름에 대해 조이스틱 조작 횟수의 최솟값을 return 하도록 solution 함수를 만드세요. 제한 사항 name은 알파벳 대문자로만 이루어져 있습니다. name의 길이는 1 이상 20 이하입니다. 입출력 예 name return ""JEROEN"" 56 ""JAN"" 23 출처",normal,Math
205,"Leo는 카펫을 사러 갔다가 아래 그림과 같이 중앙에는 노란색으로 칠해져 있고 테두리 1줄은 갈색으로 칠해져 있는 격자 모양 카펫을 봤습니다. Leo는 집으로 돌아와서 아까 본 카펫의 노란색과 갈색으로 색칠된 격자의 개수는 기억했지만, 전체 카펫의 크기는 기억하지 못했습니다. Leo가 본 카펫에서 갈색 격자의 수 brown, 노란색 격자의 수 yellow가 매개변수로 주어질 때 카펫의 가로, 세로 크기를 순서대로 배열에 담아 return 하도록 solution 함수를 작성해주세요. 제한사항 갈색 격자의 수 brown은 8 이상 5,000 이하인 자연수입니다. 노란색 격자의 수 yellow는 1 이상 2,000,000 이하인 자연수입니다. 카펫의 가로 길이는 세로 길이와 같거나, 세로 길이보다 깁니다. 입출력 예 brown yellow return 10 2 [4, 3] 8 1 [3, 3] 24 24 [8, 6] 출처",normal,Array
206,"한자리 숫자가 적힌 종이 조각이 흩어져있습니다. 흩어진 종이 조각을 붙여 소수를 몇 개 만들 수 있는지 알아내려 합니다. 각 종이 조각에 적힌 숫자가 적힌 문자열 numbers가 주어졌을 때, 종이 조각으로 만들 수 있는 소수가 몇 개인지 return 하도록 solution 함수를 완성해주세요. 제한사항 numbers는 길이 1 이상 7 이하인 문자열입니다. numbers는 0~9까지 숫자만으로 이루어져 있습니다. ""013""은 0, 1, 3 숫자가 적힌 종이 조각이 흩어져있다는 의미입니다. 입출력 예 numbers return ""17"" 3 ""011"" 2",normal,String
207,"H-Index는 과학자의 생산성과 영향력을 나타내는 지표입니다. 어느 과학자의 H-Index를 나타내는 값인 h를 구하려고 합니다. 위키백과1에 따르면, H-Index는 다음과 같이 구합니다. 어떤 과학자가 발표한 논문 n편 중, h번 이상 인용된 논문이 h편 이상이고 나머지 논문이 h번 이하 인용되었다면 h의 최댓값이 이 과학자의 H-Index입니다. 어떤 과학자가 발표한 논문의 인용 횟수를 담은 배열 citations가 매개변수로 주어질 때, 이 과학자의 H-Index를 return 하도록 solution 함수를 작성해주세요. 제한사항 과학자가 발표한 논문의 수는 1편 이상 1,000편 이하입니다. 논문별 인용 횟수는 0회 이상 10,000회 이하입니다. 입출력 예 citations return [3, 0, 6, 1, 5] 3 입출력 예 설명 이 과학자가 발표한 논문의 수는 5편이고, 그중 3편의 논문은 3회 이상 인용되었습니다. 그리고 나머지 2편의 논문은 3회 이하 인용되었기 때문에 이 과학자의 H-Index는 3입니다. 문제가 잘 안풀린다면😢 힌트가 필요한가요? [코딩테스트 연습 힌트 모음집]으로 오세요! → 클릭",normal,Array
208,"0 또는 양의 정수가 주어졌을 때, 정수를 이어 붙여 만들 수 있는 가장 큰 수를 알아내 주세요. 예를 들어, 주어진 정수가 [6, 10, 2]라면 [6102, 6210, 1062, 1026, 2610, 2106]를 만들 수 있고, 이중 가장 큰 수는 6210입니다. 0 또는 양의 정수가 담긴 배열 numbers가 매개변수로 주어질 때, 순서를 재배치하여 만들 수 있는 가장 큰 수를 문자열로 바꾸어 return 하도록 solution 함수를 작성해주세요. 제한 사항 numbers의 길이는 1 이상 100,000 이하입니다. numbers의 원소는 0 이상 1,000 이하입니다. 정답이 너무 클 수 있으니 문자열로 바꾸어 return 합니다. 입출력 예 numbers return [6, 10, 2] ""6210"" [3, 30, 34, 5, 9] ""9534330""",normal,Array
209,"이중 우선순위 큐는 다음 연산을 할 수 있는 자료구조를 말합니다. 명령어 수신 탑(높이) I 숫자 큐에 주어진 숫자를 삽입합니다. D 1 큐에서 최댓값을 삭제합니다. D -1 큐에서 최솟값을 삭제합니다. 이중 우선순위 큐가 할 연산 operations가 매개변수로 주어질 때, 모든 연산을 처리한 후 큐가 비어있으면 [0,0] 비어있지 않으면 [최댓값, 최솟값]을 return 하도록 solution 함수를 구현해주세요. 제한사항 operations는 길이가 1 이상 1,000,000 이하인 문자열 배열입니다. operations의 원소는 큐가 수행할 연산을 나타냅니다. 원소는 “명령어 데이터” 형식으로 주어집니다.- 최댓값/최솟값을 삭제하는 연산에서 최댓값/최솟값이 둘 이상인 경우, 하나만 삭제합니다. 빈 큐에 데이터를 삭제하라는 연산이 주어질 경우, 해당 연산은 무시합니다. 입출력 예 operations return [""I 16"", ""I -5643"", ""D -1"", ""D 1"", ""D 1"", ""I 123"", ""D -1""] [0,0] [""I -45"", ""I 653"", ""D 1"", ""I -642"", ""I 45"", ""I 97"", ""D 1"", ""D -1"", ""I 333""] [333, -45] 입출력 예 설명",normal,Array
210,"하드디스크는 한 번에 하나의 작업만 수행할 수 있습니다. 디스크 컨트롤러를 구현하는 방법은 여러 가지가 있습니다. 이 문제에서는 우선순위 디스크 컨트롤러라는 가상의 장치를 이용한다고 가정합니다. 우선순위 디스크 컨트롤러는 다음과 같이 동작합니다. 어떤 작업 요청이 들어왔을 때 작업의 번호, 작업의 요청 시각, 작업의 소요 시간을 저장해 두는 대기 큐가 있습니다. 처음에 이 큐는 비어있습니다. 디스크 컨트롤러는 하드디스크가 작업을 하고 있지 않고 대기 큐가 비어있지 않다면 가장 우선순위가 높은 작업을 대기 큐에서 꺼내서 하드디스크에 그 작업을 시킵니다. 이때, 작업의 소요시간이 짧은 것, 작업의 요청 시각이 빠른 것, 작업의 번호가 작은 것 순으로 우선순위가 높습니다. 하드디스크는 작업을 한 번 시작하면 작업을 마칠 때까지 그 작업만 수행합니다. 하드디스크가 어떤 작업을 마치는 시점과 다른 작업 요청이 들어오는 시점이 겹친다면 하드디스크가 작업을 마치자마자 디스크 컨트롤러는 요청이 들어온 작업을 대기 큐에 저장한 뒤 우선순위가 높은 작업을 대기 큐에서 꺼내서 하드디스크에 그 작업을 시킵니다. 또, 하드디스크가 어떤 작업을 마치는 시점에 다른 작업이 들어오지 않더라도 그 작업을 마치자마자 또 다른 작업을 시작할 수 있습니다. 이 과정에서 걸리는 시간은 없다고 가정합니다. 예를 들어 - 0ms 시점에 3ms가 소요되는 0번 작업 요청 - 1ms 시점에 9ms가 소요되는 1번 작업 요청 - 3ms 시점에 5ms가 소요되는 2번 작업 요청 와 같은 요청이 들어왔습니다. 이를 그림으로 표현하면 다음과 같습니다. 이 요청을 우선순위 디스크 컨트롤러가 처리하는 과정은 다음 표와 같습니다. 시점 하드디스크 대기 큐 디스크 컨트롤러 0ms [] 0ms [[0번, 0ms, 3ms]] 0번 작업 요청을 대기 큐에 저장 0ms 0번 작업 시작 [] 대기 큐에서 우선순위가 높은 0번 작업을 꺼내서 작업을 시킴 1ms 0번 작업 중 [[1번, 1ms, 9ms]] 1번 작업 요청을 대기 큐에 저장 3ms 0번 작업 완료 [[1번, 1ms, 9ms]] 3ms [[1번, 1ms, 9ms], [2번, 3ms, 5ms]] 2번 작업 요청을 대기 큐에 저장 3ms 2번 작업 시작 [[1번, 1ms, 9ms]] 대기 큐에서 우선순위가 높은 2번 작업을 꺼내서 작업을 시킴 8ms 2번 작업 완료 [[1번, 1ms, 9ms]] 8ms 1번 작업 시작 [] 대기 큐에서 우선순위가 높은 1번 작업을 꺼내서 작업을 시킴 17ms 1번 작업 완료 [] 모든 요청 작업을 마쳤을 때 각 작업에 대한 반환 시간(turnaround time)은 작업 요청부터 종료까지 걸린 시간으로 정의합니다. 위의 우선순위 디스크 컨트롤러가 처리한 각 작업의 반환 시간은 다음 그림, 표와 같습니다. 작업 번호 요청 시각 작업 종료 시각 반환 시간 0번 0ms 3ms 3ms(= 3ms - 0ms) 1번 1ms 17ms 16ms(= 17ms - 1ms) 2번 3ms 8ms 5ms(= 8ms - 3ms) 우선순위 디스크 컨트롤러에서 모든 요청 작업의 반환 시간의 평균은 8ms(= (3ms + 16ms + 5ms) / 3)가 됩니다. 각 작업에 대해 [작업이 요청되는 시점, 작업의 소요시간]을 담은 2차원 정수 배열 jobs가 매개변수로 주어질 때, 우선순위 디스크 컨트롤러가 이 작업을 처리했을 때 모든 요청 작업의 반환 시간의 평균의 정수부분을 return 하는 solution 함수를 작성해 주세요. 제한 사항 1 ≤ jobs의 길이 ≤ 500 jobs[i]는 i번 작업에 대한 정보이고 [s, l] 형태입니다. s는 작업이 요청되는 시점이며 0 ≤ s ≤ 1,000입니다. l은 작업의 소요시간이며 1 ≤ l ≤ 1,000입니다. 입출력 예 jobs return [[0, 3], [1, 9], [3, 5]] 8 입출력 예 설명",normal,Array
211,"매운 것을 좋아하는 Leo는 모든 음식의 스코빌 지수를 K 이상으로 만들고 싶습니다. 모든 음식의 스코빌 지수를 K 이상으로 만들기 위해 Leo는 스코빌 지수가 가장 낮은 두 개의 음식을 아래와 같이 특별한 방법으로 섞어 새로운 음식을 만듭니다. 섞은 음식의 스코빌 지수 = 가장 맵지 않은 음식의 스코빌 지수 + (두 번째로 맵지 않은 음식의 스코빌 지수 * 2) Leo는 모든 음식의 스코빌 지수가 K 이상이 될 때까지 반복하여 섞습니다. Leo가 가진 음식의 스코빌 지수를 담은 배열 scoville과 원하는 스코빌 지수 K가 주어질 때, 모든 음식의 스코빌 지수를 K 이상으로 만들기 위해 섞어야 하는 최소 횟수를 return 하도록 solution 함수를 작성해주세요. 제한 사항 scoville의 길이는 2 이상 1,000,000 이하입니다. K는 0 이상 1,000,000,000 이하입니다. scoville의 원소는 각각 0 이상 1,000,000 이하입니다. 모든 음식의 스코빌 지수를 K 이상으로 만들 수 없는 경우에는 -1을 return 합니다. 입출력 예 scoville K return [1, 2, 3, 9, 10, 12] 7 2 입출력 예 설명 스코빌 지수가 1인 음식과 2인 음식을 섞으면 음식의 스코빌 지수가 아래와 같이 됩니다. 새로운 음식의 스코빌 지수 = 1 + (2 * 2) = 5 가진 음식의 스코빌 지수 = [5, 3, 9, 10, 12] 스코빌 지수가 3인 음식과 5인 음식을 섞으면 음식의 스코빌 지수가 아래와 같이 됩니다. 새로운 음식의 스코빌 지수 = 3 + (5 * 2) = 13 가진 음식의 스코빌 지수 = [13, 9, 10, 12] 모든 음식의 스코빌 지수가 7 이상이 되었고 이때 섞은 횟수는 2회입니다.",normal,Array
212,"운영체제의 역할 중 하나는 컴퓨터 시스템의 자원을 효율적으로 관리하는 것입니다. 이 문제에서는 운영체제가 다음 규칙에 따라 프로세스를 관리할 경우 특정 프로세스가 몇 번째로 실행되는지 알아내면 됩니다. 1. 실행 대기 큐(Queue)에서 대기중인 프로세스 하나를 꺼냅니다. 2. 큐에 대기중인 프로세스 중 우선순위가 더 높은 프로세스가 있다면 방금 꺼낸 프로세스를 다시 큐에 넣습니다. 3. 만약 그런 프로세스가 없다면 방금 꺼낸 프로세스를 실행합니다. 3.1 한 번 실행한 프로세스는 다시 큐에 넣지 않고 그대로 종료됩니다. 예를 들어 프로세스 4개 [A, B, C, D]가 순서대로 실행 대기 큐에 들어있고, 우선순위가 [2, 1, 3, 2]라면 [C, D, A, B] 순으로 실행하게 됩니다. 현재 실행 대기 큐(Queue)에 있는 프로세스의 중요도가 순서대로 담긴 배열 priorities와, 몇 번째로 실행되는지 알고싶은 프로세스의 위치를 알려주는 location이 매개변수로 주어질 때, 해당 프로세스가 몇 번째로 실행되는지 return 하도록 solution 함수를 작성해주세요. 제한사항 priorities의 길이는 1 이상 100 이하입니다. priorities의 원소는 1 이상 9 이하의 정수입니다. priorities의 원소는 우선순위를 나타내며 숫자가 클 수록 우선순위가 높습니다. location은 0 이상 (대기 큐에 있는 프로세스 수 - 1) 이하의 값을 가집니다. priorities의 가장 앞에 있으면 0, 두 번째에 있으면 1 … 과 같이 표현합니다. 입출력 예 priorities location return [2, 1, 3, 2] 2 1 [1, 1, 9, 1, 1, 1] 0 5",normal,Array
213,"프로그래머스 팀에서는 기능 개선 작업을 수행 중입니다. 각 기능은 진도가 100%일 때 서비스에 반영할 수 있습니다. 또, 각 기능의 개발속도는 모두 다르기 때문에 뒤에 있는 기능이 앞에 있는 기능보다 먼저 개발될 수 있고, 이때 뒤에 있는 기능은 앞에 있는 기능이 배포될 때 함께 배포됩니다. 먼저 배포되어야 하는 순서대로 작업의 진도가 적힌 정수 배열 progresses와 각 작업의 개발 속도가 적힌 정수 배열 speeds가 주어질 때 각 배포마다 몇 개의 기능이 배포되는지를 return 하도록 solution 함수를 완성하세요. 제한 사항 작업의 개수(progresses, speeds배열의 길이)는 100개 이하입니다. 작업 진도는 100 미만의 자연수입니다. 작업 속도는 100 이하의 자연수입니다. 배포는 하루에 한 번만 할 수 있으며, 하루의 끝에 이루어진다고 가정합니다. 예를 들어 진도율이 95%인 작업의 개발 속도가 하루에 4%라면 배포는 2일 뒤에 이루어집니다. 입출력 예 progresses speeds return [93, 30, 55] [1, 30, 5] [2, 1] [95, 90, 99, 99, 80, 99] [1, 1, 1, 1, 1, 1] [1, 3, 2] 입출력 예 설명",normal,Array
214,"초 단위로 기록된 주식가격이 담긴 배열 prices가 매개변수로 주어질 때, 가격이 떨어지지 않은 기간은 몇 초인지를 return 하도록 solution 함수를 완성하세요. 제한사항 prices의 각 가격은 1 이상 10,000 이하인 자연수입니다. prices의 길이는 2 이상 100,000 이하입니다. 입출력 예 prices return [1, 2, 3, 2, 3] [4, 3, 1, 1, 0]",normal,Array
215,"트럭 여러 대가 강을 가로지르는 일차선 다리를 정해진 순으로 건너려 합니다. 모든 트럭이 다리를 건너려면 최소 몇 초가 걸리는지 알아내야 합니다. 다리에는 트럭이 최대 bridge_length대 올라갈 수 있으며, 다리는 weight 이하까지의 무게를 견딜 수 있습니다. 단, 다리에 완전히 오르지 않은 트럭의 무게는 무시합니다. 예를 들어, 트럭 2대가 올라갈 수 있고 무게를 10kg까지 견디는 다리가 있습니다. 무게가 [7, 4, 5, 6]kg인 트럭이 순서대로 최단 시간 안에 다리를 건너려면 다음과 같이 건너야 합니다. 경과 시간 다리를 지난 트럭 다리를 건너는 트럭 대기 트럭 0 [] [] [7,4,5,6] 1~2 [] [7] [4,5,6] 3 [7] [4] [5,6] 4 [7] [4,5] [6] 5 [7,4] [5] [6] 6~7 [7,4,5] [6] [] 8 [7,4,5,6] [] [] 따라서, 모든 트럭이 다리를 지나려면 최소 8초가 걸립니다. solution 함수의 매개변수로 다리에 올라갈 수 있는 트럭 수 bridge_length, 다리가 견딜 수 있는 무게 weight, 트럭 별 무게 truck_weights가 주어집니다. 이때 모든 트럭이 다리를 건너려면 최소 몇 초가 걸리는지 return 하도록 solution 함수를 완성하세요. 제한 조건 bridge_length는 1 이상 10,000 이하입니다. weight는 1 이상 10,000 이하입니다. truck_weights의 길이는 1 이상 10,000 이하입니다. 모든 트럭의 무게는 1 이상 weight 이하입니다. 입출력 예 bridge_length weight truck_weights return 2 10 [7,4,5,6] 8 100 100 [10] 101 100 100 [10,10,10,10,10,10,10,10,10,10] 110 출처",normal,Math
216,"스트리밍 사이트에서 장르 별로 가장 많이 재생된 노래를 두 개씩 모아 베스트 앨범을 출시하려 합니다. 노래는 고유 번호로 구분하며, 노래를 수록하는 기준은 다음과 같습니다. 속한 노래가 많이 재생된 장르를 먼저 수록합니다. 장르 내에서 많이 재생된 노래를 먼저 수록합니다. 장르 내에서 재생 횟수가 같은 노래 중에서는 고유 번호가 낮은 노래를 먼저 수록합니다. 노래의 장르를 나타내는 문자열 배열 genres와 노래별 재생 횟수를 나타내는 정수 배열 plays가 주어질 때, 베스트 앨범에 들어갈 노래의 고유 번호를 순서대로 return 하도록 solution 함수를 완성하세요. 제한사항 genres[i]는 고유번호가 i인 노래의 장르입니다. plays[i]는 고유번호가 i인 노래가 재생된 횟수입니다. genres와 plays의 길이는 같으며, 이는 1 이상 10,000 이하입니다. 장르 종류는 100개 미만입니다. 장르에 속한 곡이 하나라면, 하나의 곡만 선택합니다. 모든 장르는 재생된 횟수가 다릅니다. 입출력 예 genres plays return [""classic"", ""pop"", ""classic"", ""classic"", ""pop""] [500, 600, 150, 800, 2500] [4, 1, 3, 0] 입출력 예 설명 classic 장르는 1,450회 재생되었으며, classic 노래는 다음과 같습니다. 고유 번호 3: 800회 재생 고유 번호 0: 500회 재생 고유 번호 2: 150회 재생 pop 장르는 3,100회 재생되었으며, pop 노래는 다음과 같습니다. 고유 번호 4: 2,500회 재생 고유 번호 1: 600회 재생 따라서 pop 장르의 [4, 1]번 노래를 먼저, classic 장르의 [3, 0]번 노래를 그다음에 수록합니다. 장르 별로 가장 많이 재생된 노래를 최대 두 개까지 모아 베스트 앨범을 출시하므로 2번 노래는 수록되지 않습니다.",normal,Array
217,"코니는 매일 다른 옷을 조합하여 입는것을 좋아합니다. 예를 들어 코니가 가진 옷이 아래와 같고, 오늘 코니가 동그란 안경, 긴 코트, 파란색 티셔츠를 입었다면 다음날은 청바지를 추가로 입거나 동그란 안경 대신 검정 선글라스를 착용하거나 해야합니다. 종류 이름 얼굴 동그란 안경, 검정 선글라스 상의 파란색 티셔츠 하의 청바지 겉옷 긴 코트 코니는 각 종류별로 최대 1가지 의상만 착용할 수 있습니다. 예를 들어 위 예시의 경우 동그란 안경과 검정 선글라스를 동시에 착용할 수는 없습니다. 착용한 의상의 일부가 겹치더라도, 다른 의상이 겹치지 않거나, 혹은 의상을 추가로 더 착용한 경우에는 서로 다른 방법으로 옷을 착용한 것으로 계산합니다. 코니는 하루에 최소 한 개의 의상은 입습니다. 코니가 가진 의상들이 담긴 2차원 배열 clothes가 주어질 때 서로 다른 옷의 조합의 수를 return 하도록 solution 함수를 작성해주세요. 제한사항 clothes의 각 행은 [의상의 이름, 의상의 종류]로 이루어져 있습니다. 코니가 가진 의상의 수는 1개 이상 30개 이하입니다. 같은 이름을 가진 의상은 존재하지 않습니다. clothes의 모든 원소는 문자열로 이루어져 있습니다. 모든 문자열의 길이는 1 이상 20 이하인 자연수이고 알파벳 소문자 또는 '_' 로만 이루어져 있습니다. 입출력 예 clothes return [[""yellow_hat"", ""headgear""], [""blue_sunglasses"", ""eyewear""], [""green_turban"", ""headgear""]] 5 [[""crow_mask"", ""face""], [""blue_sunglasses"", ""face""], [""smoky_makeup"", ""face""]] 3",normal,Array
218,"전화번호부에 적힌 전화번호 중, 한 번호가 다른 번호의 접두어인 경우가 있는지 확인하려 합니다. 전화번호가 다음과 같을 경우, 구조대 전화번호는 영석이의 전화번호의 접두사입니다. 구조대 : 119 박준영 : 97 674 223 지영석 : 11 9552 4421 전화번호부에 적힌 전화번호를 담은 배열 phone_book 이 solution 함수의 매개변수로 주어질 때, 어떤 번호가 다른 번호의 접두어인 경우가 있으면 false를 그렇지 않으면 true를 return 하도록 solution 함수를 작성해주세요. 제한 사항 phone_book의 길이는 1 이상 1,000,000 이하입니다. 각 전화번호의 길이는 1 이상 20 이하입니다. 같은 전화번호가 중복해서 들어있지 않습니다. 입출력 예제 phone_book return [""119"", ""97674223"", ""1195524421""] false [""123"",""456"",""789""] true [""12"",""123"",""1235"",""567"",""88""] false 입출력 예 설명",normal,Array
219,"N진수 게임 튜브가 활동하는 코딩 동아리에서는 전통적으로 해오는 게임이 있다. 이 게임은 여러 사람이 둥글게 앉아서 숫자를 하나씩 차례대로 말하는 게임인데, 규칙은 다음과 같다. 숫자를 0부터 시작해서 차례대로 말한다. 첫 번째 사람은 0, 두 번째 사람은 1, … 열 번째 사람은 9를 말한다. 10 이상의 숫자부터는 한 자리씩 끊어서 말한다. 즉 열한 번째 사람은 10의 첫 자리인 1, 열두 번째 사람은 둘째 자리인 0을 말한다. 이렇게 게임을 진행할 경우, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 0, 1, 1, 1, 2, 1, 3, 1, 4, … 순으로 숫자를 말하면 된다. 한편 코딩 동아리 일원들은 컴퓨터를 다루는 사람답게 이진수로 이 게임을 진행하기도 하는데, 이 경우에는 0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, … 순으로 숫자를 말하면 된다. 이진수로 진행하는 게임에 익숙해져 질려가던 사람들은 좀 더 난이도를 높이기 위해 이진법에서 십육진법까지 모든 진법으로 게임을 진행해보기로 했다. 숫자 게임이 익숙하지 않은 튜브는 게임에 져서 벌칙을 받는 굴욕을 피하기 위해, 자신이 말해야 하는 숫자를 스마트폰에 미리 출력해주는 프로그램을 만들려고 한다. 튜브의 프로그램을 구현하라. 입력 형식 진법 n, 미리 구할 숫자의 갯수 t, 게임에 참가하는 인원 m, 튜브의 순서 p 가 주어진다. 2 ≦ n ≦ 16 0 ＜ t ≦ 1000 2 ≦ m ≦ 100 1 ≦ p ≦ m 출력 형식 튜브가 말해야 하는 숫자 t개를 공백 없이 차례대로 나타낸 문자열. 단, 10~15는 각각 대문자 A~F로 출력한다. 입출력 예제 n t m p result 2 4 2 1 ""0111"" 16 16 2 1 ""02468ACE11111111"" 16 16 2 2 ""13579BDF01234567"" 해설 보러가기",normal,String
220,"파일명 정렬 세 차례의 코딩 테스트와 두 차례의 면접이라는 기나긴 블라인드 공채를 무사히 통과해 카카오에 입사한 무지는 파일 저장소 서버 관리를 맡게 되었다. 저장소 서버에는 프로그램의 과거 버전을 모두 담고 있어, 이름 순으로 정렬된 파일 목록은 보기가 불편했다. 파일을 이름 순으로 정렬하면 나중에 만들어진 ver-10.zip이 ver-9.zip보다 먼저 표시되기 때문이다. 버전 번호 외에도 숫자가 포함된 파일 목록은 여러 면에서 관리하기 불편했다. 예컨대 파일 목록이 [""img12.png"", ""img10.png"", ""img2.png"", ""img1.png""]일 경우, 일반적인 정렬은 [""img1.png"", ""img10.png"", ""img12.png"", ""img2.png""] 순이 되지만, 숫자 순으로 정렬된 [""img1.png"", ""img2.png"", ""img10.png"", img12.png""] 순이 훨씬 자연스럽다. 무지는 단순한 문자 코드 순이 아닌, 파일명에 포함된 숫자를 반영한 정렬 기능을 저장소 관리 프로그램에 구현하기로 했다. 소스 파일 저장소에 저장된 파일명은 100 글자 이내로, 영문 대소문자, 숫자, 공백("" ""), 마침표("".""), 빼기 부호(""-"")만으로 이루어져 있다. 파일명은 영문자로 시작하며, 숫자를 하나 이상 포함하고 있다. 파일명은 크게 HEAD, NUMBER, TAIL의 세 부분으로 구성된다. HEAD는 숫자가 아닌 문자로 이루어져 있으며, 최소한 한 글자 이상이다. NUMBER는 한 글자에서 최대 다섯 글자 사이의 연속된 숫자로 이루어져 있으며, 앞쪽에 0이 올 수 있다. 0부터 99999 사이의 숫자로, 00000이나 0101 등도 가능하다. TAIL은 그 나머지 부분으로, 여기에는 숫자가 다시 나타날 수도 있으며, 아무 글자도 없을 수 있다. 파일명 HEAD NUMBER TAIL foo9.txt foo 9 .txt foo010bar020.zip foo 010 bar020.zip F-15 F- 15 (빈 문자열) 파일명을 세 부분으로 나눈 후, 다음 기준에 따라 파일명을 정렬한다. 파일명은 우선 HEAD 부분을 기준으로 사전 순으로 정렬한다. 이때, 문자열 비교 시 대소문자 구분을 하지 않는다. MUZI와 muzi, MuZi는 정렬 시에 같은 순서로 취급된다. 파일명의 HEAD 부분이 대소문자 차이 외에는 같을 경우, NUMBER의 숫자 순으로 정렬한다. 9 < 10 < 0011 < 012 < 13 < 014 순으로 정렬된다. 숫자 앞의 0은 무시되며, 012와 12는 정렬 시에 같은 같은 값으로 처리된다. 두 파일의 HEAD 부분과, NUMBER의 숫자도 같을 경우, 원래 입력에 주어진 순서를 유지한다. MUZI01.zip과 muzi1.png가 입력으로 들어오면, 정렬 후에도 입력 시 주어진 두 파일의 순서가 바뀌어서는 안 된다. 무지를 도와 파일명 정렬 프로그램을 구현하라. 입력 형식 입력으로 배열 files가 주어진다. files는 1000 개 이하의 파일명을 포함하는 문자열 배열이다. 각 파일명은 100 글자 이하 길이로, 영문 대소문자, 숫자, 공백("" ""), 마침표("".""), 빼기 부호(""-"")만으로 이루어져 있다. 파일명은 영문자로 시작하며, 숫자를 하나 이상 포함하고 있다. 중복된 파일명은 없으나, 대소문자나 숫자 앞부분의 0 차이가 있는 경우는 함께 주어질 수 있다. (muzi1.txt, MUZI1.txt, muzi001.txt, muzi1.TXT는 함께 입력으로 주어질 수 있다.) 출력 형식 위 기준에 따라 정렬된 배열을 출력한다. 입출력 예제 입력: [""img12.png"", ""img10.png"", ""img02.png"", ""img1.png"", ""IMG01.GIF"", ""img2.JPG""] 출력: [""img1.png"", ""IMG01.GIF"", ""img02.png"", ""img2.JPG"", ""img10.png"", ""img12.png""] 입력: [""F-5 Freedom Fighter"", ""B-50 Superfortress"", ""A-10 Thunderbolt II"", ""F-14 Tomcat""] 출력: [""A-10 Thunderbolt II"", ""B-50 Superfortress"", ""F-5 Freedom Fighter"", ""F-14 Tomcat""] 해설 보러가기",normal,Array
221,"자동완성 포털 다음에서 검색어 자동완성 기능을 넣고 싶은 라이언은 한 번 입력된 문자열을 학습해서 다음 입력 때 활용하고 싶어 졌다. 예를 들어, go 가 한 번 입력되었다면, 다음 사용자는 g 만 입력해도 go를 추천해주므로 o를 입력할 필요가 없어진다! 단, 학습에 사용된 단어들 중 앞부분이 같은 경우에는 어쩔 수 없이 다른 문자가 나올 때까지 입력을 해야 한다. 효과가 얼마나 좋을지 알고 싶은 라이언은 학습된 단어들을 찾을 때 몇 글자를 입력해야 하는지 궁금해졌다. 예를 들어, 학습된 단어들이 아래와 같을 때 go gone guild go를 찾을 때 go를 모두 입력해야 한다. gone을 찾을 때 gon 까지 입력해야 한다. (gon이 입력되기 전까지는 go 인지 gone인지 확신할 수 없다.) guild를 찾을 때는 gu 까지만 입력하면 guild가 완성된다. 이 경우 총 입력해야 할 문자의 수는 7이다. 라이언을 도와 위와 같이 문자열이 입력으로 주어지면 학습을 시킨 후, 학습된 단어들을 순서대로 찾을 때 몇 개의 문자를 입력하면 되는지 계산하는 프로그램을 만들어보자. 입력 형식 학습과 검색에 사용될 중복 없는 단어 N개가 주어진다. 모든 단어는 알파벳 소문자로 구성되며 단어의 수 N과 단어들의 길이의 총합 L의 범위는 다음과 같다. 2 <= N <= 100,000 2 <= L <= 1,000,000 출력 형식 단어를 찾을 때 입력해야 할 총 문자수를 리턴한다. 입출력 예제 words result [""go"",""gone"",""guild""] 7 [""abc"",""def"",""ghi"",""jklm""] 4 [""word"",""war"",""warrior"",""world""] 15 입출력 설명 첫 번째 예제는 본문 설명과 같다. 두 번째 예제에서는 모든 단어들이 공통된 부분이 없으므로, 가장 앞글자만 입력하면 된다. 세 번째 예제는 총 15 자를 입력해야 하고 설명은 아래와 같다. word는 word모두 입력해야 한다. war는 war 까지 모두 입력해야 한다. warrior는 warr 까지만 입력하면 된다. world는 worl까지 입력해야 한다. (word와 구분되어야 함을 명심하자) 해설 보러가기",hard,String
222,"압축 신입사원 어피치는 카카오톡으로 전송되는 메시지를 압축하여 전송 효율을 높이는 업무를 맡게 되었다. 메시지를 압축하더라도 전달되는 정보가 바뀌어서는 안 되므로, 압축 전의 정보를 완벽하게 복원 가능한 무손실 압축 알고리즘을 구현하기로 했다. 어피치는 여러 압축 알고리즘 중에서 성능이 좋고 구현이 간단한 LZW(Lempel–Ziv–Welch) 압축을 구현하기로 했다. LZW 압축은 1983년 발표된 알고리즘으로, 이미지 파일 포맷인 GIF 등 다양한 응용에서 사용되었다. LZW 압축은 다음 과정을 거친다. 길이가 1인 모든 단어를 포함하도록 사전을 초기화한다. 사전에서 현재 입력과 일치하는 가장 긴 문자열 w를 찾는다. w에 해당하는 사전의 색인 번호를 출력하고, 입력에서 w를 제거한다. 입력에서 처리되지 않은 다음 글자가 남아있다면(c), w+c에 해당하는 단어를 사전에 등록한다. 단계 2로 돌아간다. 압축 알고리즘이 영문 대문자만 처리한다고 할 때, 사전은 다음과 같이 초기화된다. 사전의 색인 번호는 정수값으로 주어지며, 1부터 시작한다고 하자. 색인 번호 1 2 3 ... 24 25 26 단어 A B C ... X Y Z 예를 들어 입력으로 KAKAO가 들어온다고 하자. 현재 사전에는 KAKAO의 첫 글자 K는 등록되어 있으나, 두 번째 글자까지인 KA는 없으므로, 첫 글자 K에 해당하는 색인 번호 11을 출력하고, 다음 글자인 A를 포함한 KA를 사전에 27 번째로 등록한다. 두 번째 글자 A는 사전에 있으나, 세 번째 글자까지인 AK는 사전에 없으므로, A의 색인 번호 1을 출력하고, AK를 사전에 28 번째로 등록한다. 세 번째 글자에서 시작하는 KA가 사전에 있으므로, KA에 해당하는 색인 번호 27을 출력하고, 다음 글자 O를 포함한 KAO를 29 번째로 등록한다. 마지막으로 처리되지 않은 글자 O에 해당하는 색인 번호 15를 출력한다. 현재 입력(w) 다음 글자(c) 출력 사전 추가(w+c) K A 11 27: KA A K 1 28: AK KA O 27 29: KAO O 15 이 과정을 거쳐 다섯 글자의 문장 KAKAO가 4개의 색인 번호 [11, 1, 27, 15]로 압축된다. 입력으로 TOBEORNOTTOBEORTOBEORNOT가 들어오면 다음과 같이 압축이 진행된다. 현재 입력(w) 다음 글자(c) 출력 사전 추가(w+c) T O 20 27: TO O B 15 28: OB B E 2 29: BE E O 5 30: EO O R 15 31: OR R N 18 32: RN N O 14 33: NO O T 15 34: OT T T 20 35: TT TO B 27 36: TOB BE O 29 37: BEO OR T 31 38: ORT TOB E 36 39: TOBE EO R 30 40: EOR RN O 32 41: RNO OT 34 입력 형식 입력으로 영문 대문자로만 이뤄진 문자열 msg가 주어진다. msg의 길이는 1 글자 이상, 1000 글자 이하이다. 출력 형식 주어진 문자열을 압축한 후의 사전 색인 번호를 배열로 출력하라. 입출력 예제 msg answer KAKAO [11, 1, 27, 15] TOBEORNOTTOBEORTOBEORNOT [20, 15, 2, 5, 15, 18, 14, 15, 20, 27, 29, 31, 36, 30, 32, 34] ABABABABABABABAB [1, 2, 27, 29, 28, 31, 30] 해설 보러가기",normal,Array
223,"방금그곡 라디오를 자주 듣는 네오는 라디오에서 방금 나왔던 음악이 무슨 음악인지 궁금해질 때가 많다. 그럴 때 네오는 다음 포털의 '방금그곡' 서비스를 이용하곤 한다. 방금그곡에서는 TV, 라디오 등에서 나온 음악에 관해 제목 등의 정보를 제공하는 서비스이다. 네오는 자신이 기억한 멜로디를 가지고 방금그곡을 이용해 음악을 찾는다. 그런데 라디오 방송에서는 한 음악을 반복해서 재생할 때도 있어서 네오가 기억하고 있는 멜로디는 음악 끝부분과 처음 부분이 이어서 재생된 멜로디일 수도 있다. 반대로, 한 음악을 중간에 끊을 경우 원본 음악에는 네오가 기억한 멜로디가 들어있다 해도 그 곡이 네오가 들은 곡이 아닐 수도 있다. 그렇기 때문에 네오는 기억한 멜로디를 재생 시간과 제공된 악보를 직접 보면서 비교하려고 한다. 다음과 같은 가정을 할 때 네오가 찾으려는 음악의 제목을 구하여라. 방금그곡 서비스에서는 음악 제목, 재생이 시작되고 끝난 시각, 악보를 제공한다. 네오가 기억한 멜로디와 악보에 사용되는 음은 C, C#, D, D#, E, F, F#, G, G#, A, A#, B 12개이다. 각 음은 1분에 1개씩 재생된다. 음악은 반드시 처음부터 재생되며 음악 길이보다 재생된 시간이 길 때는 음악이 끊김 없이 처음부터 반복해서 재생된다. 음악 길이보다 재생된 시간이 짧을 때는 처음부터 재생 시간만큼만 재생된다. 음악이 00:00를 넘겨서까지 재생되는 일은 없다. 조건이 일치하는 음악이 여러 개일 때에는 라디오에서 재생된 시간이 제일 긴 음악 제목을 반환한다. 재생된 시간도 같을 경우 먼저 입력된 음악 제목을 반환한다. 조건이 일치하는 음악이 없을 때에는 “(None)”을 반환한다. 입력 형식 입력으로 네오가 기억한 멜로디를 담은 문자열 m과 방송된 곡의 정보를 담고 있는 배열 musicinfos가 주어진다. m은 음 1개 이상 1439개 이하로 구성되어 있다. musicinfos는 100개 이하의 곡 정보를 담고 있는 배열로, 각각의 곡 정보는 음악이 시작한 시각, 끝난 시각, 음악 제목, 악보 정보가 ','로 구분된 문자열이다. 음악의 시작 시각과 끝난 시각은 24시간 HH:MM 형식이다. 음악 제목은 ',' 이외의 출력 가능한 문자로 표현된 길이 1 이상 64 이하의 문자열이다. 악보 정보는 음 1개 이상 1439개 이하로 구성되어 있다. 출력 형식 조건과 일치하는 음악 제목을 출력한다. 입출력 예시 m musicinfos answer ""ABCDEFG"" [""12:00,12:14,HELLO,CDEFGAB"", ""13:00,13:05,WORLD,ABCDEF""] ""HELLO"" ""CC#BCC#BCC#BCC#B"" [""03:00,03:30,FOO,CC#B"", ""04:00,04:08,BAR,CC#BCC#BCC#B""] ""FOO"" ""ABC"" [""12:00,12:14,HELLO,C#DEFGAB"", ""13:00,13:05,WORLD,ABCDEF""] ""WORLD"" 설명 첫 번째 예시에서 HELLO는 길이가 7분이지만 12:00부터 12:14까지 재생되었으므로 실제로 CDEFGABCDEFGAB로 재생되었고, 이 중에 기억한 멜로디인 ABCDEFG가 들어있다. 세 번째 예시에서 HELLO는 C#DEFGABC#DEFGAB로, WORLD는 ABCDE로 재생되었다. HELLO 안에 있는 ABC#은 기억한 멜로디인 ABC와 일치하지 않고, WORLD 안에 있는 ABC가 기억한 멜로디와 일치한다. 해설 보러가기",normal,Array
224,"캐시 지도개발팀에서 근무하는 제이지는 지도에서 도시 이름을 검색하면 해당 도시와 관련된 맛집 게시물들을 데이터베이스에서 읽어 보여주는 서비스를 개발하고 있다. 이 프로그램의 테스팅 업무를 담당하고 있는 어피치는 서비스를 오픈하기 전 각 로직에 대한 성능 측정을 수행하였는데, 제이지가 작성한 부분 중 데이터베이스에서 게시물을 가져오는 부분의 실행시간이 너무 오래 걸린다는 것을 알게 되었다. 어피치는 제이지에게 해당 로직을 개선하라고 닦달하기 시작하였고, 제이지는 DB 캐시를 적용하여 성능 개선을 시도하고 있지만 캐시 크기를 얼마로 해야 효율적인지 몰라 난감한 상황이다. 어피치에게 시달리는 제이지를 도와, DB 캐시를 적용할 때 캐시 크기에 따른 실행시간 측정 프로그램을 작성하시오. 입력 형식 캐시 크기(cacheSize)와 도시이름 배열(cities)을 입력받는다. cacheSize는 정수이며, 범위는 0 ≦ cacheSize ≦ 30 이다. cities는 도시 이름으로 이뤄진 문자열 배열로, 최대 도시 수는 100,000개이다. 각 도시 이름은 공백, 숫자, 특수문자 등이 없는 영문자로 구성되며, 대소문자 구분을 하지 않는다. 도시 이름은 최대 20자로 이루어져 있다. 출력 형식 입력된 도시이름 배열을 순서대로 처리할 때, ""총 실행시간""을 출력한다. 조건 캐시 교체 알고리즘은 LRU(Least Recently Used)를 사용한다. cache hit일 경우 실행시간은 1이다. cache miss일 경우 실행시간은 5이다. 입출력 예제 캐시크기(cacheSize) 도시이름(cities) 실행시간 3 [""Jeju"", ""Pangyo"", ""Seoul"", ""NewYork"", ""LA"", ""Jeju"", ""Pangyo"", ""Seoul"", ""NewYork"", ""LA""] 50 3 [""Jeju"", ""Pangyo"", ""Seoul"", ""Jeju"", ""Pangyo"", ""Seoul"", ""Jeju"", ""Pangyo"", ""Seoul""] 21 2 [""Jeju"", ""Pangyo"", ""Seoul"", ""NewYork"", ""LA"", ""SanFrancisco"", ""Seoul"", ""Rome"", ""Paris"", ""Jeju"", ""NewYork"", ""Rome""] 60 5 [""Jeju"", ""Pangyo"", ""Seoul"", ""NewYork"", ""LA"", ""SanFrancisco"", ""Seoul"", ""Rome"", ""Paris"", ""Jeju"", ""NewYork"", ""Rome""] 52 2 [""Jeju"", ""Pangyo"", ""NewYork"", ""newyork""] 16 0 [""Jeju"", ""Pangyo"", ""Seoul"", ""NewYork"", ""LA""] 25 해설 보러가기",normal,Array
225,"프렌즈4블록 블라인드 공채를 통과한 신입 사원 라이언은 신규 게임 개발 업무를 맡게 되었다. 이번에 출시할 게임 제목은 ""프렌즈4블록"". 같은 모양의 카카오프렌즈 블록이 2×2 형태로 4개가 붙어있을 경우 사라지면서 점수를 얻는 게임이다. 만약 판이 위와 같이 주어질 경우, 라이언이 2×2로 배치된 7개 블록과 콘이 2×2로 배치된 4개 블록이 지워진다. 같은 블록은 여러 2×2에 포함될 수 있으며, 지워지는 조건에 만족하는 2×2 모양이 여러 개 있다면 한꺼번에 지워진다. 블록이 지워진 후에 위에 있는 블록이 아래로 떨어져 빈 공간을 채우게 된다. 만약 빈 공간을 채운 후에 다시 2×2 형태로 같은 모양의 블록이 모이면 다시 지워지고 떨어지고를 반복하게 된다. 위 초기 배치를 문자로 표시하면 아래와 같다. TTTANT RRFACC RRRFCC TRRRAA TTMMMF TMMTTJ 각 문자는 라이언(R), 무지(M), 어피치(A), 프로도(F), 네오(N), 튜브(T), 제이지(J), 콘(C)을 의미한다 입력으로 블록의 첫 배치가 주어졌을 때, 지워지는 블록은 모두 몇 개인지 판단하는 프로그램을 제작하라. 입력 형식 입력으로 판의 높이 m, 폭 n과 판의 배치 정보 board가 들어온다. 2 ≦ n, m ≦ 30 board는 길이 n인 문자열 m개의 배열로 주어진다. 블록을 나타내는 문자는 대문자 A에서 Z가 사용된다. 출력 형식 입력으로 주어진 판 정보를 가지고 몇 개의 블록이 지워질지 출력하라. 입출력 예제 m n board answer 4 5 [""CCBDE"", ""AAADE"", ""AAABF"", ""CCBBF""] 14 6 6 [""TTTANT"", ""RRFACC"", ""RRRFCC"", ""TRRRAA"", ""TTMMMF"", ""TMMTTJ""] 15 예제에 대한 설명 입출력 예제 1의 경우, 첫 번째에는 A 블록 6개가 지워지고, 두 번째에는 B 블록 4개와 C 블록 4개가 지워져, 모두 14개의 블록이 지워진다. 입출력 예제 2는 본문 설명에 있는 그림을 옮긴 것이다. 11개와 4개의 블록이 차례로 지워지며, 모두 15개의 블록이 지워진다. 해설 보러가기",normal,Array
226,"셔틀버스 카카오에서는 무료 셔틀버스를 운행하기 때문에 판교역에서 편하게 사무실로 올 수 있다. 카카오의 직원은 서로를 '크루'라고 부르는데, 아침마다 많은 크루들이 이 셔틀을 이용하여 출근한다. 이 문제에서는 편의를 위해 셔틀은 다음과 같은 규칙으로 운행한다고 가정하자. 셔틀은 09:00부터 총 n회 t분 간격으로 역에 도착하며, 하나의 셔틀에는 최대 m명의 승객이 탈 수 있다. 셔틀은 도착했을 때 도착한 순간에 대기열에 선 크루까지 포함해서 대기 순서대로 태우고 바로 출발한다. 예를 들어 09:00에 도착한 셔틀은 자리가 있다면 09:00에 줄을 선 크루도 탈 수 있다. 일찍 나와서 셔틀을 기다리는 것이 귀찮았던 콘은, 일주일간의 집요한 관찰 끝에 어떤 크루가 몇 시에 셔틀 대기열에 도착하는지 알아냈다. 콘이 셔틀을 타고 사무실로 갈 수 있는 도착 시각 중 제일 늦은 시각을 구하여라. 단, 콘은 게으르기 때문에 같은 시각에 도착한 크루 중 대기열에서 제일 뒤에 선다. 또한, 모든 크루는 잠을 자야 하므로 23:59에 집에 돌아간다. 따라서 어떤 크루도 다음날 셔틀을 타는 일은 없다. 입력 형식 셔틀 운행 횟수 n, 셔틀 운행 간격 t, 한 셔틀에 탈 수 있는 최대 크루 수 m, 크루가 대기열에 도착하는 시각을 모은 배열 timetable이 입력으로 주어진다. 0 ＜ n ≦ 10 0 ＜ t ≦ 60 0 ＜ m ≦ 45 timetable은 최소 길이 1이고 최대 길이 2000인 배열로, 하루 동안 크루가 대기열에 도착하는 시각이 HH:MM 형식으로 이루어져 있다. 크루의 도착 시각 HH:MM은 00:01에서 23:59 사이이다. 출력 형식 콘이 무사히 셔틀을 타고 사무실로 갈 수 있는 제일 늦은 도착 시각을 출력한다. 도착 시각은 HH:MM 형식이며, 00:00에서 23:59 사이의 값이 될 수 있다. 입출력 예제 n t m timetable answer 1 1 5 [""08:00"", ""08:01"", ""08:02"", ""08:03""] ""09:00"" 2 10 2 [""09:10"", ""09:09"", ""08:00""] ""09:09"" 2 1 2 [""09:00"", ""09:00"", ""09:00"", ""09:00""] ""08:59"" 1 1 5 [""00:01"", ""00:01"", ""00:01"", ""00:01"", ""00:01""] ""00:00"" 1 1 1 [""23:59""] ""09:00"" 10 60 45 [""23:59"",""23:59"", ""23:59"", ""23:59"", ""23:59"", ""23:59"", ""23:59"", ""23:59"", ""23:59"", ""23:59"", ""23:59"", ""23:59"", ""23:59"", ""23:59"", ""23:59"", ""23:59""] ""18:00"" 해설 보러가기",normal,Array
227,"뉴스 클러스터링 여러 언론사에서 쏟아지는 뉴스, 특히 속보성 뉴스를 보면 비슷비슷한 제목의 기사가 많아 정작 필요한 기사를 찾기가 어렵다. Daum 뉴스의 개발 업무를 맡게 된 신입사원 튜브는 사용자들이 편리하게 다양한 뉴스를 찾아볼 수 있도록 문제점을 개선하는 업무를 맡게 되었다. 개발의 방향을 잡기 위해 튜브는 우선 최근 화제가 되고 있는 ""카카오 신입 개발자 공채"" 관련 기사를 검색해보았다. 카카오 첫 공채..'블라인드' 방식 채용 카카오, 합병 후 첫 공채.. 블라인드 전형으로 개발자 채용 카카오, 블라인드 전형으로 신입 개발자 공채 카카오 공채, 신입 개발자 코딩 능력만 본다 카카오, 신입 공채.. ""코딩 실력만 본다"" 카카오 ""코딩 능력만으로 2018 신입 개발자 뽑는다"" 기사의 제목을 기준으로 ""블라인드 전형""에 주목하는 기사와 ""코딩 테스트""에 주목하는 기사로 나뉘는 걸 발견했다. 튜브는 이들을 각각 묶어서 보여주면 카카오 공채 관련 기사를 찾아보는 사용자에게 유용할 듯싶었다. 유사한 기사를 묶는 기준을 정하기 위해서 논문과 자료를 조사하던 튜브는 ""자카드 유사도""라는 방법을 찾아냈다. 자카드 유사도는 집합 간의 유사도를 검사하는 여러 방법 중의 하나로 알려져 있다. 두 집합 A, B 사이의 자카드 유사도 J(A, B)는 두 집합의 교집합 크기를 두 집합의 합집합 크기로 나눈 값으로 정의된다. 예를 들어 집합 A = {1, 2, 3}, 집합 B = {2, 3, 4}라고 할 때, 교집합 A ∩ B = {2, 3}, 합집합 A ∪ B = {1, 2, 3, 4}이 되므로, 집합 A, B 사이의 자카드 유사도 J(A, B) = 2/4 = 0.5가 된다. 집합 A와 집합 B가 모두 공집합일 경우에는 나눗셈이 정의되지 않으니 따로 J(A, B) = 1로 정의한다. 자카드 유사도는 원소의 중복을 허용하는 다중집합에 대해서 확장할 수 있다. 다중집합 A는 원소 ""1""을 3개 가지고 있고, 다중집합 B는 원소 ""1""을 5개 가지고 있다고 하자. 이 다중집합의 교집합 A ∩ B는 원소 ""1""을 min(3, 5)인 3개, 합집합 A ∪ B는 원소 ""1""을 max(3, 5)인 5개 가지게 된다. 다중집합 A = {1, 1, 2, 2, 3}, 다중집합 B = {1, 2, 2, 4, 5}라고 하면, 교집합 A ∩ B = {1, 2, 2}, 합집합 A ∪ B = {1, 1, 2, 2, 3, 4, 5}가 되므로, 자카드 유사도 J(A, B) = 3/7, 약 0.42가 된다. 이를 이용하여 문자열 사이의 유사도를 계산하는데 이용할 수 있다. 문자열 ""FRANCE""와 ""FRENCH""가 주어졌을 때, 이를 두 글자씩 끊어서 다중집합을 만들 수 있다. 각각 {FR, RA, AN, NC, CE}, {FR, RE, EN, NC, CH}가 되며, 교집합은 {FR, NC}, 합집합은 {FR, RA, AN, NC, CE, RE, EN, CH}가 되므로, 두 문자열 사이의 자카드 유사도 J(""FRANCE"", ""FRENCH"") = 2/8 = 0.25가 된다. 입력 형식 입력으로는 str1과 str2의 두 문자열이 들어온다. 각 문자열의 길이는 2 이상, 1,000 이하이다. 입력으로 들어온 문자열은 두 글자씩 끊어서 다중집합의 원소로 만든다. 이때 영문자로 된 글자 쌍만 유효하고, 기타 공백이나 숫자, 특수 문자가 들어있는 경우는 그 글자 쌍을 버린다. 예를 들어 ""ab+""가 입력으로 들어오면, ""ab""만 다중집합의 원소로 삼고, ""b+""는 버린다. 다중집합 원소 사이를 비교할 때, 대문자와 소문자의 차이는 무시한다. ""AB""와 ""Ab"", ""ab""는 같은 원소로 취급한다. 출력 형식 입력으로 들어온 두 문자열의 자카드 유사도를 출력한다. 유사도 값은 0에서 1 사이의 실수이므로, 이를 다루기 쉽도록 65536을 곱한 후에 소수점 아래를 버리고 정수부만 출력한다. 예제 입출력 str1 str2 answer FRANCE french 16384 handshake shake hands 65536 aa1+aa2 AAAA12 43690 E=M*C^2 e=m*c^2 65536 해설 보러가기",normal,String
228,"추석 트래픽 이번 추석에도 시스템 장애가 없는 명절을 보내고 싶은 어피치는 서버를 증설해야 할지 고민이다. 장애 대비용 서버 증설 여부를 결정하기 위해 작년 추석 기간인 9월 15일 로그 데이터를 분석한 후 초당 최대 처리량을 계산해보기로 했다. 초당 최대 처리량은 요청의 응답 완료 여부에 관계없이 임의 시간부터 1초(=1,000밀리초)간 처리하는 요청의 최대 개수를 의미한다. 입력 형식 solution 함수에 전달되는 lines 배열은 N(1 ≦ N ≦ 2,000)개의 로그 문자열로 되어 있으며, 각 로그 문자열마다 요청에 대한 응답완료시간 S와 처리시간 T가 공백으로 구분되어 있다. 응답완료시간 S는 작년 추석인 2016년 9월 15일만 포함하여 고정 길이 2016-09-15 hh:mm:ss.sss 형식으로 되어 있다. 처리시간 T는 0.1s, 0.312s, 2s 와 같이 최대 소수점 셋째 자리까지 기록하며 뒤에는 초 단위를 의미하는 s로 끝난다. 예를 들어, 로그 문자열 2016-09-15 03:10:33.020 0.011s은 ""2016년 9월 15일 오전 3시 10분 33.010초""부터 ""2016년 9월 15일 오전 3시 10분 33.020초""까지 ""0.011초"" 동안 처리된 요청을 의미한다. (처리시간은 시작시간과 끝시간을 포함) 서버에는 타임아웃이 3초로 적용되어 있기 때문에 처리시간은 0.001 ≦ T ≦ 3.000이다. lines 배열은 응답완료시간 S를 기준으로 오름차순 정렬되어 있다. 출력 형식 solution 함수에서는 로그 데이터 lines 배열에 대해 초당 최대 처리량을 리턴한다. 입출력 예제 예제1 입력: [ ""2016-09-15 01:00:04.001 2.0s"", ""2016-09-15 01:00:07.000 2s"" ] 출력: 1 예제2 입력: [ ""2016-09-15 01:00:04.002 2.0s"", ""2016-09-15 01:00:07.000 2s"" ] 출력: 2 설명: 처리시간은 시작시간과 끝시간을 포함하므로 첫 번째 로그는 01:00:02.003 ~ 01:00:04.002에서 2초 동안 처리되었으며, 두 번째 로그는 01:00:05.001 ~ 01:00:07.000에서 2초 동안 처리된다. 따라서, 첫 번째 로그가 끝나는 시점과 두 번째 로그가 시작하는 시점의 구간인 01:00:04.002 ~ 01:00:05.001 1초 동안 최대 2개가 된다. 예제3 입력: [ ""2016-09-15 20:59:57.421 0.351s"", ""2016-09-15 20:59:58.233 1.181s"", ""2016-09-15 20:59:58.299 0.8s"", ""2016-09-15 20:59:58.688 1.041s"", ""2016-09-15 20:59:59.591 1.412s"", ""2016-09-15 21:00:00.464 1.466s"", ""2016-09-15 21:00:00.741 1.581s"", ""2016-09-15 21:00:00.748 2.31s"", ""2016-09-15 21:00:00.966 0.381s"", ""2016-09-15 21:00:02.066 2.62s"" ] 출력: 7 설명: 아래 타임라인 그림에서 빨간색으로 표시된 1초 각 구간의 처리량을 구해보면 (1)은 4개, (2)는 7개, (3)는 2개임을 알 수 있다. 따라서 초당 최대 처리량은 7이 되며, 동일한 최대 처리량을 갖는 1초 구간은 여러 개 존재할 수 있으므로 이 문제에서는 구간이 아닌 개수만 출력한다. 해설 보러가기",normal,Array
229,"xx 회사의 2xN명의 사원들은 N명씩 두 팀으로 나눠 숫자 게임을 하려고 합니다. 두 개의 팀을 각각 A팀과 B팀이라고 하겠습니다. 숫자 게임의 규칙은 다음과 같습니다. 먼저 모든 사원이 무작위로 자연수를 하나씩 부여받습니다. 각 사원은 딱 한 번씩 경기를 합니다. 각 경기당 A팀에서 한 사원이, B팀에서 한 사원이 나와 서로의 수를 공개합니다. 그때 숫자가 큰 쪽이 승리하게 되고, 승리한 사원이 속한 팀은 승점을 1점 얻게 됩니다. 만약 숫자가 같다면 누구도 승점을 얻지 않습니다. 전체 사원들은 우선 무작위로 자연수를 하나씩 부여받았습니다. 그다음 A팀은 빠르게 출전순서를 정했고 자신들의 출전 순서를 B팀에게 공개해버렸습니다. B팀은 그것을 보고 자신들의 최종 승점을 가장 높이는 방법으로 팀원들의 출전 순서를 정했습니다. 이때의 B팀이 얻는 승점을 구해주세요. A 팀원들이 부여받은 수가 출전 순서대로 나열되어있는 배열 A와 i번째 원소가 B팀의 i번 팀원이 부여받은 수를 의미하는 배열 B가 주어질 때, B 팀원들이 얻을 수 있는 최대 승점을 return 하도록 solution 함수를 완성해주세요. 제한사항 A와 B의 길이는 같습니다. A와 B의 길이는 1 이상 100,000 이하입니다. A와 B의 각 원소는 1 이상 1,000,000,000 이하의 자연수입니다. 입출력 예 A B result [5,1,3,7] [2,2,6,8] 3 [2,2,2,2] [1,1,1,1] 0 입출력 예 설명",normal,Array
230,"△△ 게임대회가 개최되었습니다. 이 대회는 N명이 참가하고, 토너먼트 형식으로 진행됩니다. N명의 참가자는 각각 1부터 N번을 차례대로 배정받습니다. 그리고, 1번↔2번, 3번↔4번, ... , N-1번↔N번의 참가자끼리 게임을 진행합니다. 각 게임에서 이긴 사람은 다음 라운드에 진출할 수 있습니다. 이때, 다음 라운드에 진출할 참가자의 번호는 다시 1번부터 N/2번을 차례대로 배정받습니다. 만약 1번↔2번 끼리 겨루는 게임에서 2번이 승리했다면 다음 라운드에서 1번을 부여받고, 3번↔4번에서 겨루는 게임에서 3번이 승리했다면 다음 라운드에서 2번을 부여받게 됩니다. 게임은 최종 한 명이 남을 때까지 진행됩니다. 이때, 처음 라운드에서 A번을 가진 참가자는 경쟁자로 생각하는 B번 참가자와 몇 번째 라운드에서 만나는지 궁금해졌습니다. 게임 참가자 수 N, 참가자 번호 A, 경쟁자 번호 B가 함수 solution의 매개변수로 주어질 때, 처음 라운드에서 A번을 가진 참가자는 경쟁자로 생각하는 B번 참가자와 몇 번째 라운드에서 만나는지 return 하는 solution 함수를 완성해 주세요. 단, A번 참가자와 B번 참가자는 서로 붙게 되기 전까지 항상 이긴다고 가정합니다. 제한사항 N : 21 이상 220 이하인 자연수 (2의 지수 승으로 주어지므로 부전승은 발생하지 않습니다.) A, B : N 이하인 자연수 (단, A ≠ B 입니다.) 입출력 예 N A B answer 8 4 7 3 입출력 예 설명",normal,Math
231,"XX 게임에서는 지형 편집 기능을 이용하여 플레이어가 직접 게임 속 지형을 수정할 수 있습니다. 이 게임에서는 1 x 1 x 1 크기의 정육면체 블록을 쌓아 게임 속 지형을 표현합니다. 이때, 블록이 공중에 떠 있거나, 블록 하나가 여러 개의 칸에 걸쳐 놓일 수는 없습니다. 따라서 지형을 편집하기 위해서는 각 칸의 제일 위에 블록 1개를 새로 추가하거나, 제일 위에 있는 블록 한 개를 삭제하는 방식으로 지형을 수정해야 합니다. 이때, 블록 한 개를 새로 추가하거나 삭제하기 위해서는 게임머니를 사용해야 하므로 몇 개의 블록을 추가하고 삭제할지 신중한 선택이 필요합니다. 이 게임을 즐기던 한 플레이어는 N x N 크기의 지역에 자신만의 별장을 만들고 싶어졌습니다. 이를 위해서는 울퉁불퉁한 지형의 모든 칸의 높이가 같아지도록 만들어야 합니다. 이때, 블록 한 개를 추가하려면 P의 비용이, 제거하려면 Q의 비용이 들게 됩니다. 다음은 블록 한 개를 추가할 때 5의 비용이, 제거할 때 3의 비용이 드는 경우, 3 x 3 넓이의 모든 칸의 블록 높이가 같아지도록 만드는 예시입니다. 위 그림과 같이 지형 블록이 놓여 있는 경우 모든 칸의 높이가 3으로 같아지도록 한다면 다음과 같은 모양이 됩니다. 이를 위해서는 3보다 높은 칸의 블록 2개를 제거하고, 3보다 낮은 칸에 총 8개의 블록을 추가해야 하며, 2 x 3 + 8 x 5 = 46의 비용이 들게 됩니다. 그러나 아래 그림과 같이 모든 칸의 높이가 2로 같아지도록 할 때는 6개의 블록을 제거하고, 3개의 블록을 추가하면 6 x 3 + 3 x 5 = 33의 비용이 들게 되며, 이때가 최소비용이 됩니다. 현재 지형의 상태를 나타내는 배열 land와 블록 한 개를 추가하는 데 필요한 비용 P, 블록 한 개를 제거하는 데 필요한 비용 Q가 매개변수로 주어질 때, 모든 칸에 쌓여있는 블록의 높이가 같아지도록 하는 데 필요한 비용의 최솟값을 return 하도록 solution 함수를 완성해 주세요. 제한사항 land는 N x N 크기의 2차원 배열이며, N의 범위는 1 ≤ N ≤ 300입니다. land의 각 원소는 각 칸에 놓여 있는 블록의 수를 나타내며, 0 이상 10억 이하의 정수입니다. 각 칸에 블록 하나를 추가하는 데는 P, 제거하는 데는 Q의 비용이 들며, P, Q의 범위는 1 ≤ P, Q ≤ 100인 자연수입니다. 입출력 예 land P Q result [[1, 2], [2, 3]] 3 2 5 [[4, 4, 3], [3, 2, 2], [ 2, 1, 0 ]] 5 3 33 입출력 예 설명",hard,Array
232,"단어 퍼즐은 주어진 단어 조각들을 이용해서 주어진 문장을 완성하는 퍼즐입니다. 이때, 주어진 각 단어 조각들은 각각 무한개씩 있다고 가정합니다. 예를 들어 주어진 단어 조각이 [“ba”, “na”, “n”, “a”]인 경우 ""ba"", ""na"", ""n"", ""a"" 단어 조각이 각각 무한개씩 있습니다. 이때, 만들어야 하는 문장이 “banana”라면 “ba”, “na”, “n”, “a”의 4개를 사용하여 문장을 완성할 수 있지만, “ba”, “na”, “na”의 3개만을 사용해도 “banana”를 완성할 수 있습니다. 사용 가능한 단어 조각들을 담고 있는 배열 strs와 완성해야 하는 문자열 t가 매개변수로 주어질 때, 주어진 문장을 완성하기 위해 사용해야 하는 단어조각 개수의 최솟값을 return 하도록 solution 함수를 완성해 주세요. 만약 주어진 문장을 완성하는 것이 불가능하면 -1을 return 하세요. 제한사항 strs는 사용 가능한 단어 조각들이 들어있는 배열로, 길이는 1 이상 100 이하입니다. strs의 각 원소는 사용 가능한 단어조각들이 중복 없이 들어있습니다. 사용 가능한 단어 조각들은 문자열 형태이며, 모든 단어 조각의 길이는 1 이상 5 이하입니다. t는 완성해야 하는 문자열이며 길이는 1 이상 20,000 이하입니다. 모든 문자열은 알파벳 소문자로만 이루어져 있습니다. 입출력 예 strs t result [""ba"",""na"",""n"",""a""] ""banana"" 3 [""app"",""ap"",""p"",""l"",""e"",""ple"",""pp""] ""apple"" 2 [""ba"",""an"",""nan"",""ban"",""n""] ""banana"" -1 입출력 예 설명",hard,Array
233,"1부터 n까지 번호가 붙어있는 n명의 사람이 영어 끝말잇기를 하고 있습니다. 영어 끝말잇기는 다음과 같은 규칙으로 진행됩니다. 1번부터 번호 순서대로 한 사람씩 차례대로 단어를 말합니다. 마지막 사람이 단어를 말한 다음에는 다시 1번부터 시작합니다. 앞사람이 말한 단어의 마지막 문자로 시작하는 단어를 말해야 합니다. 이전에 등장했던 단어는 사용할 수 없습니다. 한 글자인 단어는 인정되지 않습니다. 다음은 3명이 끝말잇기를 하는 상황을 나타냅니다. tank → kick → know → wheel → land → dream → mother → robot → tank 위 끝말잇기는 다음과 같이 진행됩니다. 1번 사람이 자신의 첫 번째 차례에 tank를 말합니다. 2번 사람이 자신의 첫 번째 차례에 kick을 말합니다. 3번 사람이 자신의 첫 번째 차례에 know를 말합니다. 1번 사람이 자신의 두 번째 차례에 wheel을 말합니다. (계속 진행) 끝말잇기를 계속 진행해 나가다 보면, 3번 사람이 자신의 세 번째 차례에 말한 tank 라는 단어는 이전에 등장했던 단어이므로 탈락하게 됩니다. 사람의 수 n과 사람들이 순서대로 말한 단어 words 가 매개변수로 주어질 때, 가장 먼저 탈락하는 사람의 번호와 그 사람이 자신의 몇 번째 차례에 탈락하는지를 구해서 return 하도록 solution 함수를 완성해주세요. 제한 사항 끝말잇기에 참여하는 사람의 수 n은 2 이상 10 이하의 자연수입니다. words는 끝말잇기에 사용한 단어들이 순서대로 들어있는 배열이며, 길이는 n 이상 100 이하입니다. 단어의 길이는 2 이상 50 이하입니다. 모든 단어는 알파벳 소문자로만 이루어져 있습니다. 끝말잇기에 사용되는 단어의 뜻(의미)은 신경 쓰지 않으셔도 됩니다. 정답은 [ 번호, 차례 ] 형태로 return 해주세요. 만약 주어진 단어들로 탈락자가 생기지 않는다면, [0, 0]을 return 해주세요. 입출력 예 n words result 3 [""tank"", ""kick"", ""know"", ""wheel"", ""land"", ""dream"", ""mother"", ""robot"", ""tank""] [3,3] 5 [""hello"", ""observe"", ""effect"", ""take"", ""either"", ""recognize"", ""encourage"", ""ensure"", ""establish"", ""hang"", ""gather"", ""refer"", ""reference"", ""estimate"", ""executive""] [0,0] 2 [""hello"", ""one"", ""even"", ""never"", ""now"", ""world"", ""draw""] [1,3] 입출력 예 설명",normal,Array
234,"OO 연구소는 한 번에 K 칸을 앞으로 점프하거나, (현재까지 온 거리) x 2 에 해당하는 위치로 순간이동을 할 수 있는 특수한 기능을 가진 아이언 슈트를 개발하여 판매하고 있습니다. 이 아이언 슈트는 건전지로 작동되는데, 순간이동을 하면 건전지 사용량이 줄지 않지만, 앞으로 K 칸을 점프하면 K 만큼의 건전지 사용량이 듭니다. 그러므로 아이언 슈트를 착용하고 이동할 때는 순간 이동을 하는 것이 더 효율적입니다. 아이언 슈트 구매자는 아이언 슈트를 착용하고 거리가 N 만큼 떨어져 있는 장소로 가려고 합니다. 단, 건전지 사용량을 줄이기 위해 점프로 이동하는 것은 최소로 하려고 합니다. 아이언 슈트 구매자가 이동하려는 거리 N이 주어졌을 때, 사용해야 하는 건전지 사용량의 최솟값을 return하는 solution 함수를 만들어 주세요. 예를 들어 거리가 5만큼 떨어져 있는 장소로 가려고 합니다. 아이언 슈트를 입고 거리가 5만큼 떨어져 있는 장소로 갈 수 있는 경우의 수는 여러 가지입니다. 처음 위치 0 에서 5 칸을 앞으로 점프하면 바로 도착하지만, 건전지 사용량이 5 만큼 듭니다. 처음 위치 0 에서 2 칸을 앞으로 점프한 다음 순간이동 하면 (현재까지 온 거리 : 2) x 2에 해당하는 위치로 이동할 수 있으므로 위치 4로 이동합니다. 이때 1 칸을 앞으로 점프하면 도착하므로 건전지 사용량이 3 만큼 듭니다. 처음 위치 0 에서 1 칸을 앞으로 점프한 다음 순간이동 하면 (현재까지 온 거리 : 1) x 2에 해당하는 위치로 이동할 수 있으므로 위치 2로 이동됩니다. 이때 다시 순간이동 하면 (현재까지 온 거리 : 2) x 2 만큼 이동할 수 있으므로 위치 4로 이동합니다. 이때 1 칸을 앞으로 점프하면 도착하므로 건전지 사용량이 2 만큼 듭니다. 위의 3가지 경우 거리가 5만큼 떨어져 있는 장소로 가기 위해서 3번째 경우가 건전지 사용량이 가장 적으므로 답은 2가 됩니다. 제한 사항 숫자 N: 1 이상 10억 이하의 자연수 숫자 K: 1 이상의 자연수 입출력 예 N result 5 2 6 2 5000 5 입출력 예 설명",normal,Math
235,"N개의 아파트가 일렬로 쭉 늘어서 있습니다. 이 중에서 일부 아파트 옥상에는 4g 기지국이 설치되어 있습니다. 기술이 발전해 5g 수요가 높아져 4g 기지국을 5g 기지국으로 바꾸려 합니다. 그런데 5g 기지국은 4g 기지국보다 전달 범위가 좁아, 4g 기지국을 5g 기지국으로 바꾸면 어떤 아파트에는 전파가 도달하지 않습니다. 예를 들어 11개의 아파트가 쭉 늘어서 있고, [4, 11] 번째 아파트 옥상에는 4g 기지국이 설치되어 있습니다. 만약 이 4g 기지국이 전파 도달 거리가 1인 5g 기지국으로 바뀔 경우 모든 아파트에 전파를 전달할 수 없습니다. (전파의 도달 거리가 W일 땐, 기지국이 설치된 아파트를 기준으로 전파를 양쪽으로 W만큼 전달할 수 있습니다.) 초기에, 1, 2, 6, 7, 8, 9번째 아파트에는 전파가 전달되지 않습니다. 1, 7, 9번째 아파트 옥상에 기지국을 설치할 경우, 모든 아파트에 전파를 전달할 수 있습니다. 더 많은 아파트 옥상에 기지국을 설치하면 모든 아파트에 전파를 전달할 수 있습니다. 이때, 우리는 5g 기지국을 최소로 설치하면서 모든 아파트에 전파를 전달하려고 합니다. 위의 예시에선 최소 3개의 아파트 옥상에 기지국을 설치해야 모든 아파트에 전파를 전달할 수 있습니다. 아파트의 개수 N, 현재 기지국이 설치된 아파트의 번호가 담긴 1차원 배열 stations, 전파의 도달 거리 W가 매개변수로 주어질 때, 모든 아파트에 전파를 전달하기 위해 증설해야 할 기지국 개수의 최솟값을 리턴하는 solution 함수를 완성해주세요 제한사항 N: 200,000,000 이하의 자연수 stations의 크기: 10,000 이하의 자연수 stations는 오름차순으로 정렬되어 있고, 배열에 담긴 수는 N보다 같거나 작은 자연수입니다. W: 10,000 이하의 자연수 입출력 예 N stations W answer 11 [4, 11] 1 3 16 [9] 2 3 입출력 예 설명",normal,Array
236,"N개의 마을로 이루어진 나라가 있습니다. 이 나라의 각 마을에는 1부터 N까지의 번호가 각각 하나씩 부여되어 있습니다. 각 마을은 양방향으로 통행할 수 있는 도로로 연결되어 있는데, 서로 다른 마을 간에 이동할 때는 이 도로를 지나야 합니다. 도로를 지날 때 걸리는 시간은 도로별로 다릅니다. 현재 1번 마을에 있는 음식점에서 각 마을로 음식 배달을 하려고 합니다. 각 마을로부터 음식 주문을 받으려고 하는데, N개의 마을 중에서 K 시간 이하로 배달이 가능한 마을에서만 주문을 받으려고 합니다. 다음은 N = 5, K = 3인 경우의 예시입니다. 위 그림에서 1번 마을에 있는 음식점은 [1, 2, 4, 5] 번 마을까지는 3 이하의 시간에 배달할 수 있습니다. 그러나 3번 마을까지는 3시간 이내로 배달할 수 있는 경로가 없으므로 3번 마을에서는 주문을 받지 않습니다. 따라서 1번 마을에 있는 음식점이 배달 주문을 받을 수 있는 마을은 4개가 됩니다. 마을의 개수 N, 각 마을을 연결하는 도로의 정보 road, 음식 배달이 가능한 시간 K가 매개변수로 주어질 때, 음식 주문을 받을 수 있는 마을의 개수를 return 하도록 solution 함수를 완성해주세요. 제한사항 마을의 개수 N은 1 이상 50 이하의 자연수입니다. road의 길이(도로 정보의 개수)는 1 이상 2,000 이하입니다. road의 각 원소는 마을을 연결하고 있는 각 도로의 정보를 나타냅니다. road는 길이가 3인 배열이며, 순서대로 (a, b, c)를 나타냅니다. a, b(1 ≤ a, b ≤ N, a != b)는 도로가 연결하는 두 마을의 번호이며, c(1 ≤ c ≤ 10,000, c는 자연수)는 도로를 지나는데 걸리는 시간입니다. 두 마을 a, b를 연결하는 도로는 여러 개가 있을 수 있습니다. 한 도로의 정보가 여러 번 중복해서 주어지지 않습니다. K는 음식 배달이 가능한 시간을 나타내며, 1 이상 500,000 이하입니다. 임의의 두 마을간에 항상 이동 가능한 경로가 존재합니다. 1번 마을에 있는 음식점이 K 이하의 시간에 배달이 가능한 마을의 개수를 return 하면 됩니다. 입출력 예 N road K result 5 [[1,2,1],[2,3,3],[5,2,2],[1,4,2],[5,3,1],[5,4,2]] 3 4 6 [[1,2,1],[1,3,2],[2,3,2],[3,4,3],[3,5,2],[3,5,3],[5,6,1]] 4 4 입출력 예 설명",normal,Array
237,"평면 위에 N개의 직사각형이 놓여있습니다. 직사각형의 각 변은 x축, y축에 평행합니다. 각각의 직사각형은 왼쪽 아래 좌표(x1, y1)과 오른쪽 위 좌표 (x2, y2)를 가지며, (x1, y1, x2, y2)로 나타내고, 서로 겹쳐있을 수 있습니다. 이때 이 직사각형들이 차지하는 면적을 구하려고 합니다. 다음은 N = 5인 경우의 예시입니다. 위 그림에는 5개의 직사각형 (1, 1, 6, 5), (2, 0, 4, 2), (2, 4, 5, 7), (4, 3, 8, 6), (7, 5, 9, 7) 이 놓여있습니다. 이때 전체 직사각형이 덮고 있는 면적은 아래 그림의 검은 테두리 안쪽의 면적과 같습니다. 따라서 위 예시에서 5개의 직사각형이 덮고 있는 면적은 38이 됩니다. 평면 위에 놓여있는 직사각형들의 좌표가 매개변수 rectangles로 주어질 때, 직사각형들이 덮고 있는 면적의 넓이를 return하도록 solution 합수를 완성해 주세요. 제한사항 직사각형의 개수 N : 1 ≤ N ≤ 100,000 직사각형의 좌표 x1, y1, x2, y2 : 0 ≤ x1 < x2 ≤ 109 , 0 ≤ y1 < y2 ≤ 109 x1, y1, x2, y2는 정수 입출력 예 rectangles result [[0, 1, 4, 4], [3, 1, 5, 3]] 14 [[1, 1, 6, 5], [2, 0, 4, 2], [2, 4, 5, 7], [4, 3, 8, 6], [7, 5, 9, 7]] 38 입출력 예 설명",hard,Math
238,"짝지어 제거하기는, 알파벳 소문자로 이루어진 문자열을 가지고 시작합니다. 먼저 문자열에서 같은 알파벳이 2개 붙어 있는 짝을 찾습니다. 그다음, 그 둘을 제거한 뒤, 앞뒤로 문자열을 이어 붙입니다. 이 과정을 반복해서 문자열을 모두 제거한다면 짝지어 제거하기가 종료됩니다. 문자열 S가 주어졌을 때, 짝지어 제거하기를 성공적으로 수행할 수 있는지 반환하는 함수를 완성해 주세요. 성공적으로 수행할 수 있으면 1을, 아닐 경우 0을 리턴해주면 됩니다. 예를 들어, 문자열 S = baabaa 라면 b aa baa → bb aa → aa → 의 순서로 문자열을 모두 제거할 수 있으므로 1을 반환합니다. 제한사항 문자열의 길이 : 1,000,000이하의 자연수 문자열은 모두 소문자로 이루어져 있습니다. 입출력 예 s result baabaa 1 cdcd 0 입출력 예 설명",normal,String
239,"N개의 스티커가 원형으로 연결되어 있습니다. 다음 그림은 N = 8인 경우의 예시입니다. 원형으로 연결된 스티커에서 몇 장의 스티커를 뜯어내어 뜯어낸 스티커에 적힌 숫자의 합이 최대가 되도록 하고 싶습니다. 단 스티커 한 장을 뜯어내면 양쪽으로 인접해있는 스티커는 찢어져서 사용할 수 없게 됩니다. 예를 들어 위 그림에서 14가 적힌 스티커를 뜯으면 인접해있는 10, 6이 적힌 스티커는 사용할 수 없습니다. 스티커에 적힌 숫자가 배열 형태로 주어질 때, 스티커를 뜯어내어 얻을 수 있는 숫자의 합의 최댓값을 return 하는 solution 함수를 완성해 주세요. 원형의 스티커 모양을 위해 배열의 첫 번째 원소와 마지막 원소가 서로 연결되어 있다고 간주합니다. 제한 사항 sticker는 원형으로 연결된 스티커의 각 칸에 적힌 숫자가 순서대로 들어있는 배열로, 길이(N)는 1 이상 100,000 이하입니다. sticker의 각 원소는 스티커의 각 칸에 적힌 숫자이며, 각 칸에 적힌 숫자는 1 이상 100 이하의 자연수입니다. 원형의 스티커 모양을 위해 sticker 배열의 첫 번째 원소와 마지막 원소가 서로 연결되어있다고 간주합니다. 입출력 예 sticker answer [14, 6, 5, 11, 3, 9, 2, 10] 36 [1, 3, 2, 5, 4] 8 입출력 예 설명",normal,Array
240,"두 수의 최소공배수(Least Common Multiple)란 입력된 두 수의 배수 중 공통이 되는 가장 작은 숫자를 의미합니다. 예를 들어 2와 7의 최소공배수는 14가 됩니다. 정의를 확장해서, n개의 수의 최소공배수는 n 개의 수들의 배수 중 공통이 되는 가장 작은 숫자가 됩니다. n개의 숫자를 담은 배열 arr이 입력되었을 때 이 수들의 최소공배수를 반환하는 함수, solution을 완성해 주세요. 제한 사항 arr은 길이 1이상, 15이하인 배열입니다. arr의 원소는 100 이하인 자연수입니다. 입출력 예 arr result [2,6,8,14] 168 [1,2,3] 6",normal,Array
241,"가로, 세로 길이가 n인 정사각형으로된 체스판이 있습니다. 체스판 위의 n개의 퀸이 서로를 공격할 수 없도록 배치하고 싶습니다. 예를 들어서 n이 4인경우 다음과 같이 퀸을 배치하면 n개의 퀸은 서로를 한번에 공격 할 수 없습니다. 체스판의 가로 세로의 세로의 길이 n이 매개변수로 주어질 때, n개의 퀸이 조건에 만족 하도록 배치할 수 있는 방법의 수를 return하는 solution함수를 완성해주세요. 제한사항 퀸(Queen)은 가로, 세로, 대각선으로 이동할 수 있습니다. n은 12이하의 자연수 입니다. 입출력 예 n result 4 2 입출력 예 설명",normal,Simulation
242,"JadenCase란 모든 단어의 첫 문자가 대문자이고, 그 외의 알파벳은 소문자인 문자열입니다. 단, 첫 문자가 알파벳이 아닐 때에는 이어지는 알파벳은 소문자로 쓰면 됩니다. (첫 번째 입출력 예 참고) 문자열 s가 주어졌을 때, s를 JadenCase로 바꾼 문자열을 리턴하는 함수, solution을 완성해주세요. 제한 조건 s는 길이 1 이상 200 이하인 문자열입니다. s는 알파벳과 숫자, 공백문자("" "")로 이루어져 있습니다. 숫자는 단어의 첫 문자로만 나옵니다. 숫자로만 이루어진 단어는 없습니다. 공백문자가 연속해서 나올 수 있습니다. 입출력 예 s return ""3people unFollowed me"" ""3people Unfollowed Me"" ""for the last week"" ""For The Last Week""",normal,String
243,"2차원 행렬 arr1과 arr2를 입력받아, arr1에 arr2를 곱한 결과를 반환하는 함수, solution을 완성해주세요. 제한 조건 행렬 arr1, arr2의 행과 열의 길이는 2 이상 100 이하입니다. 행렬 arr1, arr2의 원소는 -10 이상 20 이하인 자연수입니다. 곱할 수 있는 배열만 주어집니다. 입출력 예 arr1 arr2 return [[1, 4], [3, 2], [4, 1]] [[3, 3], [3, 3]] [[15, 15], [15, 15], [15, 15]] [[2, 3, 2], [4, 2, 4], [3, 1, 4]] [[5, 4, 3], [2, 4, 1], [3, 1, 1]] [[22, 22, 11], [36, 28, 18], [29, 20, 14]]",normal,Array
244,"하노이 탑(Tower of Hanoi)은 퍼즐의 일종입니다. 세 개의 기둥과 이 기동에 꽂을 수 있는 크기가 다양한 원판들이 있고, 퍼즐을 시작하기 전에는 한 기둥에 원판들이 작은 것이 위에 있도록 순서대로 쌓여 있습니다. 게임의 목적은 다음 두 가지 조건을 만족시키면서, 한 기둥에 꽂힌 원판들을 그 순서 그대로 다른 기둥으로 옮겨서 다시 쌓는 것입니다. 한 번에 하나의 원판만 옮길 수 있습니다. 큰 원판이 작은 원판 위에 있어서는 안됩니다. 하노이 탑의 세 개의 기둥을 왼쪽 부터 1번, 2번, 3번이라고 하겠습니다. 1번에는 n개의 원판이 있고 이 n개의 원판을 3번 원판으로 최소 횟수로 옮기려고 합니다. 1번 기둥에 있는 원판의 개수 n이 매개변수로 주어질 때, n개의 원판을 3번 원판으로 최소로 옮기는 방법을 return하는 solution를 완성해주세요. 제한사항 n은 15이하의 자연수 입니다. 입출력 예 n result 2 [ [1,2], [1,3], [2,3] ] 입출력 예 설명",normal,Math
245,"피보나치 수는 F(0) = 0, F(1) = 1일 때, 1 이상의 n에 대하여 F(n) = F(n-1) + F(n-2) 가 적용되는 수 입니다. 예를들어 F(2) = F(0) + F(1) = 0 + 1 = 1 F(3) = F(1) + F(2) = 1 + 1 = 2 F(4) = F(2) + F(3) = 1 + 2 = 3 F(5) = F(3) + F(4) = 2 + 3 = 5 와 같이 이어집니다. 2 이상의 n이 입력되었을 때, n번째 피보나치 수를 1234567으로 나눈 나머지를 리턴하는 함수, solution을 완성해 주세요. 제한 사항 n은 2 이상 100,000 이하인 자연수입니다. 입출력 예 n return 3 2 5 5 입출력 예 설명 피보나치수는 0번째부터 0, 1, 1, 2, 3, 5, ... 와 같이 이어집니다. 문제가 잘 안풀린다면😢 힌트가 필요한가요? [코딩테스트 연습 힌트 모음집]으로 오세요! → 클릭",normal,Math
246,"크기가 a by b인 행렬과 크기가 b by c 인 행렬이 있을 때, 두 행렬을 곱하기 위해서는 총 a x b x c 번 곱셈해야합니다. 예를 들어서 크기가 5 by 3인 행렬과 크기가 3 by 2인 행렬을 곱할때는 총 5 x 3 x 2 = 30번의 곱하기 연산을 해야 합니다. 행렬이 2개일 때는 연산 횟수가 일정 하지만, 행렬의 개수가 3개 이상일 때는 연산의 순서에 따라서 곱하기 연산의 횟수가 바뀔 수 있습니다. 예를 들어서 크기가 5 by 3인 행렬 A, 크기가 3 by 10인 행렬 B, 크기가 10 by 6인 행렬 C가 있을 때, 순서대로 A와 B를 먼저 곱하고, 그 결과에 C를 곱하면 A와 B행렬을 곱할 때 150번을, AB 에 C를 곱할 때 300번을 연산을 해서 총 450번의 곱하기 연산을 합니다. 하지만, B와 C를 먼저 곱한 다음 A 와 BC를 곱하면 180 + 90 = 270번 만에 연산이 끝납니다. 각 행렬의 크기 matrix_sizes 가 매개변수로 주어 질 때, 모든 행렬을 곱하기 위한 최소 곱셈 연산의 수를 return하는 solution 함수를 완성해 주세요. 제한 사항 행렬의 개수는 3이상 200이하의 자연수입니다. 각 행렬의 행과 열의 크기는 200이하의 자연수 입니다. 계산을 할 수 없는 행렬은 입력으로 주어지지 않습니다. 입출력 예 matrix_sizes result [[5,3],[3,10],[10,6]] 270 입출력 예 설명",normal,Math
247,"길이가 같은 배열 A, B 두개가 있습니다. 각 배열은 자연수로 이루어져 있습니다. 배열 A, B에서 각각 한 개의 숫자를 뽑아 두 수를 곱합니다. 이러한 과정을 배열의 길이만큼 반복하며, 두 수를 곱한 값을 누적하여 더합니다. 이때 최종적으로 누적된 값이 최소가 되도록 만드는 것이 목표입니다. (단, 각 배열에서 k번째 숫자를 뽑았다면 다음에 k번째 숫자는 다시 뽑을 수 없습니다.) 예를 들어 A = [1, 4, 2] , B = [5, 4, 4] 라면 A에서 첫번째 숫자인 1, B에서 첫번째 숫자인 5를 뽑아 곱하여 더합니다. (누적된 값 : 0 + 5(1x5) = 5) A에서 두번째 숫자인 4, B에서 세번째 숫자인 4를 뽑아 곱하여 더합니다. (누적된 값 : 5 + 16(4x4) = 21) A에서 세번째 숫자인 2, B에서 두번째 숫자인 4를 뽑아 곱하여 더합니다. (누적된 값 : 21 + 8(2x4) = 29) 즉, 이 경우가 최소가 되므로 29를 return 합니다. 배열 A, B가 주어질 때 최종적으로 누적된 최솟값을 return 하는 solution 함수를 완성해 주세요. 제한사항 배열 A, B의 크기 : 1,000 이하의 자연수 배열 A, B의 원소의 크기 : 1,000 이하의 자연수 입출력 예 A B answer [1, 4, 2] [5, 4, 4] 29 [1,2] [3,4] 10 입출력 예 설명",normal,Array
248,"문자열 s에는 공백으로 구분된 숫자들이 저장되어 있습니다. str에 나타나는 숫자 중 최소값과 최대값을 찾아 이를 ""(최소값) (최대값)""형태의 문자열을 반환하는 함수, solution을 완성하세요. 예를들어 s가 ""1 2 3 4""라면 ""1 4""를 리턴하고, ""-1 -2 -3 -4""라면 ""-4 -1""을 리턴하면 됩니다. 제한 조건 s에는 둘 이상의 정수가 공백으로 구분되어 있습니다. 입출력 예 s return ""1 2 3 4"" ""1 4"" ""-1 -2 -3 -4"" ""-4 -1"" ""-1 -1"" ""-1 -1""",normal,String
249,"자연수 n 개로 이루어진 중복 집합(multi set, 편의상 이후에는 ""집합""으로 통칭) 중에 다음 두 조건을 만족하는 집합을 최고의 집합이라고 합니다. 각 원소의 합이 S가 되는 수의 집합 위 조건을 만족하면서 각 원소의 곱 이 최대가 되는 집합 예를 들어서 자연수 2개로 이루어진 집합 중 합이 9가 되는 집합은 다음과 같이 4개가 있습니다. { 1, 8 }, { 2, 7 }, { 3, 6 }, { 4, 5 } 그중 각 원소의 곱이 최대인 { 4, 5 }가 최고의 집합입니다. 집합의 원소의 개수 n과 모든 원소들의 합 s가 매개변수로 주어질 때, 최고의 집합을 return 하는 solution 함수를 완성해주세요. 제한사항 최고의 집합은 오름차순으로 정렬된 1차원 배열(list, vector) 로 return 해주세요. 만약 최고의 집합이 존재하지 않는 경우에 크기가 1인 1차원 배열(list, vector) 에 -1 을 채워서 return 해주세요. 자연수의 개수 n은 1 이상 10,000 이하의 자연수입니다. 모든 원소들의 합 s는 1 이상, 100,000,000 이하의 자연수입니다. 입출력 예 n s result 2 9 [4, 5] 2 1 [-1] 2 8 [4, 4] 입출력 예 설명",normal,Array
250,"n명의 사람이 일렬로 줄을 서고 있습니다. n명의 사람들에게는 각각 1번부터 n번까지 번호가 매겨져 있습니다. n명이 사람을 줄을 서는 방법은 여러가지 방법이 있습니다. 예를 들어서 3명의 사람이 있다면 다음과 같이 6개의 방법이 있습니다. [1, 2, 3] [1, 3, 2] [2, 1, 3] [2, 3, 1] [3, 1, 2] [3, 2, 1] 사람의 수 n과, 자연수 k가 주어질 때, 사람을 나열 하는 방법을 사전 순으로 나열 했을 때, k번째 방법을 return하는 solution 함수를 완성해주세요. 제한사항 n은 20이하의 자연수 입니다. k는 n! 이하의 자연수 입니다. 입출력 예 n k result 3 5 [3,1,2] 입출력 예시 설명",normal,Design
251,"올바른 괄호란 (())나 ()와 같이 올바르게 모두 닫힌 괄호를 의미합니다. )(나 ())() 와 같은 괄호는 올바르지 않은 괄호가 됩니다. 괄호 쌍의 개수 n이 주어질 때, n개의 괄호 쌍으로 만들 수 있는 모든 가능한 괄호 문자열의 갯수를 반환하는 함수 solution을 완성해 주세요. 제한사항 괄호 쌍의 개수 N : 1 ≤ n ≤ 14, N은 정수 입출력 예 n result 2 2 3 5 입출력 예 설명",hard,String
252,"회사원 Demi는 가끔은 야근을 하는데요, 야근을 하면 야근 피로도가 쌓입니다. 야근 피로도는 야근을 시작한 시점에서 남은 일의 작업량을 제곱하여 더한 값입니다. Demi는 N시간 동안 야근 피로도를 최소화하도록 일할 겁니다.Demi가 1시간 동안 작업량 1만큼을 처리할 수 있다고 할 때, 퇴근까지 남은 N 시간과 각 일에 대한 작업량 works에 대해 야근 피로도를 최소화한 값을 리턴하는 함수 solution을 완성해주세요. 제한 사항 works는 길이 1 이상, 20,000 이하인 배열입니다. works의 원소는 50000 이하인 자연수입니다. n은 1,000,000 이하인 자연수입니다. 입출력 예 works n result [4, 3, 3] 4 12 [2, 1, 2] 1 6 [1,1] 3 0 입출력 예 설명",normal,Array
253,"Finn은 요즘 수학공부에 빠져 있습니다. 수학 공부를 하던 Finn은 자연수 n을 연속한 자연수들로 표현 하는 방법이 여러개라는 사실을 알게 되었습니다. 예를들어 15는 다음과 같이 4가지로 표현 할 수 있습니다. 1 + 2 + 3 + 4 + 5 = 15 4 + 5 + 6 = 15 7 + 8 = 15 15 = 15 자연수 n이 매개변수로 주어질 때, 연속된 자연수들로 n을 표현하는 방법의 수를 return하는 solution를 완성해주세요. 제한사항 n은 10,000 이하의 자연수 입니다. 입출력 예 n result 15 4 입출력 예 설명",normal,Math
254,"그렙시에는 숫자 0이 적힌 블록들이 설치된 도로에 다른 숫자가 적힌 블록들을 설치하기로 하였습니다. 숫자 블록을 설치하는 규칙은 다음과 같습니다. 블록에 적힌 번호가 n 일 때, 가장 첫 블록은 n * 2번째 위치에 설치합니다. 그 다음은 n * 3, 그 다음은 n * 4, ...위치에 설치합니다. 기존에 설치된 블록은 빼고 새로운 블록을 집어넣습니다. 블록은 1이 적힌 블록부터 숫자를 1씩 증가시키며 순서대로 설치합니다. 예를 들어 1이 적힌 블록은 2, 3, 4, 5, ... 인 위치에 우선 설치합니다. 그 다음 2가 적힌 블록은 4, 6, 8, 10, ... 인 위치에 설치하고, 3이 적힌 블록은 6, 9, 12... 인 위치에 설치합니다. 이렇게 3이 적힌 블록까지 설치하고 나면 첫 10개의 블록에 적힌 번호는 [0, 1, 1, 2, 1, 3, 1, 2, 3, 2]가 됩니다. 그렙시는 길이가 1,000,000,000인 도로에 1부터 10,000,000까지의 숫자가 적힌 블록들을 이용해 위의 규칙대로 모두 설치 했습니다. 그렙시의 시장님은 특정 구간에 어떤 블록이 깔려 있는지 알고 싶습니다. 구간을 나타내는 두 정수 begin, end 가 매개변수로 주어 질 때, 그 구간에 깔려 있는 블록의 숫자 배열을 return하는 solution 함수를 완성해 주세요. 제한 사항 1 ≤ begin ≤ end ≤ 1,000,000,000 end - begin ≤ 5,000 입출력 예 begin end result 1 10 [0, 1, 1, 2, 1, 3, 1, 4, 3, 5] 입출력 예 설명",normal,Array
255,"처리해야 할 동일한 작업이 n 개가 있고, 이를 처리하기 위한 CPU가 있습니다. 이 CPU는 다음과 같은 특징이 있습니다. CPU에는 여러 개의 코어가 있고, 코어별로 한 작업을 처리하는 시간이 다릅니다. 한 코어에서 작업이 끝나면 작업이 없는 코어가 바로 다음 작업을 수행합니다. 2개 이상의 코어가 남을 경우 앞의 코어부터 작업을 처리 합니다. 처리해야 될 작업의 개수 n과, 각 코어의 처리시간이 담긴 배열 cores 가 매개변수로 주어질 때, 마지막 작업을 처리하는 코어의 번호를 return 하는 solution 함수를 완성해주세요. 제한 사항 코어의 수는 10,000 이하 2이상 입니다. 코어당 작업을 처리하는 시간은 10,000이하 입니다. 처리해야 하는 일의 개수는 50,000개를 넘기지 않습니다. 입출력 예 n cores result 6 [1,2,3] 2 입출력 예 설명",normal,Array
256,"효진이는 멀리 뛰기를 연습하고 있습니다. 효진이는 한번에 1칸, 또는 2칸을 뛸 수 있습니다. 칸이 총 4개 있을 때, 효진이는 (1칸, 1칸, 1칸, 1칸) (1칸, 2칸, 1칸) (1칸, 1칸, 2칸) (2칸, 1칸, 1칸) (2칸, 2칸) 의 5가지 방법으로 맨 끝 칸에 도달할 수 있습니다. 멀리뛰기에 사용될 칸의 수 n이 주어질 때, 효진이가 끝에 도달하는 방법이 몇 가지인지 알아내, 여기에 1234567를 나눈 나머지를 리턴하는 함수, solution을 완성하세요. 예를 들어 4가 입력된다면, 5를 return하면 됩니다. 제한 사항 n은 1 이상, 2000 이하인 정수입니다. 입출력 예 n result 4 5 3 3 입출력 예 설명",normal,Math
257,"땅따먹기 게임을 하려고 합니다. 땅따먹기 게임의 땅(land)은 총 N행 4열로 이루어져 있고, 모든 칸에는 점수가 쓰여 있습니다. 1행부터 땅을 밟으며 한 행씩 내려올 때, 각 행의 4칸 중 한 칸만 밟으면서 내려와야 합니다. 단, 땅따먹기 게임에는 한 행씩 내려올 때, 같은 열을 연속해서 밟을 수 없는 특수 규칙이 있습니다. 예를 들면, | 1 | 2 | 3 | 5 | | 5 | 6 | 7 | 8 | | 4 | 3 | 2 | 1 | 로 땅이 주어졌다면, 1행에서 네번째 칸 (5)를 밟았으면, 2행의 네번째 칸 (8)은 밟을 수 없습니다. 마지막 행까지 모두 내려왔을 때, 얻을 수 있는 점수의 최대값을 return하는 solution 함수를 완성해 주세요. 위 예의 경우, 1행의 네번째 칸 (5), 2행의 세번째 칸 (7), 3행의 첫번째 칸 (4) 땅을 밟아 16점이 최고점이 되므로 16을 return 하면 됩니다. 제한사항 행의 개수 N : 100,000 이하의 자연수 열의 개수는 4개이고, 땅(land)은 2차원 배열로 주어집니다. 점수 : 100 이하의 자연수 입출력 예 land answer [[1,2,3,5],[5,6,7,8],[4,3,2,1]] 16 입출력 예 설명",normal,Array
258,"자연수 n이 주어졌을 때, n의 다음 큰 숫자는 다음과 같이 정의 합니다. 조건 1. n의 다음 큰 숫자는 n보다 큰 자연수 입니다. 조건 2. n의 다음 큰 숫자와 n은 2진수로 변환했을 때 1의 갯수가 같습니다. 조건 3. n의 다음 큰 숫자는 조건 1, 2를 만족하는 수 중 가장 작은 수 입니다. 예를 들어서 78(1001110)의 다음 큰 숫자는 83(1010011)입니다. 자연수 n이 매개변수로 주어질 때, n의 다음 큰 숫자를 return 하는 solution 함수를 완성해주세요. 제한 사항 n은 1,000,000 이하의 자연수 입니다. 입출력 예 n result 78 83 15 23 입출력 예 설명",normal,Math
259,"괄호가 바르게 짝지어졌다는 것은 '(' 문자로 열렸으면 반드시 짝지어서 ')' 문자로 닫혀야 한다는 뜻입니다. 예를 들어 ""()()"" 또는 ""(())()"" 는 올바른 괄호입니다. "")()("" 또는 ""(()("" 는 올바르지 않은 괄호입니다. '(' 또는 ')' 로만 이루어진 문자열 s가 주어졌을 때, 문자열 s가 올바른 괄호이면 true를 return 하고, 올바르지 않은 괄호이면 false를 return 하는 solution 함수를 완성해 주세요. 제한사항 문자열 s의 길이 : 100,000 이하의 자연수 문자열 s는 '(' 또는 ')' 로만 이루어져 있습니다. 입출력 예 s answer ""()()"" true ""(())()"" true "")()("" false ""(()("" false 입출력 예 설명",normal,String
260,"Finn은 편의점에서 야간 아르바이트를 하고 있습니다. 야간에 손님이 너무 없어 심심한 Finn은 손님들께 거스름돈을 n 원을 줄 때 방법의 경우의 수를 구하기로 하였습니다. 예를 들어서 손님께 5원을 거슬러 줘야 하고 1원, 2원, 5원이 있다면 다음과 같이 4가지 방법으로 5원을 거슬러 줄 수 있습니다. 1원을 5개 사용해서 거슬러 준다. 1원을 3개 사용하고, 2원을 1개 사용해서 거슬러 준다. 1원을 1개 사용하고, 2원을 2개 사용해서 거슬러 준다. 5원을 1개 사용해서 거슬러 준다. 거슬러 줘야 하는 금액 n과 Finn이 현재 보유하고 있는 돈의 종류 money가 매개변수로 주어질 때, Finn이 n 원을 거슬러 줄 방법의 수를 return 하도록 solution 함수를 완성해 주세요. 제한 사항 n은 100,000 이하의 자연수입니다. 화폐 단위는 100종류 이하입니다. 모든 화폐는 무한하게 있다고 가정합니다. 정답이 커질 수 있으니, 1,000,000,007로 나눈 나머지를 return 해주세요. 입출력 예 n money result 5 [1,2,5] 4 입출력 예 설명",normal,Math
261,"1와 0로 채워진 표(board)가 있습니다. 표 1칸은 1 x 1 의 정사각형으로 이루어져 있습니다. 표에서 1로 이루어진 가장 큰 정사각형을 찾아 넓이를 return 하는 solution 함수를 완성해 주세요. (단, 정사각형이란 축에 평행한 정사각형을 말합니다.) 예를 들어 1 2 3 4 0 1 1 1 1 1 1 1 1 1 1 1 0 0 1 0 가 있다면 가장 큰 정사각형은 1 2 3 4 0 1 1 1 1 1 1 1 1 1 1 1 0 0 1 0 가 되며 넓이는 9가 되므로 9를 반환해 주면 됩니다. 제한사항 표(board)는 2차원 배열로 주어집니다. 표(board)의 행(row)의 크기 : 1,000 이하의 자연수 표(board)의 열(column)의 크기 : 1,000 이하의 자연수 표(board)의 값은 1또는 0으로만 이루어져 있습니다. 입출력 예 board answer [[0,1,1,1],[1,1,1,1],[1,1,1,1],[0,0,1,0]] 9 [[0,0,1,1],[1,1,1,1]] 4 입출력 예 설명",normal,Array
262,"앞뒤를 뒤집어도 똑같은 문자열을 팰린드롬(palindrome)이라고 합니다. 문자열 s가 주어질 때, s의 부분문자열(Substring)중 가장 긴 팰린드롬의 길이를 return 하는 solution 함수를 완성해 주세요. 예를들면, 문자열 s가 ""abcdcba""이면 7을 return하고 ""abacde""이면 3을 return합니다. 제한사항 문자열 s의 길이 : 2,500 이하의 자연수 문자열 s는 알파벳 소문자로만 구성 입출력 예 s answer ""abcdcba"" 7 ""abacde"" 3 입출력 예 설명",normal,String
263,"가로 길이가 2이고 세로의 길이가 1인 직사각형 모양의 타일이 있습니다. 이 직사각형 타일을 이용하여 세로의 길이가 3이고 가로의 길이가 n인 바닥을 가득 채우려고 합니다. 타일을 채울 때는 다음과 같이 2가지 방법이 있습니다 타일을 가로로 배치 하는 경우 타일을 세로로 배치 하는 경우 예를들어서 n이 8인 직사각형은 다음과 같이 채울 수 있습니다. 직사각형의 가로의 길이 n이 매개변수로 주어질 때, 이 직사각형을 채우는 방법의 수를 return 하는 solution 함수를 완성해주세요. 제한사항 가로의 길이 n은 5,000이하의 자연수 입니다. 경우의 수가 많아 질 수 있으므로, 경우의 수를 1,000,000,007으로 나눈 나머지를 return해주세요. 입출력 예 n result 4 11 입출력 예 설명",normal,Math
264,"가로 길이가 2이고 세로의 길이가 1인 직사각형모양의 타일이 있습니다. 이 직사각형 타일을 이용하여 세로의 길이가 2이고 가로의 길이가 n인 바닥을 가득 채우려고 합니다. 타일을 채울 때는 다음과 같이 2가지 방법이 있습니다. 타일을 가로로 배치 하는 경우 타일을 세로로 배치 하는 경우 예를들어서 n이 7인 직사각형은 다음과 같이 채울 수 있습니다. 직사각형의 가로의 길이 n이 매개변수로 주어질 때, 이 직사각형을 채우는 방법의 수를 return 하는 solution 함수를 완성해주세요. 제한사항 가로의 길이 n은 60,000이하의 자연수 입니다. 경우의 수가 많아 질 수 있으므로, 경우의 수를 1,000,000,007으로 나눈 나머지를 return해주세요. 입출력 예 n result 4 5 입출력 예 설명",normal,Math
265,"124 나라가 있습니다. 124 나라에서는 10진법이 아닌 다음과 같은 자신들만의 규칙으로 수를 표현합니다. 124 나라에는 자연수만 존재합니다. 124 나라에는 모든 수를 표현할 때 1, 2, 4만 사용합니다. 예를 들어서 124 나라에서 사용하는 숫자는 다음과 같이 변환됩니다. 10진법 124 나라 10진법 124 나라 1 1 6 14 2 2 7 21 3 4 8 22 4 11 9 24 5 12 10 41 자연수 n이 매개변수로 주어질 때, n을 124 나라에서 사용하는 숫자로 바꾼 값을 return 하도록 solution 함수를 완성해 주세요. 제한사항 n은 50,000,000이하의 자연수 입니다. 입출력 예 n result 1 1 2 2 3 4 4 11",normal,Math
266,"ROR 게임은 두 팀으로 나누어서 진행하며, 상대 팀 진영을 먼저 파괴하면 이기는 게임입니다. 따라서, 각 팀은 상대 팀 진영에 최대한 빨리 도착하는 것이 유리합니다. 지금부터 당신은 한 팀의 팀원이 되어 게임을 진행하려고 합니다. 다음은 5 x 5 크기의 맵에, 당신의 캐릭터가 (행: 1, 열: 1) 위치에 있고, 상대 팀 진영은 (행: 5, 열: 5) 위치에 있는 경우의 예시입니다. 위 그림에서 검은색 부분은 벽으로 막혀있어 갈 수 없는 길이며, 흰색 부분은 갈 수 있는 길입니다. 캐릭터가 움직일 때는 동, 서, 남, 북 방향으로 한 칸씩 이동하며, 게임 맵을 벗어난 길은 갈 수 없습니다. 아래 예시는 캐릭터가 상대 팀 진영으로 가는 두 가지 방법을 나타내고 있습니다. 첫 번째 방법은 11개의 칸을 지나서 상대 팀 진영에 도착했습니다. 두 번째 방법은 15개의 칸을 지나서 상대팀 진영에 도착했습니다. 위 예시에서는 첫 번째 방법보다 더 빠르게 상대팀 진영에 도착하는 방법은 없으므로, 이 방법이 상대 팀 진영으로 가는 가장 빠른 방법입니다. 만약, 상대 팀이 자신의 팀 진영 주위에 벽을 세워두었다면 상대 팀 진영에 도착하지 못할 수도 있습니다. 예를 들어, 다음과 같은 경우에 당신의 캐릭터는 상대 팀 진영에 도착할 수 없습니다. 게임 맵의 상태 maps가 매개변수로 주어질 때, 캐릭터가 상대 팀 진영에 도착하기 위해서 지나가야 하는 칸의 개수의 최솟값을 return 하도록 solution 함수를 완성해주세요. 단, 상대 팀 진영에 도착할 수 없을 때는 -1을 return 해주세요. 제한사항 maps는 n x m 크기의 게임 맵의 상태가 들어있는 2차원 배열로, n과 m은 각각 1 이상 100 이하의 자연수입니다. n과 m은 서로 같을 수도, 다를 수도 있지만, n과 m이 모두 1인 경우는 입력으로 주어지지 않습니다. maps는 0과 1로만 이루어져 있으며, 0은 벽이 있는 자리, 1은 벽이 없는 자리를 나타냅니다. 처음에 캐릭터는 게임 맵의 좌측 상단인 (1, 1) 위치에 있으며, 상대방 진영은 게임 맵의 우측 하단인 (n, m) 위치에 있습니다. 입출력 예 maps answer [[1,0,1,1,1],[1,0,1,0,1],[1,0,1,1,1],[1,1,1,0,1],[0,0,0,0,1]] 11 [[1,0,1,1,1],[1,0,1,0,1],[1,0,1,1,1],[1,1,1,0,0],[0,0,0,0,1]] -1 입출력 예 설명",normal,Array
267,"사칙연산에서 더하기(+)는 결합법칙이 성립하지만, 빼기(-)는 결합법칙이 성립하지 않습니다. 예를 들어 식 1 - 5 - 3은 연산 순서에 따라 다음과 같이 다른 결과를 가집니다. ((1 - 5) - 3) = -7 (1 - (5 - 3)) = -1 위 예시와 같이 뺄셈은 연산 순서에 따라 그 결과가 바뀔 수 있습니다. 또 다른 예로 식 1 - 3 + 5 - 8은 연산 순서에 따라 다음과 같이 5가지 결과가 나옵니다. (((1 - 3) + 5) - 8) = -5 ((1 - (3 + 5)) - 8) = -15 (1 - ((3 + 5) - 8)) = 1 (1 - (3 + (5 - 8))) = 1 ((1 - 3) + (5 - 8)) = -5 위와 같이 서로 다른 연산 순서의 계산 결과는 [-15, -5, -5, 1, 1]이 되며, 이중 최댓값은 1입니다. 문자열 형태의 숫자와, 더하기 기호(""+""), 뺄셈 기호(""-"")가 들어있는 배열 arr가 매개변수로 주어질 때, 서로 다른 연산순서의 계산 결과 중 최댓값을 return 하도록 solution 함수를 완성해 주세요. 제한 사항 arr는 두 연산자 ""+"", ""-"" 와 숫자가 들어있는 배열이며, 길이는 3 이상 201 이하 입니다. arr의 길이는 항상 홀수입니다. arr에 들어있는 숫자의 개수는 2개 이상 101개 이하이며, 연산자의 개수는 (숫자의 개수) -1 입니다. 숫자는 1 이상 1,000 이하의 자연수가 문자열 형태로 들어있습니다.. (ex : ""456"") 배열의 첫 번째 원소와 마지막 원소는 반드시 숫자이며, 숫자와 연산자가 항상 번갈아가며 들어있습니다. 입출력 예 arr result [""1"", ""-"", ""3"", ""+"", ""5"", ""-"", ""8""] 1 [""5"", ""-"", ""3"", ""+"", ""1"", ""+"", ""2"", ""-"", ""4""] 3 입출력 예시",hard,Array
268,"네오의 귀걸이 귀걸이를 좋아하는 네오는 자신만을 위한 귀걸이를 만들기로 하였다. 기하학적으로 아름다운 귀걸이를 만들고 싶던 네오는 아래와 같은 모습의 귀걸이를 구상 중이다. 2차원 좌표 평면에 N개의 점이 주어져 있다. 점들의 x나 y 좌표가 겹치는 경우는 없다고 하자. 이들 점 중 가장 왼쪽에 위치한 점은 항상 가장 위쪽에 위치한 점과 같다. 이 점을 S라고 부르자. 마찬가지로, 가장 오른쪽에 위치한 점은 항상 가장 아래쪽에 위치한 점과 같다. 이 점을 E라고 부르자. 기하학적으로 아름다운 귀걸이는 다음의 조건을 만족해야 한다. 주어진 점들을 왼쪽 위와 오른쪽 아래 꼭짓점으로 가지는 축에 평행한 직사각형들이 순서대로 놓여있다. 이때, 첫 번째 직사각형은 S를 왼쪽 위 꼭짓점으로 가져야 한다. 순서의 마지막 직사각형은 E를 오른쪽 아래 꼭짓점으로 가져야 한다. 순서에서, 어떤 직사각형 A 바로 다음에 직사각형 B가 등장한다면, A의 오른쪽 아래 꼭짓점은 B의 왼쪽 위 꼭짓점과 같은 점이어야 한다. 주어진 점 각각은 자신의 특징적인 k값을 가지고 있다. 이 값의 의미는 해당 점이 어떤 직사각형의 오른쪽 아래 점이 되는 경우 그 직사각형의 가로 폭과 세로 높이의 합이 정확히 k가 되어야 한다는 뜻이다. 네오는 주어진 점들로 만들 수 있는 기하학적인 귀걸이가 몇 가지인지 궁금하다. 또, 점을 하나 추가했을 때 혹은 점을 하나 제거했을 때의 종류도 몇 가지인지 궁금하다. 네오가 궁금증을 해결하기 위해 여러분의 도움이 필요하다. S와 E는 처음상태에서 고정된다. S와 E가 제거되는 경우와 추가되는 점이 일정한 영역을 벗어나는 경우에 주의하라. 입력 형식 입력은 점의 개수 n, 점의 정보를 담은 배열 point, 점의 추가 또는 삭제 정보를 담은 배열 query로 구성된다. point 배열은 n × 3 크기의 2차원 배열로, 각각의 행은 점의 x좌표, y좌표, 그리고 그 점의 k값으로 이루어져 있다. query 배열은 n × 4 크기의 2차원 배열로, 점을 추가하거나 삭제하는 변화의 정보를 담고 있다. 각 변화는 독립적으로 초기 상태에 대해서 적용됨에 주의하라. 즉, 변화가 누적되는 것이 아니다. 각 행의 첫 번째 값은 변화의 종류를 담은 값으로, 0인 경우 점을 추가하는 경우를 의미하고 1인 경우 최초에 주어진 n개의 점들 중 하나를 제거하는 경우를 의미한다. 점을 추가하는 경우는 새로 추가되는 점의 x좌표, y좌표, k값이 이후의 원소로 주어진다. 점을 삭제하는 경우는 삭제하려는 점의 x좌표, y좌표가 이후의 원소로 주어지며, 마지막 원소는 배열의 크기를 맞추기 위한 것으로 의미 없는 값이다. 제한조건은 다음과 같다. 2 <= n <= 100,000 주어진 점들 중 가장 왼쪽에 위치한 점은 항상 가장 위쪽에 위치한 점과 같음이 보장된다. 또한, 가장 오른쪽에 위치한 점은 항상 가장 아래쪽에 위치한 점과 같음이 보장된다. 추가되는 점은 최초에 주어진 점과 x좌표나 y좌표가 겹치지 않음이 보장된다. 제거되는 점은 최초에 주어진 점들 중 하나임이 보장된다. 모든 좌표 값은 -1,000,000,000 이상 1,000,000,000이하의 정수이다. 출력 형식 리턴 타입은 정수의 배열로, 총 n+1개의 원소로 이루어진 배열을 리턴한다. 첫 번째 원소는 초기 상태에서 가능한 기하학적 귀걸이의 개수를 1,000,000,007로 나눈 나머지여야 한다. 다음 n개의 원소는 각 변화에 대해 그 변화를 적용한 이후 가능한 귀걸이의 개수를 1,000,000,007로 나눈 나머지가 입력의 순서에 맞게 들어있으면 된다. 예제 입출력 n point query answer 3 [[0, 4, 1], [2, 2, 4], [4, 0, 4]] [[0, 3, 3, 4], [0, 3, 1, 2], [1, 2, 2, 0]] [1, 2, 1, 0]",hard,Array
269,"IU와 콘의 보드게임 2017년 8월 5일, 다양한 방법으로 3단 고음을 마스터한 아이유는 신나게 놀기로 했다. 무엇을 할까 고민하던 그녀는 콘이 보드게임을 플레이하고 있는 것을 보고 흥미가 생겼다. 보드판은 다음과 같이 생겼다. 게임판에는 점 A, B, C 위치에 핀이 꼽혀 있으며 이 세 점은 게임판에서 가장 큰 삼각형을 이루고 있다. 고무줄이 세 개가 있는데 각각이 A와 B, B와 C, C와 A에 묶여 있어 삼각형 ABC를 그리고 있다. 이 커다란 삼각형 ABC 안에는 n개의 핀이 무작위로 꼽혀 있다. 이 게임은 세 개의 고무줄을 삼각형 ABC의 안쪽으로 이동시켜 새로운 도형을 만들어 내는 것이 목표이며, 그 과정에서 핀의 위치는 고정되어 움직일 수 없다. 삼각형 ABC 내부의 핀들과 고무줄의 물리적 특성에 의해 이러한 방식으로 만들어지는 도형들은 다음과 같은 성질을 갖는다. 꼭짓점은 모두 어떤 핀에 의해 만들어지며 변은 핀과 핀 사이의 선분이 된다. 끝점이 A와 B에 고정된 고무줄은 A에서 시작하여 B로 끝나는 안쪽으로 오목한 모양을 그리게 된다. 끝점이 B와 C에 고정된 고무줄은 B에서 시작하여 C로 끝나는 안쪽으로 오목한 모양을 그리게 된다. 끝점이 C와 A에 고정된 고무줄은 C에서 시작하여 A로 끝나는 안쪽으로 오목한 모양을 그리게 된다. 여기에 아래의 추가 조건을 만족하는 도형을 모두 찾고 싶다. 임의의 두 고무줄이 서로 교차하지 않으며, 점 A, B, C를 제외한 곳에서 겹치지 않는다. 따라서 만들어지는 도형의 내부와 외부가 명확하게 구분된다. 그 도형의 내부에 다른 핀이 존재하지 않는다. 위의 첫 번째 그림은 게임판의 시작 형태를 보여주고 있다. 여기에는 삼각형 ABC 안에 8개의 핀이 꼽혀 있으며, 세 개의 고무줄은 서로 다른 색으로 표현되어 있다. 두 번째 그림은 추가 조건 두 가지를 모두 만족하는 도형의 예를 보여준다. 세 번째와 네 번째 그림은 고무줄로 만들 수 있는 모양이지만 추가 조건을 만족시키지 못하는 예이다. 세 번째 도형은 두 고무줄이 교차하여 추가 조건 1을 만족하지 못하고 네 번째 도형은 추가 조건 1을 만족하지만 내부에 핀이 존재하여 조건 2를 만족하지 못한다. 위의 두 번째 도형과 같이 추가 조건 1과 2를 모두 만족하는 도형이 몇 개인지 맞히는 사람이 이기는 게임이다. 승부욕이 강한 아이유는 콘에게 지고 싶지 않아 여러분에게 도움을 요청했다. 삼각형 ABC 내부에 위치한 n개의 핀의 좌표가 주어질 때에 위의 조건을 만족하는 도형의 개수를 세는 프로그램을 작성하시오. 입력 형식 입력은 삼각형 내부의 핀의 개수 n, 삼각형의 좌표 triangle, 핀의 좌표 v 배열로 구성되어 있다. triangle은 3 × 2 크기의 2차원 배열이며, v는 n × 2 크기의 2차원 배열이다. 제한조건은 다음과 같다. 0 <= n <= 500 triangle과 v의 원소인 x좌표와 y좌표는 모두 -100,000,000 이상 100,000,000 이하이다. triangle과 v로 주어진 모든 점을 통틀어, 같은 좌표를 가진 두 핀이 입력으로 주어지지 않는다. triangle과 v로 주어진 모든 점을 통틀어, 임의의 세 점이 하나의 직선 위에 놓이는 경우는 없다. 출력 형식 문제에 설명된 조건을 모두 만족하는 도형의 개수를 리턴한다. 예제 입출력 n triangle v answer 2 [[0, 8], [-4, 0], [4, 0]] [[-1, 3], [1, 4]] 6 10 [[-13, 40], [-27, -48], [31, 6]] [[2, 21], [15, -1], [6, -13], [-20, -27], [5, 9], [5, 11], [-18, -26], [-15, 19], [7, 4], [-5, -18]] 73 예제에 대한 설명 첫 번째 예제에는 삼각형의 꼭짓점을 제외하고 총 2개의 핀의 위치가 주어졌다. 삼각형의 좌표를 A(0, 8), B(-4, 0), C(4, 0), 그리고 삼각형 내부의 핀을 D(-1, 3), E(1, 4)라고 하자. 고무줄로 만들 수 있으면서 추가 조건 1, 2를 만족하는 도형은 총 6개로 아래와 같다. 사각형 ABCD, 사각형 AEBC, 오각형 ADBCE, 오각형 ABDCE, 오각형 ADBEC, 오각형 ABDEC 그 외의 도형은 모두 추가 조건 1 혹은 추가 조건 2를 만족하지 못한다.",hard,Array
270,"스마트한 프로도 직장인 프로도는 오늘도 열심히 일한다. 회사에서 인정받는 프로도는 직장 상사에게 문제를 풀어 달라는 요청을 받았다. 문제를 읽은 프로도는 혼자 풀긴 어려운 문제로 보여 여러분에게 도움을 요청하였다. 상사가 전달한 문제는 아래와 같다. 그래프 G에 대해서, 서로 다른 두 정점 사이에 간선이 존재한다면 단지 한 간선만 존재한다. 또한 동일한 정점을 연결하는 간선(셀프 루프)은 존재하지 않는다. G의 두 간선 e_1과 e_2가 인접하다면, e_1이 연결하는 두 정점 중 하나는 e_2가 연결하는 정점과 일치한다. 그래프 G의 매칭 M은 간선들의 집합이고 M에 속하는 임의의 두 간선은 서로 인접하지 않다. 여기서, 공집합은 매칭임에 주목하자. 그래프 G와 정수 k에 대해서, 초기에 |M_0|≥k이고 |M_t|≥k 인 두 매칭 M_0와 M_t가 주어진다. 우리는 매칭 M_0에서 G의 간선을 추가하거나 또는 삭제해서 M_0를 변환한다. 변환의 한 단계에서는 하나의 간선을 추가하거나 삭제할 수 있다. 이렇게 해서 변환된 간선들의 집합 M_1은 다시 매칭이 되어야 한다. 다시 말해서, 각 변환 단계의 결과물은 매칭이어야 한다. 따라서 i번째 단계에서는 매칭 M_i-1를 매칭 M_i로 변환하게 된다. 이런 식으로 M_0에서 시작해서 중간 매칭들로의 변환 단계들을 거쳐서 마지막에 M_t를 만들어야 한다. 다시 말해서, p번의 단계를 거쳐 만들어진 매칭 M_p에 대해서, M_p = M_t를 만족하면 된다. 하지만 중간에 만들어지는 M_i (0 < i < p)는 크기에 제한이 있어서 |M_i| ≥ k-2를 만족해야만 한다. 매칭 M_0에서 M_t로 위의 조건들을 만족하면서 항상 변환할 수 있다는 것이 잘 알려져 있다. 따라서 여러분은 그 변환 과정을 리턴하는 프로그램을 작성하여야 한다. 예를 들어, 아래 그림에서 초기 매칭 M_0 = {e_3, e_6}이고 마지막 매칭 M_t = {e_2, e_4}이고, k = 2 인 경우이다. 그림에서와 같이 간선들을 추가하거나 삭제하면, M_0에서 M_t로 변환할 수 있다. 입력 형식 입력은 총 9가지의 변수로 주어진다. n과 m은 각각 그래프 G의 정점과 간선의 수이다. 그래프 G의 정점들은 1부터 n까지의 정수로, 간선들은 1부터 m까지의 정수로 나타낸다. a와 b는 각각 크기가 m인 1차원 배열로, 간선이 잇는 두 점을 나타낸다. i번째 간선이 잇는 두 정점의 번호가 a와 b의 i번째 원소가 된다. k는 문제에서 설명된 것과 같다. m1과 m2는 각각 초기 매칭 M_0의 크기, 마지막 매칭 M_t의 크기이다. e1과 e2는 각각 M_0와 M_t에 속하는 간선의 정보를 나타내는 1차원 배열이며, 각각의 원소의 개수는 m1과 m2이다. 제한조건은 다음과 같다. 1 <= n <= 100,000 1 <= m <= 1,000,000 1 <= k <= 50,000 m1 >= k, m2 >= k 출력 형식 리턴 타입은 2차원 정수 배열이다. 매칭 M_0에서 M_t로 변환하는데 p단계가 걸린다고 할 때, 배열의 크기는 p × 2가 되어야 한다. 각 행의 첫 번째 원소는 0 또는 1로, 0이면 간선을 삭제했음을 의미하며 1이면 간선을 추가했음을 의미한다. 두 번째 원소는 추가 또는 삭제하는 간선의 번호이다. 답이 될 수 있는 변환이 여러 가지인 경우에는 그중 한 가지를 리턴하면 된다. 변수명 값 n 5 m 6 a [1, 1, 2, 2, 3, 4] b [2, 3, 3, 4, 5, 5] k 2 m1 2 m2 2 e1 [3, 6] e2 [2, 4] answer [[0, 3], [1, 2], [0, 6], [1, 4]] 알림 이 문제의 경우 같은 입력에 대해 정답이 여러 개 존재할 수 있으나, ‘실행’을 눌러 예제 입출력에 대해 테스트를 진행할 때 등록된 한 가지 답만 정답으로 처리되고 있습니다. ‘코드 채점’을 눌러 제출할 시에는 올바르게 채점되니 참고하여 주시기 바랍니다.",hard,Array
271,"튜브의 소개팅 얼마 전 소개팅에 실패해 낙담한 튜브를 안타깝게 여긴 친구들은 튜브에게 새로운 사람을 소개해주기로 했다. 좀 더 자연스러운 자리를 만들기 위해, 튜브와 소개팅녀를 파티에 초대하기로 했다. 친구들은 튜브에게 파티에 초대된 모든 사람의 위치를 알려주었다. 사각형 모양의 파티장 입구는 왼쪽 맨 위였고, 만나야 하는 상대의 좌석은 파티장의 오른쪽 맨 아래였다. 파티장의 가로 길이가 n이라고 하고, 세로 길이를 m이라 할 때, 튜브와 소개팅 상대의 위치는 각각, (0, 0), (m - 1, n - 1)이 된다. 튜브는 (0, 0)에서 (m - 1, n - 1)까지 가는 가장 짧은 길을 알고 싶다. 이동은 좌/우/상/하로만 가능하다. 또한, 조금이라도 더 빠르게 이동하고 싶은 튜브는 이동하는 중에 가능한 덜 수다스러운 친구들만 만나고 싶다. 다시 말해, 목표 지점까지 길이가 같은 여러 개의 경로가 존재할 경우, 경로상에 위치한 친구들과 나눠야 하는 대화 시간의 합이 적은 것을 더 선호한다. 튜브에게는 스트레스를 심하게 받을 경우 미친 오리로 변하는 비밀이 있다. 경로 상에 위치한 친구들과 나눠야 하는 대화 시간의 합이 s를 초과한다면 미친 오리로 변하고 소개팅에 실패하고 말 것이다! 그러므로 아무리 짧은 경로라도 친구들과 나눠야 하는 대화 시간의 합이 s를 초과한다면 그 경로를 진행할 수는 없다. 튜브가 소개팅 상대에게 무사히 갈 수 있는 경로를 알려주자. 입력 형식 입력은 파티장의 크기 m과 n 그리고 튜브가 참을 수 있는 대화 시간의 총합 s, 친구와의 대화에 필요한 시간 t가 담긴 2차원 배열 time_map으로 주어진다. t가 -1인 경우는 파티 테이블이 위치한 경우라 지나갈 수 없다. 그리고 시작 지점과 도착 지점에서는 수다에 필요한 시간이 없다, 즉 t = 0이다. 추가 제한조건은 아래와 같다. 2 <= n, m <= 50 1 <= s <= 2^31-1 -1 <= t <= 2^31-1 모든 입력에는 문제의 조건을 만족하는 경로가 하나 이상 존재한다. 출력 형식 리턴 타입은 원소가 두 개인 정수 배열이다. 튜브가 이동해야 하는 경로의 길이와 해당 경로를 지나갈 때 친구와 나눠야 하는 대화 시간의 총합을 리턴한다. 예제 입출력 m n s time_map answer 3 3 150 [[0, 2, 99], [100, 100, 4], [1, 2, 0]] [4, 103] 4 6 25 [[0, 1, 1, -1, 2, 4], [-1, 7, 2, 1, 5, 7], [-1, 1, -1, 1, 6, 3], [-1, 1, -1, -1, 7, 0]] [8, 15] 5 5 12 [[0, 1, 1, 1, 1], [9, 9, 9, 1, 9], [1, 1, 1, 1, 9], [1, 1, 5, 9, 9], [1, 1, 1, 1, 0]] [12, 11]",hard,Array
272,"몸짱 트레이너 라이언의 고민 헬스장에서 일하는 몸짱 트레이너 라이언은 최근 손님들에게 불평을 많이 들었다. 그것은 옷을 갈아입는데 다른 사람과 너무 가까워서 옷을 갈아입기가 불편하다는 것이었다. 불만을 해결하기 위해 고민하던 라이언은 손님들의 예약시간을 참고해서 되도록이면 서로 멀리 떨어지도록 키를 나눠주기로 마음먹었다. 예를 들어, 락커들이 3x3 정사각형 모양으로 배치되어있고, 동시간대에 2명의 손님이 예약되어있다면 아래와 같이 락커를 할당하는 것을 고려해볼 수 있다. 라이언이 일하는 헬스장은 아래와 같은 상황이라고 가정하자. 락커는 정사각형으로 배치되어있고, 락커 사이에 옷을 갈아입을 공간이 있다. 단, 이 공간은 계산에서 제외된다. 락커 간 거리는 상하좌우는 1로, 대각선은 2로 계산한다. 손님들은 철저하게 예약시간에 맞춰 락커를 이용하고, 퇴실하는 시간까지 락커를 차지한다. 영업시간은 오전 10시부터 오후 10시까지이다. 헬스장은 예약제로 운영되므로 락커의 개수보다 더 많은 손님들이 동시간대에 몰리는 경우는 없다. 이런 조건에서 헬스장을 이용한 손님들 중 가장 가까웠던 손님 간의 거리는 얼마일까? 입력 형식 입력은 정사각형 한 변의 길이 n과 손님수 m, 그리고 각 손님의 예약된 입실/퇴실 시간 timetable로 주어진다. 제한조건은 다음과 같다. 0 < n <= 10 0 <= m <= 1,000 timetable은 m × 2 크기의 2차원 배열이다. 각 행은 손님의 입실시각과 퇴실시각이 분 단위로 환산된 값 (t1, t2)가 들어있다. t1, t2에 대해서는 다음 조건이 성립한다. 600 <= t1 < t2 <= 1,320 출력 형식 할당된 락커들 간 거리 중 최소거리를 리턴한다. 손님 간에 이용 시간이 한 번도 겹치지 않을 경우에는 0을 리턴한다. 예제 입출력 n m timetable answer 3 2 [[1170,1210], [1200,1260]] 4 2 1 [[840,900]] 0 2 2 [[600,630],[630,700]] 2 4 5 [[1140,1200],[1150,1200],[1100,1200],[1210,1300],[1220,1280]] 4 예제에 대한 설명 첫 번째 예제: 손님 2명이 20:00부터 20:10까지 이용시간이 겹치고, 이 상황은 본문에 소개된 예와 같다. 두 번째 예제: 손님이 1명으로 겹치는 시간이 없기 때문에 0을 출력한다. 세 번째 예제: 손님 2명이 10:30에 겹친다. 2x2 정사각형에 2명을 배치해야 하므로 정답은 2가 된다. (ex. (0,0), (1,1)에 배치) 네 번째 예제: 손님 3명이 19:10부터 20:00까지 이용시간이 겹친다. 이 경우 아래와 같이 배치해서 할당된 모든 락커 간 거리가 4가 되도록 할 수 있다. (할당된 락커는 #으로 표시) # 0 0 0 0 0 0 # 0 0 0 0 0 # 0 0 네 번째 예제에서 손님을 모서리부터 배치하는 건 좋은 전략이 아니다. 2명까지는 거리가 6으로 가장 먼 거리가 되지만 예약된 다음 손님이 들어오면 할당된 락커 간 거리는 3이 돼버린다. 이런 경우 라이언은 예약시간을 고려해서 거리가 4가 되도록 배치한다.",normal,Array
273,"GPS 카카오 택시 개발자 Jay-G는 다음 업데이트를 준비하기 위해 개선사항을 위한 여러 피드백을 받았다. 그중에서 손님이 자주 탑승하는 위치를 추천해주었으면 한다는 의견이 많았다. 다음 업데이트 준비를 위해 Jay-G는 택시의 승하차 및 이동 경로를 수집하여 분석하기 시작하였다. 데이터를 분석하던 Jay-G는 몇 가지 특이사항을 발견했다. 택시의 이동 경로를 GPS를 통해 수집하게 되는데, GPS 신호 불량, 통신 오류 등 다양한 원인으로 위치의 오류가 발생한 것을 알게 되었다. 다만 승차 위치와 하차 위치는 오류가 없는 것으로 확인이 되었다. 개발자 Jay-G는 수집한 이동 경로의 오류를 최소한으로 수정하여 좀 더 정확한 이동 경로를 구하고 싶어 한다. 택시는 다음과 같은 조건으로만 이동한다. 먼저 택시는 거점을 이동해 다니며, 거점 간의 이동은 해당하는 도로가 있는 경우에만 가능하다. 또한, 교통 상황에 따라 택시는 한 거점에 머무를 수 있고, 왔던 길을 되돌아갈 수 있다. 모든 도로는 방향이 별도로 없는 왕복 도로이다. 예를 들어, 위 그래프에서 택시가 다음과 같이 시간대별로 이동 경로를 보내왔다. t 위치 1 1 2 2 3 3 4 3 5 6 6 7 하지만 위의 택시가 보내온 경로에는 거점 3에서 거점 6으로 이동할 수 있는 도로가 없으므로 이동 경로에 오류가 있다. 이러한 오류를 최소한으로 수정하여 이동 가능한 경로로 만들고 싶다. 이 경우 1회의 오류를 수정하여 다음과 같이 이동 가능한 경로를 만들 수 있다. 시간 t=4의 위치를 거점 5로 한 번 수정하면 이동 가능한 경로가 된다. t 위치 1 1 2 2 3 3 4 5 5 6 6 7 이와 비슷하게 시간 t=4의 위치를 거점 4로 바꾸거나, 시간 t=5 위치를 거점 5로 바꾸면 이동 가능한 경로로 만들 수 있다. 위의 경우 수정한 오류의 개수는 1개이다. t 위치 1 1 2 2 3 3 4 4 5 6 6 7 t 위치 1 1 2 2 3 3 4 3 5 5 6 7 위와 같이 택시가 보내온 경로에서 이동 가능한 경로로 만드는 최소의 오류 수정 횟수를 구하여라. 입력 형식 주어지는 입력은 총 다섯 가지로, 거점 개수 n과 도로의 개수 m, 각 거점 간의 연결된 도로 정보 edge_list, 택시가 시간대별로 보내오는 거점 정보의 총 개수 k, 그리고 머물렀던 거점의 정보 gps_log이다. 제한조건은 아래와 같다. 2 <= n <= 200 1 <= m <= 10,000 2 <= k <= 100 edge_list는 m × 2 크기의 2차원 배열로, 각 행의 두 값은 도로가 잇는 두 거점의 번호를 의미한다. 거점의 번호는 1부터 n까지 숫자이다. 모든 도로는 양방향 통행이 가능하다. 입력되는 데이터에서 항상 모든 거점 간 경로가 있음이 보장되지 않는다. gps_log의 시작 거점과 도착 거점은 바뀔 수 없다. 출력 형식 이동 가능한 경로로 만들 수 있는 최소의 오류 수정 횟수를 리턴한다. 올바른 경로로 수정하는 것이 불가능할 경우 -1을 리턴한다. 예제 입출력 변수명 값 n 7 m 10 edge_list [[1, 2], [1, 3], [2, 3], [2, 4], [3, 4], [3, 5], [4, 6], [5, 6], [5, 7], [6, 7]] k 6 gps_log [1, 2, 3, 3, 6, 7] answer 1 변수명 값 n 7 m 10 edge_list [[1, 2], [1, 3], [2, 3], [2, 4], [3, 4], [3, 5], [4, 6], [5, 6], [5, 7], [6, 7]] k 6 gps_log [1, 2, 4, 6, 5, 7] answer 0 예제에 대한 설명 두 예제 모두 edge_list의 데이터는 본문의 그림과 같은 예이다. 첫 번째 테스트 케이스에서 gps_log로 주어진 경로 중 거점 3에서 거점 6으로 가는 도로가 없다. 여기서 시간 t=4의 위치를 거점 5로 한 번 수정하면 이동 가능한 경로가 된다. 두 번째 테스트 케이스는 gps_log로 주어진 경로가 모두 도로로 연결된 경우이므로 수정이 필요 없다.",normal,Array
274,"리틀 프렌즈 사천성 언제나 맛있는 음식들이 가득한 평화로운 푸드 타운. 푸드 타운에서 행복하게 사는 리틀 프렌즈들은 마을에 있는 매직 스푼을 보물처럼 보관하고 있다. 매직 스푼은 재료만 준비해서 냄비에 넣고 휘젓기만 하면 순식간에 최고의 요리로 만들어주는 신비의 아이템. 어느 날 매직 스푼을 호시탐탐 노리는 악당들이 보물을 훔쳐간다. 매직 스푼을 되찾고 다시 마을에 평화를 가져오기 위해 프렌즈의 대모험이 시작되는데... 리틀 프렌즈 사천성은 프렌즈 사천성과 유사한 게임이다. 게임은 2차원 배열에서 진행되는데, 여러 가지 무늬로 구성된 타일이 배치되어 있으며 같은 모양의 타일은 두 개씩 배치되어 있다. 게임의 목적은 배치된 모든 타일을 제거하는 것으로, 같은 모양의 타일을 규칙에 따라 제거하면 된다. 타일을 제거할 수 있는 경우는 다음과 같다. 다음 조건을 만족하는 경로가 있을 때 두 타일을 제거할 수 있다. 경로의 양 끝은 제거하려는 두 타일이다. 경로는 두 개 이하의 수평/수직 선분으로 구성되어 있고, 이들은 모두 연결되어 있다. (즉, 경로를 한 번 이하로 꺾을 수 있다) 참고: 프렌즈 사천성은 경로가 세 개 이하의 선분으로 구성되어야 한다는 점이 다르다. (즉, 경로를 두 번 이하로 꺾을 수 있다) 경로 상에는 다른 타일 또는 장애물이 없어야 한다. 위의 배열에서 어피치 타일은 직선의 경로로 이을 수 있으므로 제거 가능하다. 라이언 타일 역시 한 번 꺾인 경로로 연결되므로 제거 가능하다. 무지 타일의 경우 다른 타일을 지나지 않는 경로는 두 번 꺾여야 하므로 제거할 수 없는 타일이며, 튜브 타일 역시 직선의 경로 사이에 장애물이 있으므로 제거 가능하지 않다. 타일 배열이 주어졌을 때, 규칙에 따라 타일을 모두 제거할 수 있는지, 그 경우 어떤 순서로 타일을 제거하면 되는지 구하는 프로그램을 작성해보자. 입력 형식 입력은 게임판의 크기를 나타내는 m과 n, 그리고 배치된 타일의 정보를 담은 문자열 배열 board로 주어진다. 이 배열의 크기는 m이며, 각각의 원소는 n글자의 문자열로 구성되어 있다. 입력되는 값의 제한조건은 다음과 같다. 1 <= m, n <= 100 board의 원소는 아래 나열된 문자로 구성된 문자열이다. 각 문자의 의미는 다음과 같다. .: 빈칸을 나타낸다. *: 막힌 칸을 나타낸다. 알파벳 대문자(A-Z): 타일을 나타낸다. 이 문제에서, 같은 글자로 이루어진 타일은 한 테스트 케이스에 항상 두 개씩만 존재한다. board에는 알파벳 대문자가 항상 존재한다. 즉, 타일이 없는 입력은 주어지지 않는다. 출력 형식 해가 존재하는 경우 타일을 제거하는 순서대로 한 글자씩 이루어진 문자열을, 그렇지 않은 경우 IMPOSSIBLE을 리턴한다. 해가 여러 가지인 경우, 알파벳 순으로 가장 먼저인 문자열을 리턴한다. 예제 입출력 m n board answer 3 3 [""DBA"", ""C*A"", ""CDB""] ""ABCD"" 2 4 [""NRYN"", ""ARYA""] ""RYAN"" 4 4 ["".ZI."", ""M.**"", ""MZU."", "".IU.""] ""MUZI"" 2 2 [""AB"", ""BA""] ""IMPOSSIBLE"" 예제에 대한 설명 첫 번째 테스트 케이스에서 처음으로 제거 가능한 타일은 A와 C이다. 그리고 모든 가능한 경우를 나열하면 ABCD, ACBD, ACDB, CABD, CADB, CDAB이다. 이 중 알파벳 순으로 가장 먼저인 ABCD가 정답이다. 네 번째 테스트 케이스는 초기 상태에서 제거할 수 있는 타일이 없으므로 타일을 모두 제거하는 것이 불가능하다. 따라서 정답은 IMPOSSIBLE이다.",normal,Array
275,"단체사진 찍기 가을을 맞아 카카오프렌즈는 단체로 소풍을 떠났다. 즐거운 시간을 보내고 마지막에 단체사진을 찍기 위해 카메라 앞에 일렬로 나란히 섰다. 그런데 각자가 원하는 배치가 모두 달라 어떤 순서로 설지 정하는데 시간이 오래 걸렸다. 네오는 프로도와 나란히 서기를 원했고, 튜브가 뿜은 불을 맞은 적이 있던 라이언은 튜브에게서 적어도 세 칸 이상 떨어져서 서기를 원했다. 사진을 찍고 나서 돌아오는 길에, 무지는 모두가 원하는 조건을 만족하면서도 다르게 서는 방법이 있지 않았을까 생각해보게 되었다. 각 프렌즈가 원하는 조건을 입력으로 받았을 때 모든 조건을 만족할 수 있도록 서는 경우의 수를 계산하는 프로그램을 작성해보자. 입력 형식 입력은 조건의 개수를 나타내는 정수 n과 n개의 원소로 구성된 문자열 배열 data로 주어진다. data의 원소는 각 프렌즈가 원하는 조건이 N~F=0과 같은 형태의 문자열로 구성되어 있다. 제한조건은 아래와 같다. 1 <= n <= 100 data의 원소는 다섯 글자로 구성된 문자열이다. 각 원소의 조건은 다음과 같다. 첫 번째 글자와 세 번째 글자는 다음 8개 중 하나이다. {A, C, F, J, M, N, R, T} 각각 어피치, 콘, 프로도, 제이지, 무지, 네오, 라이언, 튜브를 의미한다. 첫 번째 글자는 조건을 제시한 프렌즈, 세 번째 글자는 상대방이다. 첫 번째 글자와 세 번째 글자는 항상 다르다. 두 번째 글자는 항상 ~이다. 네 번째 글자는 다음 3개 중 하나이다. {=, <, >} 각각 같음, 미만, 초과를 의미한다. 다섯 번째 글자는 0 이상 6 이하의 정수의 문자형이며, 조건에 제시되는 간격을 의미한다. 이때 간격은 두 프렌즈 사이에 있는 다른 프렌즈의 수이다. 출력 형식 모든 조건을 만족하는 경우의 수를 리턴한다. 예제 입출력 n data answer 2 [""N~F=0"", ""R~T>2""] 3648 2 [""M~C<2"", ""C~M>1""] 0 예제에 대한 설명 첫 번째 예제는 문제에 설명된 바와 같이, 네오는 프로도와의 간격이 0이기를 원하고 라이언은 튜브와의 간격이 2보다 크기를 원하는 상황이다. 두 번째 예제는 무지가 콘과의 간격이 2보다 작기를 원하고, 반대로 콘은 무지와의 간격이 1보다 크기를 원하는 상황이다. 이는 동시에 만족할 수 없는 조건이므로 경우의 수는 0이다.",normal,Array
276,"신비로운 유적 탐험 카카오 고고학 연구팀은 20,000년 전 문명의 발상지를 조사하던 중 벽면에 그려진 비슷한 모양의 그림을 여러 개 발견하게 되었다. 각각의 그림은 트리 형태로 구성되어 있으며 그림의 일부가 유실되어 전체의 정보를 해독할 수는 없었다. 연구팀은 이 그림들이 특정한 부족의 가계도를 그린 것으로 추정하였다. 트리의 루트는 부족의 조상을 의미하며, 루트의 자식들은 트리 상에서 부모-자식 관계로 연결되어 있고, 그들의 자식은 또 새로운 가지로 연결되어 있는 식이다. 이렇게 가족 전체의 관계가 여러 개의 (같은 모양의) 그림으로 남아있으며, 유실된 정보를 제외하고 공통적으로 남아있는 정보를 토대로 이 부족에 대한 연구를 진행할 수 있다고 판단하였다. 다행히 그림의 중심부에는 유실의 흔적이 없어 두 그림의 루트는 같은 사람을 의미한다고 간주할 수 있었다. 아래 그림은 서로 다른 두 그림에서 얻은 정보를 보기 좋은 형태로 나타낸 것이다. 트리의 번호들은 한 트리에서 각각의 정점을 구별하기 위한 것으로 두 트리의 같은 번호가 같은 사람이라는 의미는 아니다. 가설이 맞는지를 확인하기 위해, 두 그림에서 얻은 트리의 공통부분이 얼마나 되는지를 알아보고 싶다. 그림에서 확인할 수 있는 정보는 상대적인 부모-자식 관계가 전부이기 때문에 자식들의 이름이나 순서 등의 정보는 없다. 따라서 자식들의 순서를 무시하고, 각 트리의 루트를 포함하는 부분 트리로서 두 트리에 모두 포함되는 트리를 공통부분으로 정의하자. 두 개의 트리를 입력으로 받아 최대 공통부분의 크기를 계산하는 프로그램을 작성하라. 입력 형식 입력은 두 트리를 나타내는 n1, g1, n2, g2로 주어진다. n1, n2는 각 트리의 노드 수를 의미한다. g1, g2는 트리의 정보를 나타내는 값으로, 각각 크기가 (n1 - 1) × 2와 (n2 - 1) × 2인 2차원 배열로 주어진다. g1, g2의 각각의 행은 연결된 두 노드를 의미하는데, 두 개의 값 중 하나가 부모 노드의 번호, 다른 하나가 자식 노드의 번호이다. 입력되는 값의 제한조건은 아래와 같다. 1 <= n1, n2 <= 100 노드 번호는 각각 1부터 n1, n2까지의 값이 사용되며, 각 트리의 1번 노드가 루트이다. 입력되는 데이터는 항상 올바른 트리임이 보장된다. 출력 형식 두 트리의 최대 공통부분의 노드 수를 리턴한다. 예제 입출력 param value n1 8 g1 [[3, 1], [5, 7], [8, 7], [2, 3], [3, 6], [1, 5], [4, 3]] n2 9 g2 [[1, 5], [5, 6], [3, 7], [3, 1], [7, 4], [7, 2], [9, 8], [5, 9]] answer 7 예제에 대한 설명 본문의 그림과 같은 예이다. 첫 번째 트리에서 1, 2, 3, 4, 5, 7, 8번의 사용자를 포함하는 트리는 두 번째 트리에서 1, 3, 4, 5, 6, 7, 9번 사용자를 포함하는 트리와 모양이 동일하며, 이것이 가장 큰 경우이다.",hard,Array
277,"캠핑 무지를 돌보느라 지친 콘은 한적한 시골의 한 캠핑장에 놀러 갔다. 캠핑장은 텐트를 칠 수 있는 넓은 평지를 제공하고 있는데, 이 평지에는 이미 캠핑장에서 설치해 놓은 n개의 쐐기가 박혀 있다. 캠핑장 이용 고객은 이 쐐기들 중 한 쌍을 골라 다음과 같은 조건을 만족하도록 텐트를 설치해야 한다. 텐트는 직사각형 형태여야 한다. 텐트의 네 면이 정확하게 동, 서, 남, 북을 향해야 한다. 대각에 위치하는 텐트의 두 꼭짓점이 정확하게 선택한 두 개의 쐐기에 위치해야 한다. 텐트가 점유하는 직사각형 영역의 넓이는 0보다는 커야 한다. 텐트가 점유하는 직사각형 영역 내부에 다른 쐐기를 포함하면 안 된다. (다른 쐐기가 경계에 위치하는 경우는 허용함) 캠핑장에서는 위와 같은 조건을 만족하는 위치라면 어디든 고객이 텐트를 설치할 수 있도록 정확한 크기의 텐트를 모두 구비하여 대여해준다고 한다. 당신은 위와 같은 조건을 만족하는 텐트를 설치할 수 있는 쐐기의 쌍의 개수는 총 몇 가지가 될지 궁금해졌다. n개의 쐐기의 위치가 좌표로 주어질 때, 위의 조건을 만족하는 쐐기의 쌍의 개수를 계산하는 프로그램을 작성하시오. 단, 동서 방향은 x축, 남북 방향은 y축과 평행하다고 가정한다. 입력 형식 입력은 쐐기의 개수를 의미하는 정수 n과, n × 2 크기의 2차원 배열 data로 주어지며, 배열의 각 행은 캠핑장에 설치된 쐐기의 x좌표와 y좌표를 의미한다. 제한 조건은 다음과 같다. 2 <= n <= 5,000 n개의 쐐기는 모두 x좌표 0 이상 2^31-1 이하, y좌표 0 이상 2^31-1 이하에 위치한다. 입력되는 n개의 쐐기 중 x좌표와 y좌표가 모두 같은 경우는 없다. 출력 형식 입력에 주어진 각 케이스에 대해 가능한 텐트의 쐐기의 쌍의 개수를 정수 형태로 리턴한다. 예제 입출력 n data answer 4 [[0, 0], [1, 1], [0, 2], [2, 0]] 3 예제에 대한 설명 예제에는 총 4개의 쐐기가 있으며 이 중 (0,0)-(1,1), (0,2)-(1,1), (1,1)-(2,0)의 세 가지 위치에만 텐트를 설치할 수 있다. (0,0)-(0,2)와 (0,0)-(2,0)의 경우에는 직사각형 영역의 넓이가 0이 되기 때문에 조건을 만족하지 못하며, (0,2)-(2,0)의 경우 (1,1) 위치의 쐐기가 직사각형의 내부에 포함되므로 조건을 만족하지 못한다.",normal,Array
278,"보행자 천국 카카오내비 개발자인 제이지는 시내 중심가의 경로 탐색 알고리즘 개발 업무를 담당하고 있다. 최근 들어 보행자가 자유롭고 편리하게 걸을 수 있도록 보행자 중심의 교통 체계가 도입되면서 도심의 일부 구역은 자동차 통행이 금지되고, 일부 교차로에서는 보행자 안전을 위해 좌회전이나 우회전이 금지되기도 했다. 복잡해진 도로 환경으로 인해 기존의 경로 탐색 알고리즘을 보완해야 할 필요가 생겼다. 도시 중심가의 지도는 m × n 크기의 격자 모양 배열 city_map으로 주어진다. 자동차는 오른쪽 또는 아래 방향으로 한 칸씩 이동 가능하다. city_map[i][j]에는 도로의 상황을 나타내는 값이 저장되어 있다. 0인 경우에는 자동차가 자유롭게 지나갈 수 있다. 1인 경우에는 자동차 통행이 금지되어 지나갈 수 없다. 2인 경우는 보행자 안전을 위해 좌회전이나 우회전이 금지된다. (왼쪽에서 오던 차는 오른쪽으로만, 위에서 오던 차는 아래쪽으로만 진행 가능하다) 도시의 도로 상태가 입력으로 주어졌을 때, 왼쪽 위의 출발점에서 오른쪽 아래 도착점까지 자동차로 이동 가능한 전체 가능한 경로 수를 출력하는 프로그램을 작성하라. 이때 가능한 경로의 수는 컴퓨터가 표현할 수 있는 정수의 범위를 넘어설 수 있으므로, 가능한 경로 수를 20170805로 나눈 나머지 값을 출력하라. 입력 형식 입력은 도시의 크기를 나타내는 m과 n, 그리고 지도를 나타내는 2차원 배열 city_map으로 주어진다. 제한조건은 아래와 같다. 1 <= m, n <= 500 city_map의 크기는 m × n이다. 배열의 모든 원소의 값은 0, 1, 2 중 하나이다. 출발점의 좌표는 (0, 0), 도착점의 좌표는 (m - 1, n - 1)이다. 출발점과 도착점의 city_map[i][j] 값은 0이다. 출력 형식 출발점에서 도착점까지 이동 가능한 전체 경로의 수를 20170805로 나눈 나머지를 리턴한다. 예제 입출력 m n city_map answer 3 3 [[0, 0, 0], [0, 0, 0], [0, 0, 0]] 6 3 6 [[0, 2, 0, 0, 0, 2], [0, 0, 2, 0, 1, 0], [1, 0, 0, 2, 2, 0]] 2 예제에 대한 설명 첫 번째 예제는 모든 도로가 제한 없이 통행 가능한 경우로, 가능한 경우의 수는 6가지이다. 두 번째 예제는 문제 설명에 있는 그림의 경우이다. 가능한 경우의 수는 빨간 실선과 노란 점선 2가지뿐이다.",normal,Array
279,"4단 고음 I'm in my dream~↗ ~↗ ~↗ IU는 본인의 장기인 3단 고음으로 유명하다. 그러던 그녀가 어느 날 4단 고음을 성공했고 그녀의 고음은 학계에서 연구가 될 만큼 유명해졌다 [1]. [1] 견두헌, 배명진. “아이유의 고음 발성 특성 분석”, 한국음향학회, 2011년 춘계학술대회 학술발표논문지 폭포 밑 득음 수련을 하던 어느 날, 그녀는 4단 고음이 끝이 아님을 깨달았다. 3단 고음 직후 3단 고음을 연이어하거나, 3단 고음 중 다시 3단 고음을 해서 음높이를 올리는 방법이다. 어떤 순서로 3단 고음을 했는지에 따라 최종 음높이가 달라지기 때문에, 연속 3단 고음을 연습할 때마다 그 결과를 기록으로 남기기로 했다. 3단 고음은 다음과 같이 적용된다. 1단계에서는 음높이가 세 배가 되며, 2단계와 3단계에서 음높이가 각각 1씩 증가한다. 이를 기록으로 남길 때 * 와 + 기호를 사용하기로 했다. 즉, 3단 고음을 한 번 한 경우는 문자열로 나타내면 다음과 같다. *++ 이때 3단 고음을 마치고 연달아 3단 고음을 한 경우는 *++*++ 와 같이 표현할 수 있다. 3단 고음의 2단계를 마친 후 3단 고음을 새로 시작한 다음, 나머지 단계를 이어서 하는 경우는 *+*+++로 표현할 수 있다. (강조된 부분이 2번째 3단 고음을 부른 부분이다.) 이와 같이 * 와 + 로 구성된 문자열이 3단 고음의 규칙을 적용하여 만들 수 있는 문자열인 경우 '올바른 문자열'이라고 하자. 다음의 문자열은 3단 고음의 규칙으로 만들 수 있는 문자열이 아니므로 올바른 문자열이 아니다. +**+++ *+++*+ 올바른 문자열에 대해 음높이는 다음과 같이 계산할 수 있다. 시작 음높이는 항상 1이며, 문자열의 처음부터 순서대로 * 기호의 경우 3을 곱하고 + 기호의 경우 1을 더한다. *+*+++ 의 음높이를 계산하는 과정을 예로 들면 아래와 같다. 시작 음 높이: 1 * + * + + + *3 +1 *3 +1 +1 +1 최종 음높이: 15 그날 기분에 따라 최종 음높이를 정하는 IU는 최종 음높이를 결정했을 때 서로 다른 3단 고음 문자열이 몇 가지나 있는지 궁금하다. 여러분의 도움이 필요하다. 입력 형식 입력은 5 이상 2^31-1 이하의 정수 n으로 주어진다. 출력 형식 입력을 만족하는 서로 다른 문자열의 수를 리턴한다. 예제 입출력 n answer 15 1 24 0 41 2 2147483647 1735 예제에 대한 설명 세 번째 예제의 두 가지 경우는 다음과 같다. **++++*++ *+**+++++",hard,String
280,"브라이언의 고민 알림: '실행'을 눌렀을 시 올바른 코드가 틀린 결과로 표시되는 경우가 있습니다. 하단의 설명을 참고해주세요. 카카오스토리의 개발자 브라이언에게 최근 고민이 생겼다. 하루에도 수백만 명이 사용하는 서비스답게 사람들이 많이 보는 글에 광고성 댓글을 달아 불쾌감을 유발하는 사용자가 증가하고 있는데, 신고를 받은 글이 광고글인지를 운영자가 판단하여 차단하는 시스템으로는 빠르게 늘어나는 광고글을 처리하기 어렵기 때문이다. 그래서 브라이언은 신고된 글이 광고글인지를 자동으로 판단하는 시스템을 만들었다. 이제 사용자가 광고글을 보고 신고하면 그 글이 광고글로 판단된 경우 자동으로 차단된다! 드디어 깨끗한 카카오스토리를 만들었다는 기쁨도 잠시, 광고글을 올리는 사람들이 자동 차단 시스템을 회피할 수 있는 방법을 찾기 시작했고, 얼마 지나지 않아 광고 문구 사이에 특수문자를 넣으면 차단되지 않는다는 점이 알려지게 되었다. 즉, 아래와 같은 식으로 작성하면 광고글 차단이 적용되지 않는다. ♚프☆렌☆즈☆레☆이☆싱♚★사전예약★진행중 $지금$예약시♜이모티콘♜100%※증정※ ★라이언★카트♨전원♨획@득@기@회 즉시이동 http://... 생각지 못한 광고글 패턴에 당황하던 브라이언은 광고글이 일정한 규칙에 의해 만들어진다는 사실을 알게 되었는데, 그 규칙은 다음과 같다. (아래 설명 및 그 이후의 내용에서 영문 대문자는 원래 문구, 소문자는 특수기호를 의미한다.) 광고글은 원래 문구에 다음 규칙을 적용하여 만들 수 있다. (규칙 1) 특정 단어를 선택하여 글자 사이마다 같은 기호를 넣는다. ex) HELLO -> HaEaLaLaO (규칙 2) 특정 단어를 선택하여 단어 앞뒤에 같은 기호를 넣는다. ex) WORLD -> bWORLDb 위의 두 가지 규칙은 한 단어에 모두 적용될 수 있지만 같은 규칙은 두 번 적용될 수 없다. 한 번 쓰인 소문자(특수기호)는 다시 쓰일 수 없다. 마지막으로 원래 문구에 있던 공백을 제거한다. 위의 규칙에 따라, HELLO WORLD는 다음의 광고 문구로 변환될 수 있다. HELLOWORLD (기호 삽입 없이 마지막 규칙인 공백 제거만 적용되었다.) HaEaLaLaObWORLDb (첫 번째 단어에는 규칙 1이, 두 번째 단어에는 규칙 2가 적용되었다.) aHbEbLbLbOacWdOdRdLdDc (모든 단어에 모든 규칙이 적용되었다.) 단, 아래의 문구는 올바르게 변환된 광고문구가 아니다. aHELLOa bWORLDb (공백이 제거되어야 한다.) HaEaLaLObWORLDb (규칙 1은 단어의 모든 글자 사이에 적용되어야 한다. 단, 이 문장은 원문이 HELL O WORLD인 경우 올바른 변환이다.) aHELLOWORLDa (규칙 2는 한 단어에 적용되어야 한다. 단, 이 문장은 원문이 HELLOWORLD인 경우 올바른 변환이다.) HaEaLaLaOWaOaRaLaD (첫 번째 단어에 쓰인 기호 a를 두 번째 단어에 쓸 수 없다.) abHELLObaWORLD (하나의 규칙을 같은 단어에 두 번 적용할 수 없다.) 신고된 글에 대해 위 규칙이 적용되기 전 문구를 찾을 수 있으면 자동 차단 시스템을 다시 온전하게 실행할 수 있게 된다. 카카오스토리가 광고글 없는 깨끗한 공간이 될 수 있도록 프로그램을 만들어보자. 입력 형식 입력은 문자열 변수 sentence로 주어진다. 이 문자열은 영문 대소문자로만 이루어져 있으며, 길이는 1,000 이하이다. 출력 형식 입력으로 주어진 광고 문구의 규칙 적용 전 원래 문구를 리턴한다. 단 원래 문구의 경우 문장 앞뒤의 공백이 없어야 하며, 단어 사이의 공백은 한 글자여야 한다. 가능한 답이 여러 가지인 경우 그중 하나를 리턴하면 된다. 규칙에 따른 변환으로 만들 수 없는 문자열이 입력된 경우에는 소문자로 invalid를 리턴한다. 예제 입출력 sentence answer ""HaEaLaLaObWORLDb"" ""HELLO WORLD"" ""SpIpGpOpNpGJqOqA"" ""SIGONG JOA"" ""AxAxAxAoBoBoB"" ""invalid"" 예제에 대한 설명 첫 번째 테스트 케이스는 문제 설명에 제시된 데이터와 같다. 두 번째 테스트 케이스에서, 기호 q는 규칙 1, 혹은 규칙 2에 의해 추가된 기호일 수 있다. 규칙 1에 해당하는 경우 원문은 SIGONG JOA로 예제 출력과 같으며, 규칙 2에 해당하는 경우의 원문인 SIGONG J O A도 올바른 답이다. 세 번째 테스트 케이스에서 x는 규칙 1에 의해 추가된 기호여야 한다. (규칙 2에 의해 추가되었다면 기호가 단어 앞뒤에 붙게 되므로 2개여야 한다.) 그러므로 AAAA가 한 단어여야 한다. 마찬가지로 o도 규칙 1에 의해 추가된 기호여야 하기 때문에 ABBB가 한 단어여야 한다. 이는 동시에 만족할 수 없는 조건이므로 주어진 문구는 규칙을 만족할 수 없게 된다. 따라서 invalid를 리턴한다. 알림 '실행'을 눌러 기본 테스트케이스에 대해 결과를 확인할 때 정답이 여러 개인 경우에도 하나의 답만 정답으로 처리되고 있습니다. 두 번째 예제 입력에 대해 SIGONG J O A를 리턴하는 코드의 경우 정답이지만 올바르지 않은 결과로 표시됩니다. '코드 채점'을 눌러 제출할 시에는 올바르게 채점되니 참고하여 주시기 바랍니다.",normal,String
281,"카카오 프렌즈 컬러링북 출판사의 편집자인 어피치는 네오에게 컬러링북에 들어갈 원화를 그려달라고 부탁하여 여러 장의 그림을 받았다. 여러 장의 그림을 난이도 순으로 컬러링북에 넣고 싶었던 어피치는 영역이 많으면 색칠하기가 까다로워 어려워진다는 사실을 발견하고 그림의 난이도를 영역의 수로 정의하였다. (영역이란 상하좌우로 연결된 같은 색상의 공간을 의미한다.) 그림에 몇 개의 영역이 있는지와 가장 큰 영역의 넓이는 얼마인지 계산하는 프로그램을 작성해보자. 위의 그림은 총 12개 영역으로 이루어져 있으며, 가장 넓은 영역은 어피치의 얼굴면으로 넓이는 120이다. 입력 형식 입력은 그림의 크기를 나타내는 m과 n, 그리고 그림을 나타내는 m × n 크기의 2차원 배열 picture로 주어진다. 제한조건은 아래와 같다. 1 <= m, n <= 100 picture의 원소는 0 이상 2^31 - 1 이하의 임의의 값이다. picture의 원소 중 값이 0인 경우는 색칠하지 않는 영역을 뜻한다. 출력 형식 리턴 타입은 원소가 두 개인 정수 배열이다. 그림에 몇 개의 영역이 있는지와 가장 큰 영역은 몇 칸으로 이루어져 있는지를 리턴한다. 예제 입출력 m n picture answer 6 4 [[1, 1, 1, 0], [1, 2, 2, 0], [1, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 3], [0, 0, 0, 3]] [4, 5] 예제에 대한 설명 예제로 주어진 그림은 총 4개의 영역으로 구성되어 있으며, 왼쪽 위의 영역과 오른쪽의 영역은 모두 1로 구성되어 있지만 상하좌우로 이어져있지 않으므로 다른 영역이다. 가장 넓은 영역은 왼쪽 위 1이 차지하는 영역으로 총 5칸이다.",normal,Array
282,Write a function to find the number of ways to fill it with 2 x 1 dominoes for the given 3 x n board.,normal,Array
283,Write a function to check if the letters of a given string can be rearranged so that two characters that are adjacent to each other are different.,normal,Heap (Priority Queue)
284,Write a function to find the n-th number in newman conway sequence.,normal,Math
285,Write a function to find the next smallest palindrome of a specified number.,normal,Array
286,"Write a function to find eulerian number a(n, m).",normal,Math
287,Write a function to extract the ranges that are missing from the given list with the given start range and end range values.,normal,Array
288,Write a function to find the triplet with sum of the given array,normal,Array
289,Write a function to find n’th smart number.,normal,Array
290,Write a function to sum all amicable numbers from 1 to a specified number.,normal,Array
291,Write a python function to find the sum of absolute differences in all pairs of the given array.,normal,Array
292,Write a function to find x and y that satisfies ax + by = n.,normal,Math
293,Write a function to find the longest common subsequence for the given two sequences.,normal,Array
294,Write a python function to find the first missing positive number.,hard,Array
295,Write a function to find the largest triangle that can be inscribed in an ellipse.,normal,Math
296,Write a function to count the longest repeating subsequences such that the two subsequences don’t have same string characters at same positions.,normal,Array
297,Write a function to check if a nested list is a subset of another nested list.,normal,Array
298,Write a python function to find the minimum element in a sorted and rotated array.,normal,Array
299,Write a function to find the maximum sum of bi-tonic sub-sequence for the given array.,normal,Array
300,Write a function to find the longest palindromic subsequence in the given string.,normal,Array
301,Write a function to find the nth newman–shanks–williams prime number.,normal,Math
302,Write a function to find the largest sum of contiguous array in the modified array which is formed by repeating the given array k times.,normal,Array
303,Write a python function to count inversions in an array.,normal,Array
304,"Write a function to find the maximum sum of increasing subsequence from prefix till ith index and also including a given kth element which is after i, i.e., k > i .",normal,Array
305,Write a function to find the specified number of largest products from two given lists.,normal,Array
306,Write a function to re-arrange the given array in alternating positive and negative items.,normal,Array
307,Write a python function to find the minimum number of squares whose sum is equal to a given number.,normal,Math
308,Write a function to find the smallest range that includes at-least one element from each of the given arrays.,normal,Heap (Priority Queue)
309,"Write a function to find entringer number e(n, k).",normal,Math
310,Write a function to print all permutations of a given string including duplicates.,normal,Array
311,Write a function to find the number of rotations in a circularly sorted array.,normal,Array
312,"Write a function to find the maximum sum possible by using the given equation f(n) = max( (f(n/2) + f(n/3) + f(n/4) + f(n/5)), n).",normal,Array
313,Write a function to create the next bigger number by rearranging the digits of a given number.,normal,Array
314,Write a function to find k number of pairs which consist of one element from the first array and one element from the second array.,normal,Heap (Priority Queue)
315,Write a function to find the maximum sum we can make by dividing number in three parts recursively and summing them up together for the given number.,normal,Array
316,Write a python function to find the sum of even factors of a number.,normal,Math
317,Write a function to find the maximum product subarray of the given array.,normal,Array
318,Write a function to find the peak element in the given array.,normal,Array
319,Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.,normal,Array
320,Write a function to find the maximum profit earned from a maximum of k stock transactions,hard,Array
321,Write a function to determine if there is a subset of the given set with sum equal to the given sum.,normal,Array
322,Write a python function to find the first natural number whose factorial is divisible by x.,normal,Math
323,Write a function to find the number of subsequences having product smaller than k for the given non negative array.,normal,Array
324,Write a function to check if there is a subset with sum divisible by m.,normal,Array
325,Write a function to sort a list of elements using radix sort.,normal,Array
326,Write a function to find the longest bitonic subsequence for the given array.,normal,Array
327,Write a function to find the sum of maximum increasing subsequence of the given array.,normal,Array
328,Write a function to find minimum number of coins that make a given value.,normal,Array
329,Write a python function to toggle only first and last bits of a given number.,normal,Math
330,Write a function to find the length of the longest increasing subsequence of the given sequence.,normal,Array
331,Write a python function to find the maximum element in a sorted and rotated array.,normal,Array
332,Write a function for nth catalan number.,normal,Math
333,Write a function to find kth element from the given two sorted arrays.,normal,Array
334,Write a function to find the longest chain which can be formed from the given set of pairs.,normal,Array
335,Write a function to get a lucid number smaller than or equal to n.,normal,Array
336,Write a python function to find nth bell number.,normal,Array
337,Write a function to find the largest subset where each pair is divisible.,normal,Array
338,Write a function to find the median of two sorted arrays of same size.,normal,Array
339,Write a python function to find the first digit in factorial of a given number.,normal,Math
340,## write a function to find the minimum number of jumps to reach the end of the array for the given array of integers where each element represents the max number of steps that can be made forward from that element. > indented block > indented block,normal,Array
341,Write a python function to count the total set bits from 1 to n.,normal,Math
342,Write a python function to toggle bits of the number except the first and the last bit.,normal,Simulation
343,Write a function to find the longest common subsequence for the given three string sequence.,normal,Array
344,Write a function to generate a square matrix filled with elements from 1 to n raised to the power of 2 in spiral order.,normal,Array
345,Write a function to count the number of inversions in the given array.,normal,Array
346,Write a function to find the nth super ugly number from a given prime list of size k using heap queue algorithm.,normal,Heap (Priority Queue)
347,Write a function to find the length of the longest sub-sequence such that elements in the subsequences are consecutive integers.,normal,Array
348,Write a function to check if a nested list is a subset of another nested list.,normal,Hash Table
349,Write a function to find the smallest multiple of the first n numbers.,normal,Array
350,Write a python function to count the total unset bits from 1 to n.,normal,Math
351,Write a function to print the first n lucky numbers.,normal,Array
352,Write a function to count coin change.,normal,Array
353,Write a function to find the length of the shortest string that has both str1 and str2 as subsequences.,normal,Array
354,Write a function to find n-th rencontres number.,normal,Math
355,Write a function to find the nth delannoy number.,normal,Math
356,Write a function to find three closest elements from three sorted arrays.,normal,Array
357,Write a function to sort the given array by using heap sort.,normal,Array
358,Write a function to find the minimum total path sum in the given triangle.,normal,Array
